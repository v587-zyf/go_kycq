// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs_server.proto

package pbserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type FSFightType int32

const (
	FSFightType_Boss FSFightType = 0
)

var FSFightType_name = map[int32]string{
	0: "Boss",
}
var FSFightType_value = map[string]int32{
	"Boss": 0,
}

func (x FSFightType) String() string {
	return proto.EnumName(FSFightType_name, int32(x))
}
func (FSFightType) EnumDescriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{0} }

// gs请求到指定战斗
type GsRouteMessageToFight struct {
	FightId int32  `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
	CmdId   int32  `protobuf:"varint,2,opt,name=cmdId,proto3" json:"cmdId,omitempty"`
	MsgData []byte `protobuf:"bytes,3,opt,name=msgData,proto3" json:"msgData,omitempty"`
}

func (m *GsRouteMessageToFight) Reset()                    { *m = GsRouteMessageToFight{} }
func (m *GsRouteMessageToFight) String() string            { return proto.CompactTextString(m) }
func (*GsRouteMessageToFight) ProtoMessage()               {}
func (*GsRouteMessageToFight) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{0} }

func (m *GsRouteMessageToFight) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

func (m *GsRouteMessageToFight) GetCmdId() int32 {
	if m != nil {
		return m.CmdId
	}
	return 0
}

func (m *GsRouteMessageToFight) GetMsgData() []byte {
	if m != nil {
		return m.MsgData
	}
	return nil
}

type FSCreateFightReq struct {
	StageId int32  `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	CpData  []byte `protobuf:"bytes,2,opt,name=cpData,proto3" json:"cpData,omitempty"`
}

func (m *FSCreateFightReq) Reset()                    { *m = FSCreateFightReq{} }
func (m *FSCreateFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSCreateFightReq) ProtoMessage()               {}
func (*FSCreateFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{1} }

func (m *FSCreateFightReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FSCreateFightReq) GetCpData() []byte {
	if m != nil {
		return m.CpData
	}
	return nil
}

type FSCreateFightAck struct {
	FightId uint32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSCreateFightAck) Reset()                    { *m = FSCreateFightAck{} }
func (m *FSCreateFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSCreateFightAck) ProtoMessage()               {}
func (*FSCreateFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{2} }

func (m *FSCreateFightAck) GetFightId() uint32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

// fs->gs推送所有常驻战斗id
type FsResidentFightNtf struct {
	ResidentFights     map[int32]uint32              `protobuf:"bytes,1,rep,name=residentFights" json:"residentFights,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FieldBossFightInfo map[int32]*FsFieldBossInfoNtf `protobuf:"bytes,2,rep,name=fieldBossFightInfo" json:"fieldBossFightInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FsResidentFightNtf) Reset()                    { *m = FsResidentFightNtf{} }
func (m *FsResidentFightNtf) String() string            { return proto.CompactTextString(m) }
func (*FsResidentFightNtf) ProtoMessage()               {}
func (*FsResidentFightNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{3} }

func (m *FsResidentFightNtf) GetResidentFights() map[int32]uint32 {
	if m != nil {
		return m.ResidentFights
	}
	return nil
}

func (m *FsResidentFightNtf) GetFieldBossFightInfo() map[int32]*FsFieldBossInfoNtf {
	if m != nil {
		return m.FieldBossFightInfo
	}
	return nil
}

// fs->gs 野外boss血量 复活时间
type FsFieldBossInfoNtf struct {
	StageId    int32   `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Hp         float32 `protobuf:"fixed32,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ReliveTime int64   `protobuf:"varint,3,opt,name=reliveTime,proto3" json:"reliveTime,omitempty"`
}

func (m *FsFieldBossInfoNtf) Reset()                    { *m = FsFieldBossInfoNtf{} }
func (m *FsFieldBossInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*FsFieldBossInfoNtf) ProtoMessage()               {}
func (*FsFieldBossInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{4} }

func (m *FsFieldBossInfoNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FsFieldBossInfoNtf) GetHp() float32 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *FsFieldBossInfoNtf) GetReliveTime() int64 {
	if m != nil {
		return m.ReliveTime
	}
	return 0
}

// 战斗继续
type FSContinueFightReq struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *FSContinueFightReq) Reset()                    { *m = FSContinueFightReq{} }
func (m *FSContinueFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSContinueFightReq) ProtoMessage()               {}
func (*FSContinueFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{5} }

func (m *FSContinueFightReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

type FSFightEndNtf struct {
	FightType int32   `protobuf:"varint,1,opt,name=fightType,proto3" json:"fightType,omitempty"`
	StageId   int32   `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Winners   []int32 `protobuf:"varint,3,rep,packed,name=winners" json:"winners,omitempty"`
	Losers    []int32 `protobuf:"varint,4,rep,packed,name=losers" json:"losers,omitempty"`
	UseTime   int32   `protobuf:"varint,5,opt,name=useTime,proto3" json:"useTime,omitempty"`
	CpData    []byte  `protobuf:"bytes,6,opt,name=cpData,proto3" json:"cpData,omitempty"`
}

func (m *FSFightEndNtf) Reset()                    { *m = FSFightEndNtf{} }
func (m *FSFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*FSFightEndNtf) ProtoMessage()               {}
func (*FSFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{6} }

func (m *FSFightEndNtf) GetFightType() int32 {
	if m != nil {
		return m.FightType
	}
	return 0
}

func (m *FSFightEndNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FSFightEndNtf) GetWinners() []int32 {
	if m != nil {
		return m.Winners
	}
	return nil
}

func (m *FSFightEndNtf) GetLosers() []int32 {
	if m != nil {
		return m.Losers
	}
	return nil
}

func (m *FSFightEndNtf) GetUseTime() int32 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

func (m *FSFightEndNtf) GetCpData() []byte {
	if m != nil {
		return m.CpData
	}
	return nil
}

type FSEnterFightReq struct {
	FightUser *User `protobuf:"bytes,1,opt,name=fightUser" json:"fightUser,omitempty"`
	EnterType int32 `protobuf:"varint,2,opt,name=enterType,proto3" json:"enterType,omitempty"`
}

func (m *FSEnterFightReq) Reset()                    { *m = FSEnterFightReq{} }
func (m *FSEnterFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSEnterFightReq) ProtoMessage()               {}
func (*FSEnterFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{7} }

func (m *FSEnterFightReq) GetFightUser() *User {
	if m != nil {
		return m.FightUser
	}
	return nil
}

func (m *FSEnterFightReq) GetEnterType() int32 {
	if m != nil {
		return m.EnterType
	}
	return 0
}

type FSEnterFightAck struct {
	Refuse bool `protobuf:"varint,1,opt,name=refuse,proto3" json:"refuse,omitempty"`
}

func (m *FSEnterFightAck) Reset()                    { *m = FSEnterFightAck{} }
func (m *FSEnterFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSEnterFightAck) ProtoMessage()               {}
func (*FSEnterFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{8} }

func (m *FSEnterFightAck) GetRefuse() bool {
	if m != nil {
		return m.Refuse
	}
	return false
}

type FSUpdateUserInfoNtf struct {
	UserInfo *Actor `protobuf:"bytes,1,opt,name=userInfo" json:"userInfo,omitempty"`
}

func (m *FSUpdateUserInfoNtf) Reset()                    { *m = FSUpdateUserInfoNtf{} }
func (m *FSUpdateUserInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*FSUpdateUserInfoNtf) ProtoMessage()               {}
func (*FSUpdateUserInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{9} }

func (m *FSUpdateUserInfoNtf) GetUserInfo() *Actor {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

type FSUpdateUserInfoAck struct {
	Refuse bool `protobuf:"varint,1,opt,name=refuse,proto3" json:"refuse,omitempty"`
}

func (m *FSUpdateUserInfoAck) Reset()                    { *m = FSUpdateUserInfoAck{} }
func (m *FSUpdateUserInfoAck) String() string            { return proto.CompactTextString(m) }
func (*FSUpdateUserInfoAck) ProtoMessage()               {}
func (*FSUpdateUserInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{10} }

func (m *FSUpdateUserInfoAck) GetRefuse() bool {
	if m != nil {
		return m.Refuse
	}
	return false
}

type FSLeaveFightReq struct {
	ActorSessionId uint32 `protobuf:"varint,1,opt,name=actorSessionId,proto3" json:"actorSessionId,omitempty"`
	Reason         uint32 `protobuf:"varint,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *FSLeaveFightReq) Reset()                    { *m = FSLeaveFightReq{} }
func (m *FSLeaveFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSLeaveFightReq) ProtoMessage()               {}
func (*FSLeaveFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{11} }

func (m *FSLeaveFightReq) GetActorSessionId() uint32 {
	if m != nil {
		return m.ActorSessionId
	}
	return 0
}

func (m *FSLeaveFightReq) GetReason() uint32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type FSLeaveFightAck struct {
}

func (m *FSLeaveFightAck) Reset()                    { *m = FSLeaveFightAck{} }
func (m *FSLeaveFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSLeaveFightAck) ProtoMessage()               {}
func (*FSLeaveFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{12} }

type GSToFsUpdateUserFightModel struct {
	UserId     int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	FigthModel int32 `protobuf:"varint,2,opt,name=figthModel,proto3" json:"figthModel,omitempty"`
}

func (m *GSToFsUpdateUserFightModel) Reset()         { *m = GSToFsUpdateUserFightModel{} }
func (m *GSToFsUpdateUserFightModel) String() string { return proto.CompactTextString(m) }
func (*GSToFsUpdateUserFightModel) ProtoMessage()    {}
func (*GSToFsUpdateUserFightModel) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{13}
}

func (m *GSToFsUpdateUserFightModel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GSToFsUpdateUserFightModel) GetFigthModel() int32 {
	if m != nil {
		return m.FigthModel
	}
	return 0
}

type GsToFSUserReliveReq struct {
	UserId     int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ReliveType int32 `protobuf:"varint,2,opt,name=reliveType,proto3" json:"reliveType,omitempty"`
}

func (m *GsToFSUserReliveReq) Reset()                    { *m = GsToFSUserReliveReq{} }
func (m *GsToFSUserReliveReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFSUserReliveReq) ProtoMessage()               {}
func (*GsToFSUserReliveReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{14} }

func (m *GsToFSUserReliveReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFSUserReliveReq) GetReliveType() int32 {
	if m != nil {
		return m.ReliveType
	}
	return 0
}

type FSToGsUserReliveAck struct {
	ReliveTimes        int32 `protobuf:"varint,1,opt,name=reliveTimes,proto3" json:"reliveTimes,omitempty"`
	ReliveByIngotTimes int32 `protobuf:"varint,2,opt,name=reliveByIngotTimes,proto3" json:"reliveByIngotTimes,omitempty"`
}

func (m *FSToGsUserReliveAck) Reset()                    { *m = FSToGsUserReliveAck{} }
func (m *FSToGsUserReliveAck) String() string            { return proto.CompactTextString(m) }
func (*FSToGsUserReliveAck) ProtoMessage()               {}
func (*FSToGsUserReliveAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{15} }

func (m *FSToGsUserReliveAck) GetReliveTimes() int32 {
	if m != nil {
		return m.ReliveTimes
	}
	return 0
}

func (m *FSToGsUserReliveAck) GetReliveByIngotTimes() int32 {
	if m != nil {
		return m.ReliveByIngotTimes
	}
	return 0
}

type GsToFSCheckUserReliveReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFSCheckUserReliveReq) Reset()         { *m = GsToFSCheckUserReliveReq{} }
func (m *GsToFSCheckUserReliveReq) String() string { return proto.CompactTextString(m) }
func (*GsToFSCheckUserReliveReq) ProtoMessage()    {}
func (*GsToFSCheckUserReliveReq) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{16}
}

func (m *GsToFSCheckUserReliveReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGSCheckUserReliveAck struct {
	IsDie              bool  `protobuf:"varint,1,opt,name=isDie,proto3" json:"isDie,omitempty"`
	ReliveTimes        int32 `protobuf:"varint,2,opt,name=reliveTimes,proto3" json:"reliveTimes,omitempty"`
	ReliveByIngotTimes int32 `protobuf:"varint,3,opt,name=reliveByIngotTimes,proto3" json:"reliveByIngotTimes,omitempty"`
}

func (m *FsToGSCheckUserReliveAck) Reset()         { *m = FsToGSCheckUserReliveAck{} }
func (m *FsToGSCheckUserReliveAck) String() string { return proto.CompactTextString(m) }
func (*FsToGSCheckUserReliveAck) ProtoMessage()    {}
func (*FsToGSCheckUserReliveAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{17}
}

func (m *FsToGSCheckUserReliveAck) GetIsDie() bool {
	if m != nil {
		return m.IsDie
	}
	return false
}

func (m *FsToGSCheckUserReliveAck) GetReliveTimes() int32 {
	if m != nil {
		return m.ReliveTimes
	}
	return 0
}

func (m *FsToGSCheckUserReliveAck) GetReliveByIngotTimes() int32 {
	if m != nil {
		return m.ReliveByIngotTimes
	}
	return 0
}

type FSGetFightIdReq struct {
	FightType FSFightType `protobuf:"varint,1,opt,name=fightType,proto3,enum=pbserver.FSFightType" json:"fightType,omitempty"`
}

func (m *FSGetFightIdReq) Reset()                    { *m = FSGetFightIdReq{} }
func (m *FSGetFightIdReq) String() string            { return proto.CompactTextString(m) }
func (*FSGetFightIdReq) ProtoMessage()               {}
func (*FSGetFightIdReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{18} }

func (m *FSGetFightIdReq) GetFightType() FSFightType {
	if m != nil {
		return m.FightType
	}
	return FSFightType_Boss
}

type FSGetFightIdAck struct {
	FightId uint32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSGetFightIdAck) Reset()                    { *m = FSGetFightIdAck{} }
func (m *FSGetFightIdAck) String() string            { return proto.CompactTextString(m) }
func (*FSGetFightIdAck) ProtoMessage()               {}
func (*FSGetFightIdAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{19} }

func (m *FSGetFightIdAck) GetFightId() uint32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type User struct {
	SessionId       uint32 `protobuf:"varint,1,opt,name=sessionId,proto3" json:"sessionId,omitempty"`
	LocatedServerId uint32 `protobuf:"varint,2,opt,name=locatedServerId,proto3" json:"locatedServerId,omitempty"`
	UserInfo        *Actor `protobuf:"bytes,3,opt,name=userInfo" json:"userInfo,omitempty"`
	TeamId          int32  `protobuf:"varint,4,opt,name=teamId,proto3" json:"teamId,omitempty"`
	FightModel      int32  `protobuf:"varint,5,opt,name=fightModel,proto3" json:"fightModel,omitempty"`
	BirthArea       int32  `protobuf:"varint,6,opt,name=birthArea,proto3" json:"birthArea,omitempty"`
	IsRobot         bool   `protobuf:"varint,7,opt,name=isRobot,proto3" json:"isRobot,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{20} }

func (m *User) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *User) GetLocatedServerId() uint32 {
	if m != nil {
		return m.LocatedServerId
	}
	return 0
}

func (m *User) GetUserInfo() *Actor {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *User) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *User) GetFightModel() int32 {
	if m != nil {
		return m.FightModel
	}
	return 0
}

func (m *User) GetBirthArea() int32 {
	if m != nil {
		return m.BirthArea
	}
	return 0
}

func (m *User) GetIsRobot() bool {
	if m != nil {
		return m.IsRobot
	}
	return false
}

type UserDropReq struct {
	FightType int32 `protobuf:"varint,1,opt,name=fightType,proto3" json:"fightType,omitempty"`
	StageId   int32 `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	UserId    int32 `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *UserDropReq) Reset()                    { *m = UserDropReq{} }
func (m *UserDropReq) String() string            { return proto.CompactTextString(m) }
func (*UserDropReq) ProtoMessage()               {}
func (*UserDropReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{21} }

func (m *UserDropReq) GetFightType() int32 {
	if m != nil {
		return m.FightType
	}
	return 0
}

func (m *UserDropReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *UserDropReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UserDropAck struct {
	Items []*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *UserDropAck) Reset()                    { *m = UserDropAck{} }
func (m *UserDropAck) String() string            { return proto.CompactTextString(m) }
func (*UserDropAck) ProtoMessage()               {}
func (*UserDropAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{22} }

func (m *UserDropAck) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

type FSAddItemReq struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	OpType int32           `protobuf:"varint,3,opt,name=OpType,proto3" json:"OpType,omitempty"`
}

func (m *FSAddItemReq) Reset()                    { *m = FSAddItemReq{} }
func (m *FSAddItemReq) String() string            { return proto.CompactTextString(m) }
func (*FSAddItemReq) ProtoMessage()               {}
func (*FSAddItemReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{23} }

func (m *FSAddItemReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FSAddItemReq) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *FSAddItemReq) GetOpType() int32 {
	if m != nil {
		return m.OpType
	}
	return 0
}

type FSAddItemAck struct {
	IsSuccess bool `protobuf:"varint,1,opt,name=isSuccess,proto3" json:"isSuccess,omitempty"`
}

func (m *FSAddItemAck) Reset()                    { *m = FSAddItemAck{} }
func (m *FSAddItemAck) String() string            { return proto.CompactTextString(m) }
func (*FSAddItemAck) ProtoMessage()               {}
func (*FSAddItemAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{24} }

func (m *FSAddItemAck) GetIsSuccess() bool {
	if m != nil {
		return m.IsSuccess
	}
	return false
}

type GsTOFsPickUpReq struct {
	UseId  int32   `protobuf:"varint,1,opt,name=useId,proto3" json:"useId,omitempty"`
	ObjIds []int32 `protobuf:"varint,2,rep,packed,name=objIds" json:"objIds,omitempty"`
}

func (m *GsTOFsPickUpReq) Reset()                    { *m = GsTOFsPickUpReq{} }
func (m *GsTOFsPickUpReq) String() string            { return proto.CompactTextString(m) }
func (*GsTOFsPickUpReq) ProtoMessage()               {}
func (*GsTOFsPickUpReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{25} }

func (m *GsTOFsPickUpReq) GetUseId() int32 {
	if m != nil {
		return m.UseId
	}
	return 0
}

func (m *GsTOFsPickUpReq) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

type FsTOGsPickUpAck struct {
	Items map[int32]*ItemUnitForPickUp `protobuf:"bytes,1,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FsTOGsPickUpAck) Reset()                    { *m = FsTOGsPickUpAck{} }
func (m *FsTOGsPickUpAck) String() string            { return proto.CompactTextString(m) }
func (*FsTOGsPickUpAck) ProtoMessage()               {}
func (*FsTOGsPickUpAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{26} }

func (m *FsTOGsPickUpAck) GetItems() map[int32]*ItemUnitForPickUp {
	if m != nil {
		return m.Items
	}
	return nil
}

// 玩家技能使用
type FsSkillUseNtf struct {
	UseId          int32   `protobuf:"varint,1,opt,name=useId,proto3" json:"useId,omitempty"`
	HeroIndex      int32   `protobuf:"varint,2,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	SkillId        int32   `protobuf:"varint,3,opt,name=skillId,proto3" json:"skillId,omitempty"`
	CdStartTime    int64   `protobuf:"varint,4,opt,name=cdStartTime,proto3" json:"cdStartTime,omitempty"`
	CdStopTime     int64   `protobuf:"varint,5,opt,name=cdStopTime,proto3" json:"cdStopTime,omitempty"`
	KillMonsterIds []int32 `protobuf:"varint,6,rep,packed,name=killMonsterIds" json:"killMonsterIds,omitempty"`
}

func (m *FsSkillUseNtf) Reset()                    { *m = FsSkillUseNtf{} }
func (m *FsSkillUseNtf) String() string            { return proto.CompactTextString(m) }
func (*FsSkillUseNtf) ProtoMessage()               {}
func (*FsSkillUseNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{27} }

func (m *FsSkillUseNtf) GetUseId() int32 {
	if m != nil {
		return m.UseId
	}
	return 0
}

func (m *FsSkillUseNtf) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *FsSkillUseNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *FsSkillUseNtf) GetCdStartTime() int64 {
	if m != nil {
		return m.CdStartTime
	}
	return 0
}

func (m *FsSkillUseNtf) GetCdStopTime() int64 {
	if m != nil {
		return m.CdStopTime
	}
	return 0
}

func (m *FsSkillUseNtf) GetKillMonsterIds() []int32 {
	if m != nil {
		return m.KillMonsterIds
	}
	return nil
}

// 清理武将技能CD
type FsTOGsClearSkillCdNtf struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	HeroIndex int32 `protobuf:"varint,2,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
}

func (m *FsTOGsClearSkillCdNtf) Reset()                    { *m = FsTOGsClearSkillCdNtf{} }
func (m *FsTOGsClearSkillCdNtf) String() string            { return proto.CompactTextString(m) }
func (*FsTOGsClearSkillCdNtf) ProtoMessage()               {}
func (*FsTOGsClearSkillCdNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{28} }

func (m *FsTOGsClearSkillCdNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsTOGsClearSkillCdNtf) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

type FsRandomDeliveryNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Rand   bool  `protobuf:"varint,2,opt,name=rand,proto3" json:"rand,omitempty"`
}

func (m *FsRandomDeliveryNtf) Reset()                    { *m = FsRandomDeliveryNtf{} }
func (m *FsRandomDeliveryNtf) String() string            { return proto.CompactTextString(m) }
func (*FsRandomDeliveryNtf) ProtoMessage()               {}
func (*FsRandomDeliveryNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{29} }

func (m *FsRandomDeliveryNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsRandomDeliveryNtf) GetRand() bool {
	if m != nil {
		return m.Rand
	}
	return false
}

// game推送fs使用道具
type GsToFsUseItemNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ItemId int32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
}

func (m *GsToFsUseItemNtf) Reset()                    { *m = GsToFsUseItemNtf{} }
func (m *GsToFsUseItemNtf) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUseItemNtf) ProtoMessage()               {}
func (*GsToFsUseItemNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{30} }

func (m *GsToFsUseItemNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUseItemNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

// 检查战斗是否存在
type GSTOFSCheckFightReq struct {
	FightId int32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *GSTOFSCheckFightReq) Reset()                    { *m = GSTOFSCheckFightReq{} }
func (m *GSTOFSCheckFightReq) String() string            { return proto.CompactTextString(m) }
func (*GSTOFSCheckFightReq) ProtoMessage()               {}
func (*GSTOFSCheckFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{31} }

func (m *GSTOFSCheckFightReq) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type FSTOGSCheckFightAck struct {
	FightId int32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSTOGSCheckFightAck) Reset()                    { *m = FSTOGSCheckFightAck{} }
func (m *FSTOGSCheckFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSTOGSCheckFightAck) ProtoMessage()               {}
func (*FSTOGSCheckFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{32} }

func (m *FSTOGSCheckFightAck) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type GsToFsGetCheerNumReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsGetCheerNumReq) Reset()                    { *m = GsToFsGetCheerNumReq{} }
func (m *GsToFsGetCheerNumReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGetCheerNumReq) ProtoMessage()               {}
func (*GsToFsGetCheerNumReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{33} }

func (m *GsToFsGetCheerNumReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsGetCheerNumAck struct {
	UserId   int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	CheerNum int32 `protobuf:"varint,2,opt,name=cheerNum,proto3" json:"cheerNum,omitempty"`
}

func (m *FsToGsGetCheerNumAck) Reset()                    { *m = FsToGsGetCheerNumAck{} }
func (m *FsToGsGetCheerNumAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsGetCheerNumAck) ProtoMessage()               {}
func (*FsToGsGetCheerNumAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{34} }

func (m *FsToGsGetCheerNumAck) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsGetCheerNumAck) GetCheerNum() int32 {
	if m != nil {
		return m.CheerNum
	}
	return 0
}

type GsToFsCheerReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsCheerReq) Reset()                    { *m = GsToFsCheerReq{} }
func (m *GsToFsCheerReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsCheerReq) ProtoMessage()               {}
func (*GsToFsCheerReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{35} }

func (m *GsToFsCheerReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsCheerAck struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsCheerAck) Reset()                    { *m = FsToGsCheerAck{} }
func (m *FsToGsCheerAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCheerAck) ProtoMessage()               {}
func (*FsToGsCheerAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{36} }

func (m *FsToGsCheerAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type GsToFsGetPotionCdReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsGetPotionCdReq) Reset()                    { *m = GsToFsGetPotionCdReq{} }
func (m *GsToFsGetPotionCdReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGetPotionCdReq) ProtoMessage()               {}
func (*GsToFsGetPotionCdReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{37} }

func (m *GsToFsGetPotionCdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsGetPotionCdAck struct {
	UserId  int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	UseTime int64 `protobuf:"varint,2,opt,name=useTime,proto3" json:"useTime,omitempty"`
}

func (m *FsToGsGetPotionCdAck) Reset()                    { *m = FsToGsGetPotionCdAck{} }
func (m *FsToGsGetPotionCdAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsGetPotionCdAck) ProtoMessage()               {}
func (*FsToGsGetPotionCdAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{38} }

func (m *FsToGsGetPotionCdAck) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsGetPotionCdAck) GetUseTime() int64 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

type GsToFsUsePotionReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsUsePotionReq) Reset()                    { *m = GsToFsUsePotionReq{} }
func (m *GsToFsUsePotionReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUsePotionReq) ProtoMessage()               {}
func (*GsToFsUsePotionReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{39} }

func (m *GsToFsUsePotionReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsUsePotionAck struct {
	Result  bool  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	UseTime int64 `protobuf:"varint,2,opt,name=useTime,proto3" json:"useTime,omitempty"`
}

func (m *FsToGsUsePotionAck) Reset()                    { *m = FsToGsUsePotionAck{} }
func (m *FsToGsUsePotionAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUsePotionAck) ProtoMessage()               {}
func (*FsToGsUsePotionAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{40} }

func (m *FsToGsUsePotionAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *FsToGsUsePotionAck) GetUseTime() int64 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

type GsToFsCollectionReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ObjId  int32 `protobuf:"varint,2,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *GsToFsCollectionReq) Reset()                    { *m = GsToFsCollectionReq{} }
func (m *GsToFsCollectionReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsCollectionReq) ProtoMessage()               {}
func (*GsToFsCollectionReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{41} }

func (m *GsToFsCollectionReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsCollectionReq) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type FsToGsCollectionAck struct {
	StartTime int64 `protobuf:"varint,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *FsToGsCollectionAck) Reset()                    { *m = FsToGsCollectionAck{} }
func (m *FsToGsCollectionAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCollectionAck) ProtoMessage()               {}
func (*FsToGsCollectionAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{42} }

func (m *FsToGsCollectionAck) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *FsToGsCollectionAck) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type FsToGsCollectionNtf struct {
	UserId    int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageType int32           `protobuf:"varint,2,opt,name=stageType,proto3" json:"stageType,omitempty"`
	Items     map[int32]int32 `protobuf:"bytes,3,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FsToGsCollectionNtf) Reset()                    { *m = FsToGsCollectionNtf{} }
func (m *FsToGsCollectionNtf) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCollectionNtf) ProtoMessage()               {}
func (*FsToGsCollectionNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{43} }

func (m *FsToGsCollectionNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsCollectionNtf) GetStageType() int32 {
	if m != nil {
		return m.StageType
	}
	return 0
}

func (m *FsToGsCollectionNtf) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

// 使用合体
type GsToFsUseFitReq struct {
	UserId int32     `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Fit    *ActorFit `protobuf:"bytes,2,opt,name=fit" json:"fit,omitempty"`
}

func (m *GsToFsUseFitReq) Reset()                    { *m = GsToFsUseFitReq{} }
func (m *GsToFsUseFitReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUseFitReq) ProtoMessage()               {}
func (*GsToFsUseFitReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{44} }

func (m *GsToFsUseFitReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUseFitReq) GetFit() *ActorFit {
	if m != nil {
		return m.Fit
	}
	return nil
}

type FsToGsUseFitAck struct {
	IsSuccess bool `protobuf:"varint,1,opt,name=isSuccess,proto3" json:"isSuccess,omitempty"`
}

func (m *FsToGsUseFitAck) Reset()                    { *m = FsToGsUseFitAck{} }
func (m *FsToGsUseFitAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUseFitAck) ProtoMessage()               {}
func (*FsToGsUseFitAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{45} }

func (m *FsToGsUseFitAck) GetIsSuccess() bool {
	if m != nil {
		return m.IsSuccess
	}
	return false
}

type GsToFsFitCacelReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsFitCacelReq) Reset()                    { *m = GsToFsFitCacelReq{} }
func (m *GsToFsFitCacelReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsFitCacelReq) ProtoMessage()               {}
func (*GsToFsFitCacelReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{46} }

func (m *GsToFsFitCacelReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsFitCacelAck struct {
}

func (m *FsToGsFitCacelAck) Reset()                    { *m = FsToGsFitCacelAck{} }
func (m *FsToGsFitCacelAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsFitCacelAck) ProtoMessage()               {}
func (*FsToGsFitCacelAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{47} }

type GsToFsUpdatePetReq struct {
	UserId int32     `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Pet    *ActorPet `protobuf:"bytes,2,opt,name=pet" json:"pet,omitempty"`
}

func (m *GsToFsUpdatePetReq) Reset()                    { *m = GsToFsUpdatePetReq{} }
func (m *GsToFsUpdatePetReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUpdatePetReq) ProtoMessage()               {}
func (*GsToFsUpdatePetReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{48} }

func (m *GsToFsUpdatePetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUpdatePetReq) GetPet() *ActorPet {
	if m != nil {
		return m.Pet
	}
	return nil
}

type FsToGsUpdatePetAck struct {
}

func (m *FsToGsUpdatePetAck) Reset()                    { *m = FsToGsUpdatePetAck{} }
func (m *FsToGsUpdatePetAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUpdatePetAck) ProtoMessage()               {}
func (*FsToGsUpdatePetAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{49} }

type WorldBossStatusNtf struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Status  int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WorldBossStatusNtf) Reset()                    { *m = WorldBossStatusNtf{} }
func (m *WorldBossStatusNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldBossStatusNtf) ProtoMessage()               {}
func (*WorldBossStatusNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{50} }

func (m *WorldBossStatusNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *WorldBossStatusNtf) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ExpStageKillMonsterNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *ExpStageKillMonsterNtf) Reset()                    { *m = ExpStageKillMonsterNtf{} }
func (m *ExpStageKillMonsterNtf) String() string            { return proto.CompactTextString(m) }
func (*ExpStageKillMonsterNtf) ProtoMessage()               {}
func (*ExpStageKillMonsterNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{51} }

func (m *ExpStageKillMonsterNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type PersonFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *PersonFightResult) Reset()                    { *m = PersonFightResult{} }
func (m *PersonFightResult) String() string            { return proto.CompactTextString(m) }
func (*PersonFightResult) ProtoMessage()               {}
func (*PersonFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{52} }

func (m *PersonFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PersonFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *PersonFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type VipBossFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *VipBossFightResult) Reset()                    { *m = VipBossFightResult{} }
func (m *VipBossFightResult) String() string            { return proto.CompactTextString(m) }
func (*VipBossFightResult) ProtoMessage()               {}
func (*VipBossFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{53} }

func (m *VipBossFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *VipBossFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *VipBossFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type TowerFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *TowerFightResult) Reset()                    { *m = TowerFightResult{} }
func (m *TowerFightResult) String() string            { return proto.CompactTextString(m) }
func (*TowerFightResult) ProtoMessage()               {}
func (*TowerFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{54} }

func (m *TowerFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TowerFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *TowerFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type FieldBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FieldBossResult) Reset()                    { *m = FieldBossResult{} }
func (m *FieldBossResult) String() string            { return proto.CompactTextString(m) }
func (*FieldBossResult) ProtoMessage()               {}
func (*FieldBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{55} }

func (m *FieldBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *FieldBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

type DarkPalaceBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DarkPalaceBossResult) Reset()                    { *m = DarkPalaceBossResult{} }
func (m *DarkPalaceBossResult) String() string            { return proto.CompactTextString(m) }
func (*DarkPalaceBossResult) ProtoMessage()               {}
func (*DarkPalaceBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{56} }

func (m *DarkPalaceBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *DarkPalaceBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

type MiningNewFightInfoReq struct {
	MiningId     int32 `protobuf:"varint,1,opt,name=miningId,proto3" json:"miningId,omitempty"`
	MiningUserId int32 `protobuf:"varint,2,opt,name=miningUserId,proto3" json:"miningUserId,omitempty"`
	IsRetake     bool  `protobuf:"varint,3,opt,name=isRetake,proto3" json:"isRetake,omitempty"`
}

func (m *MiningNewFightInfoReq) Reset()                    { *m = MiningNewFightInfoReq{} }
func (m *MiningNewFightInfoReq) String() string            { return proto.CompactTextString(m) }
func (*MiningNewFightInfoReq) ProtoMessage()               {}
func (*MiningNewFightInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{57} }

func (m *MiningNewFightInfoReq) GetMiningId() int32 {
	if m != nil {
		return m.MiningId
	}
	return 0
}

func (m *MiningNewFightInfoReq) GetMiningUserId() int32 {
	if m != nil {
		return m.MiningUserId
	}
	return 0
}

func (m *MiningNewFightInfoReq) GetIsRetake() bool {
	if m != nil {
		return m.IsRetake
	}
	return false
}

type MiningNewFightInfoAck struct {
	ReadyOk bool `protobuf:"varint,1,opt,name=readyOk,proto3" json:"readyOk,omitempty"`
}

func (m *MiningNewFightInfoAck) Reset()                    { *m = MiningNewFightInfoAck{} }
func (m *MiningNewFightInfoAck) String() string            { return proto.CompactTextString(m) }
func (*MiningNewFightInfoAck) ProtoMessage()               {}
func (*MiningNewFightInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{58} }

func (m *MiningNewFightInfoAck) GetReadyOk() bool {
	if m != nil {
		return m.ReadyOk
	}
	return false
}

type MiningFightResultNtf struct {
	UserId       int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	MiningId     int32 `protobuf:"varint,2,opt,name=miningId,proto3" json:"miningId,omitempty"`
	MiningUserId int32 `protobuf:"varint,3,opt,name=miningUserId,proto3" json:"miningUserId,omitempty"`
	IsRetake     bool  `protobuf:"varint,4,opt,name=isRetake,proto3" json:"isRetake,omitempty"`
	Result       int32 `protobuf:"varint,5,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *MiningFightResultNtf) Reset()                    { *m = MiningFightResultNtf{} }
func (m *MiningFightResultNtf) String() string            { return proto.CompactTextString(m) }
func (*MiningFightResultNtf) ProtoMessage()               {}
func (*MiningFightResultNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{59} }

func (m *MiningFightResultNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MiningFightResultNtf) GetMiningId() int32 {
	if m != nil {
		return m.MiningId
	}
	return 0
}

func (m *MiningFightResultNtf) GetMiningUserId() int32 {
	if m != nil {
		return m.MiningUserId
	}
	return 0
}

func (m *MiningFightResultNtf) GetIsRetake() bool {
	if m != nil {
		return m.IsRetake
	}
	return false
}

func (m *MiningFightResultNtf) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 推送玩家击杀一波怪物
type HangUpKillWaveNtf struct {
	UserId  int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageId int32 `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *HangUpKillWaveNtf) Reset()                    { *m = HangUpKillWaveNtf{} }
func (m *HangUpKillWaveNtf) String() string            { return proto.CompactTextString(m) }
func (*HangUpKillWaveNtf) ProtoMessage()               {}
func (*HangUpKillWaveNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{60} }

func (m *HangUpKillWaveNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HangUpKillWaveNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

// 推送玩家击杀挂机BOSS
type HangUpBossFightEndNtf struct {
	UserId  int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageId int32           `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Result  int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	Items   map[int32]int32 `protobuf:"bytes,4,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HangUpBossFightEndNtf) Reset()                    { *m = HangUpBossFightEndNtf{} }
func (m *HangUpBossFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*HangUpBossFightEndNtf) ProtoMessage()               {}
func (*HangUpBossFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{61} }

func (m *HangUpBossFightEndNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

type FightTotalData struct {
	Damage   int64 `protobuf:"varint,1,opt,name=damage,proto3" json:"damage,omitempty"`
	BeDamage int64 `protobuf:"varint,2,opt,name=beDamage,proto3" json:"beDamage,omitempty"`
	Treat    int64 `protobuf:"varint,3,opt,name=treat,proto3" json:"treat,omitempty"`
}

func (m *FightTotalData) Reset()                    { *m = FightTotalData{} }
func (m *FightTotalData) String() string            { return proto.CompactTextString(m) }
func (*FightTotalData) ProtoMessage()               {}
func (*FightTotalData) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{62} }

func (m *FightTotalData) GetDamage() int64 {
	if m != nil {
		return m.Damage
	}
	return 0
}

func (m *FightTotalData) GetBeDamage() int64 {
	if m != nil {
		return m.BeDamage
	}
	return 0
}

func (m *FightTotalData) GetTreat() int64 {
	if m != nil {
		return m.Treat
	}
	return 0
}

type GuildbonfireExpAddNtf struct {
	GuildId int32   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=userIds" json:"userIds,omitempty"`
}

func (m *GuildbonfireExpAddNtf) Reset()                    { *m = GuildbonfireExpAddNtf{} }
func (m *GuildbonfireExpAddNtf) String() string            { return proto.CompactTextString(m) }
func (*GuildbonfireExpAddNtf) ProtoMessage()               {}
func (*GuildbonfireExpAddNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{63} }

func (m *GuildbonfireExpAddNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GuildbonfireExpAddNtf) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type PaodianGoodsAddNtf struct {
	StageId int32           `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	UserIds map[int32]int32 `protobuf:"bytes,2,rep,name=userIds" json:"userIds,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *PaodianGoodsAddNtf) Reset()                    { *m = PaodianGoodsAddNtf{} }
func (m *PaodianGoodsAddNtf) String() string            { return proto.CompactTextString(m) }
func (*PaodianGoodsAddNtf) ProtoMessage()               {}
func (*PaodianGoodsAddNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{64} }

func (m *PaodianGoodsAddNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *PaodianGoodsAddNtf) GetUserIds() map[int32]int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type ShabakeFightEndNtf struct {
	UserRank  []*ShabakeRankScore `protobuf:"bytes,1,rep,name=userRank" json:"userRank,omitempty"`
	GuildRank []*ShabakeRankScore `protobuf:"bytes,2,rep,name=guildRank" json:"guildRank,omitempty"`
}

func (m *ShabakeFightEndNtf) Reset()                    { *m = ShabakeFightEndNtf{} }
func (m *ShabakeFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeFightEndNtf) ProtoMessage()               {}
func (*ShabakeFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{65} }

func (m *ShabakeFightEndNtf) GetUserRank() []*ShabakeRankScore {
	if m != nil {
		return m.UserRank
	}
	return nil
}

func (m *ShabakeFightEndNtf) GetGuildRank() []*ShabakeRankScore {
	if m != nil {
		return m.GuildRank
	}
	return nil
}

type ShabakeRankScore struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Score int32 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *ShabakeRankScore) Reset()                    { *m = ShabakeRankScore{} }
func (m *ShabakeRankScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeRankScore) ProtoMessage()               {}
func (*ShabakeRankScore) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{66} }

func (m *ShabakeRankScore) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ShabakeRankScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func init() {
	proto.RegisterType((*GsRouteMessageToFight)(nil), "pbserver.GsRouteMessageToFight")
	proto.RegisterType((*FSCreateFightReq)(nil), "pbserver.FSCreateFightReq")
	proto.RegisterType((*FSCreateFightAck)(nil), "pbserver.FSCreateFightAck")
	proto.RegisterType((*FsResidentFightNtf)(nil), "pbserver.FsResidentFightNtf")
	proto.RegisterType((*FsFieldBossInfoNtf)(nil), "pbserver.FsFieldBossInfoNtf")
	proto.RegisterType((*FSContinueFightReq)(nil), "pbserver.FSContinueFightReq")
	proto.RegisterType((*FSFightEndNtf)(nil), "pbserver.FSFightEndNtf")
	proto.RegisterType((*FSEnterFightReq)(nil), "pbserver.FSEnterFightReq")
	proto.RegisterType((*FSEnterFightAck)(nil), "pbserver.FSEnterFightAck")
	proto.RegisterType((*FSUpdateUserInfoNtf)(nil), "pbserver.FSUpdateUserInfoNtf")
	proto.RegisterType((*FSUpdateUserInfoAck)(nil), "pbserver.FSUpdateUserInfoAck")
	proto.RegisterType((*FSLeaveFightReq)(nil), "pbserver.FSLeaveFightReq")
	proto.RegisterType((*FSLeaveFightAck)(nil), "pbserver.FSLeaveFightAck")
	proto.RegisterType((*GSToFsUpdateUserFightModel)(nil), "pbserver.GSToFsUpdateUserFightModel")
	proto.RegisterType((*GsToFSUserReliveReq)(nil), "pbserver.GsToFSUserReliveReq")
	proto.RegisterType((*FSToGsUserReliveAck)(nil), "pbserver.FSToGsUserReliveAck")
	proto.RegisterType((*GsToFSCheckUserReliveReq)(nil), "pbserver.GsToFSCheckUserReliveReq")
	proto.RegisterType((*FsToGSCheckUserReliveAck)(nil), "pbserver.FsToGSCheckUserReliveAck")
	proto.RegisterType((*FSGetFightIdReq)(nil), "pbserver.FSGetFightIdReq")
	proto.RegisterType((*FSGetFightIdAck)(nil), "pbserver.FSGetFightIdAck")
	proto.RegisterType((*User)(nil), "pbserver.User")
	proto.RegisterType((*UserDropReq)(nil), "pbserver.UserDropReq")
	proto.RegisterType((*UserDropAck)(nil), "pbserver.UserDropAck")
	proto.RegisterType((*FSAddItemReq)(nil), "pbserver.FSAddItemReq")
	proto.RegisterType((*FSAddItemAck)(nil), "pbserver.FSAddItemAck")
	proto.RegisterType((*GsTOFsPickUpReq)(nil), "pbserver.GsTOFsPickUpReq")
	proto.RegisterType((*FsTOGsPickUpAck)(nil), "pbserver.FsTOGsPickUpAck")
	proto.RegisterType((*FsSkillUseNtf)(nil), "pbserver.FsSkillUseNtf")
	proto.RegisterType((*FsTOGsClearSkillCdNtf)(nil), "pbserver.FsTOGsClearSkillCdNtf")
	proto.RegisterType((*FsRandomDeliveryNtf)(nil), "pbserver.FsRandomDeliveryNtf")
	proto.RegisterType((*GsToFsUseItemNtf)(nil), "pbserver.GsToFsUseItemNtf")
	proto.RegisterType((*GSTOFSCheckFightReq)(nil), "pbserver.GSTOFSCheckFightReq")
	proto.RegisterType((*FSTOGSCheckFightAck)(nil), "pbserver.FSTOGSCheckFightAck")
	proto.RegisterType((*GsToFsGetCheerNumReq)(nil), "pbserver.GsToFsGetCheerNumReq")
	proto.RegisterType((*FsToGsGetCheerNumAck)(nil), "pbserver.FsToGsGetCheerNumAck")
	proto.RegisterType((*GsToFsCheerReq)(nil), "pbserver.GsToFsCheerReq")
	proto.RegisterType((*FsToGsCheerAck)(nil), "pbserver.FsToGsCheerAck")
	proto.RegisterType((*GsToFsGetPotionCdReq)(nil), "pbserver.GsToFsGetPotionCdReq")
	proto.RegisterType((*FsToGsGetPotionCdAck)(nil), "pbserver.FsToGsGetPotionCdAck")
	proto.RegisterType((*GsToFsUsePotionReq)(nil), "pbserver.GsToFsUsePotionReq")
	proto.RegisterType((*FsToGsUsePotionAck)(nil), "pbserver.FsToGsUsePotionAck")
	proto.RegisterType((*GsToFsCollectionReq)(nil), "pbserver.GsToFsCollectionReq")
	proto.RegisterType((*FsToGsCollectionAck)(nil), "pbserver.FsToGsCollectionAck")
	proto.RegisterType((*FsToGsCollectionNtf)(nil), "pbserver.FsToGsCollectionNtf")
	proto.RegisterType((*GsToFsUseFitReq)(nil), "pbserver.GsToFsUseFitReq")
	proto.RegisterType((*FsToGsUseFitAck)(nil), "pbserver.FsToGsUseFitAck")
	proto.RegisterType((*GsToFsFitCacelReq)(nil), "pbserver.GsToFsFitCacelReq")
	proto.RegisterType((*FsToGsFitCacelAck)(nil), "pbserver.FsToGsFitCacelAck")
	proto.RegisterType((*GsToFsUpdatePetReq)(nil), "pbserver.GsToFsUpdatePetReq")
	proto.RegisterType((*FsToGsUpdatePetAck)(nil), "pbserver.FsToGsUpdatePetAck")
	proto.RegisterType((*WorldBossStatusNtf)(nil), "pbserver.WorldBossStatusNtf")
	proto.RegisterType((*ExpStageKillMonsterNtf)(nil), "pbserver.ExpStageKillMonsterNtf")
	proto.RegisterType((*PersonFightResult)(nil), "pbserver.PersonFightResult")
	proto.RegisterType((*VipBossFightResult)(nil), "pbserver.VipBossFightResult")
	proto.RegisterType((*TowerFightResult)(nil), "pbserver.TowerFightResult")
	proto.RegisterType((*FieldBossResult)(nil), "pbserver.FieldBossResult")
	proto.RegisterType((*DarkPalaceBossResult)(nil), "pbserver.DarkPalaceBossResult")
	proto.RegisterType((*MiningNewFightInfoReq)(nil), "pbserver.MiningNewFightInfoReq")
	proto.RegisterType((*MiningNewFightInfoAck)(nil), "pbserver.MiningNewFightInfoAck")
	proto.RegisterType((*MiningFightResultNtf)(nil), "pbserver.MiningFightResultNtf")
	proto.RegisterType((*HangUpKillWaveNtf)(nil), "pbserver.HangUpKillWaveNtf")
	proto.RegisterType((*HangUpBossFightEndNtf)(nil), "pbserver.HangUpBossFightEndNtf")
	proto.RegisterType((*FightTotalData)(nil), "pbserver.FightTotalData")
	proto.RegisterType((*GuildbonfireExpAddNtf)(nil), "pbserver.GuildbonfireExpAddNtf")
	proto.RegisterType((*PaodianGoodsAddNtf)(nil), "pbserver.PaodianGoodsAddNtf")
	proto.RegisterType((*ShabakeFightEndNtf)(nil), "pbserver.ShabakeFightEndNtf")
	proto.RegisterType((*ShabakeRankScore)(nil), "pbserver.ShabakeRankScore")
	proto.RegisterEnum("pbserver.FSFightType", FSFightType_name, FSFightType_value)
}
func (m *GsRouteMessageToFight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsRouteMessageToFight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	if m.CmdId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CmdId))
	}
	if len(m.MsgData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.MsgData)))
		i += copy(dAtA[i:], m.MsgData)
	}
	return i, nil
}

func (m *FSCreateFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSCreateFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.CpData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.CpData)))
		i += copy(dAtA[i:], m.CpData)
	}
	return i, nil
}

func (m *FSCreateFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSCreateFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *FsResidentFightNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsResidentFightNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResidentFights) > 0 {
		for k, _ := range m.ResidentFights {
			dAtA[i] = 0xa
			i++
			v := m.ResidentFights[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if len(m.FieldBossFightInfo) > 0 {
		for k, _ := range m.FieldBossFightInfo {
			dAtA[i] = 0x12
			i++
			v := m.FieldBossFightInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *FsFieldBossInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsFieldBossInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Hp))))
		i += 4
	}
	if m.ReliveTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTime))
	}
	return i, nil
}

func (m *FSContinueFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSContinueFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *FSFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.Winners) > 0 {
		dAtA3 := make([]byte, len(m.Winners)*10)
		var j2 int
		for _, num1 := range m.Winners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Losers) > 0 {
		dAtA5 := make([]byte, len(m.Losers)*10)
		var j4 int
		for _, num1 := range m.Losers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	if len(m.CpData) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.CpData)))
		i += copy(dAtA[i:], m.CpData)
	}
	return i, nil
}

func (m *FSEnterFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSEnterFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightUser.Size()))
		n6, err := m.FightUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.EnterType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.EnterType))
	}
	return i, nil
}

func (m *FSEnterFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSEnterFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Refuse {
		dAtA[i] = 0x8
		i++
		if m.Refuse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FSUpdateUserInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSUpdateUserInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserInfo.Size()))
		n7, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *FSUpdateUserInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSUpdateUserInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Refuse {
		dAtA[i] = 0x8
		i++
		if m.Refuse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FSLeaveFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSLeaveFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActorSessionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ActorSessionId))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *FSLeaveFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSLeaveFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GSToFsUpdateUserFightModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSToFsUpdateUserFightModel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.FigthModel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FigthModel))
	}
	return i, nil
}

func (m *GsToFSUserReliveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFSUserReliveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ReliveType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveType))
	}
	return i, nil
}

func (m *FSToGsUserReliveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSToGsUserReliveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveByIngotTimes))
	}
	return i, nil
}

func (m *GsToFSCheckUserReliveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFSCheckUserReliveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGSCheckUserReliveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGSCheckUserReliveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsDie {
		dAtA[i] = 0x8
		i++
		if m.IsDie {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReliveTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveByIngotTimes))
	}
	return i, nil
}

func (m *FSGetFightIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSGetFightIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	return i, nil
}

func (m *FSGetFightIdAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSGetFightIdAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.SessionId))
	}
	if m.LocatedServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.LocatedServerId))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserInfo.Size()))
		n8, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.TeamId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.TeamId))
	}
	if m.FightModel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightModel))
	}
	if m.BirthArea != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BirthArea))
	}
	if m.IsRobot {
		dAtA[i] = 0x38
		i++
		if m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserDropReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDropReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *UserDropAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDropAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FSAddItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSAddItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.OpType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.OpType))
	}
	return i, nil
}

func (m *FSAddItemAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSAddItemAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSuccess {
		dAtA[i] = 0x8
		i++
		if m.IsSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsTOFsPickUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsTOFsPickUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseId))
	}
	if len(m.ObjIds) > 0 {
		dAtA10 := make([]byte, len(m.ObjIds)*10)
		var j9 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *FsTOGsPickUpAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsTOGsPickUpAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0xa
			i++
			v := m.Items[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func (m *FsSkillUseNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsSkillUseNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseId))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.HeroIndex))
	}
	if m.SkillId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.SkillId))
	}
	if m.CdStartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CdStartTime))
	}
	if m.CdStopTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CdStopTime))
	}
	if len(m.KillMonsterIds) > 0 {
		dAtA13 := make([]byte, len(m.KillMonsterIds)*10)
		var j12 int
		for _, num1 := range m.KillMonsterIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *FsTOGsClearSkillCdNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsTOGsClearSkillCdNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.HeroIndex))
	}
	return i, nil
}

func (m *FsRandomDeliveryNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsRandomDeliveryNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Rand {
		dAtA[i] = 0x10
		i++
		if m.Rand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsUseItemNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUseItemNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *GSTOFSCheckFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSTOFSCheckFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *FSTOGSCheckFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSTOGSCheckFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *GsToFsGetCheerNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGetCheerNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsGetCheerNumAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsGetCheerNumAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.CheerNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CheerNum))
	}
	return i, nil
}

func (m *GsToFsCheerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCheerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsCheerAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCheerAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsGetPotionCdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGetPotionCdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsGetPotionCdAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsGetPotionCdAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	return i, nil
}

func (m *GsToFsUsePotionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUsePotionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsUsePotionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUsePotionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	return i, nil
}

func (m *GsToFsCollectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCollectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *FsToGsCollectionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCollectionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *FsToGsCollectionNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCollectionNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageType))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x1a
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *GsToFsUseFitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUseFitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Fit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Fit.Size()))
		n14, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *FsToGsUseFitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUseFitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSuccess {
		dAtA[i] = 0x8
		i++
		if m.IsSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsFitCacelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsFitCacelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsFitCacelAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsFitCacelAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GsToFsUpdatePetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUpdatePetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Pet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Pet.Size()))
		n15, err := m.Pet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *FsToGsUpdatePetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUpdatePetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WorldBossStatusNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldBossStatusNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *ExpStageKillMonsterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStageKillMonsterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *PersonFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersonFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *VipBossFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipBossFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *TowerFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *FieldBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	return i, nil
}

func (m *DarkPalaceBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DarkPalaceBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n17, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	return i, nil
}

func (m *MiningNewFightInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningNewFightInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MiningId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningUserId))
	}
	if m.IsRetake {
		dAtA[i] = 0x18
		i++
		if m.IsRetake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningNewFightInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningNewFightInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadyOk {
		dAtA[i] = 0x8
		i++
		if m.ReadyOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningFightResultNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningFightResultNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.MiningId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningUserId))
	}
	if m.IsRetake {
		dAtA[i] = 0x20
		i++
		if m.IsRetake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Result != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *HangUpKillWaveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HangUpKillWaveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *HangUpBossFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HangUpBossFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x22
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *FightTotalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightTotalData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Damage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Damage))
	}
	if m.BeDamage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BeDamage))
	}
	if m.Treat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Treat))
	}
	return i, nil
}

func (m *GuildbonfireExpAddNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildbonfireExpAddNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuildId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.GuildId))
	}
	if len(m.UserIds) > 0 {
		dAtA19 := make([]byte, len(m.UserIds)*10)
		var j18 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	return i, nil
}

func (m *PaodianGoodsAddNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianGoodsAddNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.UserIds) > 0 {
		for k, _ := range m.UserIds {
			dAtA[i] = 0x12
			i++
			v := m.UserIds[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ShabakeFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, msg := range m.UserRank {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildRank) > 0 {
		for _, msg := range m.GuildRank {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeRankScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeRankScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Id))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func encodeVarintFsServer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GsRouteMessageToFight) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	if m.CmdId != 0 {
		n += 1 + sovFsServer(uint64(m.CmdId))
	}
	l = len(m.MsgData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSCreateFightReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	l = len(m.CpData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSCreateFightAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *FsResidentFightNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ResidentFights) > 0 {
		for k, v := range m.ResidentFights {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if len(m.FieldBossFightInfo) > 0 {
		for k, v := range m.FieldBossFightInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FsFieldBossInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Hp != 0 {
		n += 5
	}
	if m.ReliveTime != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTime))
	}
	return n
}

func (m *FSContinueFightReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	return n
}

func (m *FSFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if len(m.Winners) > 0 {
		l = 0
		for _, e := range m.Winners {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if len(m.Losers) > 0 {
		l = 0
		for _, e := range m.Losers {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	l = len(m.CpData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSEnterFightReq) Size() (n int) {
	var l int
	_ = l
	if m.FightUser != nil {
		l = m.FightUser.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	if m.EnterType != 0 {
		n += 1 + sovFsServer(uint64(m.EnterType))
	}
	return n
}

func (m *FSEnterFightAck) Size() (n int) {
	var l int
	_ = l
	if m.Refuse {
		n += 2
	}
	return n
}

func (m *FSUpdateUserInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSUpdateUserInfoAck) Size() (n int) {
	var l int
	_ = l
	if m.Refuse {
		n += 2
	}
	return n
}

func (m *FSLeaveFightReq) Size() (n int) {
	var l int
	_ = l
	if m.ActorSessionId != 0 {
		n += 1 + sovFsServer(uint64(m.ActorSessionId))
	}
	if m.Reason != 0 {
		n += 1 + sovFsServer(uint64(m.Reason))
	}
	return n
}

func (m *FSLeaveFightAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GSToFsUpdateUserFightModel) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.FigthModel != 0 {
		n += 1 + sovFsServer(uint64(m.FigthModel))
	}
	return n
}

func (m *GsToFSUserReliveReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ReliveType != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveType))
	}
	return n
}

func (m *FSToGsUserReliveAck) Size() (n int) {
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveByIngotTimes))
	}
	return n
}

func (m *GsToFSCheckUserReliveReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGSCheckUserReliveAck) Size() (n int) {
	var l int
	_ = l
	if m.IsDie {
		n += 2
	}
	if m.ReliveTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveByIngotTimes))
	}
	return n
}

func (m *FSGetFightIdReq) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	return n
}

func (m *FSGetFightIdAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.SessionId != 0 {
		n += 1 + sovFsServer(uint64(m.SessionId))
	}
	if m.LocatedServerId != 0 {
		n += 1 + sovFsServer(uint64(m.LocatedServerId))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	if m.TeamId != 0 {
		n += 1 + sovFsServer(uint64(m.TeamId))
	}
	if m.FightModel != 0 {
		n += 1 + sovFsServer(uint64(m.FightModel))
	}
	if m.BirthArea != 0 {
		n += 1 + sovFsServer(uint64(m.BirthArea))
	}
	if m.IsRobot {
		n += 2
	}
	return n
}

func (m *UserDropReq) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *UserDropAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *FSAddItemReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.OpType != 0 {
		n += 1 + sovFsServer(uint64(m.OpType))
	}
	return n
}

func (m *FSAddItemAck) Size() (n int) {
	var l int
	_ = l
	if m.IsSuccess {
		n += 2
	}
	return n
}

func (m *GsTOFsPickUpReq) Size() (n int) {
	var l int
	_ = l
	if m.UseId != 0 {
		n += 1 + sovFsServer(uint64(m.UseId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *FsTOGsPickUpAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FsSkillUseNtf) Size() (n int) {
	var l int
	_ = l
	if m.UseId != 0 {
		n += 1 + sovFsServer(uint64(m.UseId))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovFsServer(uint64(m.HeroIndex))
	}
	if m.SkillId != 0 {
		n += 1 + sovFsServer(uint64(m.SkillId))
	}
	if m.CdStartTime != 0 {
		n += 1 + sovFsServer(uint64(m.CdStartTime))
	}
	if m.CdStopTime != 0 {
		n += 1 + sovFsServer(uint64(m.CdStopTime))
	}
	if len(m.KillMonsterIds) > 0 {
		l = 0
		for _, e := range m.KillMonsterIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *FsTOGsClearSkillCdNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovFsServer(uint64(m.HeroIndex))
	}
	return n
}

func (m *FsRandomDeliveryNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Rand {
		n += 2
	}
	return n
}

func (m *GsToFsUseItemNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ItemId != 0 {
		n += 1 + sovFsServer(uint64(m.ItemId))
	}
	return n
}

func (m *GSTOFSCheckFightReq) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *FSTOGSCheckFightAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *GsToFsGetCheerNumReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsGetCheerNumAck) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.CheerNum != 0 {
		n += 1 + sovFsServer(uint64(m.CheerNum))
	}
	return n
}

func (m *GsToFsCheerReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsCheerAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GsToFsGetPotionCdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsGetPotionCdAck) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	return n
}

func (m *GsToFsUsePotionReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsUsePotionAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	return n
}

func (m *GsToFsCollectionReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ObjId != 0 {
		n += 1 + sovFsServer(uint64(m.ObjId))
	}
	return n
}

func (m *FsToGsCollectionAck) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovFsServer(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFsServer(uint64(m.EndTime))
	}
	return n
}

func (m *FsToGsCollectionNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageType != 0 {
		n += 1 + sovFsServer(uint64(m.StageType))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GsToFsUseFitReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsUseFitAck) Size() (n int) {
	var l int
	_ = l
	if m.IsSuccess {
		n += 2
	}
	return n
}

func (m *GsToFsFitCacelReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsFitCacelAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GsToFsUpdatePetReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Pet != nil {
		l = m.Pet.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsUpdatePetAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WorldBossStatusNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Status != 0 {
		n += 1 + sovFsServer(uint64(m.Status))
	}
	return n
}

func (m *ExpStageKillMonsterNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *PersonFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *VipBossFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *TowerFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *FieldBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DarkPalaceBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MiningNewFightInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.MiningId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningUserId))
	}
	if m.IsRetake {
		n += 2
	}
	return n
}

func (m *MiningNewFightInfoAck) Size() (n int) {
	var l int
	_ = l
	if m.ReadyOk {
		n += 2
	}
	return n
}

func (m *MiningFightResultNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.MiningId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningUserId))
	}
	if m.IsRetake {
		n += 2
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *HangUpKillWaveNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	return n
}

func (m *HangUpBossFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FightTotalData) Size() (n int) {
	var l int
	_ = l
	if m.Damage != 0 {
		n += 1 + sovFsServer(uint64(m.Damage))
	}
	if m.BeDamage != 0 {
		n += 1 + sovFsServer(uint64(m.BeDamage))
	}
	if m.Treat != 0 {
		n += 1 + sovFsServer(uint64(m.Treat))
	}
	return n
}

func (m *GuildbonfireExpAddNtf) Size() (n int) {
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovFsServer(uint64(m.GuildId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *PaodianGoodsAddNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if len(m.UserIds) > 0 {
		for k, v := range m.UserIds {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ShabakeFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, e := range m.UserRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	if len(m.GuildRank) > 0 {
		for _, e := range m.GuildRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *ShabakeRankScore) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFsServer(uint64(m.Id))
	}
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	return n
}

func sovFsServer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFsServer(x uint64) (n int) {
	return sovFsServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GsRouteMessageToFight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsRouteMessageToFight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsRouteMessageToFight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdId", wireType)
			}
			m.CmdId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgData = append(m.MsgData[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgData == nil {
				m.MsgData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSCreateFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSCreateFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSCreateFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpData = append(m.CpData[:0], dAtA[iNdEx:postIndex]...)
			if m.CpData == nil {
				m.CpData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSCreateFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSCreateFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSCreateFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsResidentFightNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsResidentFightNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsResidentFightNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentFights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResidentFights == nil {
				m.ResidentFights = make(map[int32]uint32)
			}
			var mapkey int32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResidentFights[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldBossFightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldBossFightInfo == nil {
				m.FieldBossFightInfo = make(map[int32]*FsFieldBossInfoNtf)
			}
			var mapkey int32
			var mapvalue *FsFieldBossInfoNtf
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FsFieldBossInfoNtf{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldBossFightInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsFieldBossInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsFieldBossInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsFieldBossInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Hp = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTime", wireType)
			}
			m.ReliveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSContinueFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSContinueFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSContinueFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners = append(m.Winners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winners = append(m.Winners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Losers = append(m.Losers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Losers = append(m.Losers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Losers", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpData = append(m.CpData[:0], dAtA[iNdEx:postIndex]...)
			if m.CpData == nil {
				m.CpData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSEnterFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSEnterFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSEnterFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FightUser == nil {
				m.FightUser = &User{}
			}
			if err := m.FightUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterType", wireType)
			}
			m.EnterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSEnterFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSEnterFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSEnterFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refuse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Refuse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSUpdateUserInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSUpdateUserInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSUpdateUserInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &Actor{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSUpdateUserInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSUpdateUserInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSUpdateUserInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refuse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Refuse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSLeaveFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSLeaveFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSLeaveFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorSessionId", wireType)
			}
			m.ActorSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActorSessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSLeaveFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSLeaveFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSLeaveFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSToFsUpdateUserFightModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSToFsUpdateUserFightModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSToFsUpdateUserFightModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FigthModel", wireType)
			}
			m.FigthModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FigthModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFSUserReliveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFSUserReliveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFSUserReliveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveType", wireType)
			}
			m.ReliveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSToGsUserReliveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSToGsUserReliveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSToGsUserReliveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTimes", wireType)
			}
			m.ReliveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveByIngotTimes", wireType)
			}
			m.ReliveByIngotTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveByIngotTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFSCheckUserReliveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFSCheckUserReliveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFSCheckUserReliveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGSCheckUserReliveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGSCheckUserReliveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGSCheckUserReliveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDie", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDie = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTimes", wireType)
			}
			m.ReliveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveByIngotTimes", wireType)
			}
			m.ReliveByIngotTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveByIngotTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSGetFightIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSGetFightIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSGetFightIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (FSFightType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSGetFightIdAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSGetFightIdAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSGetFightIdAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocatedServerId", wireType)
			}
			m.LocatedServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocatedServerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &Actor{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightModel", wireType)
			}
			m.FightModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthArea", wireType)
			}
			m.BirthArea = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthArea |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRobot = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDropReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDropReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDropReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDropAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDropAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDropAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSAddItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSAddItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSAddItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSAddItemAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSAddItemAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSAddItemAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsTOFsPickUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsTOFsPickUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsTOFsPickUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseId", wireType)
			}
			m.UseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsTOGsPickUpAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsTOGsPickUpAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsTOGsPickUpAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]*ItemUnitForPickUp)
			}
			var mapkey int32
			var mapvalue *ItemUnitForPickUp
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnitForPickUp{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsSkillUseNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsSkillUseNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsSkillUseNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseId", wireType)
			}
			m.UseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStartTime", wireType)
			}
			m.CdStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStopTime", wireType)
			}
			m.CdStopTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStopTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KillMonsterIds = append(m.KillMonsterIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KillMonsterIds = append(m.KillMonsterIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonsterIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsTOGsClearSkillCdNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsTOGsClearSkillCdNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsTOGsClearSkillCdNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsRandomDeliveryNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsRandomDeliveryNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsRandomDeliveryNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUseItemNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUseItemNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUseItemNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSTOFSCheckFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSTOFSCheckFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSTOFSCheckFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSTOGSCheckFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSTOGSCheckFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSTOGSCheckFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGetCheerNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGetCheerNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGetCheerNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsGetCheerNumAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsGetCheerNumAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsGetCheerNumAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheerNum", wireType)
			}
			m.CheerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCheerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCheerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCheerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCheerAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCheerAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCheerAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGetPotionCdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGetPotionCdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGetPotionCdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsGetPotionCdAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsGetPotionCdAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsGetPotionCdAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUsePotionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUsePotionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUsePotionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUsePotionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUsePotionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUsePotionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCollectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCollectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCollectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCollectionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCollectionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCollectionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCollectionNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCollectionNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCollectionNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageType", wireType)
			}
			m.StageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUseFitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUseFitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUseFitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &ActorFit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUseFitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUseFitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUseFitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsFitCacelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsFitCacelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsFitCacelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsFitCacelAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsFitCacelAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsFitCacelAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUpdatePetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUpdatePetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUpdatePetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pet == nil {
				m.Pet = &ActorPet{}
			}
			if err := m.Pet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUpdatePetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUpdatePetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUpdatePetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldBossStatusNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldBossStatusNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldBossStatusNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStageKillMonsterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStageKillMonsterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStageKillMonsterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipBossFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipBossFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipBossFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DarkPalaceBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DarkPalaceBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DarkPalaceBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningNewFightInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningNewFightInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningNewFightInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningId", wireType)
			}
			m.MiningId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningUserId", wireType)
			}
			m.MiningUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRetake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRetake = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningNewFightInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningNewFightInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningNewFightInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadyOk = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningFightResultNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningFightResultNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningFightResultNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningId", wireType)
			}
			m.MiningId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningUserId", wireType)
			}
			m.MiningUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRetake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRetake = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HangUpKillWaveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HangUpKillWaveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HangUpKillWaveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HangUpBossFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HangUpBossFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HangUpBossFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightTotalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightTotalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightTotalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Damage", wireType)
			}
			m.Damage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Damage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamage", wireType)
			}
			m.BeDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeDamage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treat", wireType)
			}
			m.Treat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Treat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildbonfireExpAddNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildbonfireExpAddNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildbonfireExpAddNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianGoodsAddNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianGoodsAddNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianGoodsAddNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserIds == nil {
				m.UserIds = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRank = append(m.UserRank, &ShabakeRankScore{})
			if err := m.UserRank[len(m.UserRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildRank = append(m.GuildRank, &ShabakeRankScore{})
			if err := m.GuildRank[len(m.GuildRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeRankScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeRankScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeRankScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFsServer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFsServer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFsServer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsServer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fs_server.proto", fileDescriptorFsServer) }

var fileDescriptorFsServer = []byte{
	// 2052 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x6f, 0x23, 0x49,
	0xf5, 0xdf, 0xb6, 0xe3, 0x4c, 0xe6, 0xe5, 0x77, 0xe7, 0xc7, 0x5a, 0xfe, 0x8e, 0xa2, 0x7c, 0x4b,
	0xcb, 0x92, 0xd9, 0x09, 0xd9, 0x9d, 0x2c, 0x62, 0x47, 0xc3, 0xcf, 0xc4, 0x49, 0x7b, 0xcd, 0x92,
	0x49, 0xe8, 0x76, 0x18, 0x84, 0xb4, 0xa0, 0x8e, 0xbb, 0xec, 0x34, 0xb6, 0xbb, 0x4c, 0x57, 0x39,
	0x33, 0xb9, 0x72, 0xe0, 0x6f, 0xe0, 0x8c, 0xb8, 0x71, 0x40, 0x1c, 0x11, 0xe2, 0x88, 0xe0, 0xc8,
	0x1f, 0x00, 0x12, 0x1a, 0x24, 0x2e, 0xfc, 0x0b, 0x1c, 0xd0, 0xab, 0xaa, 0xee, 0xae, 0xb6, 0x9d,
	0xf6, 0xcc, 0x82, 0x96, 0x9b, 0xdf, 0xab, 0x57, 0x9f, 0x7a, 0xef, 0xd5, 0xfb, 0xd5, 0x65, 0x58,
	0xed, 0xf0, 0x1f, 0x71, 0x1a, 0xdf, 0xd0, 0xf8, 0x60, 0x18, 0x33, 0xc1, 0xec, 0x85, 0xe1, 0x95,
	0xa2, 0x6b, 0x4b, 0x6d, 0x36, 0x18, 0xb0, 0x48, 0xf1, 0x89, 0x0f, 0x5b, 0x0d, 0xee, 0xb2, 0x91,
	0xa0, 0x67, 0x94, 0x73, 0xbf, 0x4b, 0x5b, 0xcc, 0x09, 0xbb, 0xd7, 0xc2, 0xae, 0xc2, 0xbd, 0x0e,
	0xfe, 0x68, 0x06, 0x55, 0x6b, 0xd7, 0xda, 0xab, 0xb8, 0x09, 0x69, 0x6f, 0x42, 0xa5, 0x3d, 0x08,
	0x9a, 0x41, 0xb5, 0x24, 0xf9, 0x8a, 0x40, 0xf9, 0x01, 0xef, 0x9e, 0xf8, 0xc2, 0xaf, 0x96, 0x77,
	0xad, 0xbd, 0x25, 0x37, 0x21, 0xc9, 0x09, 0xac, 0x39, 0x5e, 0x3d, 0xa6, 0xbe, 0xa0, 0x12, 0xda,
	0xa5, 0x3f, 0x41, 0x69, 0x2e, 0xfc, 0x2e, 0xcd, 0xd0, 0x35, 0x69, 0x6f, 0xc3, 0x7c, 0x7b, 0x28,
	0x61, 0x4a, 0x12, 0x46, 0x53, 0x64, 0x7f, 0x0c, 0xe5, 0xa8, 0xdd, 0x1b, 0xd7, 0x71, 0x39, 0xd5,
	0x91, 0xfc, 0xab, 0x04, 0xb6, 0xc3, 0x5d, 0xca, 0xc3, 0x80, 0x46, 0x42, 0x6e, 0x78, 0x26, 0x3a,
	0xf6, 0xf7, 0x61, 0x25, 0x36, 0x79, 0xbc, 0x6a, 0xed, 0x96, 0xf7, 0x16, 0x0f, 0x3f, 0x38, 0x48,
	0xdc, 0x73, 0x30, 0xb9, 0xeb, 0x20, 0xc7, 0xe0, 0xa7, 0x91, 0x88, 0x6f, 0xdd, 0x31, 0x1c, 0x3b,
	0x00, 0xbb, 0x13, 0xd2, 0x7e, 0x70, 0xcc, 0x38, 0x97, 0xac, 0x66, 0xd4, 0x61, 0xd5, 0x92, 0x44,
	0xff, 0x72, 0x21, 0xba, 0x33, 0xb1, 0x4d, 0x9d, 0x30, 0x05, 0xaf, 0x76, 0x04, 0x1b, 0x53, 0x94,
	0xb1, 0xd7, 0xa0, 0xdc, 0xa3, 0xb7, 0xda, 0x93, 0xf8, 0x13, 0xef, 0xe8, 0xc6, 0xef, 0x8f, 0xa8,
	0x74, 0xe2, 0xb2, 0xab, 0x88, 0xa7, 0xa5, 0x27, 0x56, 0xad, 0x0d, 0x6f, 0xdf, 0x71, 0xe2, 0x14,
	0x98, 0x43, 0x13, 0x66, 0xf1, 0xf0, 0x81, 0x69, 0x48, 0x8a, 0x82, 0x00, 0xcf, 0x44, 0xc7, 0x38,
	0x84, 0xfc, 0x10, 0xbd, 0x3f, 0x2e, 0x50, 0x70, 0xe9, 0x2b, 0x50, 0xba, 0x1e, 0xca, 0x43, 0x4a,
	0x6e, 0xe9, 0x7a, 0x68, 0xef, 0x00, 0xc4, 0xb4, 0x1f, 0xde, 0xd0, 0x56, 0x38, 0xa0, 0x32, 0x9e,
	0xca, 0xae, 0xc1, 0x21, 0x07, 0x60, 0x3b, 0x5e, 0x9d, 0x45, 0x22, 0x8c, 0x46, 0xaf, 0x11, 0x54,
	0xe4, 0x57, 0x16, 0x2c, 0x3b, 0x9e, 0x14, 0x3c, 0x8d, 0x02, 0xd4, 0xe5, 0x01, 0xdc, 0x97, 0xb1,
	0xd2, 0xba, 0x1d, 0x52, 0x2d, 0x9d, 0x31, 0x4c, 0xa4, 0x52, 0x5e, 0xd3, 0x2a, 0xdc, 0x7b, 0x11,
	0x46, 0x11, 0x8d, 0x79, 0xb5, 0xbc, 0x5b, 0xc6, 0x15, 0x4d, 0x62, 0xe0, 0xf6, 0x19, 0xc7, 0x85,
	0x39, 0xb9, 0xa0, 0x29, 0xdc, 0x31, 0xe2, 0xca, 0x90, 0x8a, 0xc2, 0xd2, 0xa4, 0x11, 0xea, 0xf3,
	0xb9, 0x50, 0xff, 0x14, 0x56, 0x1d, 0xef, 0x34, 0x12, 0x34, 0x4e, 0x4d, 0xdb, 0xd7, 0xea, 0x5e,
	0x72, 0x1a, 0x4b, 0x75, 0x17, 0x0f, 0x57, 0xb2, 0xcb, 0x40, 0xae, 0x9b, 0x09, 0xa0, 0x71, 0x14,
	0xb7, 0x4b, 0xe3, 0x94, 0x01, 0x19, 0x83, 0x3c, 0xcc, 0xc3, 0x63, 0x22, 0x6d, 0xc3, 0x7c, 0x4c,
	0x3b, 0x23, 0xae, 0x5c, 0xb1, 0xe0, 0x6a, 0x8a, 0x1c, 0xc3, 0x86, 0xe3, 0x5d, 0x0e, 0x03, 0x5f,
	0x50, 0x04, 0x4e, 0x2e, 0xf2, 0x11, 0x2c, 0x8c, 0x34, 0xa9, 0x95, 0x59, 0xcd, 0x94, 0x39, 0x6a,
	0x0b, 0x16, 0xbb, 0xa9, 0x00, 0xf9, 0xd2, 0x24, 0x46, 0xd1, 0x91, 0xdf, 0x45, 0xed, 0xbe, 0x43,
	0xfd, 0x9b, 0xec, 0x5e, 0xdf, 0x85, 0x15, 0x1f, 0x41, 0x3d, 0xca, 0x79, 0xc8, 0xa2, 0x34, 0xdb,
	0xc7, 0xb8, 0x0a, 0xd2, 0xe7, 0x2c, 0xd2, 0x51, 0xaf, 0x29, 0xb2, 0x9e, 0x87, 0x3c, 0x6a, 0xf7,
	0x48, 0x0b, 0x6a, 0x0d, 0xaf, 0xc5, 0x1c, 0x9e, 0x29, 0x26, 0xd7, 0xce, 0x58, 0x40, 0xfb, 0x08,
	0x24, 0xd5, 0x4f, 0xe2, 0x48, 0x53, 0x18, 0x96, 0x9d, 0xb0, 0x2b, 0xae, 0xa5, 0x94, 0x76, 0xac,
	0xc1, 0x21, 0x67, 0xb0, 0xd1, 0xe0, 0x2d, 0xe6, 0x78, 0xf2, 0x42, 0x64, 0xb8, 0xa2, 0xfe, 0x05,
	0x70, 0x3a, 0xa6, 0xb3, 0x7b, 0x32, 0x38, 0xa4, 0x8b, 0x9e, 0x6b, 0xb1, 0x06, 0xcf, 0xe0, 0xd0,
	0x73, 0xbb, 0xb0, 0x98, 0xa5, 0x02, 0xd7, 0x98, 0x26, 0xcb, 0x3e, 0x00, 0x5b, 0x91, 0xc7, 0xb7,
	0xcd, 0xa8, 0xcb, 0x84, 0x12, 0x54, 0x07, 0x4c, 0x59, 0x21, 0x87, 0x50, 0x55, 0x7a, 0xd7, 0xaf,
	0x69, 0xbb, 0xf7, 0x5a, 0xca, 0x93, 0x9f, 0x5a, 0x50, 0x75, 0x78, 0x8b, 0x35, 0xc6, 0x37, 0xa1,
	0x8a, 0x9b, 0x50, 0x09, 0xf9, 0x49, 0x98, 0xdc, 0xad, 0x22, 0xc6, 0x15, 0x2f, 0xbd, 0xae, 0xe2,
	0xe5, 0x3b, 0x15, 0x77, 0xf0, 0x66, 0x1b, 0x54, 0x15, 0xc3, 0x66, 0x80, 0xfa, 0x7e, 0x38, 0x9e,
	0xd8, 0x2b, 0x87, 0x5b, 0x46, 0xd9, 0x52, 0x45, 0x00, 0x17, 0x8d, 0x7c, 0x27, 0x8f, 0xf2, 0x38,
	0xc5, 0xbd, 0xe5, 0x9f, 0x16, 0xcc, 0x25, 0x69, 0xc6, 0xc7, 0x42, 0x32, 0x63, 0xd8, 0x7b, 0xb0,
	0xda, 0x67, 0x6d, 0x5f, 0xd0, 0xc0, 0x93, 0x67, 0xeb, 0x5a, 0xb2, 0xec, 0x8e, 0xb3, 0x73, 0xe9,
	0x54, 0x9e, 0x91, 0x4e, 0x78, 0x1f, 0x82, 0xfa, 0x83, 0x66, 0x50, 0x9d, 0x53, 0xf7, 0xa1, 0x28,
	0x1d, 0x9b, 0x3a, 0x82, 0x75, 0xa5, 0x31, 0x38, 0xa8, 0xec, 0x55, 0x18, 0x8b, 0xeb, 0xa3, 0x98,
	0xaa, 0x7a, 0x53, 0x71, 0x33, 0x06, 0x5a, 0x1b, 0x72, 0x97, 0x5d, 0x31, 0x51, 0xbd, 0x27, 0xaf,
	0x2c, 0x21, 0xc9, 0xa7, 0xb0, 0x88, 0xc6, 0x9e, 0xc4, 0x6c, 0x88, 0xee, 0xfd, 0xac, 0x75, 0x33,
	0x0b, 0xa3, 0x72, 0x2e, 0x8c, 0x3e, 0xca, 0xe0, 0xd1, 0xeb, 0x7b, 0x50, 0x09, 0x05, 0x1d, 0x24,
	0x7d, 0xd9, 0xce, 0xfc, 0xd0, 0x14, 0x74, 0x70, 0x19, 0x85, 0xc2, 0x55, 0x02, 0xe4, 0x37, 0x16,
	0x2c, 0x39, 0xde, 0x51, 0x10, 0xe0, 0x42, 0x51, 0x96, 0x7d, 0x94, 0x40, 0xaa, 0x66, 0xfc, 0xff,
	0x66, 0x30, 0x64, 0xdb, 0x25, 0xbe, 0xee, 0xed, 0x4a, 0x1e, 0x01, 0xcf, 0x87, 0xd2, 0x4e, 0xad,
	0xb2, 0xa2, 0x6a, 0x4f, 0x00, 0x32, 0xe1, 0x59, 0xbd, 0xb7, 0x62, 0xb6, 0xc5, 0x7d, 0x43, 0x65,
	0xb4, 0xf6, 0x01, 0xdc, 0x0f, 0xb9, 0x37, 0x6a, 0xb7, 0x29, 0xe7, 0x3a, 0x55, 0x32, 0x06, 0xf9,
	0x26, 0xac, 0x36, 0x78, 0xeb, 0xdc, 0xe1, 0x17, 0x61, 0xbb, 0x77, 0x29, 0xbd, 0xbf, 0x09, 0x95,
	0x11, 0xcf, 0xfa, 0x9b, 0x22, 0x50, 0x51, 0x76, 0xf5, 0xe3, 0x66, 0xa0, 0x4c, 0xac, 0xb8, 0x9a,
	0x22, 0xbf, 0xb4, 0x60, 0xd5, 0xe1, 0xad, 0xf3, 0x86, 0x46, 0xc0, 0x23, 0x9f, 0xe6, 0x1d, 0xfc,
	0x8e, 0xd9, 0xd1, 0x73, 0x92, 0x93, 0x0e, 0xa9, 0x5d, 0xce, 0x30, 0xfc, 0x71, 0x7e, 0x5a, 0xf8,
	0xbf, 0xc9, 0xcb, 0x73, 0x58, 0xac, 0x8d, 0x31, 0xbc, 0xf2, 0x47, 0x6c, 0xce, 0xdc, 0xeb, 0x85,
	0xfd, 0xfe, 0x25, 0xa7, 0xd8, 0x5f, 0xa6, 0x9b, 0xf9, 0x00, 0xee, 0x5f, 0xd3, 0x98, 0x35, 0xa3,
	0x80, 0xbe, 0x4c, 0xba, 0x5a, 0xca, 0x90, 0xa1, 0x87, 0x10, 0x69, 0x84, 0x25, 0x24, 0x96, 0x9d,
	0x76, 0xe0, 0x09, 0x3f, 0x96, 0x45, 0x43, 0xa6, 0x4d, 0xd9, 0x35, 0x59, 0x98, 0x3b, 0x48, 0xb2,
	0x61, 0xda, 0xa5, 0xcb, 0xae, 0xc1, 0xc1, 0x06, 0x84, 0x58, 0x67, 0x2c, 0xe2, 0x02, 0x63, 0x8a,
	0x57, 0xe7, 0xa5, 0xa3, 0xc7, 0xb8, 0xe4, 0x0c, 0xb6, 0x94, 0x17, 0xeb, 0x7d, 0xea, 0xc7, 0xd2,
	0xa2, 0xba, 0x9c, 0x36, 0xee, 0x8a, 0xcd, 0x42, 0x93, 0xc8, 0x11, 0x6c, 0x38, 0xdc, 0xf5, 0xa3,
	0x80, 0x0d, 0x4e, 0x64, 0xed, 0x8b, 0x6f, 0x8b, 0xc0, 0x6c, 0x98, 0x8b, 0xfd, 0x48, 0x65, 0xde,
	0x82, 0x2b, 0x7f, 0x93, 0x63, 0x58, 0x93, 0x95, 0x1d, 0x5b, 0x08, 0x5e, 0x42, 0xd1, 0xfe, 0x6d,
	0x98, 0xc7, 0x7b, 0x4e, 0x73, 0x57, 0x53, 0xe4, 0x7d, 0xd8, 0x68, 0x78, 0xad, 0x73, 0xdd, 0x1d,
	0xcc, 0x69, 0x6b, 0xfa, 0x07, 0x02, 0x6e, 0x70, 0xbc, 0xd6, 0x79, 0xc3, 0xd8, 0x30, 0xa5, 0xa2,
	0x1a, 0x1b, 0x0e, 0x60, 0x53, 0x69, 0xd9, 0xa0, 0xa2, 0x7e, 0x4d, 0x69, 0xfc, 0x6c, 0x54, 0x94,
	0xd2, 0xe4, 0xdb, 0xb0, 0x29, 0x5b, 0x8f, 0x29, 0xaf, 0x67, 0x8a, 0xa9, 0x96, 0xd5, 0x60, 0xa1,
	0xad, 0xc5, 0xb4, 0x6d, 0x29, 0x4d, 0xf6, 0x60, 0x45, 0x9d, 0x2d, 0x81, 0x8a, 0x4e, 0xdd, 0x83,
	0x15, 0x75, 0xaa, 0x94, 0x4c, 0x67, 0x18, 0x3e, 0xea, 0x8b, 0x6c, 0x86, 0x41, 0x2a, 0x67, 0xcf,
	0x05, 0x13, 0x21, 0x8b, 0xea, 0x41, 0x11, 0xf2, 0xc7, 0x86, 0x3d, 0x89, 0x7c, 0x91, 0x3d, 0xc6,
	0x48, 0x59, 0x92, 0xc1, 0x9a, 0x90, 0x64, 0x1f, 0xec, 0xf4, 0xbe, 0x15, 0x52, 0xd1, 0xb9, 0x0e,
	0x8e, 0xe9, 0x7a, 0xc0, 0x50, 0xd2, 0x05, 0x56, 0x15, 0x9c, 0x5a, 0xd7, 0x73, 0x0f, 0xaf, 0xb3,
	0x7e, 0x9f, 0xb6, 0x67, 0x1c, 0x8b, 0xe9, 0x2d, 0x2b, 0x54, 0x52, 0x20, 0x25, 0x81, 0xc3, 0x93,
	0x76, 0x6f, 0x0a, 0xa2, 0x6b, 0x24, 0x4f, 0x73, 0xd7, 0x92, 0xe7, 0x66, 0x0c, 0xd4, 0x89, 0x46,
	0x81, 0xa9, 0x93, 0x26, 0xc9, 0x1f, 0xac, 0x49, 0xbc, 0x19, 0xa9, 0x28, 0x7b, 0x95, 0x39, 0x33,
	0xa7, 0x0c, 0xfb, 0x1b, 0x49, 0xd9, 0x2c, 0xcb, 0xb2, 0xb9, 0x97, 0x2b, 0x9b, 0xe3, 0x67, 0x4c,
	0x29, 0x9d, 0x9f, 0xbd, 0x67, 0x9c, 0xcb, 0x2e, 0xa0, 0x6e, 0xd4, 0x09, 0x45, 0x91, 0x5f, 0xdf,
	0x81, 0x72, 0x27, 0x14, 0xba, 0xfa, 0xda, 0x63, 0x23, 0x04, 0xee, 0xc5, 0x65, 0xf2, 0xbe, 0x6c,
	0x0a, 0xea, 0xd2, 0x9d, 0x50, 0xcc, 0xee, 0x43, 0x8f, 0x60, 0x5d, 0x69, 0xe0, 0x84, 0xa2, 0xee,
	0xb7, 0x69, 0xbf, 0x28, 0xa4, 0x36, 0x60, 0x5d, 0xa1, 0x27, 0xc2, 0x38, 0x6d, 0xbb, 0x69, 0x54,
	0xca, 0x69, 0xfb, 0x82, 0xce, 0x32, 0x63, 0x48, 0xef, 0x32, 0x03, 0xf7, 0xe2, 0x32, 0xd9, 0x4c,
	0x63, 0x37, 0xc1, 0xc4, 0x93, 0x1c, 0xb0, 0x9f, 0xb3, 0x58, 0x7d, 0x76, 0x7a, 0xc2, 0x17, 0x23,
	0x5e, 0xfc, 0xe1, 0xb9, 0x0d, 0xf3, 0x5c, 0x8a, 0x25, 0x35, 0x4f, 0x51, 0xe4, 0x03, 0xd8, 0x3e,
	0x7d, 0x39, 0xf4, 0x50, 0xea, 0x93, 0xac, 0xc6, 0x17, 0xc4, 0x0f, 0xf9, 0x9d, 0x05, 0xeb, 0x17,
	0x34, 0xe6, 0x2c, 0xd2, 0x15, 0x52, 0xe6, 0xcc, 0x5d, 0x36, 0x7e, 0x2d, 0x3f, 0x94, 0xbc, 0x9b,
	0x59, 0x39, 0x81, 0x31, 0x7d, 0x32, 0xd1, 0x19, 0xaa, 0x27, 0x13, 0x45, 0xfd, 0x07, 0x51, 0xf6,
	0x7b, 0x0b, 0xec, 0xef, 0x85, 0xc3, 0xf4, 0x51, 0x60, 0x86, 0xfa, 0x5f, 0xcf, 0xab, 0xff, 0xc5,
	0x4c, 0xfd, 0x49, 0x90, 0xcf, 0x45, 0xff, 0xdf, 0x5a, 0xb0, 0xd6, 0x62, 0x2f, 0xd2, 0x2f, 0xe6,
	0x42, 0xed, 0xbf, 0x9a, 0xd7, 0xfe, 0x0b, 0x99, 0xf6, 0xe3, 0x10, 0x9f, 0x8b, 0xee, 0x7f, 0xc1,
	0x31, 0x2d, 0x79, 0x2b, 0xd1, 0xaa, 0xef, 0x00, 0x70, 0x1a, 0x05, 0xcf, 0xe5, 0xdb, 0x82, 0x4e,
	0x49, 0x83, 0x63, 0xbb, 0xb0, 0x8c, 0xc6, 0xe0, 0x30, 0xd5, 0x34, 0x4c, 0xd9, 0x37, 0xea, 0x52,
	0x1e, 0x51, 0xbe, 0x11, 0xa4, 0xe2, 0xca, 0xa2, 0x3c, 0x44, 0xed, 0x12, 0xec, 0x49, 0xa1, 0x29,
	0x96, 0x3c, 0xcc, 0x8f, 0x79, 0x1b, 0x93, 0x63, 0x1e, 0x37, 0xcd, 0xfb, 0x87, 0x05, 0x9b, 0x27,
	0x7e, 0xdc, 0xbb, 0xf0, 0xfb, 0x7e, 0x9b, 0xbe, 0x81, 0x8d, 0xcf, 0xa7, 0xdb, 0xf8, 0x38, 0x3b,
	0x6f, 0x1a, 0xec, 0xff, 0xce, 0x50, 0x0e, 0x5b, 0x67, 0x61, 0x14, 0x46, 0xdd, 0x67, 0xf4, 0x45,
	0xfa, 0xb2, 0x86, 0x85, 0xae, 0x06, 0x0b, 0x03, 0xb9, 0x90, 0x46, 0x62, 0x4a, 0xdb, 0x04, 0x96,
	0xd4, 0xef, 0x4b, 0x9e, 0x7e, 0x22, 0x56, 0xdc, 0x1c, 0x0f, 0xf7, 0x87, 0xdc, 0xa5, 0xc2, 0xef,
	0xa9, 0x4f, 0x91, 0x05, 0x37, 0xa5, 0xc9, 0xe3, 0x69, 0x87, 0xea, 0x69, 0x2b, 0xa6, 0x7e, 0x70,
	0x7b, 0xde, 0xd3, 0xae, 0x4d, 0x48, 0xf2, 0x0b, 0x0b, 0x36, 0xd5, 0x1e, 0x23, 0xd2, 0x8b, 0x5a,
	0xa3, 0xa9, 0x7f, 0x69, 0x86, 0xfe, 0xe5, 0x19, 0xfa, 0xcf, 0xe5, 0xf5, 0x37, 0xd2, 0xa9, 0x62,
	0xa6, 0x13, 0x39, 0x85, 0xf5, 0x8f, 0xfd, 0xa8, 0x7b, 0x39, 0xc4, 0xf2, 0xfb, 0xdc, 0xbf, 0xa1,
	0x45, 0x0a, 0xde, 0xf9, 0xd9, 0x49, 0xfe, 0x6a, 0xc1, 0x96, 0xc2, 0x49, 0xab, 0x92, 0x7e, 0x00,
	0x7c, 0x63, 0xac, 0xbb, 0x32, 0xdf, 0xfe, 0x56, 0x52, 0x4e, 0xe6, 0x64, 0x7c, 0xbe, 0x97, 0x85,
	0xc9, 0xd4, 0x93, 0xff, 0xab, 0xd3, 0xc1, 0x0f, 0x60, 0x45, 0x3d, 0x68, 0x30, 0xe1, 0xf7, 0x4f,
	0x7c, 0xe1, 0xa3, 0x96, 0x81, 0x3f, 0xf0, 0xbb, 0xc9, 0xb0, 0xa4, 0x29, 0xbc, 0x84, 0x2b, 0x7a,
	0xa2, 0x56, 0xd4, 0xa8, 0x94, 0xd2, 0x88, 0x2f, 0x62, 0xea, 0x0b, 0xfd, 0xd2, 0xaa, 0x08, 0xf2,
	0x09, 0x6c, 0x35, 0x46, 0x61, 0x3f, 0xb8, 0x62, 0x51, 0x27, 0x8c, 0xe9, 0xe9, 0xcb, 0xe1, 0x51,
	0x10, 0xe8, 0x76, 0xda, 0xc5, 0x85, 0xac, 0x9d, 0x6a, 0x52, 0x8f, 0x88, 0x71, 0xf6, 0x29, 0x9a,
	0x90, 0xe4, 0xd7, 0x16, 0xd8, 0x17, 0x3e, 0x0b, 0x42, 0x3f, 0x6a, 0x30, 0x16, 0xf0, 0x0c, 0xea,
	0x8e, 0xce, 0x5c, 0xcf, 0x43, 0x2d, 0x1e, 0x3e, 0x34, 0x7a, 0xe4, 0x04, 0xd0, 0x81, 0x0a, 0x35,
	0xed, 0xd6, 0x64, 0x67, 0xed, 0x29, 0x2c, 0x99, 0x0b, 0x6f, 0xe4, 0xda, 0x9f, 0x59, 0x60, 0x7b,
	0xd7, 0xfe, 0x95, 0xdf, 0xa3, 0x66, 0xdc, 0x7c, 0x45, 0x3d, 0xd6, 0xb8, 0x7e, 0xd4, 0xd3, 0xdf,
	0xd0, 0xb5, 0x4c, 0x31, 0x2d, 0x8f, 0x8b, 0x5e, 0x9b, 0xc5, 0xd4, 0x4d, 0x65, 0xed, 0x27, 0x70,
	0x5f, 0x7a, 0x49, 0x6e, 0x2c, 0xcd, 0xdc, 0x98, 0x09, 0x93, 0x27, 0xb0, 0x36, 0xbe, 0x6c, 0xaf,
	0x40, 0x29, 0x4c, 0x5c, 0x56, 0x0a, 0xe5, 0x48, 0xcd, 0x71, 0x21, 0x31, 0x43, 0x12, 0xef, 0xbd,
	0x0d, 0x8b, 0xc6, 0x83, 0x97, 0xbd, 0x00, 0x73, 0x18, 0x8b, 0x6b, 0x6f, 0x1d, 0xaf, 0xfd, 0xe9,
	0xd5, 0x8e, 0xf5, 0xe7, 0x57, 0x3b, 0xd6, 0xdf, 0x5e, 0xed, 0x58, 0x3f, 0xff, 0xfb, 0xce, 0x5b,
	0x57, 0xf3, 0xf2, 0xef, 0xa0, 0x0f, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x81, 0x39, 0x16, 0x98,
	0x39, 0x1a, 0x00, 0x00,
}
