// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package pbserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ErrorAck struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ErrorAck) Reset()                    { *m = ErrorAck{} }
func (m *ErrorAck) String() string            { return proto.CompactTextString(m) }
func (*ErrorAck) ProtoMessage()               {}
func (*ErrorAck) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *ErrorAck) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrorAck) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ItemUnit struct {
	ItemId  int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemNum int32 `protobuf:"varint,2,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
}

func (m *ItemUnit) Reset()                    { *m = ItemUnit{} }
func (m *ItemUnit) String() string            { return proto.CompactTextString(m) }
func (*ItemUnit) ProtoMessage()               {}
func (*ItemUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *ItemUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemUnit) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

type ItemUnits struct {
	Items []*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *ItemUnits) Reset()                    { *m = ItemUnits{} }
func (m *ItemUnits) String() string            { return proto.CompactTextString(m) }
func (*ItemUnits) ProtoMessage()               {}
func (*ItemUnits) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *ItemUnits) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

type ItemUnitForPickUp struct {
	ItemId    int32  `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemNum   int32  `protobuf:"varint,2,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
	Owner     string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	MonsterId int32  `protobuf:"varint,4,opt,name=monsterId,proto3" json:"monsterId,omitempty"`
	DropDate  string `protobuf:"bytes,5,opt,name=dropDate,proto3" json:"dropDate,omitempty"`
}

func (m *ItemUnitForPickUp) Reset()                    { *m = ItemUnitForPickUp{} }
func (m *ItemUnitForPickUp) String() string            { return proto.CompactTextString(m) }
func (*ItemUnitForPickUp) ProtoMessage()               {}
func (*ItemUnitForPickUp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *ItemUnitForPickUp) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemUnitForPickUp) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *ItemUnitForPickUp) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ItemUnitForPickUp) GetMonsterId() int32 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *ItemUnitForPickUp) GetDropDate() string {
	if m != nil {
		return m.DropDate
	}
	return ""
}

type HandShakeReq struct {
	ShakeNo int32 `protobuf:"varint,1,opt,name=shakeNo,proto3" json:"shakeNo,omitempty"`
}

func (m *HandShakeReq) Reset()                    { *m = HandShakeReq{} }
func (m *HandShakeReq) String() string            { return proto.CompactTextString(m) }
func (*HandShakeReq) ProtoMessage()               {}
func (*HandShakeReq) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *HandShakeReq) GetShakeNo() int32 {
	if m != nil {
		return m.ShakeNo
	}
	return 0
}

type HandShakeAck struct {
}

func (m *HandShakeAck) Reset()                    { *m = HandShakeAck{} }
func (m *HandShakeAck) String() string            { return proto.CompactTextString(m) }
func (*HandShakeAck) ProtoMessage()               {}
func (*HandShakeAck) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

type HandCloseNtf struct {
	SessionNo int32 `protobuf:"varint,1,opt,name=sessionNo,proto3" json:"sessionNo,omitempty"`
}

func (m *HandCloseNtf) Reset()                    { *m = HandCloseNtf{} }
func (m *HandCloseNtf) String() string            { return proto.CompactTextString(m) }
func (*HandCloseNtf) ProtoMessage()               {}
func (*HandCloseNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

func (m *HandCloseNtf) GetSessionNo() int32 {
	if m != nil {
		return m.SessionNo
	}
	return 0
}

type Actor struct {
	UserId          uint32               `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	NickName        string               `protobuf:"bytes,2,opt,name=nickName,proto3" json:"nickName,omitempty"`
	Avatar          string               `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Vip             int32                `protobuf:"varint,4,opt,name=vip,proto3" json:"vip,omitempty"`
	Official        int32                `protobuf:"varint,5,opt,name=official,proto3" json:"official,omitempty"`
	DarkPalaceTimes int32                `protobuf:"varint,6,opt,name=darkPalaceTimes,proto3" json:"darkPalaceTimes,omitempty"`
	Heros           map[int32]*ActorHero `protobuf:"bytes,7,rep,name=heros" json:"heros,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	GuildId         int32                `protobuf:"varint,8,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName       string               `protobuf:"bytes,9,opt,name=guildName,proto3" json:"guildName,omitempty"`
	Pet             *ActorPet            `protobuf:"bytes,10,opt,name=pet" json:"pet,omitempty"`
}

func (m *Actor) Reset()                    { *m = Actor{} }
func (m *Actor) String() string            { return proto.CompactTextString(m) }
func (*Actor) ProtoMessage()               {}
func (*Actor) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

func (m *Actor) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Actor) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *Actor) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *Actor) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Actor) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *Actor) GetDarkPalaceTimes() int32 {
	if m != nil {
		return m.DarkPalaceTimes
	}
	return 0
}

func (m *Actor) GetHeros() map[int32]*ActorHero {
	if m != nil {
		return m.Heros
	}
	return nil
}

func (m *Actor) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *Actor) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *Actor) GetPet() *ActorPet {
	if m != nil {
		return m.Pet
	}
	return nil
}

type ActorHero struct {
	Index        int32             `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Sex          int32             `protobuf:"varint,2,opt,name=sex,proto3" json:"sex,omitempty"`
	Job          int32             `protobuf:"varint,3,opt,name=job,proto3" json:"job,omitempty"`
	Level        int32             `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	Prop         *ActorProp        `protobuf:"bytes,5,opt,name=prop" json:"prop,omitempty"`
	Skills       []*Skill          `protobuf:"bytes,6,rep,name=skills" json:"skills,omitempty"`
	Uniqueskills []*Skill          `protobuf:"bytes,7,rep,name=uniqueskills" json:"uniqueskills,omitempty"`
	DisplayInfo  *ActorDisplayInfo `protobuf:"bytes,8,opt,name=displayInfo" json:"displayInfo,omitempty"`
	Buffs        []int32           `protobuf:"varint,9,rep,packed,name=buffs" json:"buffs,omitempty"`
}

func (m *ActorHero) Reset()                    { *m = ActorHero{} }
func (m *ActorHero) String() string            { return proto.CompactTextString(m) }
func (*ActorHero) ProtoMessage()               {}
func (*ActorHero) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{8} }

func (m *ActorHero) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ActorHero) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *ActorHero) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *ActorHero) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ActorHero) GetProp() *ActorProp {
	if m != nil {
		return m.Prop
	}
	return nil
}

func (m *ActorHero) GetSkills() []*Skill {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *ActorHero) GetUniqueskills() []*Skill {
	if m != nil {
		return m.Uniqueskills
	}
	return nil
}

func (m *ActorHero) GetDisplayInfo() *ActorDisplayInfo {
	if m != nil {
		return m.DisplayInfo
	}
	return nil
}

func (m *ActorHero) GetBuffs() []int32 {
	if m != nil {
		return m.Buffs
	}
	return nil
}

type ActorDisplayInfo struct {
	ClothItemId     int32 `protobuf:"varint,1,opt,name=clothItemId,proto3" json:"clothItemId,omitempty"`
	ClothType       int32 `protobuf:"varint,2,opt,name=clothType,proto3" json:"clothType,omitempty"`
	WeaponItemId    int32 `protobuf:"varint,3,opt,name=weaponItemId,proto3" json:"weaponItemId,omitempty"`
	WeaponType      int32 `protobuf:"varint,4,opt,name=weaponType,proto3" json:"weaponType,omitempty"`
	WingId          int32 `protobuf:"varint,5,opt,name=wingId,proto3" json:"wingId,omitempty"`
	MagicCircleLvId int32 `protobuf:"varint,6,opt,name=magicCircleLvId,proto3" json:"magicCircleLvId,omitempty"`
}

func (m *ActorDisplayInfo) Reset()                    { *m = ActorDisplayInfo{} }
func (m *ActorDisplayInfo) String() string            { return proto.CompactTextString(m) }
func (*ActorDisplayInfo) ProtoMessage()               {}
func (*ActorDisplayInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{9} }

func (m *ActorDisplayInfo) GetClothItemId() int32 {
	if m != nil {
		return m.ClothItemId
	}
	return 0
}

func (m *ActorDisplayInfo) GetClothType() int32 {
	if m != nil {
		return m.ClothType
	}
	return 0
}

func (m *ActorDisplayInfo) GetWeaponItemId() int32 {
	if m != nil {
		return m.WeaponItemId
	}
	return 0
}

func (m *ActorDisplayInfo) GetWeaponType() int32 {
	if m != nil {
		return m.WeaponType
	}
	return 0
}

func (m *ActorDisplayInfo) GetWingId() int32 {
	if m != nil {
		return m.WingId
	}
	return 0
}

func (m *ActorDisplayInfo) GetMagicCircleLvId() int32 {
	if m != nil {
		return m.MagicCircleLvId
	}
	return 0
}

type ActorProp struct {
	Props map[int32]int64 `protobuf:"bytes,1,rep,name=props" json:"props,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ActorProp) Reset()                    { *m = ActorProp{} }
func (m *ActorProp) String() string            { return proto.CompactTextString(m) }
func (*ActorProp) ProtoMessage()               {}
func (*ActorProp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{10} }

func (m *ActorProp) GetProps() map[int32]int64 {
	if m != nil {
		return m.Props
	}
	return nil
}

type ActorPet struct {
	PetId int32 `protobuf:"varint,1,opt,name=petId,proto3" json:"petId,omitempty"`
	Lv    int32 `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	Grade int32 `protobuf:"varint,3,opt,name=grade,proto3" json:"grade,omitempty"`
	Break int32 `protobuf:"varint,4,opt,name=break,proto3" json:"break,omitempty"`
}

func (m *ActorPet) Reset()                    { *m = ActorPet{} }
func (m *ActorPet) String() string            { return proto.CompactTextString(m) }
func (*ActorPet) ProtoMessage()               {}
func (*ActorPet) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{11} }

func (m *ActorPet) GetPetId() int32 {
	if m != nil {
		return m.PetId
	}
	return 0
}

func (m *ActorPet) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *ActorPet) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *ActorPet) GetBreak() int32 {
	if m != nil {
		return m.Break
	}
	return 0
}

type ActorFit struct {
	Id        int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lv        int32       `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	FashionId int32       `protobuf:"varint,3,opt,name=fashionId,proto3" json:"fashionId,omitempty"`
	FashionLv int32       `protobuf:"varint,4,opt,name=fashionLv,proto3" json:"fashionLv,omitempty"`
	Skills    []*FitSkill `protobuf:"bytes,5,rep,name=skills" json:"skills,omitempty"`
}

func (m *ActorFit) Reset()                    { *m = ActorFit{} }
func (m *ActorFit) String() string            { return proto.CompactTextString(m) }
func (*ActorFit) ProtoMessage()               {}
func (*ActorFit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{12} }

func (m *ActorFit) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActorFit) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *ActorFit) GetFashionId() int32 {
	if m != nil {
		return m.FashionId
	}
	return 0
}

func (m *ActorFit) GetFashionLv() int32 {
	if m != nil {
		return m.FashionLv
	}
	return 0
}

func (m *ActorFit) GetSkills() []*FitSkill {
	if m != nil {
		return m.Skills
	}
	return nil
}

type FitSkill struct {
	Id   int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lv   int32 `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	Star int32 `protobuf:"varint,3,opt,name=star,proto3" json:"star,omitempty"`
}

func (m *FitSkill) Reset()                    { *m = FitSkill{} }
func (m *FitSkill) String() string            { return proto.CompactTextString(m) }
func (*FitSkill) ProtoMessage()               {}
func (*FitSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{13} }

func (m *FitSkill) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FitSkill) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *FitSkill) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

type Skill struct {
	Id        int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level     int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	CdEndTime int64 `protobuf:"varint,3,opt,name=cdEndTime,proto3" json:"cdEndTime,omitempty"`
}

func (m *Skill) Reset()                    { *m = Skill{} }
func (m *Skill) String() string            { return proto.CompactTextString(m) }
func (*Skill) ProtoMessage()               {}
func (*Skill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{14} }

func (m *Skill) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Skill) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Skill) GetCdEndTime() int64 {
	if m != nil {
		return m.CdEndTime
	}
	return 0
}

func init() {
	proto.RegisterType((*ErrorAck)(nil), "pbserver.ErrorAck")
	proto.RegisterType((*ItemUnit)(nil), "pbserver.ItemUnit")
	proto.RegisterType((*ItemUnits)(nil), "pbserver.ItemUnits")
	proto.RegisterType((*ItemUnitForPickUp)(nil), "pbserver.ItemUnitForPickUp")
	proto.RegisterType((*HandShakeReq)(nil), "pbserver.HandShakeReq")
	proto.RegisterType((*HandShakeAck)(nil), "pbserver.HandShakeAck")
	proto.RegisterType((*HandCloseNtf)(nil), "pbserver.HandCloseNtf")
	proto.RegisterType((*Actor)(nil), "pbserver.Actor")
	proto.RegisterType((*ActorHero)(nil), "pbserver.ActorHero")
	proto.RegisterType((*ActorDisplayInfo)(nil), "pbserver.ActorDisplayInfo")
	proto.RegisterType((*ActorProp)(nil), "pbserver.ActorProp")
	proto.RegisterType((*ActorPet)(nil), "pbserver.ActorPet")
	proto.RegisterType((*ActorFit)(nil), "pbserver.ActorFit")
	proto.RegisterType((*FitSkill)(nil), "pbserver.FitSkill")
	proto.RegisterType((*Skill)(nil), "pbserver.Skill")
}
func (m *ErrorAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ItemUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemNum))
	}
	return i, nil
}

func (m *ItemUnits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUnits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ItemUnitForPickUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUnitForPickUp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemNum))
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if m.MonsterId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MonsterId))
	}
	if len(m.DropDate) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DropDate)))
		i += copy(dAtA[i:], m.DropDate)
	}
	return i, nil
}

func (m *HandShakeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandShakeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShakeNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ShakeNo))
	}
	return i, nil
}

func (m *HandShakeAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandShakeAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *HandCloseNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandCloseNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SessionNo))
	}
	return i, nil
}

func (m *Actor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserId))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Vip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Vip))
	}
	if m.Official != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Official))
	}
	if m.DarkPalaceTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DarkPalaceTimes))
	}
	if len(m.Heros) > 0 {
		for k, _ := range m.Heros {
			dAtA[i] = 0x3a
			i++
			v := m.Heros[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.Pet != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pet.Size()))
		n2, err := m.Pet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ActorHero) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorHero) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Index))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if m.Job != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.Level != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Prop != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Prop.Size()))
		n3, err := m.Prop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Skills) > 0 {
		for _, msg := range m.Skills {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Uniqueskills) > 0 {
		for _, msg := range m.Uniqueskills {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DisplayInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DisplayInfo.Size()))
		n4, err := m.DisplayInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Buffs) > 0 {
		dAtA6 := make([]byte, len(m.Buffs)*10)
		var j5 int
		for _, num1 := range m.Buffs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *ActorDisplayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorDisplayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClothItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MagicCircleLvId))
	}
	return i, nil
}

func (m *ActorProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0xa
			i++
			v := m.Props[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ActorPet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorPet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PetId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PetId))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Grade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	if m.Break != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Break))
	}
	return i, nil
}

func (m *ActorFit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorFit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.FashionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionLv))
	}
	if len(m.Skills) > 0 {
		for _, msg := range m.Skills {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FitSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FitSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *Skill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Skill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.CdEndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CdEndTime))
	}
	return i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ErrorAck) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCommon(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ItemUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovCommon(uint64(m.ItemNum))
	}
	return n
}

func (m *ItemUnits) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ItemUnitForPickUp) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovCommon(uint64(m.ItemNum))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.MonsterId != 0 {
		n += 1 + sovCommon(uint64(m.MonsterId))
	}
	l = len(m.DropDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *HandShakeReq) Size() (n int) {
	var l int
	_ = l
	if m.ShakeNo != 0 {
		n += 1 + sovCommon(uint64(m.ShakeNo))
	}
	return n
}

func (m *HandShakeAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *HandCloseNtf) Size() (n int) {
	var l int
	_ = l
	if m.SessionNo != 0 {
		n += 1 + sovCommon(uint64(m.SessionNo))
	}
	return n
}

func (m *Actor) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCommon(uint64(m.UserId))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovCommon(uint64(m.Vip))
	}
	if m.Official != 0 {
		n += 1 + sovCommon(uint64(m.Official))
	}
	if m.DarkPalaceTimes != 0 {
		n += 1 + sovCommon(uint64(m.DarkPalaceTimes))
	}
	if len(m.Heros) > 0 {
		for k, v := range m.Heros {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.GuildId != 0 {
		n += 1 + sovCommon(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Pet != nil {
		l = m.Pet.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ActorHero) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCommon(uint64(m.Index))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Skills) > 0 {
		for _, e := range m.Skills {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Uniqueskills) > 0 {
		for _, e := range m.Uniqueskills {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.DisplayInfo != nil {
		l = m.DisplayInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Buffs) > 0 {
		l = 0
		for _, e := range m.Buffs {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *ActorDisplayInfo) Size() (n int) {
	var l int
	_ = l
	if m.ClothItemId != 0 {
		n += 1 + sovCommon(uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		n += 1 + sovCommon(uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		n += 1 + sovCommon(uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		n += 1 + sovCommon(uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		n += 1 + sovCommon(uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		n += 1 + sovCommon(uint64(m.MagicCircleLvId))
	}
	return n
}

func (m *ActorProp) Size() (n int) {
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ActorPet) Size() (n int) {
	var l int
	_ = l
	if m.PetId != 0 {
		n += 1 + sovCommon(uint64(m.PetId))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Break != 0 {
		n += 1 + sovCommon(uint64(m.Break))
	}
	return n
}

func (m *ActorFit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.FashionId != 0 {
		n += 1 + sovCommon(uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		n += 1 + sovCommon(uint64(m.FashionLv))
	}
	if len(m.Skills) > 0 {
		for _, e := range m.Skills {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *FitSkill) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	return n
}

func (m *Skill) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.CdEndTime != 0 {
		n += 1 + sovCommon(uint64(m.CdEndTime))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ErrorAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUnits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUnits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUnits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUnitForPickUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUnitForPickUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUnitForPickUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandShakeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandShakeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandShakeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShakeNo", wireType)
			}
			m.ShakeNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShakeNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandShakeAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandShakeAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandShakeAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandCloseNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandCloseNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandCloseNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionNo", wireType)
			}
			m.SessionNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DarkPalaceTimes", wireType)
			}
			m.DarkPalaceTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DarkPalaceTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Heros == nil {
				m.Heros = make(map[int32]*ActorHero)
			}
			var mapkey int32
			var mapvalue *ActorHero
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ActorHero{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Heros[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pet == nil {
				m.Pet = &ActorPet{}
			}
			if err := m.Pet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorHero) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorHero: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorHero: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &ActorProp{}
			}
			if err := m.Prop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skills = append(m.Skills, &Skill{})
			if err := m.Skills[len(m.Skills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uniqueskills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uniqueskills = append(m.Uniqueskills, &Skill{})
			if err := m.Uniqueskills[len(m.Uniqueskills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisplayInfo == nil {
				m.DisplayInfo = &ActorDisplayInfo{}
			}
			if err := m.DisplayInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Buffs = append(m.Buffs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Buffs = append(m.Buffs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorDisplayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorDisplayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorDisplayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothItemId", wireType)
			}
			m.ClothItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothType", wireType)
			}
			m.ClothType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponItemId", wireType)
			}
			m.WeaponItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponType", wireType)
			}
			m.WeaponType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			m.WingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircleLvId", wireType)
			}
			m.MagicCircleLvId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCircleLvId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorPet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorPet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorPet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetId", wireType)
			}
			m.PetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Break", wireType)
			}
			m.Break = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Break |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorFit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorFit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorFit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionId", wireType)
			}
			m.FashionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionLv", wireType)
			}
			m.FashionLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skills = append(m.Skills, &FitSkill{})
			if err := m.Skills[len(m.Skills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FitSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FitSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FitSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Skill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdEndTime", wireType)
			}
			m.CdEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 872 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6a, 0x1b, 0x47,
	0x14, 0xee, 0x4a, 0x5e, 0x5b, 0x3a, 0x76, 0x13, 0x77, 0x1a, 0xca, 0x62, 0x82, 0x10, 0x4b, 0x21,
	0x6a, 0x29, 0xa2, 0x24, 0x2d, 0x98, 0x12, 0x0a, 0x6e, 0x62, 0x13, 0xd1, 0xd4, 0x98, 0x49, 0x72,
	0xd7, 0x9b, 0xf1, 0xee, 0x48, 0x9e, 0xee, 0xcf, 0x6c, 0x66, 0x46, 0xeb, 0x98, 0xbe, 0x41, 0x2f,
	0x0b, 0x85, 0x3e, 0x49, 0x9f, 0xa1, 0x97, 0xbd, 0xec, 0x65, 0x71, 0x5f, 0xa4, 0x9c, 0xd9, 0x99,
	0xdd, 0xb5, 0x6c, 0x28, 0xb9, 0x11, 0xe7, 0xfb, 0xe6, 0x3b, 0x67, 0xce, 0xdf, 0xac, 0x60, 0x2f,
	0x91, 0x45, 0x21, 0xcb, 0x79, 0xa5, 0xa4, 0x91, 0x64, 0x54, 0x9d, 0x6b, 0xae, 0x6a, 0xae, 0xe2,
	0x43, 0x18, 0x1d, 0x2b, 0x25, 0xd5, 0x51, 0x92, 0x11, 0x02, 0x5b, 0x89, 0x4c, 0x79, 0x14, 0x4c,
	0x83, 0x59, 0x48, 0xad, 0x4d, 0x22, 0xd8, 0x29, 0xb8, 0xd6, 0x6c, 0xc5, 0xa3, 0xc1, 0x34, 0x98,
	0x8d, 0xa9, 0x87, 0xf1, 0x53, 0x18, 0x2d, 0x0c, 0x2f, 0xde, 0x94, 0xc2, 0x90, 0x4f, 0x60, 0x5b,
	0x18, 0x5e, 0x2c, 0x52, 0xe7, 0xeb, 0x10, 0x7a, 0xa3, 0x75, 0xba, 0x2e, 0xac, 0x77, 0x48, 0x3d,
	0x8c, 0xbf, 0x86, 0xb1, 0xf7, 0xd6, 0x64, 0x06, 0x21, 0xf2, 0x3a, 0x0a, 0xa6, 0xc3, 0xd9, 0xee,
	0x63, 0x32, 0xf7, 0xe9, 0xcd, 0xbd, 0x86, 0x36, 0x82, 0xf8, 0xb7, 0x00, 0x3e, 0xf2, 0xdc, 0x89,
	0x54, 0x67, 0x22, 0xc9, 0xde, 0x54, 0xef, 0x7f, 0x3d, 0x79, 0x00, 0xa1, 0xbc, 0x2c, 0xb9, 0x8a,
	0x86, 0xb6, 0xa8, 0x06, 0x90, 0x87, 0x30, 0x2e, 0x64, 0xa9, 0x0d, 0x57, 0x8b, 0x34, 0xda, 0xb2,
	0x1e, 0x1d, 0x41, 0x0e, 0x60, 0x94, 0x2a, 0x59, 0x3d, 0x67, 0x86, 0x47, 0xa1, 0x75, 0x6b, 0x71,
	0x3c, 0x83, 0xbd, 0x17, 0xac, 0x4c, 0x5f, 0x5d, 0xb0, 0x8c, 0x53, 0xfe, 0x16, 0x6f, 0xd6, 0x68,
	0x9f, 0x4a, 0x97, 0x92, 0x87, 0xf1, 0xbd, 0x9e, 0xf2, 0x28, 0xc9, 0xe2, 0x2f, 0x1a, 0xfc, 0x2c,
	0x97, 0x9a, 0x9f, 0x9a, 0x25, 0xe6, 0xa0, 0xb9, 0xd6, 0x42, 0x96, 0xad, 0x6f, 0x47, 0xc4, 0xbf,
	0x0c, 0x21, 0x3c, 0x4a, 0x8c, 0x54, 0x58, 0xf3, 0x5a, 0xdb, 0x44, 0x51, 0xf4, 0x21, 0x75, 0x08,
	0xb3, 0x2c, 0x45, 0x92, 0x9d, 0xb2, 0xc2, 0x4f, 0xac, 0xc5, 0xe8, 0xc3, 0x6a, 0x66, 0x98, 0x2f,
	0xdb, 0x21, 0xb2, 0x0f, 0xc3, 0x5a, 0x54, 0xae, 0x62, 0x34, 0x31, 0x8a, 0x5c, 0x2e, 0x45, 0x22,
	0x58, 0x6e, 0x6b, 0x0d, 0x69, 0x8b, 0xc9, 0x0c, 0xee, 0xa7, 0x4c, 0x65, 0x67, 0x2c, 0x67, 0x09,
	0x7f, 0x2d, 0x0a, 0xae, 0xa3, 0x6d, 0x2b, 0xd9, 0xa4, 0xc9, 0x97, 0x10, 0x5e, 0x70, 0x25, 0x75,
	0xb4, 0x63, 0xe7, 0x7a, 0xd0, 0xcd, 0xd5, 0xd6, 0x30, 0x7f, 0x81, 0x87, 0xc7, 0xa5, 0x51, 0x57,
	0xb4, 0x11, 0x62, 0xdf, 0x56, 0x6b, 0x91, 0xa7, 0x8b, 0x34, 0x1a, 0x35, 0x7d, 0x73, 0x10, 0xfb,
	0x62, 0x4d, 0x5b, 0xd8, 0xd8, 0xa6, 0xdf, 0x11, 0xe4, 0x53, 0x18, 0x56, 0xdc, 0x44, 0x30, 0x0d,
	0x6e, 0xee, 0x8f, 0xbd, 0xe7, 0x8c, 0x1b, 0x8a, 0xc7, 0x07, 0x3f, 0x00, 0x74, 0x57, 0x62, 0xd5,
	0x19, 0xbf, 0x72, 0x3d, 0x46, 0x93, 0x7c, 0x06, 0x61, 0xcd, 0xf2, 0x75, 0xd3, 0xb8, 0xdd, 0xc7,
	0x1f, 0x6f, 0xc4, 0x41, 0x5f, 0xda, 0x28, 0xbe, 0x19, 0x1c, 0x06, 0xf1, 0x1f, 0x03, 0x18, 0xb7,
	0x07, 0xb8, 0x52, 0xa2, 0x4c, 0xf9, 0x3b, 0x17, 0xb0, 0x01, 0x78, 0x89, 0xe6, 0xef, 0xdc, 0xfa,
	0xa1, 0x89, 0xcc, 0x4f, 0xf2, 0xdc, 0x4e, 0x20, 0xa4, 0x68, 0xa2, 0x67, 0xce, 0x6b, 0x9e, 0xbb,
	0x01, 0x34, 0x80, 0x3c, 0x82, 0xad, 0x4a, 0xc9, 0xca, 0xb6, 0xff, 0x76, 0x2e, 0x67, 0x4a, 0x56,
	0xd4, 0x0a, 0xc8, 0x23, 0xd8, 0xd6, 0x99, 0xc8, 0x73, 0x1c, 0x03, 0xb6, 0xf9, 0x7e, 0x27, 0x7d,
	0x85, 0x3c, 0x75, 0xc7, 0xe4, 0x09, 0xec, 0xad, 0x4b, 0xf1, 0x76, 0xcd, 0x9d, 0x7c, 0xe7, 0x6e,
	0xf9, 0x0d, 0x11, 0x79, 0x0a, 0xbb, 0xa9, 0xd0, 0x55, 0xce, 0xae, 0x16, 0xe5, 0x52, 0xda, 0xa9,
	0xdc, 0x9e, 0xe4, 0xf3, 0x4e, 0x41, 0xfb, 0x72, 0x2c, 0xed, 0x7c, 0xbd, 0x5c, 0xea, 0x68, 0x3c,
	0x1d, 0x62, 0x69, 0x16, 0xc4, 0x7f, 0x07, 0xb0, 0xbf, 0xe9, 0x47, 0xa6, 0xb0, 0x9b, 0xe4, 0xd2,
	0x5c, 0x2c, 0xfa, 0x2f, 0xb9, 0x4f, 0xe1, 0x0a, 0x58, 0xf8, 0xfa, 0xaa, 0xe2, 0xae, 0xa3, 0x1d,
	0x41, 0x62, 0xd8, 0xbb, 0xe4, 0xac, 0x92, 0xa5, 0x0b, 0xd0, 0x34, 0xf8, 0x06, 0x47, 0x26, 0x00,
	0x0d, 0xb6, 0x21, 0x9a, 0x76, 0xf7, 0x18, 0x7c, 0x20, 0x97, 0xa2, 0x5c, 0x2d, 0x52, 0xb7, 0xf4,
	0x0e, 0xe1, 0xca, 0x17, 0x6c, 0x25, 0x92, 0x67, 0x42, 0x25, 0x39, 0x7f, 0x59, 0x2f, 0x52, 0xbf,
	0xf2, 0x1b, 0x74, 0xfc, 0xb3, 0x5b, 0x09, 0x9c, 0x0f, 0xf9, 0x0a, 0x42, 0x9c, 0x90, 0xff, 0xae,
	0x4d, 0xee, 0x98, 0xe1, 0x1c, 0x7f, 0xfc, 0x1b, 0xb0, 0xe2, 0x83, 0x43, 0x80, 0x8e, 0xbc, 0x63,
	0x4b, 0x1f, 0xf4, 0xb7, 0x74, 0xd8, 0x5f, 0xc8, 0x1f, 0x61, 0xe4, 0x17, 0x1e, 0x55, 0x15, 0x37,
	0x6d, 0x23, 0x1b, 0x40, 0xee, 0xc1, 0x20, 0xaf, 0x5d, 0xef, 0x06, 0x79, 0x8d, 0xaa, 0x95, 0x62,
	0x29, 0x77, 0xdd, 0x6a, 0x80, 0x9d, 0x9a, 0xe2, 0x2c, 0xf3, 0x0b, 0x69, 0x41, 0xfc, 0x6b, 0xe0,
	0xc2, 0x9f, 0x08, 0x83, 0x81, 0x84, 0x8f, 0x3d, 0x10, 0xb7, 0x03, 0x3f, 0x84, 0xf1, 0x92, 0xe9,
	0x0b, 0x21, 0xcb, 0x76, 0x14, 0x1d, 0xd1, 0x3b, 0x7d, 0x59, 0xfb, 0x0f, 0x6d, 0x4b, 0x90, 0xcf,
	0xdb, 0x85, 0x0e, 0x37, 0xff, 0x0f, 0x4e, 0x84, 0xb9, 0xb1, 0xd3, 0xf1, 0xb7, 0x30, 0xf2, 0xdc,
	0xff, 0xe6, 0x44, 0x60, 0x4b, 0xfb, 0x8f, 0x5f, 0x48, 0xad, 0x1d, 0x7f, 0x0f, 0xe1, 0xdd, 0xce,
	0xed, 0xa3, 0x1c, 0xf4, 0x1f, 0x25, 0xae, 0x60, 0x7a, 0x5c, 0xa6, 0xf8, 0x7d, 0xb3, 0x71, 0x86,
	0xb4, 0x23, 0xbe, 0xdb, 0xff, 0xf3, 0x7a, 0x12, 0xfc, 0x75, 0x3d, 0x09, 0xfe, 0xb9, 0x9e, 0x04,
	0xbf, 0xff, 0x3b, 0xf9, 0xe0, 0x7c, 0xdb, 0xfe, 0xdf, 0x3e, 0xf9, 0x2f, 0x00, 0x00, 0xff, 0xff,
	0xba, 0xad, 0x9b, 0x95, 0x7f, 0x07, 0x00, 0x00,
}
