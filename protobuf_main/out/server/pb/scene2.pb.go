// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scene2.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Buff struct {
	Idx int32 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Ts  int64 `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *Buff) Reset()                    { *m = Buff{} }
func (m *Buff) String() string            { return proto.CompactTextString(m) }
func (*Buff) ProtoMessage()               {}
func (*Buff) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{0} }

func (m *Buff) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Buff) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type BuffHpChangeInfo struct {
	Idx      int32 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Death    int32 `protobuf:"varint,2,opt,name=death,proto3" json:"death,omitempty"`
	TargetId int32 `protobuf:"varint,3,opt,name=targetId,proto3" json:"targetId,omitempty"`
	ChangeHp int64 `protobuf:"varint,4,opt,name=changeHp,proto3" json:"changeHp,omitempty"`
	TotalHp  int64 `protobuf:"varint,5,opt,name=totalHp,proto3" json:"totalHp,omitempty"`
}

func (m *BuffHpChangeInfo) Reset()                    { *m = BuffHpChangeInfo{} }
func (m *BuffHpChangeInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeInfo) ProtoMessage()               {}
func (*BuffHpChangeInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{1} }

func (m *BuffHpChangeInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffHpChangeInfo) GetDeath() int32 {
	if m != nil {
		return m.Death
	}
	return 0
}

func (m *BuffHpChangeInfo) GetTargetId() int32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *BuffHpChangeInfo) GetChangeHp() int64 {
	if m != nil {
		return m.ChangeHp
	}
	return 0
}

func (m *BuffHpChangeInfo) GetTotalHp() int64 {
	if m != nil {
		return m.TotalHp
	}
	return 0
}

type SceneObj struct {
	ObjType  int32          `protobuf:"varint,1,opt,name=objType,proto3" json:"objType,omitempty"`
	X        int32          `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y        int32          `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Dir      int32          `protobuf:"varint,4,opt,name=dir,proto3" json:"dir,omitempty"`
	ObjId    int32          `protobuf:"varint,5,opt,name=objId,proto3" json:"objId,omitempty"`
	TeamId   int32          `protobuf:"varint,6,opt,name=teamId,proto3" json:"teamId,omitempty"`
	Hp       int64          `protobuf:"varint,7,opt,name=hp,proto3" json:"hp,omitempty"`
	HpMax    int64          `protobuf:"varint,8,opt,name=hpMax,proto3" json:"hpMax,omitempty"`
	Buffs    []*BuffAdd     `protobuf:"bytes,9,rep,name=buffs" json:"buffs,omitempty"`
	User     *SceneUser     `protobuf:"bytes,21,opt,name=user" json:"user,omitempty"`
	Hero     *SceneHero     `protobuf:"bytes,22,opt,name=hero" json:"hero,omitempty"`
	Monster  *SceneMonster  `protobuf:"bytes,23,opt,name=monster" json:"monster,omitempty"`
	Observer *SceneObserver `protobuf:"bytes,24,opt,name=observer" json:"observer,omitempty"`
	Tortoise *SceneTortoise `protobuf:"bytes,25,opt,name=tortoise" json:"tortoise,omitempty"`
}

func (m *SceneObj) Reset()                    { *m = SceneObj{} }
func (m *SceneObj) String() string            { return proto.CompactTextString(m) }
func (*SceneObj) ProtoMessage()               {}
func (*SceneObj) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{2} }

func (m *SceneObj) GetObjType() int32 {
	if m != nil {
		return m.ObjType
	}
	return 0
}

func (m *SceneObj) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *SceneObj) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *SceneObj) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *SceneObj) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObj) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *SceneObj) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SceneObj) GetHpMax() int64 {
	if m != nil {
		return m.HpMax
	}
	return 0
}

func (m *SceneObj) GetBuffs() []*BuffAdd {
	if m != nil {
		return m.Buffs
	}
	return nil
}

func (m *SceneObj) GetUser() *SceneUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SceneObj) GetHero() *SceneHero {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *SceneObj) GetMonster() *SceneMonster {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *SceneObj) GetObserver() *SceneObserver {
	if m != nil {
		return m.Observer
	}
	return nil
}

func (m *SceneObj) GetTortoise() *SceneTortoise {
	if m != nil {
		return m.Tortoise
	}
	return nil
}

type SceneUser struct {
	UserId             int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Name               string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Weapons            map[int32]int32 `protobuf:"bytes,4,rep,name=weapons" json:"weapons,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MedalIdx           int32           `protobuf:"varint,5,opt,name=medalIdx,proto3" json:"medalIdx,omitempty"`
	Display            *DisplayNtf     `protobuf:"bytes,6,opt,name=display" json:"display,omitempty"`
	Vip                int32           `protobuf:"varint,7,opt,name=vip,proto3" json:"vip,omitempty"`
	Kingdom            int32           `protobuf:"varint,8,opt,name=kingdom,proto3" json:"kingdom,omitempty"`
	Lvl                int32           `protobuf:"varint,9,opt,name=lvl,proto3" json:"lvl,omitempty"`
	Sex                int32           `protobuf:"varint,10,opt,name=sex,proto3" json:"sex,omitempty"`
	Combat             int64           `protobuf:"varint,11,opt,name=combat,proto3" json:"combat,omitempty"`
	Kill               int32           `protobuf:"varint,12,opt,name=kill,proto3" json:"kill,omitempty"`
	GuildId            int32           `protobuf:"varint,13,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName          string          `protobuf:"bytes,14,opt,name=guildName,proto3" json:"guildName,omitempty"`
	KingdomPos         int32           `protobuf:"varint,15,opt,name=kingdomPos,proto3" json:"kingdomPos,omitempty"`
	Avatar             string          `protobuf:"bytes,16,opt,name=avatar,proto3" json:"avatar,omitempty"`
	HeroIdxList        []*HeroPosInfo  `protobuf:"bytes,17,rep,name=heroIdxList" json:"heroIdxList,omitempty"`
	Mrank              int32           `protobuf:"varint,19,opt,name=mrank,proto3" json:"mrank,omitempty"`
	DrinkCount         int32           `protobuf:"varint,20,opt,name=drinkCount,proto3" json:"drinkCount,omitempty"`
	ToastUserIds       []int32         `protobuf:"varint,21,rep,packed,name=toastUserIds" json:"toastUserIds,omitempty"`
	EmperorAchieveStar int32           `protobuf:"varint,22,opt,name=emperorAchieveStar,proto3" json:"emperorAchieveStar,omitempty"`
	// bool  fighting   = 50; // true 战斗中 false 观战
	// int32 fightingCD = 51;
	MedalLvl           int32  `protobuf:"varint,23,opt,name=medalLvl,proto3" json:"medalLvl,omitempty"`
	ArtifactId         int32  `protobuf:"varint,24,opt,name=artifactId,proto3" json:"artifactId,omitempty"`
	ArtifactLvl        int32  `protobuf:"varint,25,opt,name=artifactLvl,proto3" json:"artifactLvl,omitempty"`
	ArtifactClothId    int32  `protobuf:"varint,26,opt,name=artifactClothId,proto3" json:"artifactClothId,omitempty"`
	ArtifactClothLvl   int32  `protobuf:"varint,27,opt,name=artifactClothLvl,proto3" json:"artifactClothLvl,omitempty"`
	SwordSpiritStage   int32  `protobuf:"varint,28,opt,name=swordSpiritStage,proto3" json:"swordSpiritStage,omitempty"`
	GuildLogoId        int32  `protobuf:"varint,29,opt,name=guildLogoId,proto3" json:"guildLogoId,omitempty"`
	GuildColorId       int32  `protobuf:"varint,30,opt,name=guildColorId,proto3" json:"guildColorId,omitempty"`
	BeforeGuildName    string `protobuf:"bytes,31,opt,name=beforeGuildName,proto3" json:"beforeGuildName,omitempty"`
	IsStatue           bool   `protobuf:"varint,32,opt,name=isStatue,proto3" json:"isStatue,omitempty"`
	PkStatus           int32  `protobuf:"varint,34,opt,name=pkStatus,proto3" json:"pkStatus,omitempty"`
	TargetAssistObjId  int32  `protobuf:"varint,35,opt,name=targetAssistObjId,proto3" json:"targetAssistObjId,omitempty"`
	AssistActive       bool   `protobuf:"varint,36,opt,name=assistActive,proto3" json:"assistActive,omitempty"`
	ChangePKStatusCdSt int32  `protobuf:"varint,37,opt,name=changePKStatusCdSt,proto3" json:"changePKStatusCdSt,omitempty"`
	TransferType       int32  `protobuf:"varint,38,opt,name=transferType,proto3" json:"transferType,omitempty"`
	Brighten           string `protobuf:"bytes,39,opt,name=brighten,proto3" json:"brighten,omitempty"`
	TransferQuality    int32  `protobuf:"varint,40,opt,name=transferQuality,proto3" json:"transferQuality,omitempty"`
	RobotType          int32  `protobuf:"varint,41,opt,name=robotType,proto3" json:"robotType,omitempty"`
}

func (m *SceneUser) Reset()                    { *m = SceneUser{} }
func (m *SceneUser) String() string            { return proto.CompactTextString(m) }
func (*SceneUser) ProtoMessage()               {}
func (*SceneUser) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{3} }

func (m *SceneUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneUser) GetWeapons() map[int32]int32 {
	if m != nil {
		return m.Weapons
	}
	return nil
}

func (m *SceneUser) GetMedalIdx() int32 {
	if m != nil {
		return m.MedalIdx
	}
	return 0
}

func (m *SceneUser) GetDisplay() *DisplayNtf {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *SceneUser) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *SceneUser) GetKingdom() int32 {
	if m != nil {
		return m.Kingdom
	}
	return 0
}

func (m *SceneUser) GetLvl() int32 {
	if m != nil {
		return m.Lvl
	}
	return 0
}

func (m *SceneUser) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *SceneUser) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *SceneUser) GetKill() int32 {
	if m != nil {
		return m.Kill
	}
	return 0
}

func (m *SceneUser) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SceneUser) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *SceneUser) GetKingdomPos() int32 {
	if m != nil {
		return m.KingdomPos
	}
	return 0
}

func (m *SceneUser) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *SceneUser) GetHeroIdxList() []*HeroPosInfo {
	if m != nil {
		return m.HeroIdxList
	}
	return nil
}

func (m *SceneUser) GetMrank() int32 {
	if m != nil {
		return m.Mrank
	}
	return 0
}

func (m *SceneUser) GetDrinkCount() int32 {
	if m != nil {
		return m.DrinkCount
	}
	return 0
}

func (m *SceneUser) GetToastUserIds() []int32 {
	if m != nil {
		return m.ToastUserIds
	}
	return nil
}

func (m *SceneUser) GetEmperorAchieveStar() int32 {
	if m != nil {
		return m.EmperorAchieveStar
	}
	return 0
}

func (m *SceneUser) GetMedalLvl() int32 {
	if m != nil {
		return m.MedalLvl
	}
	return 0
}

func (m *SceneUser) GetArtifactId() int32 {
	if m != nil {
		return m.ArtifactId
	}
	return 0
}

func (m *SceneUser) GetArtifactLvl() int32 {
	if m != nil {
		return m.ArtifactLvl
	}
	return 0
}

func (m *SceneUser) GetArtifactClothId() int32 {
	if m != nil {
		return m.ArtifactClothId
	}
	return 0
}

func (m *SceneUser) GetArtifactClothLvl() int32 {
	if m != nil {
		return m.ArtifactClothLvl
	}
	return 0
}

func (m *SceneUser) GetSwordSpiritStage() int32 {
	if m != nil {
		return m.SwordSpiritStage
	}
	return 0
}

func (m *SceneUser) GetGuildLogoId() int32 {
	if m != nil {
		return m.GuildLogoId
	}
	return 0
}

func (m *SceneUser) GetGuildColorId() int32 {
	if m != nil {
		return m.GuildColorId
	}
	return 0
}

func (m *SceneUser) GetBeforeGuildName() string {
	if m != nil {
		return m.BeforeGuildName
	}
	return ""
}

func (m *SceneUser) GetIsStatue() bool {
	if m != nil {
		return m.IsStatue
	}
	return false
}

func (m *SceneUser) GetPkStatus() int32 {
	if m != nil {
		return m.PkStatus
	}
	return 0
}

func (m *SceneUser) GetTargetAssistObjId() int32 {
	if m != nil {
		return m.TargetAssistObjId
	}
	return 0
}

func (m *SceneUser) GetAssistActive() bool {
	if m != nil {
		return m.AssistActive
	}
	return false
}

func (m *SceneUser) GetChangePKStatusCdSt() int32 {
	if m != nil {
		return m.ChangePKStatusCdSt
	}
	return 0
}

func (m *SceneUser) GetTransferType() int32 {
	if m != nil {
		return m.TransferType
	}
	return 0
}

func (m *SceneUser) GetBrighten() string {
	if m != nil {
		return m.Brighten
	}
	return ""
}

func (m *SceneUser) GetTransferQuality() int32 {
	if m != nil {
		return m.TransferQuality
	}
	return 0
}

func (m *SceneUser) GetRobotType() int32 {
	if m != nil {
		return m.RobotType
	}
	return 0
}

type HeroPosInfo struct {
	Id      int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Pos     int32 `protobuf:"varint,2,opt,name=pos,proto3" json:"pos,omitempty"`
	Quality int32 `protobuf:"varint,3,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *HeroPosInfo) Reset()                    { *m = HeroPosInfo{} }
func (m *HeroPosInfo) String() string            { return proto.CompactTextString(m) }
func (*HeroPosInfo) ProtoMessage()               {}
func (*HeroPosInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{4} }

func (m *HeroPosInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroPosInfo) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *HeroPosInfo) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type SceneHero struct {
	OwnerId   int32  `protobuf:"varint,1,opt,name=ownerId,proto3" json:"ownerId,omitempty"`
	OwnerName string `protobuf:"bytes,2,opt,name=ownerName,proto3" json:"ownerName,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	HeroIdx   int32  `protobuf:"varint,4,opt,name=heroIdx,proto3" json:"heroIdx,omitempty"`
	MedalIdx  int32  `protobuf:"varint,5,opt,name=medalIdx,proto3" json:"medalIdx,omitempty"`
	Quality   int32  `protobuf:"varint,6,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *SceneHero) Reset()                    { *m = SceneHero{} }
func (m *SceneHero) String() string            { return proto.CompactTextString(m) }
func (*SceneHero) ProtoMessage()               {}
func (*SceneHero) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{5} }

func (m *SceneHero) GetOwnerId() int32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *SceneHero) GetOwnerName() string {
	if m != nil {
		return m.OwnerName
	}
	return ""
}

func (m *SceneHero) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneHero) GetHeroIdx() int32 {
	if m != nil {
		return m.HeroIdx
	}
	return 0
}

func (m *SceneHero) GetMedalIdx() int32 {
	if m != nil {
		return m.MedalIdx
	}
	return 0
}

func (m *SceneHero) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type SceneMonster struct {
	Idx int32 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *SceneMonster) Reset()                    { *m = SceneMonster{} }
func (m *SceneMonster) String() string            { return proto.CompactTextString(m) }
func (*SceneMonster) ProtoMessage()               {}
func (*SceneMonster) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{6} }

func (m *SceneMonster) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type SceneTortoise struct {
	Speed         int32 `protobuf:"varint,1,opt,name=speed,proto3" json:"speed,omitempty"`
	BuffAddLayers int32 `protobuf:"varint,2,opt,name=buffAddLayers,proto3" json:"buffAddLayers,omitempty"`
	BuffDecLayers int32 `protobuf:"varint,3,opt,name=buffDecLayers,proto3" json:"buffDecLayers,omitempty"`
}

func (m *SceneTortoise) Reset()                    { *m = SceneTortoise{} }
func (m *SceneTortoise) String() string            { return proto.CompactTextString(m) }
func (*SceneTortoise) ProtoMessage()               {}
func (*SceneTortoise) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{7} }

func (m *SceneTortoise) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *SceneTortoise) GetBuffAddLayers() int32 {
	if m != nil {
		return m.BuffAddLayers
	}
	return 0
}

func (m *SceneTortoise) GetBuffDecLayers() int32 {
	if m != nil {
		return m.BuffDecLayers
	}
	return 0
}

type SceneObserver struct {
	UserId     int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Kill       int32  `protobuf:"varint,3,opt,name=kill,proto3" json:"kill,omitempty"`
	Kingdom    int32  `protobuf:"varint,4,opt,name=kingdom,proto3" json:"kingdom,omitempty"`
	KingdomPos int32  `protobuf:"varint,5,opt,name=kingdomPos,proto3" json:"kingdomPos,omitempty"`
	Avatar     string `protobuf:"bytes,6,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *SceneObserver) Reset()                    { *m = SceneObserver{} }
func (m *SceneObserver) String() string            { return proto.CompactTextString(m) }
func (*SceneObserver) ProtoMessage()               {}
func (*SceneObserver) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{8} }

func (m *SceneObserver) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneObserver) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneObserver) GetKill() int32 {
	if m != nil {
		return m.Kill
	}
	return 0
}

func (m *SceneObserver) GetKingdom() int32 {
	if m != nil {
		return m.Kingdom
	}
	return 0
}

func (m *SceneObserver) GetKingdomPos() int32 {
	if m != nil {
		return m.KingdomPos
	}
	return 0
}

func (m *SceneObserver) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

type SceneEnterNtf struct {
	Objs []*SceneObj `protobuf:"bytes,1,rep,name=objs" json:"objs,omitempty"`
}

func (m *SceneEnterNtf) Reset()                    { *m = SceneEnterNtf{} }
func (m *SceneEnterNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneEnterNtf) ProtoMessage()               {}
func (*SceneEnterNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{9} }

func (m *SceneEnterNtf) GetObjs() []*SceneObj {
	if m != nil {
		return m.Objs
	}
	return nil
}

type SceneLeaveNtf struct {
	ObjIds []int32 `protobuf:"varint,1,rep,packed,name=objIds" json:"objIds,omitempty"`
}

func (m *SceneLeaveNtf) Reset()                    { *m = SceneLeaveNtf{} }
func (m *SceneLeaveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneLeaveNtf) ProtoMessage()               {}
func (*SceneLeaveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{10} }

func (m *SceneLeaveNtf) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

type SceneMoveRpt struct {
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	ObjId int32 `protobuf:"varint,4,opt,name=objId,proto3" json:"objId,omitempty"`
	Dir   int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *SceneMoveRpt) Reset()                    { *m = SceneMoveRpt{} }
func (m *SceneMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveRpt) ProtoMessage()               {}
func (*SceneMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{11} }

func (m *SceneMoveRpt) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *SceneMoveRpt) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *SceneMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type SceneMoveNtf struct {
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	ObjId int32 `protobuf:"varint,4,opt,name=objId,proto3" json:"objId,omitempty"`
	Dir   int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *SceneMoveNtf) Reset()                    { *m = SceneMoveNtf{} }
func (m *SceneMoveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveNtf) ProtoMessage()               {}
func (*SceneMoveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{12} }

func (m *SceneMoveNtf) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *SceneMoveNtf) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *SceneMoveNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveNtf) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type AttackRpt struct {
	// 没有移动施法
	AttackerId int32   `protobuf:"varint,1,opt,name=attackerId,proto3" json:"attackerId,omitempty"`
	SkillId    int32   `protobuf:"varint,2,opt,name=skillId,proto3" json:"skillId,omitempty"`
	ObjIds     []int32 `protobuf:"varint,3,rep,packed,name=objIds" json:"objIds,omitempty"`
	LinkNum    int32   `protobuf:"varint,4,opt,name=linkNum,proto3" json:"linkNum,omitempty"`
	Dir        int32   `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *AttackRpt) Reset()                    { *m = AttackRpt{} }
func (m *AttackRpt) String() string            { return proto.CompactTextString(m) }
func (*AttackRpt) ProtoMessage()               {}
func (*AttackRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{13} }

func (m *AttackRpt) GetAttackerId() int32 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *AttackRpt) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackRpt) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *AttackRpt) GetLinkNum() int32 {
	if m != nil {
		return m.LinkNum
	}
	return 0
}

func (m *AttackRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type SkillGongfuInfo struct {
	SkillId         int32   `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	WugongId        int32   `protobuf:"varint,2,opt,name=wugongId,proto3" json:"wugongId,omitempty"`
	NeigongId       int32   `protobuf:"varint,3,opt,name=neigongId,proto3" json:"neigongId,omitempty"`
	QinggongId      int32   `protobuf:"varint,4,opt,name=qinggongId,proto3" json:"qinggongId,omitempty"`
	WugongLevel     int32   `protobuf:"varint,5,opt,name=wugongLevel,proto3" json:"wugongLevel,omitempty"`
	WugongStar      int32   `protobuf:"varint,6,opt,name=wugongStar,proto3" json:"wugongStar,omitempty"`
	NeigongLevel    int32   `protobuf:"varint,7,opt,name=neigongLevel,proto3" json:"neigongLevel,omitempty"`
	NeigongStar     int32   `protobuf:"varint,8,opt,name=neigongStar,proto3" json:"neigongStar,omitempty"`
	QinggongLevel   int32   `protobuf:"varint,9,opt,name=qinggongLevel,proto3" json:"qinggongLevel,omitempty"`
	QinggongStar    int32   `protobuf:"varint,10,opt,name=qinggongStar,proto3" json:"qinggongStar,omitempty"`
	ObjId           int32   `protobuf:"varint,11,opt,name=objId,proto3" json:"objId,omitempty"`
	WugongCorrect   float64 `protobuf:"fixed64,12,opt,name=wugongCorrect,proto3" json:"wugongCorrect,omitempty"`
	NeigongCorrect  float64 `protobuf:"fixed64,13,opt,name=neigongCorrect,proto3" json:"neigongCorrect,omitempty"`
	QinggongCorrect float64 `protobuf:"fixed64,14,opt,name=qinggongCorrect,proto3" json:"qinggongCorrect,omitempty"`
}

func (m *SkillGongfuInfo) Reset()                    { *m = SkillGongfuInfo{} }
func (m *SkillGongfuInfo) String() string            { return proto.CompactTextString(m) }
func (*SkillGongfuInfo) ProtoMessage()               {}
func (*SkillGongfuInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{14} }

func (m *SkillGongfuInfo) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *SkillGongfuInfo) GetWugongId() int32 {
	if m != nil {
		return m.WugongId
	}
	return 0
}

func (m *SkillGongfuInfo) GetNeigongId() int32 {
	if m != nil {
		return m.NeigongId
	}
	return 0
}

func (m *SkillGongfuInfo) GetQinggongId() int32 {
	if m != nil {
		return m.QinggongId
	}
	return 0
}

func (m *SkillGongfuInfo) GetWugongLevel() int32 {
	if m != nil {
		return m.WugongLevel
	}
	return 0
}

func (m *SkillGongfuInfo) GetWugongStar() int32 {
	if m != nil {
		return m.WugongStar
	}
	return 0
}

func (m *SkillGongfuInfo) GetNeigongLevel() int32 {
	if m != nil {
		return m.NeigongLevel
	}
	return 0
}

func (m *SkillGongfuInfo) GetNeigongStar() int32 {
	if m != nil {
		return m.NeigongStar
	}
	return 0
}

func (m *SkillGongfuInfo) GetQinggongLevel() int32 {
	if m != nil {
		return m.QinggongLevel
	}
	return 0
}

func (m *SkillGongfuInfo) GetQinggongStar() int32 {
	if m != nil {
		return m.QinggongStar
	}
	return 0
}

func (m *SkillGongfuInfo) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SkillGongfuInfo) GetWugongCorrect() float64 {
	if m != nil {
		return m.WugongCorrect
	}
	return 0
}

func (m *SkillGongfuInfo) GetNeigongCorrect() float64 {
	if m != nil {
		return m.NeigongCorrect
	}
	return 0
}

func (m *SkillGongfuInfo) GetQinggongCorrect() float64 {
	if m != nil {
		return m.QinggongCorrect
	}
	return 0
}

type SkillXiaLvInfo struct {
	Id           int32   `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Lv           int32   `protobuf:"varint,2,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Star         int32   `protobuf:"varint,3,opt,name=Star,proto3" json:"Star,omitempty"`
	XiaLvCorrect float64 `protobuf:"fixed64,4,opt,name=XiaLvCorrect,proto3" json:"XiaLvCorrect,omitempty"`
}

func (m *SkillXiaLvInfo) Reset()                    { *m = SkillXiaLvInfo{} }
func (m *SkillXiaLvInfo) String() string            { return proto.CompactTextString(m) }
func (*SkillXiaLvInfo) ProtoMessage()               {}
func (*SkillXiaLvInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{15} }

func (m *SkillXiaLvInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SkillXiaLvInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *SkillXiaLvInfo) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *SkillXiaLvInfo) GetXiaLvCorrect() float64 {
	if m != nil {
		return m.XiaLvCorrect
	}
	return 0
}

type SkillClash struct {
	MyGongfu    *SkillGongfuInfo `protobuf:"bytes,1,opt,name=myGongfu" json:"myGongfu,omitempty"`
	EnemyGongfu *SkillGongfuInfo `protobuf:"bytes,2,opt,name=enemyGongfu" json:"enemyGongfu,omitempty"`
	MyXiaLv     *SkillXiaLvInfo  `protobuf:"bytes,3,opt,name=myXiaLv" json:"myXiaLv,omitempty"`
	EnemyXiaLv  *SkillXiaLvInfo  `protobuf:"bytes,4,opt,name=enemyXiaLv" json:"enemyXiaLv,omitempty"`
}

func (m *SkillClash) Reset()                    { *m = SkillClash{} }
func (m *SkillClash) String() string            { return proto.CompactTextString(m) }
func (*SkillClash) ProtoMessage()               {}
func (*SkillClash) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{16} }

func (m *SkillClash) GetMyGongfu() *SkillGongfuInfo {
	if m != nil {
		return m.MyGongfu
	}
	return nil
}

func (m *SkillClash) GetEnemyGongfu() *SkillGongfuInfo {
	if m != nil {
		return m.EnemyGongfu
	}
	return nil
}

func (m *SkillClash) GetMyXiaLv() *SkillXiaLvInfo {
	if m != nil {
		return m.MyXiaLv
	}
	return nil
}

func (m *SkillClash) GetEnemyXiaLv() *SkillXiaLvInfo {
	if m != nil {
		return m.EnemyXiaLv
	}
	return nil
}

type AttackNtf struct {
	SkillId        int32       `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	AttackerId     int32       `protobuf:"varint,2,opt,name=attackerId,proto3" json:"attackerId,omitempty"`
	ObjIds         []int32     `protobuf:"varint,3,rep,packed,name=objIds" json:"objIds,omitempty"`
	LinkNum        int32       `protobuf:"varint,4,opt,name=linkNum,proto3" json:"linkNum,omitempty"`
	Dir            int32       `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
	SkillClashInfo *SkillClash `protobuf:"bytes,6,opt,name=skillClashInfo" json:"skillClashInfo,omitempty"`
}

func (m *AttackNtf) Reset()                    { *m = AttackNtf{} }
func (m *AttackNtf) String() string            { return proto.CompactTextString(m) }
func (*AttackNtf) ProtoMessage()               {}
func (*AttackNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{17} }

func (m *AttackNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackNtf) GetAttackerId() int32 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *AttackNtf) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *AttackNtf) GetLinkNum() int32 {
	if m != nil {
		return m.LinkNum
	}
	return 0
}

func (m *AttackNtf) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *AttackNtf) GetSkillClashInfo() *SkillClash {
	if m != nil {
		return m.SkillClashInfo
	}
	return nil
}

type EnterSkillClashNtf struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *EnterSkillClashNtf) Reset()                    { *m = EnterSkillClashNtf{} }
func (m *EnterSkillClashNtf) String() string            { return proto.CompactTextString(m) }
func (*EnterSkillClashNtf) ProtoMessage()               {}
func (*EnterSkillClashNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{18} }

func (m *EnterSkillClashNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type LeaveSkillClashNtf struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *LeaveSkillClashNtf) Reset()                    { *m = LeaveSkillClashNtf{} }
func (m *LeaveSkillClashNtf) String() string            { return proto.CompactTextString(m) }
func (*LeaveSkillClashNtf) ProtoMessage()               {}
func (*LeaveSkillClashNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{19} }

func (m *LeaveSkillClashNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type SceneJoinFightReq struct {
	X       int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y       int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Dir     int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
	HeroIdx int32 `protobuf:"varint,6,opt,name=heroIdx,proto3" json:"heroIdx,omitempty"`
}

func (m *SceneJoinFightReq) Reset()                    { *m = SceneJoinFightReq{} }
func (m *SceneJoinFightReq) String() string            { return proto.CompactTextString(m) }
func (*SceneJoinFightReq) ProtoMessage()               {}
func (*SceneJoinFightReq) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{20} }

func (m *SceneJoinFightReq) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *SceneJoinFightReq) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *SceneJoinFightReq) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *SceneJoinFightReq) GetHeroIdx() int32 {
	if m != nil {
		return m.HeroIdx
	}
	return 0
}

type SceneJoinFightAck struct {
	GoodsChanges *Goods `protobuf:"bytes,1,opt,name=goodsChanges" json:"goodsChanges,omitempty"`
}

func (m *SceneJoinFightAck) Reset()                    { *m = SceneJoinFightAck{} }
func (m *SceneJoinFightAck) String() string            { return proto.CompactTextString(m) }
func (*SceneJoinFightAck) ProtoMessage()               {}
func (*SceneJoinFightAck) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{21} }

func (m *SceneJoinFightAck) GetGoodsChanges() *Goods {
	if m != nil {
		return m.GoodsChanges
	}
	return nil
}

//
type HurtEffect struct {
	ObjId           int32   `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Hp              int64   `protobuf:"varint,2,opt,name=hp,proto3" json:"hp,omitempty"`
	Death           int32   `protobuf:"varint,3,opt,name=death,proto3" json:"death,omitempty"`
	IsBomb          int32   `protobuf:"varint,4,opt,name=isBomb,proto3" json:"isBomb,omitempty"`
	TriggerSkills   []int32 `protobuf:"varint,5,rep,packed,name=triggerSkills" json:"triggerSkills,omitempty"`
	FightBackDamage int64   `protobuf:"varint,6,opt,name=fightBackDamage,proto3" json:"fightBackDamage,omitempty"`
	ClashRatio      float64 `protobuf:"fixed64,7,opt,name=clashRatio,proto3" json:"clashRatio,omitempty"`
	ShowHp          int64   `protobuf:"varint,8,opt,name=showHp,proto3" json:"showHp,omitempty"`
	IsDodge         bool    `protobuf:"varint,9,opt,name=isDodge,proto3" json:"isDodge,omitempty"`
	IsPress         int32   `protobuf:"varint,10,opt,name=isPress,proto3" json:"isPress,omitempty"`
}

func (m *HurtEffect) Reset()                    { *m = HurtEffect{} }
func (m *HurtEffect) String() string            { return proto.CompactTextString(m) }
func (*HurtEffect) ProtoMessage()               {}
func (*HurtEffect) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{22} }

func (m *HurtEffect) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *HurtEffect) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *HurtEffect) GetDeath() int32 {
	if m != nil {
		return m.Death
	}
	return 0
}

func (m *HurtEffect) GetIsBomb() int32 {
	if m != nil {
		return m.IsBomb
	}
	return 0
}

func (m *HurtEffect) GetTriggerSkills() []int32 {
	if m != nil {
		return m.TriggerSkills
	}
	return nil
}

func (m *HurtEffect) GetFightBackDamage() int64 {
	if m != nil {
		return m.FightBackDamage
	}
	return 0
}

func (m *HurtEffect) GetClashRatio() float64 {
	if m != nil {
		return m.ClashRatio
	}
	return 0
}

func (m *HurtEffect) GetShowHp() int64 {
	if m != nil {
		return m.ShowHp
	}
	return 0
}

func (m *HurtEffect) GetIsDodge() bool {
	if m != nil {
		return m.IsDodge
	}
	return false
}

func (m *HurtEffect) GetIsPress() int32 {
	if m != nil {
		return m.IsPress
	}
	return 0
}

type BuffEffect struct {
	Idx   int32       `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Hurts *HurtEffect `protobuf:"bytes,4,opt,name=hurts" json:"hurts,omitempty"`
}

func (m *BuffEffect) Reset()                    { *m = BuffEffect{} }
func (m *BuffEffect) String() string            { return proto.CompactTextString(m) }
func (*BuffEffect) ProtoMessage()               {}
func (*BuffEffect) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{23} }

func (m *BuffEffect) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffEffect) GetHurts() *HurtEffect {
	if m != nil {
		return m.Hurts
	}
	return nil
}

type BuffAdd struct {
	Id        int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TargetId  int32 `protobuf:"varint,2,opt,name=targetId,proto3" json:"targetId,omitempty"`
	Idx       int32 `protobuf:"varint,3,opt,name=idx,proto3" json:"idx,omitempty"`
	BuffId    int32 `protobuf:"varint,4,opt,name=buffId,proto3" json:"buffId,omitempty"`
	Ts        int64 `protobuf:"varint,5,opt,name=ts,proto3" json:"ts,omitempty"`
	HurtType  int32 `protobuf:"varint,6,opt,name=hurtType,proto3" json:"hurtType,omitempty"`
	Step      int32 `protobuf:"varint,7,opt,name=step,proto3" json:"step,omitempty"`
	ParamRate int32 `protobuf:"varint,8,opt,name=paramRate,proto3" json:"paramRate,omitempty"`
	ParamNum  int32 `protobuf:"varint,9,opt,name=paramNum,proto3" json:"paramNum,omitempty"`
	Level     int32 `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *BuffAdd) Reset()                    { *m = BuffAdd{} }
func (m *BuffAdd) String() string            { return proto.CompactTextString(m) }
func (*BuffAdd) ProtoMessage()               {}
func (*BuffAdd) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{24} }

func (m *BuffAdd) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuffAdd) GetTargetId() int32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *BuffAdd) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffAdd) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *BuffAdd) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *BuffAdd) GetHurtType() int32 {
	if m != nil {
		return m.HurtType
	}
	return 0
}

func (m *BuffAdd) GetStep() int32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *BuffAdd) GetParamRate() int32 {
	if m != nil {
		return m.ParamRate
	}
	return 0
}

func (m *BuffAdd) GetParamNum() int32 {
	if m != nil {
		return m.ParamNum
	}
	return 0
}

func (m *BuffAdd) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type BuffInfo struct {
	TargetId int32 `protobuf:"varint,1,opt,name=targetId,proto3" json:"targetId,omitempty"`
	Idx      int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *BuffInfo) Reset()                    { *m = BuffInfo{} }
func (m *BuffInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffInfo) ProtoMessage()               {}
func (*BuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{25} }

func (m *BuffInfo) GetTargetId() int32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *BuffInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type ChangeBuffNtf struct {
	Buff            *BuffAdd    `protobuf:"bytes,1,opt,name=buff" json:"buff,omitempty"`
	DeleteBuffInfos []*BuffInfo `protobuf:"bytes,2,rep,name=deleteBuffInfos" json:"deleteBuffInfos,omitempty"`
}

func (m *ChangeBuffNtf) Reset()                    { *m = ChangeBuffNtf{} }
func (m *ChangeBuffNtf) String() string            { return proto.CompactTextString(m) }
func (*ChangeBuffNtf) ProtoMessage()               {}
func (*ChangeBuffNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{26} }

func (m *ChangeBuffNtf) GetBuff() *BuffAdd {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *ChangeBuffNtf) GetDeleteBuffInfos() []*BuffInfo {
	if m != nil {
		return m.DeleteBuffInfos
	}
	return nil
}

type AttackEffectNtf struct {
	SkillId    int32         `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	AttackerId int32         `protobuf:"varint,2,opt,name=attackerId,proto3" json:"attackerId,omitempty"`
	LinkNum    int32         `protobuf:"varint,3,opt,name=linkNum,proto3" json:"linkNum,omitempty"`
	Hurts      []*HurtEffect `protobuf:"bytes,4,rep,name=hurts" json:"hurts,omitempty"`
}

func (m *AttackEffectNtf) Reset()                    { *m = AttackEffectNtf{} }
func (m *AttackEffectNtf) String() string            { return proto.CompactTextString(m) }
func (*AttackEffectNtf) ProtoMessage()               {}
func (*AttackEffectNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{27} }

func (m *AttackEffectNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackEffectNtf) GetAttackerId() int32 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *AttackEffectNtf) GetLinkNum() int32 {
	if m != nil {
		return m.LinkNum
	}
	return 0
}

func (m *AttackEffectNtf) GetHurts() []*HurtEffect {
	if m != nil {
		return m.Hurts
	}
	return nil
}

type BuffHpChangeNtf struct {
	BuffHpChangeInfos []*BuffHpChangeInfo `protobuf:"bytes,1,rep,name=buffHpChangeInfos" json:"buffHpChangeInfos,omitempty"`
}

func (m *BuffHpChangeNtf) Reset()                    { *m = BuffHpChangeNtf{} }
func (m *BuffHpChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeNtf) ProtoMessage()               {}
func (*BuffHpChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{28} }

func (m *BuffHpChangeNtf) GetBuffHpChangeInfos() []*BuffHpChangeInfo {
	if m != nil {
		return m.BuffHpChangeInfos
	}
	return nil
}

type MainCityEnterRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityEnterRpt) Reset()                    { *m = MainCityEnterRpt{} }
func (m *MainCityEnterRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityEnterRpt) ProtoMessage()               {}
func (*MainCityEnterRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{29} }

func (m *MainCityEnterRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type MainCityMoveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Dir   int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *MainCityMoveRpt) Reset()                    { *m = MainCityMoveRpt{} }
func (m *MainCityMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityMoveRpt) ProtoMessage()               {}
func (*MainCityMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{30} }

func (m *MainCityMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *MainCityMoveRpt) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MainCityMoveRpt) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MainCityMoveRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type MainCityLeaveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *MainCityLeaveRpt) Reset()                    { *m = MainCityLeaveRpt{} }
func (m *MainCityLeaveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityLeaveRpt) ProtoMessage()               {}
func (*MainCityLeaveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{31} }

func (m *MainCityLeaveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type MainCityUpdateRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityUpdateRpt) Reset()                    { *m = MainCityUpdateRpt{} }
func (m *MainCityUpdateRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityUpdateRpt) ProtoMessage()               {}
func (*MainCityUpdateRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{32} }

func (m *MainCityUpdateRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type BossHpNtf struct {
	Hps map[int32]int64 `protobuf:"bytes,1,rep,name=hps" json:"hps,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *BossHpNtf) Reset()                    { *m = BossHpNtf{} }
func (m *BossHpNtf) String() string            { return proto.CompactTextString(m) }
func (*BossHpNtf) ProtoMessage()               {}
func (*BossHpNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{33} }

func (m *BossHpNtf) GetHps() map[int32]int64 {
	if m != nil {
		return m.Hps
	}
	return nil
}

type TortoiseFightInfoNtf struct {
	CountDown    int32   `protobuf:"varint,1,opt,name=countDown,proto3" json:"countDown,omitempty"`
	TortoisesIds []int32 `protobuf:"varint,2,rep,packed,name=tortoisesIds" json:"tortoisesIds,omitempty"`
	Racing       bool    `protobuf:"varint,3,opt,name=racing,proto3" json:"racing,omitempty"`
}

func (m *TortoiseFightInfoNtf) Reset()                    { *m = TortoiseFightInfoNtf{} }
func (m *TortoiseFightInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*TortoiseFightInfoNtf) ProtoMessage()               {}
func (*TortoiseFightInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene2, []int{34} }

func (m *TortoiseFightInfoNtf) GetCountDown() int32 {
	if m != nil {
		return m.CountDown
	}
	return 0
}

func (m *TortoiseFightInfoNtf) GetTortoisesIds() []int32 {
	if m != nil {
		return m.TortoisesIds
	}
	return nil
}

func (m *TortoiseFightInfoNtf) GetRacing() bool {
	if m != nil {
		return m.Racing
	}
	return false
}

func init() {
	proto.RegisterType((*Buff)(nil), "pb.Buff")
	proto.RegisterType((*BuffHpChangeInfo)(nil), "pb.BuffHpChangeInfo")
	proto.RegisterType((*SceneObj)(nil), "pb.SceneObj")
	proto.RegisterType((*SceneUser)(nil), "pb.SceneUser")
	proto.RegisterType((*HeroPosInfo)(nil), "pb.HeroPosInfo")
	proto.RegisterType((*SceneHero)(nil), "pb.SceneHero")
	proto.RegisterType((*SceneMonster)(nil), "pb.SceneMonster")
	proto.RegisterType((*SceneTortoise)(nil), "pb.SceneTortoise")
	proto.RegisterType((*SceneObserver)(nil), "pb.SceneObserver")
	proto.RegisterType((*SceneEnterNtf)(nil), "pb.SceneEnterNtf")
	proto.RegisterType((*SceneLeaveNtf)(nil), "pb.SceneLeaveNtf")
	proto.RegisterType((*SceneMoveRpt)(nil), "pb.SceneMoveRpt")
	proto.RegisterType((*SceneMoveNtf)(nil), "pb.SceneMoveNtf")
	proto.RegisterType((*AttackRpt)(nil), "pb.AttackRpt")
	proto.RegisterType((*SkillGongfuInfo)(nil), "pb.SkillGongfuInfo")
	proto.RegisterType((*SkillXiaLvInfo)(nil), "pb.SkillXiaLvInfo")
	proto.RegisterType((*SkillClash)(nil), "pb.SkillClash")
	proto.RegisterType((*AttackNtf)(nil), "pb.AttackNtf")
	proto.RegisterType((*EnterSkillClashNtf)(nil), "pb.EnterSkillClashNtf")
	proto.RegisterType((*LeaveSkillClashNtf)(nil), "pb.LeaveSkillClashNtf")
	proto.RegisterType((*SceneJoinFightReq)(nil), "pb.SceneJoinFightReq")
	proto.RegisterType((*SceneJoinFightAck)(nil), "pb.SceneJoinFightAck")
	proto.RegisterType((*HurtEffect)(nil), "pb.HurtEffect")
	proto.RegisterType((*BuffEffect)(nil), "pb.BuffEffect")
	proto.RegisterType((*BuffAdd)(nil), "pb.BuffAdd")
	proto.RegisterType((*BuffInfo)(nil), "pb.BuffInfo")
	proto.RegisterType((*ChangeBuffNtf)(nil), "pb.ChangeBuffNtf")
	proto.RegisterType((*AttackEffectNtf)(nil), "pb.AttackEffectNtf")
	proto.RegisterType((*BuffHpChangeNtf)(nil), "pb.BuffHpChangeNtf")
	proto.RegisterType((*MainCityEnterRpt)(nil), "pb.MainCityEnterRpt")
	proto.RegisterType((*MainCityMoveRpt)(nil), "pb.MainCityMoveRpt")
	proto.RegisterType((*MainCityLeaveRpt)(nil), "pb.MainCityLeaveRpt")
	proto.RegisterType((*MainCityUpdateRpt)(nil), "pb.MainCityUpdateRpt")
	proto.RegisterType((*BossHpNtf)(nil), "pb.BossHpNtf")
	proto.RegisterType((*TortoiseFightInfoNtf)(nil), "pb.TortoiseFightInfoNtf")
}
func (m *Buff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Buff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *BuffHpChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	if m.Death != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Death))
	}
	if m.TargetId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TargetId))
	}
	if m.ChangeHp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TotalHp))
	}
	return i, nil
}

func (m *SceneObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjType))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Y))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TeamId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Hp))
	}
	if m.HpMax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, msg := range m.Buffs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.User != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Hero != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Hero.Size()))
		n2, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Monster != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Monster.Size()))
		n3, err := m.Monster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Observer != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Observer.Size()))
		n4, err := m.Observer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Tortoise != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Tortoise.Size()))
		n5, err := m.Tortoise.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SceneUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Weapons) > 0 {
		for k, _ := range m.Weapons {
			dAtA[i] = 0x22
			i++
			v := m.Weapons[k]
			mapSize := 1 + sovScene2(uint64(k)) + 1 + sovScene2(uint64(v))
			i = encodeVarintScene2(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintScene2(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintScene2(dAtA, i, uint64(v))
		}
	}
	if m.MedalIdx != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.MedalIdx))
	}
	if m.Display != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Display.Size()))
		n6, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Vip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Vip))
	}
	if m.Kingdom != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Kingdom))
	}
	if m.Lvl != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Lvl))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Sex))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Combat))
	}
	if m.Kill != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Kill))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.KingdomPos != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.KingdomPos))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if len(m.HeroIdxList) > 0 {
		for _, msg := range m.HeroIdxList {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Mrank != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Mrank))
	}
	if m.DrinkCount != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.DrinkCount))
	}
	if len(m.ToastUserIds) > 0 {
		dAtA8 := make([]byte, len(m.ToastUserIds)*10)
		var j7 int
		for _, num1 := range m.ToastUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.EmperorAchieveStar != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.EmperorAchieveStar))
	}
	if m.MedalLvl != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.MedalLvl))
	}
	if m.ArtifactId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ArtifactId))
	}
	if m.ArtifactLvl != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ArtifactLvl))
	}
	if m.ArtifactClothId != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ArtifactClothId))
	}
	if m.ArtifactClothLvl != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ArtifactClothLvl))
	}
	if m.SwordSpiritStage != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SwordSpiritStage))
	}
	if m.GuildLogoId != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.GuildLogoId))
	}
	if m.GuildColorId != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.GuildColorId))
	}
	if len(m.BeforeGuildName) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.BeforeGuildName)))
		i += copy(dAtA[i:], m.BeforeGuildName)
	}
	if m.IsStatue {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.IsStatue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PkStatus != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.PkStatus))
	}
	if m.TargetAssistObjId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TargetAssistObjId))
	}
	if m.AssistActive {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.AssistActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChangePKStatusCdSt != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ChangePKStatusCdSt))
	}
	if m.TransferType != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TransferType))
	}
	if len(m.Brighten) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Brighten)))
		i += copy(dAtA[i:], m.Brighten)
	}
	if m.TransferQuality != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TransferQuality))
	}
	if m.RobotType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.RobotType))
	}
	return i, nil
}

func (m *HeroPosInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroPosInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Id))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Pos))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *SceneHero) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneHero) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.OwnerId))
	}
	if len(m.OwnerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.OwnerName)))
		i += copy(dAtA[i:], m.OwnerName)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.HeroIdx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.HeroIdx))
	}
	if m.MedalIdx != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.MedalIdx))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *SceneMonster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMonster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *SceneTortoise) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneTortoise) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Speed != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Speed))
	}
	if m.BuffAddLayers != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.BuffAddLayers))
	}
	if m.BuffDecLayers != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.BuffDecLayers))
	}
	return i, nil
}

func (m *SceneObserver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObserver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Kill != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Kill))
	}
	if m.Kingdom != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Kingdom))
	}
	if m.KingdomPos != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.KingdomPos))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene2(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	return i, nil
}

func (m *SceneEnterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneEnterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SceneLeaveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneLeaveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		dAtA10 := make([]byte, len(m.ObjIds)*10)
		var j9 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *SceneMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Y))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *SceneMoveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Y))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *AttackRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttackerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.AttackerId))
	}
	if m.SkillId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		dAtA12 := make([]byte, len(m.ObjIds)*10)
		var j11 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.LinkNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.LinkNum))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *SkillGongfuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillGongfuInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SkillId))
	}
	if m.WugongId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.WugongId))
	}
	if m.NeigongId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.NeigongId))
	}
	if m.QinggongId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.QinggongId))
	}
	if m.WugongLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.WugongLevel))
	}
	if m.WugongStar != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.WugongStar))
	}
	if m.NeigongLevel != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.NeigongLevel))
	}
	if m.NeigongStar != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.NeigongStar))
	}
	if m.QinggongLevel != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.QinggongLevel))
	}
	if m.QinggongStar != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.QinggongStar))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.WugongCorrect != 0 {
		dAtA[i] = 0x61
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WugongCorrect))))
		i += 8
	}
	if m.NeigongCorrect != 0 {
		dAtA[i] = 0x69
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NeigongCorrect))))
		i += 8
	}
	if m.QinggongCorrect != 0 {
		dAtA[i] = 0x71
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QinggongCorrect))))
		i += 8
	}
	return i, nil
}

func (m *SkillXiaLvInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillXiaLvInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Star))
	}
	if m.XiaLvCorrect != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XiaLvCorrect))))
		i += 8
	}
	return i, nil
}

func (m *SkillClash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillClash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MyGongfu != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.MyGongfu.Size()))
		n13, err := m.MyGongfu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.EnemyGongfu != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.EnemyGongfu.Size()))
		n14, err := m.EnemyGongfu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.MyXiaLv != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.MyXiaLv.Size()))
		n15, err := m.MyXiaLv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.EnemyXiaLv != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.EnemyXiaLv.Size()))
		n16, err := m.EnemyXiaLv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *AttackNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.AttackerId))
	}
	if len(m.ObjIds) > 0 {
		dAtA18 := make([]byte, len(m.ObjIds)*10)
		var j17 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.LinkNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.LinkNum))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	if m.SkillClashInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SkillClashInfo.Size()))
		n19, err := m.SkillClashInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *EnterSkillClashNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterSkillClashNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *LeaveSkillClashNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveSkillClashNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *SceneJoinFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneJoinFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Y))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	if m.HeroIdx != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.HeroIdx))
	}
	return i, nil
}

func (m *SceneJoinFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneJoinFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GoodsChanges != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.GoodsChanges.Size()))
		n20, err := m.GoodsChanges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *HurtEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HurtEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Hp))
	}
	if m.Death != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Death))
	}
	if m.IsBomb != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.IsBomb))
	}
	if len(m.TriggerSkills) > 0 {
		dAtA22 := make([]byte, len(m.TriggerSkills)*10)
		var j21 int
		for _, num1 := range m.TriggerSkills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if m.FightBackDamage != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.FightBackDamage))
	}
	if m.ClashRatio != 0 {
		dAtA[i] = 0x39
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ClashRatio))))
		i += 8
	}
	if m.ShowHp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ShowHp))
	}
	if m.IsDodge {
		dAtA[i] = 0x48
		i++
		if m.IsDodge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPress != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.IsPress))
	}
	return i, nil
}

func (m *BuffEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	if m.Hurts != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Hurts.Size()))
		n23, err := m.Hurts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *BuffAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Id))
	}
	if m.TargetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TargetId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	if m.BuffId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.BuffId))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Ts))
	}
	if m.HurtType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.HurtType))
	}
	if m.Step != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Step))
	}
	if m.ParamRate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ParamRate))
	}
	if m.ParamNum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ParamNum))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *BuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.TargetId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *ChangeBuffNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeBuffNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Buff != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Buff.Size()))
		n24, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.DeleteBuffInfos) > 0 {
		for _, msg := range m.DeleteBuffInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AttackEffectNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackEffectNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.AttackerId))
	}
	if m.LinkNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.LinkNum))
	}
	if len(m.Hurts) > 0 {
		for _, msg := range m.Hurts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffHpChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, msg := range m.BuffHpChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene2(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MainCityEnterRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityEnterRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Obj.Size()))
		n25, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *MainCityMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Y))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *MainCityLeaveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityLeaveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *MainCityUpdateRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityUpdateRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.Obj.Size()))
		n26, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *BossHpNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossHpNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hps) > 0 {
		for k, _ := range m.Hps {
			dAtA[i] = 0xa
			i++
			v := m.Hps[k]
			mapSize := 1 + sovScene2(uint64(k)) + 1 + sovScene2(uint64(v))
			i = encodeVarintScene2(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintScene2(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintScene2(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TortoiseFightInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TortoiseFightInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CountDown != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene2(dAtA, i, uint64(m.CountDown))
	}
	if len(m.TortoisesIds) > 0 {
		dAtA28 := make([]byte, len(m.TortoisesIds)*10)
		var j27 int
		for _, num1 := range m.TortoisesIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene2(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if m.Racing {
		dAtA[i] = 0x18
		i++
		if m.Racing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintScene2(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Buff) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	if m.Ts != 0 {
		n += 1 + sovScene2(uint64(m.Ts))
	}
	return n
}

func (m *BuffHpChangeInfo) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	if m.Death != 0 {
		n += 1 + sovScene2(uint64(m.Death))
	}
	if m.TargetId != 0 {
		n += 1 + sovScene2(uint64(m.TargetId))
	}
	if m.ChangeHp != 0 {
		n += 1 + sovScene2(uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		n += 1 + sovScene2(uint64(m.TotalHp))
	}
	return n
}

func (m *SceneObj) Size() (n int) {
	var l int
	_ = l
	if m.ObjType != 0 {
		n += 1 + sovScene2(uint64(m.ObjType))
	}
	if m.X != 0 {
		n += 1 + sovScene2(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene2(uint64(m.Y))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		n += 1 + sovScene2(uint64(m.TeamId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene2(uint64(m.Hp))
	}
	if m.HpMax != 0 {
		n += 1 + sovScene2(uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, e := range m.Buffs {
			l = e.Size()
			n += 1 + l + sovScene2(uint64(l))
		}
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.Monster != nil {
		l = m.Monster.Size()
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.Observer != nil {
		l = m.Observer.Size()
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.Tortoise != nil {
		l = m.Tortoise.Size()
		n += 2 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *SceneUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene2(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	if len(m.Weapons) > 0 {
		for k, v := range m.Weapons {
			_ = k
			_ = v
			mapEntrySize := 1 + sovScene2(uint64(k)) + 1 + sovScene2(uint64(v))
			n += mapEntrySize + 1 + sovScene2(uint64(mapEntrySize))
		}
	}
	if m.MedalIdx != 0 {
		n += 1 + sovScene2(uint64(m.MedalIdx))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovScene2(uint64(m.Vip))
	}
	if m.Kingdom != 0 {
		n += 1 + sovScene2(uint64(m.Kingdom))
	}
	if m.Lvl != 0 {
		n += 1 + sovScene2(uint64(m.Lvl))
	}
	if m.Sex != 0 {
		n += 1 + sovScene2(uint64(m.Sex))
	}
	if m.Combat != 0 {
		n += 1 + sovScene2(uint64(m.Combat))
	}
	if m.Kill != 0 {
		n += 1 + sovScene2(uint64(m.Kill))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene2(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.KingdomPos != 0 {
		n += 1 + sovScene2(uint64(m.KingdomPos))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 2 + l + sovScene2(uint64(l))
	}
	if len(m.HeroIdxList) > 0 {
		for _, e := range m.HeroIdxList {
			l = e.Size()
			n += 2 + l + sovScene2(uint64(l))
		}
	}
	if m.Mrank != 0 {
		n += 2 + sovScene2(uint64(m.Mrank))
	}
	if m.DrinkCount != 0 {
		n += 2 + sovScene2(uint64(m.DrinkCount))
	}
	if len(m.ToastUserIds) > 0 {
		l = 0
		for _, e := range m.ToastUserIds {
			l += sovScene2(uint64(e))
		}
		n += 2 + sovScene2(uint64(l)) + l
	}
	if m.EmperorAchieveStar != 0 {
		n += 2 + sovScene2(uint64(m.EmperorAchieveStar))
	}
	if m.MedalLvl != 0 {
		n += 2 + sovScene2(uint64(m.MedalLvl))
	}
	if m.ArtifactId != 0 {
		n += 2 + sovScene2(uint64(m.ArtifactId))
	}
	if m.ArtifactLvl != 0 {
		n += 2 + sovScene2(uint64(m.ArtifactLvl))
	}
	if m.ArtifactClothId != 0 {
		n += 2 + sovScene2(uint64(m.ArtifactClothId))
	}
	if m.ArtifactClothLvl != 0 {
		n += 2 + sovScene2(uint64(m.ArtifactClothLvl))
	}
	if m.SwordSpiritStage != 0 {
		n += 2 + sovScene2(uint64(m.SwordSpiritStage))
	}
	if m.GuildLogoId != 0 {
		n += 2 + sovScene2(uint64(m.GuildLogoId))
	}
	if m.GuildColorId != 0 {
		n += 2 + sovScene2(uint64(m.GuildColorId))
	}
	l = len(m.BeforeGuildName)
	if l > 0 {
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.IsStatue {
		n += 3
	}
	if m.PkStatus != 0 {
		n += 2 + sovScene2(uint64(m.PkStatus))
	}
	if m.TargetAssistObjId != 0 {
		n += 2 + sovScene2(uint64(m.TargetAssistObjId))
	}
	if m.AssistActive {
		n += 3
	}
	if m.ChangePKStatusCdSt != 0 {
		n += 2 + sovScene2(uint64(m.ChangePKStatusCdSt))
	}
	if m.TransferType != 0 {
		n += 2 + sovScene2(uint64(m.TransferType))
	}
	l = len(m.Brighten)
	if l > 0 {
		n += 2 + l + sovScene2(uint64(l))
	}
	if m.TransferQuality != 0 {
		n += 2 + sovScene2(uint64(m.TransferQuality))
	}
	if m.RobotType != 0 {
		n += 2 + sovScene2(uint64(m.RobotType))
	}
	return n
}

func (m *HeroPosInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScene2(uint64(m.Id))
	}
	if m.Pos != 0 {
		n += 1 + sovScene2(uint64(m.Pos))
	}
	if m.Quality != 0 {
		n += 1 + sovScene2(uint64(m.Quality))
	}
	return n
}

func (m *SceneHero) Size() (n int) {
	var l int
	_ = l
	if m.OwnerId != 0 {
		n += 1 + sovScene2(uint64(m.OwnerId))
	}
	l = len(m.OwnerName)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.HeroIdx != 0 {
		n += 1 + sovScene2(uint64(m.HeroIdx))
	}
	if m.MedalIdx != 0 {
		n += 1 + sovScene2(uint64(m.MedalIdx))
	}
	if m.Quality != 0 {
		n += 1 + sovScene2(uint64(m.Quality))
	}
	return n
}

func (m *SceneMonster) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	return n
}

func (m *SceneTortoise) Size() (n int) {
	var l int
	_ = l
	if m.Speed != 0 {
		n += 1 + sovScene2(uint64(m.Speed))
	}
	if m.BuffAddLayers != 0 {
		n += 1 + sovScene2(uint64(m.BuffAddLayers))
	}
	if m.BuffDecLayers != 0 {
		n += 1 + sovScene2(uint64(m.BuffDecLayers))
	}
	return n
}

func (m *SceneObserver) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene2(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.Kill != 0 {
		n += 1 + sovScene2(uint64(m.Kill))
	}
	if m.Kingdom != 0 {
		n += 1 + sovScene2(uint64(m.Kingdom))
	}
	if m.KingdomPos != 0 {
		n += 1 + sovScene2(uint64(m.KingdomPos))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *SceneEnterNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovScene2(uint64(l))
		}
	}
	return n
}

func (m *SceneLeaveNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene2(uint64(e))
		}
		n += 1 + sovScene2(uint64(l)) + l
	}
	return n
}

func (m *SceneMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovScene2(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene2(uint64(m.Y))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	return n
}

func (m *SceneMoveNtf) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovScene2(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene2(uint64(m.Y))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	return n
}

func (m *AttackRpt) Size() (n int) {
	var l int
	_ = l
	if m.AttackerId != 0 {
		n += 1 + sovScene2(uint64(m.AttackerId))
	}
	if m.SkillId != 0 {
		n += 1 + sovScene2(uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene2(uint64(e))
		}
		n += 1 + sovScene2(uint64(l)) + l
	}
	if m.LinkNum != 0 {
		n += 1 + sovScene2(uint64(m.LinkNum))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	return n
}

func (m *SkillGongfuInfo) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene2(uint64(m.SkillId))
	}
	if m.WugongId != 0 {
		n += 1 + sovScene2(uint64(m.WugongId))
	}
	if m.NeigongId != 0 {
		n += 1 + sovScene2(uint64(m.NeigongId))
	}
	if m.QinggongId != 0 {
		n += 1 + sovScene2(uint64(m.QinggongId))
	}
	if m.WugongLevel != 0 {
		n += 1 + sovScene2(uint64(m.WugongLevel))
	}
	if m.WugongStar != 0 {
		n += 1 + sovScene2(uint64(m.WugongStar))
	}
	if m.NeigongLevel != 0 {
		n += 1 + sovScene2(uint64(m.NeigongLevel))
	}
	if m.NeigongStar != 0 {
		n += 1 + sovScene2(uint64(m.NeigongStar))
	}
	if m.QinggongLevel != 0 {
		n += 1 + sovScene2(uint64(m.QinggongLevel))
	}
	if m.QinggongStar != 0 {
		n += 1 + sovScene2(uint64(m.QinggongStar))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.WugongCorrect != 0 {
		n += 9
	}
	if m.NeigongCorrect != 0 {
		n += 9
	}
	if m.QinggongCorrect != 0 {
		n += 9
	}
	return n
}

func (m *SkillXiaLvInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScene2(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovScene2(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovScene2(uint64(m.Star))
	}
	if m.XiaLvCorrect != 0 {
		n += 9
	}
	return n
}

func (m *SkillClash) Size() (n int) {
	var l int
	_ = l
	if m.MyGongfu != nil {
		l = m.MyGongfu.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.EnemyGongfu != nil {
		l = m.EnemyGongfu.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.MyXiaLv != nil {
		l = m.MyXiaLv.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	if m.EnemyXiaLv != nil {
		l = m.EnemyXiaLv.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *AttackNtf) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene2(uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		n += 1 + sovScene2(uint64(m.AttackerId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene2(uint64(e))
		}
		n += 1 + sovScene2(uint64(l)) + l
	}
	if m.LinkNum != 0 {
		n += 1 + sovScene2(uint64(m.LinkNum))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	if m.SkillClashInfo != nil {
		l = m.SkillClashInfo.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *EnterSkillClashNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	return n
}

func (m *LeaveSkillClashNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	return n
}

func (m *SceneJoinFightReq) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovScene2(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene2(uint64(m.Y))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	if m.HeroIdx != 0 {
		n += 1 + sovScene2(uint64(m.HeroIdx))
	}
	return n
}

func (m *SceneJoinFightAck) Size() (n int) {
	var l int
	_ = l
	if m.GoodsChanges != nil {
		l = m.GoodsChanges.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *HurtEffect) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene2(uint64(m.Hp))
	}
	if m.Death != 0 {
		n += 1 + sovScene2(uint64(m.Death))
	}
	if m.IsBomb != 0 {
		n += 1 + sovScene2(uint64(m.IsBomb))
	}
	if len(m.TriggerSkills) > 0 {
		l = 0
		for _, e := range m.TriggerSkills {
			l += sovScene2(uint64(e))
		}
		n += 1 + sovScene2(uint64(l)) + l
	}
	if m.FightBackDamage != 0 {
		n += 1 + sovScene2(uint64(m.FightBackDamage))
	}
	if m.ClashRatio != 0 {
		n += 9
	}
	if m.ShowHp != 0 {
		n += 1 + sovScene2(uint64(m.ShowHp))
	}
	if m.IsDodge {
		n += 2
	}
	if m.IsPress != 0 {
		n += 1 + sovScene2(uint64(m.IsPress))
	}
	return n
}

func (m *BuffEffect) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	if m.Hurts != nil {
		l = m.Hurts.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *BuffAdd) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScene2(uint64(m.Id))
	}
	if m.TargetId != 0 {
		n += 1 + sovScene2(uint64(m.TargetId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	if m.BuffId != 0 {
		n += 1 + sovScene2(uint64(m.BuffId))
	}
	if m.Ts != 0 {
		n += 1 + sovScene2(uint64(m.Ts))
	}
	if m.HurtType != 0 {
		n += 1 + sovScene2(uint64(m.HurtType))
	}
	if m.Step != 0 {
		n += 1 + sovScene2(uint64(m.Step))
	}
	if m.ParamRate != 0 {
		n += 1 + sovScene2(uint64(m.ParamRate))
	}
	if m.ParamNum != 0 {
		n += 1 + sovScene2(uint64(m.ParamNum))
	}
	if m.Level != 0 {
		n += 1 + sovScene2(uint64(m.Level))
	}
	return n
}

func (m *BuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovScene2(uint64(m.TargetId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene2(uint64(m.Idx))
	}
	return n
}

func (m *ChangeBuffNtf) Size() (n int) {
	var l int
	_ = l
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	if len(m.DeleteBuffInfos) > 0 {
		for _, e := range m.DeleteBuffInfos {
			l = e.Size()
			n += 1 + l + sovScene2(uint64(l))
		}
	}
	return n
}

func (m *AttackEffectNtf) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene2(uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		n += 1 + sovScene2(uint64(m.AttackerId))
	}
	if m.LinkNum != 0 {
		n += 1 + sovScene2(uint64(m.LinkNum))
	}
	if len(m.Hurts) > 0 {
		for _, e := range m.Hurts {
			l = e.Size()
			n += 1 + l + sovScene2(uint64(l))
		}
	}
	return n
}

func (m *BuffHpChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, e := range m.BuffHpChangeInfos {
			l = e.Size()
			n += 1 + l + sovScene2(uint64(l))
		}
	}
	return n
}

func (m *MainCityEnterRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *MainCityMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	if m.X != 0 {
		n += 1 + sovScene2(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene2(uint64(m.Y))
	}
	if m.Dir != 0 {
		n += 1 + sovScene2(uint64(m.Dir))
	}
	return n
}

func (m *MainCityLeaveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene2(uint64(m.ObjId))
	}
	return n
}

func (m *MainCityUpdateRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene2(uint64(l))
	}
	return n
}

func (m *BossHpNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Hps) > 0 {
		for k, v := range m.Hps {
			_ = k
			_ = v
			mapEntrySize := 1 + sovScene2(uint64(k)) + 1 + sovScene2(uint64(v))
			n += mapEntrySize + 1 + sovScene2(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TortoiseFightInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.CountDown != 0 {
		n += 1 + sovScene2(uint64(m.CountDown))
	}
	if len(m.TortoisesIds) > 0 {
		l = 0
		for _, e := range m.TortoisesIds {
			l += sovScene2(uint64(e))
		}
		n += 1 + sovScene2(uint64(l)) + l
	}
	if m.Racing {
		n += 2
	}
	return n
}

func sovScene2(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozScene2(x uint64) (n int) {
	return sovScene2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Buff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Buff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Buff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Death", wireType)
			}
			m.Death = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Death |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHp", wireType)
			}
			m.ChangeHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHp", wireType)
			}
			m.TotalHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjType", wireType)
			}
			m.ObjType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpMax", wireType)
			}
			m.HpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HpMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffs = append(m.Buffs, &BuffAdd{})
			if err := m.Buffs[len(m.Buffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &SceneUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &SceneHero{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = &SceneMonster{}
			}
			if err := m.Monster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Observer == nil {
				m.Observer = &SceneObserver{}
			}
			if err := m.Observer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tortoise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tortoise == nil {
				m.Tortoise = &SceneTortoise{}
			}
			if err := m.Tortoise.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weapons == nil {
				m.Weapons = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene2(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScene2
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Weapons[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalIdx", wireType)
			}
			m.MedalIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &DisplayNtf{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kingdom", wireType)
			}
			m.Kingdom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kingdom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			m.Lvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			m.Kill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kill |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KingdomPos", wireType)
			}
			m.KingdomPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KingdomPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIdxList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroIdxList = append(m.HeroIdxList, &HeroPosInfo{})
			if err := m.HeroIdxList[len(m.HeroIdxList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mrank", wireType)
			}
			m.Mrank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mrank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrinkCount", wireType)
			}
			m.DrinkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrinkCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ToastUserIds = append(m.ToastUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ToastUserIds = append(m.ToastUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ToastUserIds", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmperorAchieveStar", wireType)
			}
			m.EmperorAchieveStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmperorAchieveStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalLvl", wireType)
			}
			m.MedalLvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalLvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactId", wireType)
			}
			m.ArtifactId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactLvl", wireType)
			}
			m.ArtifactLvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactLvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactClothId", wireType)
			}
			m.ArtifactClothId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactClothId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactClothLvl", wireType)
			}
			m.ArtifactClothLvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactClothLvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwordSpiritStage", wireType)
			}
			m.SwordSpiritStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwordSpiritStage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildLogoId", wireType)
			}
			m.GuildLogoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildLogoId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildColorId", wireType)
			}
			m.GuildColorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildColorId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeGuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeGuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStatue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStatue = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkStatus", wireType)
			}
			m.PkStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAssistObjId", wireType)
			}
			m.TargetAssistObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetAssistObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssistActive = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePKStatusCdSt", wireType)
			}
			m.ChangePKStatusCdSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangePKStatusCdSt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferType", wireType)
			}
			m.TransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brighten", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brighten = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferQuality", wireType)
			}
			m.TransferQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotType", wireType)
			}
			m.RobotType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroPosInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroPosInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroPosInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneHero) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneHero: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneHero: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIdx", wireType)
			}
			m.HeroIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalIdx", wireType)
			}
			m.MedalIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMonster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMonster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMonster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneTortoise) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneTortoise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneTortoise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffAddLayers", wireType)
			}
			m.BuffAddLayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffAddLayers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffDecLayers", wireType)
			}
			m.BuffDecLayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffDecLayers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObserver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObserver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObserver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			m.Kill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kill |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kingdom", wireType)
			}
			m.Kingdom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kingdom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KingdomPos", wireType)
			}
			m.KingdomPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KingdomPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneEnterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneEnterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneEnterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &SceneObj{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneLeaveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneLeaveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneLeaveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkNum", wireType)
			}
			m.LinkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillGongfuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillGongfuInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillGongfuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WugongId", wireType)
			}
			m.WugongId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WugongId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeigongId", wireType)
			}
			m.NeigongId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeigongId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinggongId", wireType)
			}
			m.QinggongId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QinggongId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WugongLevel", wireType)
			}
			m.WugongLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WugongLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WugongStar", wireType)
			}
			m.WugongStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WugongStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeigongLevel", wireType)
			}
			m.NeigongLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeigongLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeigongStar", wireType)
			}
			m.NeigongStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeigongStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinggongLevel", wireType)
			}
			m.QinggongLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QinggongLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinggongStar", wireType)
			}
			m.QinggongStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QinggongStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WugongCorrect", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WugongCorrect = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeigongCorrect", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NeigongCorrect = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QinggongCorrect", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QinggongCorrect = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillXiaLvInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillXiaLvInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillXiaLvInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XiaLvCorrect", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XiaLvCorrect = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillClash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillClash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillClash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyGongfu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MyGongfu == nil {
				m.MyGongfu = &SkillGongfuInfo{}
			}
			if err := m.MyGongfu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyGongfu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnemyGongfu == nil {
				m.EnemyGongfu = &SkillGongfuInfo{}
			}
			if err := m.EnemyGongfu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyXiaLv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MyXiaLv == nil {
				m.MyXiaLv = &SkillXiaLvInfo{}
			}
			if err := m.MyXiaLv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyXiaLv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnemyXiaLv == nil {
				m.EnemyXiaLv = &SkillXiaLvInfo{}
			}
			if err := m.EnemyXiaLv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkNum", wireType)
			}
			m.LinkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillClashInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillClashInfo == nil {
				m.SkillClashInfo = &SkillClash{}
			}
			if err := m.SkillClashInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterSkillClashNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterSkillClashNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterSkillClashNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveSkillClashNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveSkillClashNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveSkillClashNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneJoinFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneJoinFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneJoinFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIdx", wireType)
			}
			m.HeroIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneJoinFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneJoinFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneJoinFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoodsChanges == nil {
				m.GoodsChanges = &Goods{}
			}
			if err := m.GoodsChanges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HurtEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HurtEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HurtEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Death", wireType)
			}
			m.Death = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Death |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBomb", wireType)
			}
			m.IsBomb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBomb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TriggerSkills = append(m.TriggerSkills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TriggerSkills = append(m.TriggerSkills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerSkills", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightBackDamage", wireType)
			}
			m.FightBackDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightBackDamage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClashRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ClashRatio = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowHp", wireType)
			}
			m.ShowHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDodge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDodge = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPress", wireType)
			}
			m.IsPress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hurts == nil {
				m.Hurts = &HurtEffect{}
			}
			if err := m.Hurts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamRate", wireType)
			}
			m.ParamRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamNum", wireType)
			}
			m.ParamNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParamNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeBuffNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeBuffNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeBuffNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &BuffAdd{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteBuffInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteBuffInfos = append(m.DeleteBuffInfos, &BuffInfo{})
			if err := m.DeleteBuffInfos[len(m.DeleteBuffInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackEffectNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackEffectNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackEffectNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkNum", wireType)
			}
			m.LinkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hurts = append(m.Hurts, &HurtEffect{})
			if err := m.Hurts[len(m.Hurts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffHpChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuffHpChangeInfos = append(m.BuffHpChangeInfos, &BuffHpChangeInfo{})
			if err := m.BuffHpChangeInfos[len(m.BuffHpChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityEnterRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityEnterRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityEnterRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityLeaveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityLeaveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityLeaveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityUpdateRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityUpdateRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityUpdateRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossHpNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossHpNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossHpNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene2
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hps == nil {
				m.Hps = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene2(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScene2
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Hps[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TortoiseFightInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TortoiseFightInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TortoiseFightInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDown", wireType)
			}
			m.CountDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TortoisesIds = append(m.TortoisesIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene2
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TortoisesIds = append(m.TortoisesIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TortoisesIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Racing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Racing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScene2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScene2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScene2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthScene2
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowScene2
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipScene2(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthScene2 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScene2   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("scene2.proto", fileDescriptorScene2) }

var fileDescriptorScene2 = []byte{
	// 2131 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x72, 0x23, 0x49,
	0xf1, 0xff, 0xb7, 0x3e, 0x6c, 0x39, 0xe5, 0xcf, 0xde, 0x59, 0xff, 0x6b, 0xcd, 0xe0, 0xf5, 0x36,
	0xc3, 0xae, 0x98, 0xd8, 0x35, 0xb1, 0x5e, 0x98, 0xd8, 0xd8, 0x9b, 0x3f, 0x86, 0xb1, 0xc0, 0xf3,
	0x41, 0x7b, 0x27, 0x20, 0x82, 0x53, 0x4b, 0x5d, 0x92, 0xda, 0x6a, 0x75, 0xf5, 0x74, 0x95, 0x64,
	0xeb, 0x11, 0x08, 0x78, 0x00, 0x88, 0xe0, 0xc2, 0x89, 0x08, 0xde, 0x82, 0x1b, 0x47, 0x4e, 0x9c,
	0x89, 0x21, 0x38, 0xf3, 0x0a, 0x44, 0x66, 0x55, 0xb5, 0xaa, 0x65, 0xcf, 0x30, 0x1b, 0xec, 0xad,
	0xf3, 0x97, 0x59, 0x95, 0x59, 0x59, 0x59, 0xbf, 0xca, 0x2e, 0x58, 0x97, 0x7d, 0x9e, 0xf1, 0xa3,
	0xc3, 0xbc, 0x10, 0x4a, 0xf8, 0xb5, 0xbc, 0xb7, 0xb7, 0xde, 0x17, 0x93, 0x89, 0xc8, 0x34, 0x12,
	0x74, 0xa0, 0x71, 0x32, 0x1d, 0x0c, 0xfc, 0x6d, 0xa8, 0x27, 0xf1, 0x0d, 0xf3, 0x0e, 0xbc, 0x4e,
	0x33, 0xc4, 0x4f, 0x7f, 0x13, 0x6a, 0x4a, 0xb2, 0xda, 0x81, 0xd7, 0xa9, 0x87, 0x35, 0x25, 0x83,
	0xdf, 0x7a, 0xb0, 0x8d, 0xa6, 0xe7, 0xf9, 0xe9, 0x28, 0xca, 0x86, 0xbc, 0x9b, 0x0d, 0xc4, 0x1d,
	0xc3, 0xee, 0x41, 0x33, 0xe6, 0x91, 0x1a, 0xd1, 0xc8, 0x66, 0xa8, 0x05, 0x7f, 0x0f, 0x5a, 0x2a,
	0x2a, 0x86, 0x5c, 0x75, 0x63, 0x56, 0x27, 0x45, 0x29, 0xa3, 0xae, 0x4f, 0x33, 0x9e, 0xe7, 0xac,
	0x41, 0xee, 0x4a, 0xd9, 0x67, 0xb0, 0xaa, 0x84, 0x8a, 0xd2, 0xf3, 0x9c, 0x35, 0x49, 0x65, 0xc5,
	0xe0, 0xf7, 0x75, 0x68, 0x5d, 0xe2, 0xda, 0x9e, 0xf7, 0xae, 0xd0, 0x4c, 0xf4, 0xae, 0xbe, 0x9e,
	0xe7, 0xdc, 0x84, 0x62, 0x45, 0x7f, 0x1d, 0xbc, 0x1b, 0x13, 0x8a, 0x77, 0x83, 0xd2, 0xdc, 0xf8,
	0xf7, 0xe6, 0x18, 0x7c, 0x9c, 0x14, 0xe4, 0xb3, 0x19, 0xe2, 0x27, 0x06, 0x2f, 0x7a, 0x57, 0xdd,
	0x98, 0x9c, 0x35, 0x43, 0x2d, 0xf8, 0xbb, 0xb0, 0xa2, 0x78, 0x34, 0xe9, 0xc6, 0x6c, 0x85, 0x60,
	0x23, 0x61, 0x86, 0x46, 0x39, 0x5b, 0xd5, 0x19, 0x1a, 0xe5, 0x38, 0x7a, 0x94, 0x3f, 0x8d, 0x6e,
	0x58, 0x8b, 0x20, 0x2d, 0xf8, 0x1f, 0x41, 0xb3, 0x37, 0x1d, 0x0c, 0x24, 0x5b, 0x3b, 0xa8, 0x77,
	0xda, 0x47, 0xed, 0xc3, 0xbc, 0x77, 0x88, 0x79, 0x3c, 0x8e, 0xe3, 0x50, 0x6b, 0xfc, 0x8f, 0xa0,
	0x31, 0x95, 0xbc, 0x60, 0xef, 0x1f, 0x78, 0x9d, 0xf6, 0xd1, 0x06, 0x5a, 0xd0, 0xd2, 0x5e, 0x4a,
	0x5e, 0x84, 0xa4, 0x42, 0x93, 0x11, 0x2f, 0x04, 0xdb, 0x5d, 0x32, 0x39, 0xe7, 0x85, 0x08, 0x49,
	0xe5, 0x3f, 0x84, 0xd5, 0x89, 0xc8, 0xa4, 0xe2, 0x05, 0xfb, 0x7f, 0xb2, 0xda, 0x2e, 0xad, 0x9e,
	0x6a, 0x3c, 0xb4, 0x06, 0xfe, 0x67, 0xd0, 0x12, 0x3d, 0xc9, 0x8b, 0x19, 0x2f, 0x18, 0x23, 0xe3,
	0x9d, 0xd2, 0xf8, 0xb9, 0x51, 0x84, 0xa5, 0x09, 0x9a, 0x2b, 0x51, 0x28, 0x91, 0x48, 0xce, 0x3e,
	0x58, 0x32, 0xff, 0xda, 0x28, 0xc2, 0xd2, 0x24, 0xf8, 0x33, 0xc0, 0x5a, 0xb9, 0x00, 0x4c, 0x1f,
	0x2e, 0xa1, 0x1b, 0x9b, 0xbd, 0x31, 0x92, 0xef, 0x43, 0x23, 0x8b, 0x26, 0x9c, 0x76, 0x67, 0x2d,
	0xa4, 0x6f, 0xff, 0x47, 0xb0, 0x7a, 0xcd, 0xa3, 0x5c, 0x64, 0x92, 0x35, 0x28, 0x5d, 0x7b, 0x95,
	0x64, 0x1c, 0xfe, 0x42, 0x2b, 0x1f, 0x67, 0xaa, 0x98, 0x87, 0xd6, 0x14, 0x2b, 0x68, 0xc2, 0xe3,
	0x28, 0xed, 0xc6, 0x37, 0x66, 0xe7, 0x4a, 0xd9, 0xef, 0xc0, 0x6a, 0x9c, 0xc8, 0x3c, 0x8d, 0xe6,
	0xb4, 0x7b, 0xed, 0xa3, 0x4d, 0x9c, 0xf1, 0x4c, 0x43, 0xcf, 0xd4, 0x20, 0xb4, 0x6a, 0x2c, 0x87,
	0x59, 0xa2, 0xf7, 0xb3, 0x19, 0xe2, 0x27, 0x96, 0xd5, 0x38, 0xc9, 0x86, 0xb1, 0x98, 0xd0, 0x96,
	0x36, 0x43, 0x2b, 0xa2, 0x6d, 0x3a, 0x4b, 0xd9, 0x9a, 0xb6, 0x4d, 0x67, 0x29, 0x22, 0x92, 0xdf,
	0x30, 0xd0, 0x88, 0xe4, 0x37, 0xb8, 0xee, 0xbe, 0x98, 0xf4, 0x22, 0xc5, 0xda, 0x54, 0x0f, 0x46,
	0xc2, 0x75, 0x8f, 0x93, 0x34, 0x65, 0xeb, 0x64, 0x4a, 0xdf, 0xe8, 0x69, 0x38, 0x4d, 0xd2, 0xb8,
	0x1b, 0xb3, 0x0d, 0xed, 0xc9, 0x88, 0xfe, 0x7d, 0x58, 0xa3, 0xcf, 0x67, 0x98, 0xaa, 0x4d, 0x4a,
	0xd5, 0x02, 0xf0, 0xf7, 0x01, 0x4c, 0x48, 0x2f, 0x84, 0x64, 0x5b, 0x34, 0xd4, 0x41, 0x30, 0x86,
	0x68, 0x16, 0xa9, 0xa8, 0x60, 0xdb, 0x34, 0xd4, 0x48, 0xfe, 0xe7, 0xd0, 0xc6, 0x9a, 0xe9, 0xc6,
	0x37, 0x17, 0x89, 0x54, 0x6c, 0x87, 0x72, 0xbd, 0x85, 0x99, 0xc1, 0x82, 0x7a, 0x21, 0x24, 0x9e,
	0xee, 0xd0, 0xb5, 0xc1, 0xea, 0x9e, 0x14, 0x51, 0x36, 0x66, 0xef, 0xe9, 0xb3, 0x41, 0x02, 0x06,
	0x10, 0x17, 0x49, 0x36, 0x3e, 0x15, 0xd3, 0x4c, 0xb1, 0x7b, 0x3a, 0x80, 0x05, 0xe2, 0x07, 0xb0,
	0xae, 0x44, 0x24, 0xd5, 0x4b, 0xda, 0x73, 0xc9, 0xde, 0x3f, 0xa8, 0x77, 0x9a, 0x61, 0x05, 0xf3,
	0x0f, 0xc1, 0xe7, 0x93, 0x9c, 0x17, 0xa2, 0x38, 0xee, 0x8f, 0x12, 0x3e, 0xe3, 0x97, 0x18, 0xf0,
	0x2e, 0xcd, 0x75, 0x87, 0xa6, 0xdc, 0xee, 0x8b, 0x59, 0x4a, 0x95, 0x6e, 0xb7, 0xfb, 0x62, 0x96,
	0x62, 0x3c, 0x51, 0xa1, 0x92, 0x41, 0xd4, 0x47, 0xaa, 0x61, 0x3a, 0x9e, 0x05, 0xe2, 0x1f, 0x40,
	0xdb, 0x4a, 0x38, 0xfc, 0x03, 0x32, 0x70, 0x21, 0xbf, 0x03, 0x5b, 0x56, 0x3c, 0x4d, 0x85, 0x1a,
	0x75, 0x63, 0xb6, 0x47, 0x56, 0xcb, 0xb0, 0xff, 0x10, 0xb6, 0x2b, 0x10, 0x4e, 0xf8, 0x1d, 0x32,
	0xbd, 0x85, 0xa3, 0xad, 0xbc, 0x16, 0x45, 0x7c, 0x99, 0x27, 0x45, 0xa2, 0x2e, 0x55, 0x34, 0xe4,
	0xec, 0xbe, 0xb6, 0x5d, 0xc6, 0x31, 0x46, 0xda, 0xe1, 0x0b, 0x31, 0x14, 0xdd, 0x98, 0x7d, 0x57,
	0xc7, 0xe8, 0x40, 0x98, 0x55, 0x12, 0x4f, 0x45, 0x2a, 0xf0, 0x60, 0xed, 0x93, 0x49, 0x05, 0xc3,
	0x75, 0xf4, 0xf8, 0x40, 0x14, 0xfc, 0x49, 0x59, 0x3e, 0x1f, 0x52, 0x0d, 0x2c, 0xc3, 0x98, 0xcf,
	0x44, 0x5e, 0xaa, 0x48, 0x4d, 0x39, 0x3b, 0x38, 0xf0, 0x3a, 0xad, 0xb0, 0x94, 0x51, 0x97, 0x8f,
	0xe9, 0x5b, 0xb2, 0x40, 0xe7, 0xda, 0xca, 0xfe, 0xa7, 0xb0, 0xa3, 0x49, 0xfc, 0x58, 0xca, 0x44,
	0xaa, 0xe7, 0xc4, 0x9c, 0xdf, 0x23, 0xa3, 0xdb, 0x0a, 0x8c, 0x39, 0x22, 0xf1, 0xb8, 0xaf, 0x92,
	0x19, 0x67, 0x0f, 0xc8, 0x53, 0x05, 0xc3, 0x4a, 0xd0, 0xd4, 0xff, 0xe2, 0x67, 0xda, 0xc7, 0x69,
	0x7c, 0xa9, 0xd8, 0xf7, 0x75, 0x25, 0xdc, 0xd6, 0x50, 0x75, 0x15, 0x51, 0x26, 0x07, 0xbc, 0x20,
	0xf2, 0xff, 0x58, 0xe7, 0xc1, 0xc5, 0x70, 0x05, 0xbd, 0x22, 0x19, 0x8e, 0x14, 0xcf, 0xd8, 0x27,
	0x94, 0x80, 0x52, 0xc6, 0x1c, 0x59, 0xdb, 0x9f, 0x4f, 0xa3, 0x34, 0x51, 0x73, 0xd6, 0xd1, 0x7b,
	0xbd, 0x04, 0xe3, 0x31, 0x2c, 0x44, 0x4f, 0x28, 0x72, 0xf3, 0x03, 0xb2, 0x59, 0x00, 0x7b, 0x5f,
	0xc1, 0xba, 0xcb, 0x4c, 0x48, 0x06, 0x63, 0x3e, 0xb7, 0xd7, 0xe2, 0x98, 0xcf, 0xf1, 0xf4, 0xcc,
	0xa2, 0x74, 0xca, 0xed, 0xb5, 0x48, 0xc2, 0x57, 0xb5, 0x2f, 0xbd, 0xa0, 0x0b, 0x6d, 0xe7, 0xcc,
	0xe1, 0xa5, 0x92, 0x58, 0xa6, 0xac, 0x25, 0x31, 0x4e, 0x95, 0x0b, 0x69, 0x86, 0xe1, 0x27, 0x72,
	0xc5, 0x2b, 0x13, 0xac, 0xbe, 0xca, 0xac, 0x18, 0xfc, 0xc9, 0x33, 0xbc, 0x8b, 0x13, 0xd2, 0xa5,
	0x78, 0x9d, 0x39, 0xc4, 0x6b, 0x45, 0x5c, 0x0c, 0x7d, 0x3e, 0x5b, 0xd0, 0xef, 0x02, 0x28, 0x79,
	0xb9, 0xee, 0xf0, 0x32, 0x83, 0x55, 0xc3, 0x05, 0xe6, 0xba, 0xb4, 0xe2, 0x5b, 0xb9, 0xd7, 0x89,
	0x74, 0xa5, 0x1a, 0xe9, 0x01, 0xac, 0xbb, 0x17, 0xd3, 0xed, 0x3e, 0x22, 0x78, 0x05, 0x1b, 0x95,
	0xeb, 0x05, 0x33, 0x28, 0x73, 0xce, 0xed, 0x62, 0xb4, 0xe0, 0x3f, 0x80, 0x8d, 0x9e, 0xbe, 0x4c,
	0x2f, 0xa2, 0x39, 0x2f, 0x6c, 0xa2, 0xaa, 0xa0, 0xb5, 0x3a, 0xe3, 0x7d, 0x63, 0x55, 0x5f, 0x58,
	0x95, 0x60, 0xf0, 0x47, 0xcf, 0xf8, 0xb4, 0x37, 0xe0, 0x37, 0xba, 0xba, 0x2c, 0xad, 0xd7, 0xab,
	0xb4, 0x6e, 0x2f, 0x90, 0x46, 0xf5, 0x02, 0xa9, 0x12, 0x77, 0xf3, 0x2d, 0xc4, 0xbd, 0xe2, 0x12,
	0x77, 0xf0, 0xb9, 0x09, 0xf1, 0x71, 0xa6, 0x78, 0xf1, 0x4c, 0x0d, 0xfc, 0x03, 0x68, 0x88, 0xde,
	0x95, 0x64, 0x1e, 0x51, 0xf8, 0xba, 0x73, 0x8b, 0x5f, 0x85, 0xa4, 0x09, 0x3e, 0x31, 0x43, 0x2e,
	0x78, 0x34, 0xe3, 0x38, 0x64, 0x17, 0x56, 0xa8, 0xb1, 0xd1, 0x83, 0x9a, 0xa1, 0x91, 0x82, 0xb0,
	0xdc, 0x94, 0x19, 0x0f, 0x73, 0xf5, 0xd6, 0xde, 0xa9, 0xec, 0x94, 0x1a, 0x6e, 0xa7, 0x64, 0x3a,
	0xaa, 0x66, 0xd9, 0x51, 0x55, 0xe6, 0x44, 0xdf, 0xdf, 0xc6, 0x9c, 0xbf, 0xf6, 0x60, 0xed, 0x58,
	0xa9, 0xa8, 0x3f, 0xc6, 0x28, 0x91, 0xf1, 0x49, 0x70, 0xf6, 0xc9, 0x41, 0x70, 0x0f, 0x24, 0x6e,
	0x46, 0x37, 0x36, 0x7e, 0xad, 0xe8, 0xe4, 0xa1, 0xee, 0xe6, 0x01, 0x47, 0xa4, 0x49, 0x36, 0x7e,
	0x36, 0x2d, 0x77, 0xcd, 0x88, 0x77, 0xc4, 0xf2, 0xaf, 0x3a, 0x6c, 0x5d, 0xe2, 0x7c, 0x4f, 0x44,
	0x36, 0x1c, 0x4c, 0xe9, 0x08, 0x3b, 0x1e, 0xbd, 0xaa, 0xc7, 0x3d, 0x68, 0x5d, 0x4f, 0x87, 0x22,
	0x1b, 0x96, 0xc1, 0x94, 0x32, 0x1e, 0xca, 0x8c, 0x27, 0x46, 0xa9, 0x73, 0xb2, 0x00, 0x70, 0x95,
	0xaf, 0x92, 0x6c, 0x68, 0xd4, 0x3a, 0x2c, 0x07, 0xc1, 0x3b, 0x43, 0xcf, 0x74, 0xc1, 0x67, 0x3c,
	0x35, 0x11, 0xba, 0x10, 0xce, 0xa0, 0xc5, 0x4b, 0x5b, 0x55, 0xcd, 0xd0, 0x41, 0x90, 0x4b, 0x8d,
	0x3b, 0x3d, 0x85, 0xee, 0x83, 0x2a, 0x18, 0x7a, 0x31, 0x32, 0x4d, 0xa2, 0x9b, 0x22, 0x17, 0xc2,
	0x93, 0x66, 0xa3, 0xd2, 0xd3, 0xe8, 0x16, 0xa9, 0x0a, 0xa2, 0x2f, 0x0b, 0xd0, 0x44, 0xba, 0x6b,
	0xaa, 0x60, 0x8b, 0x6a, 0x68, 0xbb, 0xd5, 0xf0, 0x00, 0x36, 0x74, 0xcc, 0xa7, 0xa2, 0x28, 0x78,
	0x5f, 0x51, 0x17, 0xe5, 0x85, 0x55, 0xd0, 0xff, 0x18, 0x36, 0x4d, 0x50, 0xd6, 0x6c, 0x83, 0xcc,
	0x96, 0x50, 0xe4, 0x7f, 0xeb, 0xd3, 0x1a, 0x6e, 0x92, 0xe1, 0x32, 0x1c, 0x8c, 0x60, 0x93, 0xb6,
	0xf9, 0x97, 0x49, 0x74, 0x31, 0xb3, 0x44, 0x5d, 0x6e, 0x70, 0x4d, 0xff, 0x0d, 0x5c, 0xcc, 0xcc,
	0xae, 0xd6, 0x2e, 0x66, 0xc8, 0x07, 0xb4, 0x36, 0xc3, 0x07, 0x36, 0xc7, 0x34, 0x81, 0x75, 0xd6,
	0x20, 0x67, 0x15, 0x2c, 0xf8, 0xbb, 0x07, 0x40, 0xae, 0x4e, 0xd3, 0x48, 0x8e, 0xfc, 0x1f, 0x42,
	0x6b, 0x32, 0xd7, 0xc5, 0x45, 0xce, 0xda, 0x47, 0xef, 0xd1, 0x19, 0xaf, 0xd6, 0x5c, 0x58, 0x1a,
	0xf9, 0x3f, 0x86, 0x36, 0xcf, 0x78, 0x39, 0xa6, 0xf6, 0xe6, 0x31, 0xae, 0x9d, 0xff, 0x29, 0xac,
	0x4e, 0xe6, 0x14, 0x08, 0x45, 0xdc, 0x3e, 0xf2, 0xcb, 0x21, 0xe5, 0x9a, 0x43, 0x6b, 0xe2, 0x1f,
	0x01, 0xd0, 0x60, 0x3d, 0xa0, 0xf1, 0xc6, 0x01, 0x8e, 0x55, 0xf0, 0x97, 0xf2, 0xd8, 0x22, 0x11,
	0xbc, 0xf9, 0x90, 0x54, 0x0f, 0x74, 0xed, 0xd6, 0x81, 0xfe, 0x16, 0x8e, 0xad, 0xff, 0x08, 0x36,
	0x65, 0x99, 0x63, 0x8c, 0xd4, 0xfd, 0x39, 0x58, 0x64, 0x3f, 0x5c, 0xb2, 0x0a, 0x1e, 0x82, 0x4f,
	0xcc, 0xbb, 0x30, 0xc1, 0xb5, 0x94, 0xa5, 0xea, 0x39, 0xa5, 0x8a, 0xb6, 0x44, 0xb9, 0xef, 0x62,
	0xfb, 0x2b, 0xd8, 0x21, 0x9a, 0xfc, 0xa9, 0x48, 0xb2, 0x9f, 0x60, 0x73, 0x12, 0xf2, 0x57, 0xef,
	0xf2, 0xef, 0xea, 0x2c, 0xc9, 0xb9, 0xa2, 0x57, 0x2a, 0x57, 0x74, 0x70, 0xb2, 0x3c, 0xf9, 0x71,
	0x7f, 0xec, 0x7f, 0x06, 0xeb, 0x43, 0x21, 0x62, 0xa9, 0x7f, 0xe6, 0xa5, 0xa9, 0xad, 0x35, 0x5c,
	0xff, 0x13, 0xc4, 0xc3, 0x8a, 0x3a, 0xf8, 0x43, 0x0d, 0xe0, 0x7c, 0x5a, 0xa8, 0xc7, 0x83, 0x01,
	0x1e, 0x9c, 0x3b, 0x57, 0x61, 0x7e, 0x88, 0x6b, 0xee, 0x0f, 0xb1, 0x7e, 0x0b, 0xa8, 0xbb, 0x6f,
	0x01, 0xbb, 0xb0, 0x92, 0xc8, 0x13, 0x31, 0xe9, 0x99, 0x6d, 0x32, 0x12, 0x1e, 0x6d, 0x55, 0x24,
	0xc3, 0xa1, 0xc9, 0x2e, 0xde, 0x8a, 0xb8, 0xbd, 0x55, 0x10, 0x8f, 0xec, 0x00, 0xd7, 0x70, 0x12,
	0xf5, 0xc7, 0x67, 0xd1, 0x04, 0xfb, 0xe8, 0x15, 0x72, 0xb8, 0x0c, 0x63, 0x1d, 0xf5, 0x69, 0x13,
	0x23, 0x95, 0x08, 0xa2, 0x33, 0x2f, 0x74, 0x10, 0x8c, 0x43, 0x8e, 0xc4, 0xf5, 0x79, 0x6e, 0xfe,
	0xd7, 0x8d, 0x84, 0x89, 0x4c, 0xe4, 0x99, 0x88, 0x87, 0x9c, 0xc8, 0xab, 0x15, 0x5a, 0x51, 0x6b,
	0x5e, 0x14, 0x5c, 0x4a, 0xc3, 0x58, 0x56, 0x0c, 0xce, 0x00, 0xf0, 0x9f, 0xde, 0x64, 0xc7, 0x74,
	0x33, 0xb5, 0xc5, 0xab, 0xc8, 0x03, 0x68, 0x8e, 0xa6, 0x85, 0x92, 0xe6, 0xa8, 0x50, 0x99, 0x2d,
	0xd2, 0x19, 0x6a, 0x65, 0xf0, 0x6f, 0x0f, 0x56, 0xcd, 0xd3, 0xc0, 0xad, 0x3e, 0xd0, 0x7d, 0x41,
	0xa9, 0x2d, 0xbd, 0xa0, 0x18, 0x7f, 0xf5, 0x85, 0xbf, 0x5d, 0x58, 0xc1, 0xde, 0xa6, 0xbc, 0x2a,
	0x8c, 0x64, 0x1e, 0x75, 0x9a, 0xf6, 0x51, 0x07, 0x67, 0x45, 0xd7, 0xd4, 0xd5, 0xea, 0xaa, 0x29,
	0x65, 0x24, 0x30, 0xa9, 0xb8, 0xfd, 0x21, 0xa6, 0x6f, 0xbc, 0xa4, 0xf2, 0xa8, 0x88, 0x26, 0x61,
	0xa4, 0xb8, 0xa1, 0xff, 0x05, 0x40, 0x3f, 0x0b, 0x28, 0xe0, 0x11, 0x5c, 0x33, 0x3f, 0x0b, 0x46,
	0xc6, 0x5a, 0x48, 0xe9, 0x42, 0xd0, 0x99, 0xd3, 0x42, 0xf0, 0x25, 0xb4, 0x70, 0xc1, 0x44, 0xa8,
	0xee, 0x0a, 0xbd, 0xbb, 0x57, 0xb8, 0xc8, 0x68, 0x30, 0x82, 0x0d, 0x5d, 0x9b, 0x38, 0x1e, 0x0f,
	0xd6, 0x87, 0xd0, 0xc0, 0x45, 0x9a, 0x42, 0xae, 0x3c, 0xb3, 0x90, 0xc2, 0x7f, 0x04, 0x5b, 0x31,
	0x4f, 0xb9, 0xe2, 0xd6, 0x23, 0x36, 0x8b, 0x65, 0xd3, 0x64, 0xc1, 0x70, 0xd9, 0x28, 0xf8, 0x8d,
	0x07, 0x5b, 0x9a, 0xb7, 0xf4, 0x6e, 0xfd, 0x6f, 0xec, 0xe5, 0xb0, 0x54, 0xbd, 0xca, 0x52, 0x4e,
	0x8d, 0xd4, 0xdf, 0x5c, 0x23, 0x2f, 0x61, 0xcb, 0x7d, 0x85, 0xc3, 0x60, 0x4e, 0x60, 0xa7, 0xb7,
	0xf4, 0x30, 0x67, 0xfb, 0xc1, 0x7b, 0x76, 0x69, 0xae, 0x32, 0xbc, 0x6d, 0x1e, 0x1c, 0xc1, 0xf6,
	0xd3, 0x28, 0xc9, 0x4e, 0x13, 0x35, 0x27, 0x82, 0xd3, 0x9d, 0x55, 0x5d, 0xf4, 0xae, 0x4c, 0x42,
	0xab, 0x9d, 0x25, 0x2a, 0x30, 0x14, 0x3b, 0xc6, 0xb6, 0x8c, 0x77, 0xf3, 0xc2, 0x37, 0x22, 0xb2,
	0xa0, 0xb3, 0x08, 0x85, 0xf8, 0xf3, 0x8d, 0xf3, 0x06, 0x5f, 0xc0, 0x8e, 0xb5, 0x7c, 0x99, 0xc7,
	0x91, 0xe2, 0xef, 0x12, 0xf5, 0x04, 0xd6, 0x4e, 0x84, 0x94, 0xe7, 0x39, 0xa6, 0xae, 0x03, 0xf5,
	0x51, 0x6e, 0x93, 0xb5, 0x4b, 0xc9, 0xb2, 0xba, 0xc3, 0xf3, 0xdc, 0xbc, 0x33, 0xa1, 0xc9, 0xde,
	0x23, 0x68, 0x59, 0xe0, 0xbf, 0xfd, 0xde, 0xd5, 0xdd, 0xdf, 0xbb, 0x1c, 0xee, 0xd9, 0x5f, 0x18,
	0xe2, 0x5e, 0x4c, 0x37, 0x7a, 0xbe, 0x0f, 0x6b, 0x7d, 0x31, 0xcd, 0xd4, 0x99, 0xb8, 0xce, 0xcc,
	0x4c, 0x0b, 0x40, 0x3f, 0x9b, 0xe8, 0x51, 0x12, 0x6f, 0xba, 0x9a, 0x7d, 0x36, 0x59, 0x60, 0x78,
	0xc6, 0x8b, 0xa8, 0x9f, 0x64, 0x43, 0x4a, 0x66, 0x2b, 0x34, 0xd2, 0xc9, 0xf6, 0x5f, 0x5f, 0xef,
	0x7b, 0x7f, 0x7b, 0xbd, 0xef, 0xfd, 0xe3, 0xf5, 0xbe, 0xf7, 0xbb, 0x7f, 0xee, 0xff, 0x5f, 0x6f,
	0x85, 0xde, 0x7a, 0xbf, 0xf8, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x36, 0x77, 0x10, 0xbd, 0x0d,
	0x16, 0x00, 0x00,
}
