// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ErrorAck struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ErrorAck) Reset()                    { *m = ErrorAck{} }
func (m *ErrorAck) String() string            { return proto.CompactTextString(m) }
func (*ErrorAck) ProtoMessage()               {}
func (*ErrorAck) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *ErrorAck) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrorAck) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type UserLoginInfo struct {
	Userid                         int32                    `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	NickName                       string                   `protobuf:"bytes,2,opt,name=nickName,proto3" json:"nickName,omitempty"`
	Avatar                         string                   `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	VipLevel                       int32                    `protobuf:"varint,4,opt,name=vipLevel,proto3" json:"vipLevel,omitempty"`
	VipScore                       int32                    `protobuf:"varint,5,opt,name=vipScore,proto3" json:"vipScore,omitempty"`
	Level                          int32                    `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	Exp                            int32                    `protobuf:"varint,7,opt,name=exp,proto3" json:"exp,omitempty"`
	Gold                           int64                    `protobuf:"varint,8,opt,name=gold,proto3" json:"gold,omitempty"`
	Ingot                          int32                    `protobuf:"varint,9,opt,name=ingot,proto3" json:"ingot,omitempty"`
	CreateTime                     int32                    `protobuf:"varint,10,opt,name=createTime,proto3" json:"createTime,omitempty"`
	StageId                        int32                    `protobuf:"varint,11,opt,name=stageId,proto3" json:"stageId,omitempty"`
	StageWave                      int32                    `protobuf:"varint,12,opt,name=stageWave,proto3" json:"stageWave,omitempty"`
	Combat                         int64                    `protobuf:"varint,14,opt,name=combat,proto3" json:"combat,omitempty"`
	Heros                          []*HeroInfo              `protobuf:"bytes,15,rep,name=heros" json:"heros,omitempty"`
	Rein                           *Rein                    `protobuf:"bytes,16,opt,name=rein" json:"rein,omitempty"`
	ReinCost                       []*ReinCost              `protobuf:"bytes,17,rep,name=reinCost" json:"reinCost,omitempty"`
	Fabao                          []*Fabao                 `protobuf:"bytes,18,rep,name=fabao" json:"fabao,omitempty"`
	FieldBossInfo                  *FieldBossInfo           `protobuf:"bytes,19,opt,name=fieldBossInfo" json:"fieldBossInfo,omitempty"`
	WorldBossInfo                  *WorldBossInfoNtf        `protobuf:"bytes,20,opt,name=worldBossInfo" json:"worldBossInfo,omitempty"`
	ArenaFightNum                  int32                    `protobuf:"varint,21,opt,name=ArenaFightNum,proto3" json:"ArenaFightNum,omitempty"`
	FightModel                     int32                    `protobuf:"varint,22,opt,name=fightModel,proto3" json:"fightModel,omitempty"`
	Task                           *TaskInfoNtf             `protobuf:"bytes,23,opt,name=task" json:"task,omitempty"`
	ShopInfo                       map[int32]*ShopInfo      `protobuf:"bytes,24,rep,name=shopInfo" json:"shopInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ChuanqiBi                      int32                    `protobuf:"varint,25,opt,name=chuanqiBi,proto3" json:"chuanqiBi,omitempty"`
	MaterialStage                  map[int32]int32          `protobuf:"bytes,26,rep,name=materialStage" json:"materialStage,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Panaceas                       map[int32]*PanaceaInfo   `protobuf:"bytes,27,rep,name=panaceas" json:"panaceas,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	SignInfo                       *SignInfo                `protobuf:"bytes,28,opt,name=signInfo" json:"signInfo,omitempty"`
	DayStateInfo                   *DayStateInfo            `protobuf:"bytes,29,opt,name=dayStateInfo" json:"dayStateInfo,omitempty"`
	Official                       int32                    `protobuf:"varint,30,opt,name=official,proto3" json:"official,omitempty"`
	Holy                           []*Holy                  `protobuf:"bytes,31,rep,name=holy" json:"holy,omitempty"`
	Atlases                        []*Atlas                 `protobuf:"bytes,32,rep,name=atlases" json:"atlases,omitempty"`
	AtlasGathers                   []*AtlasGather           `protobuf:"bytes,33,rep,name=atlasGathers" json:"atlasGathers,omitempty"`
	MiningWorkTime                 int64                    `protobuf:"varint,34,opt,name=miningWorkTime,proto3" json:"miningWorkTime,omitempty"`
	Miner                          int32                    `protobuf:"varint,35,opt,name=miner,proto3" json:"miner,omitempty"`
	ExpStage                       *ExpStage                `protobuf:"bytes,36,opt,name=expStage" json:"expStage,omitempty"`
	Pets                           map[int32]*PetInfo       `protobuf:"bytes,37,rep,name=pets" json:"pets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Juexues                        []*Juexue                `protobuf:"bytes,38,rep,name=juexues" json:"juexues,omitempty"`
	UserWear                       *UserWear                `protobuf:"bytes,39,opt,name=userWear" json:"userWear,omitempty"`
	IsHaveGetDailyCompetitveReward int32                    `protobuf:"varint,40,opt,name=isHaveGetDailyCompetitveReward,proto3" json:"isHaveGetDailyCompetitveReward,omitempty"`
	Honour                         int64                    `protobuf:"varint,41,opt,name=honour,proto3" json:"honour,omitempty"`
	DarkPalaceInfo                 *DarkPalaceInfo          `protobuf:"bytes,42,opt,name=darkPalaceInfo" json:"darkPalaceInfo,omitempty"`
	PersonBoss                     map[int32]int32          `protobuf:"bytes,43,rep,name=personBoss" json:"personBoss,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipBoss                        map[int32]int32          `protobuf:"bytes,44,rep,name=vipBoss" json:"vipBoss,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipGift                        []int32                  `protobuf:"varint,45,rep,packed,name=vipGift" json:"vipGift,omitempty"`
	Fit                            *Fit                     `protobuf:"bytes,46,opt,name=fit" json:"fit,omitempty"`
	RechargeAll                    int32                    `protobuf:"varint,47,opt,name=rechargeAll,proto3" json:"rechargeAll,omitempty"`
	AccumulativeAllGetIds          []int32                  `protobuf:"varint,48,rep,packed,name=accumulativeAllGetIds" json:"accumulativeAllGetIds,omitempty"`
	MonthCard                      map[int32]*MonthCardUnit `protobuf:"bytes,49,rep,name=monthCard" json:"monthCard,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	FirstRecharge                  *FirstRecharge           `protobuf:"bytes,50,opt,name=firstRecharge" json:"firstRecharge,omitempty"`
	SpendRebates                   *SpendRebates            `protobuf:"bytes,51,opt,name=spendRebates" json:"spendRebates,omitempty"`
	DailyPack                      map[int32]int32          `protobuf:"bytes,52,rep,name=dailyPack" json:"dailyPack,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *UserLoginInfo) Reset()                    { *m = UserLoginInfo{} }
func (m *UserLoginInfo) String() string            { return proto.CompactTextString(m) }
func (*UserLoginInfo) ProtoMessage()               {}
func (*UserLoginInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *UserLoginInfo) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *UserLoginInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *UserLoginInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *UserLoginInfo) GetVipLevel() int32 {
	if m != nil {
		return m.VipLevel
	}
	return 0
}

func (m *UserLoginInfo) GetVipScore() int32 {
	if m != nil {
		return m.VipScore
	}
	return 0
}

func (m *UserLoginInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UserLoginInfo) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *UserLoginInfo) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *UserLoginInfo) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *UserLoginInfo) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *UserLoginInfo) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *UserLoginInfo) GetStageWave() int32 {
	if m != nil {
		return m.StageWave
	}
	return 0
}

func (m *UserLoginInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *UserLoginInfo) GetHeros() []*HeroInfo {
	if m != nil {
		return m.Heros
	}
	return nil
}

func (m *UserLoginInfo) GetRein() *Rein {
	if m != nil {
		return m.Rein
	}
	return nil
}

func (m *UserLoginInfo) GetReinCost() []*ReinCost {
	if m != nil {
		return m.ReinCost
	}
	return nil
}

func (m *UserLoginInfo) GetFabao() []*Fabao {
	if m != nil {
		return m.Fabao
	}
	return nil
}

func (m *UserLoginInfo) GetFieldBossInfo() *FieldBossInfo {
	if m != nil {
		return m.FieldBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetWorldBossInfo() *WorldBossInfoNtf {
	if m != nil {
		return m.WorldBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetArenaFightNum() int32 {
	if m != nil {
		return m.ArenaFightNum
	}
	return 0
}

func (m *UserLoginInfo) GetFightModel() int32 {
	if m != nil {
		return m.FightModel
	}
	return 0
}

func (m *UserLoginInfo) GetTask() *TaskInfoNtf {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *UserLoginInfo) GetShopInfo() map[int32]*ShopInfo {
	if m != nil {
		return m.ShopInfo
	}
	return nil
}

func (m *UserLoginInfo) GetChuanqiBi() int32 {
	if m != nil {
		return m.ChuanqiBi
	}
	return 0
}

func (m *UserLoginInfo) GetMaterialStage() map[int32]int32 {
	if m != nil {
		return m.MaterialStage
	}
	return nil
}

func (m *UserLoginInfo) GetPanaceas() map[int32]*PanaceaInfo {
	if m != nil {
		return m.Panaceas
	}
	return nil
}

func (m *UserLoginInfo) GetSignInfo() *SignInfo {
	if m != nil {
		return m.SignInfo
	}
	return nil
}

func (m *UserLoginInfo) GetDayStateInfo() *DayStateInfo {
	if m != nil {
		return m.DayStateInfo
	}
	return nil
}

func (m *UserLoginInfo) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *UserLoginInfo) GetHoly() []*Holy {
	if m != nil {
		return m.Holy
	}
	return nil
}

func (m *UserLoginInfo) GetAtlases() []*Atlas {
	if m != nil {
		return m.Atlases
	}
	return nil
}

func (m *UserLoginInfo) GetAtlasGathers() []*AtlasGather {
	if m != nil {
		return m.AtlasGathers
	}
	return nil
}

func (m *UserLoginInfo) GetMiningWorkTime() int64 {
	if m != nil {
		return m.MiningWorkTime
	}
	return 0
}

func (m *UserLoginInfo) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *UserLoginInfo) GetExpStage() *ExpStage {
	if m != nil {
		return m.ExpStage
	}
	return nil
}

func (m *UserLoginInfo) GetPets() map[int32]*PetInfo {
	if m != nil {
		return m.Pets
	}
	return nil
}

func (m *UserLoginInfo) GetJuexues() []*Juexue {
	if m != nil {
		return m.Juexues
	}
	return nil
}

func (m *UserLoginInfo) GetUserWear() *UserWear {
	if m != nil {
		return m.UserWear
	}
	return nil
}

func (m *UserLoginInfo) GetIsHaveGetDailyCompetitveReward() int32 {
	if m != nil {
		return m.IsHaveGetDailyCompetitveReward
	}
	return 0
}

func (m *UserLoginInfo) GetHonour() int64 {
	if m != nil {
		return m.Honour
	}
	return 0
}

func (m *UserLoginInfo) GetDarkPalaceInfo() *DarkPalaceInfo {
	if m != nil {
		return m.DarkPalaceInfo
	}
	return nil
}

func (m *UserLoginInfo) GetPersonBoss() map[int32]int32 {
	if m != nil {
		return m.PersonBoss
	}
	return nil
}

func (m *UserLoginInfo) GetVipBoss() map[int32]int32 {
	if m != nil {
		return m.VipBoss
	}
	return nil
}

func (m *UserLoginInfo) GetVipGift() []int32 {
	if m != nil {
		return m.VipGift
	}
	return nil
}

func (m *UserLoginInfo) GetFit() *Fit {
	if m != nil {
		return m.Fit
	}
	return nil
}

func (m *UserLoginInfo) GetRechargeAll() int32 {
	if m != nil {
		return m.RechargeAll
	}
	return 0
}

func (m *UserLoginInfo) GetAccumulativeAllGetIds() []int32 {
	if m != nil {
		return m.AccumulativeAllGetIds
	}
	return nil
}

func (m *UserLoginInfo) GetMonthCard() map[int32]*MonthCardUnit {
	if m != nil {
		return m.MonthCard
	}
	return nil
}

func (m *UserLoginInfo) GetFirstRecharge() *FirstRecharge {
	if m != nil {
		return m.FirstRecharge
	}
	return nil
}

func (m *UserLoginInfo) GetSpendRebates() *SpendRebates {
	if m != nil {
		return m.SpendRebates
	}
	return nil
}

func (m *UserLoginInfo) GetDailyPack() map[int32]int32 {
	if m != nil {
		return m.DailyPack
	}
	return nil
}

type HeroInfo struct {
	Index          int32                       `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Job            int32                       `protobuf:"varint,2,opt,name=job,proto3" json:"job,omitempty"`
	Sex            int32                       `protobuf:"varint,3,opt,name=sex,proto3" json:"sex,omitempty"`
	Equips         map[int32]*EquipUnit        `protobuf:"bytes,4,rep,name=equips" json:"equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	EquipGrids     []*EquipGrid                `protobuf:"bytes,5,rep,name=equipGrids" json:"equipGrids,omitempty"`
	HeroProp       *HeroProp                   `protobuf:"bytes,6,opt,name=heroProp" json:"heroProp,omitempty"`
	Wing           []*Wing                     `protobuf:"bytes,7,rep,name=wing" json:"wing,omitempty"`
	Zodiacs        map[int32]*SpecialEquipUnit `protobuf:"bytes,8,rep,name=zodiacs" json:"zodiacs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Kingarms       map[int32]*SpecialEquipUnit `protobuf:"bytes,9,rep,name=kingarms" json:"kingarms,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Dictates       []*DictateInfo              `protobuf:"bytes,10,rep,name=dictates" json:"dictates,omitempty"`
	WingSpecial    []*WingSpecialNtf           `protobuf:"bytes,11,rep,name=wingSpecial" json:"wingSpecial,omitempty"`
	Jewels         map[int32]*JewelInfo        `protobuf:"bytes,12,rep,name=jewels" json:"jewels,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Name           string                      `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	InsideInfo     *InsideInfo                 `protobuf:"bytes,14,opt,name=insideInfo" json:"insideInfo,omitempty"`
	Fashions       map[int32]*Fashion          `protobuf:"bytes,15,rep,name=Fashions" json:"Fashions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Wears          *Wears                      `protobuf:"bytes,16,opt,name=wears" json:"wears,omitempty"`
	Rings          map[int32]*Ring             `protobuf:"bytes,17,rep,name=rings" json:"rings,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Skills         []*SkillUnit                `protobuf:"bytes,18,rep,name=skills" json:"skills,omitempty"`
	SkillBag       map[int32]int32             `protobuf:"bytes,19,rep,name=skillBag" json:"skillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	UniqueSkills   []*SkillUnit                `protobuf:"bytes,20,rep,name=uniqueSkills" json:"uniqueSkills,omitempty"`
	UniqueSkillBag map[int32]int32             `protobuf:"bytes,21,rep,name=uniqueSkillBag" json:"uniqueSkillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GodEquips      map[int32]*GodEquip         `protobuf:"bytes,22,rep,name=godEquips" json:"godEquips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Area           map[int32]int32             `protobuf:"bytes,23,rep,name=area" json:"area,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EquipClears    map[int32]*EquipClearArr    `protobuf:"bytes,24,rep,name=equipClears" json:"equipClears,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ExpLvl         int32                       `protobuf:"varint,25,opt,name=expLvl,proto3" json:"expLvl,omitempty"`
	DragonEquip    map[int32]int32             `protobuf:"bytes,26,rep,name=dragonEquip" json:"dragonEquip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MagicCircle    map[int32]int32             `protobuf:"bytes,27,rep,name=MagicCircle" json:"MagicCircle,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Talents        *TalentInfo                 `protobuf:"bytes,28,opt,name=talents" json:"talents,omitempty"`
}

func (m *HeroInfo) Reset()                    { *m = HeroInfo{} }
func (m *HeroInfo) String() string            { return proto.CompactTextString(m) }
func (*HeroInfo) ProtoMessage()               {}
func (*HeroInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *HeroInfo) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *HeroInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *HeroInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *HeroInfo) GetEquips() map[int32]*EquipUnit {
	if m != nil {
		return m.Equips
	}
	return nil
}

func (m *HeroInfo) GetEquipGrids() []*EquipGrid {
	if m != nil {
		return m.EquipGrids
	}
	return nil
}

func (m *HeroInfo) GetHeroProp() *HeroProp {
	if m != nil {
		return m.HeroProp
	}
	return nil
}

func (m *HeroInfo) GetWing() []*Wing {
	if m != nil {
		return m.Wing
	}
	return nil
}

func (m *HeroInfo) GetZodiacs() map[int32]*SpecialEquipUnit {
	if m != nil {
		return m.Zodiacs
	}
	return nil
}

func (m *HeroInfo) GetKingarms() map[int32]*SpecialEquipUnit {
	if m != nil {
		return m.Kingarms
	}
	return nil
}

func (m *HeroInfo) GetDictates() []*DictateInfo {
	if m != nil {
		return m.Dictates
	}
	return nil
}

func (m *HeroInfo) GetWingSpecial() []*WingSpecialNtf {
	if m != nil {
		return m.WingSpecial
	}
	return nil
}

func (m *HeroInfo) GetJewels() map[int32]*JewelInfo {
	if m != nil {
		return m.Jewels
	}
	return nil
}

func (m *HeroInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeroInfo) GetInsideInfo() *InsideInfo {
	if m != nil {
		return m.InsideInfo
	}
	return nil
}

func (m *HeroInfo) GetFashions() map[int32]*Fashion {
	if m != nil {
		return m.Fashions
	}
	return nil
}

func (m *HeroInfo) GetWears() *Wears {
	if m != nil {
		return m.Wears
	}
	return nil
}

func (m *HeroInfo) GetRings() map[int32]*Ring {
	if m != nil {
		return m.Rings
	}
	return nil
}

func (m *HeroInfo) GetSkills() []*SkillUnit {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *HeroInfo) GetSkillBag() map[int32]int32 {
	if m != nil {
		return m.SkillBag
	}
	return nil
}

func (m *HeroInfo) GetUniqueSkills() []*SkillUnit {
	if m != nil {
		return m.UniqueSkills
	}
	return nil
}

func (m *HeroInfo) GetUniqueSkillBag() map[int32]int32 {
	if m != nil {
		return m.UniqueSkillBag
	}
	return nil
}

func (m *HeroInfo) GetGodEquips() map[int32]*GodEquip {
	if m != nil {
		return m.GodEquips
	}
	return nil
}

func (m *HeroInfo) GetArea() map[int32]int32 {
	if m != nil {
		return m.Area
	}
	return nil
}

func (m *HeroInfo) GetEquipClears() map[int32]*EquipClearArr {
	if m != nil {
		return m.EquipClears
	}
	return nil
}

func (m *HeroInfo) GetExpLvl() int32 {
	if m != nil {
		return m.ExpLvl
	}
	return 0
}

func (m *HeroInfo) GetDragonEquip() map[int32]int32 {
	if m != nil {
		return m.DragonEquip
	}
	return nil
}

func (m *HeroInfo) GetMagicCircle() map[int32]int32 {
	if m != nil {
		return m.MagicCircle
	}
	return nil
}

func (m *HeroInfo) GetTalents() *TalentInfo {
	if m != nil {
		return m.Talents
	}
	return nil
}

type UserWear struct {
	Petid        int32 `protobuf:"varint,1,opt,name=petid,proto3" json:"petid,omitempty"`
	FitFashionId int32 `protobuf:"varint,2,opt,name=fitFashionId,proto3" json:"fitFashionId,omitempty"`
}

func (m *UserWear) Reset()                    { *m = UserWear{} }
func (m *UserWear) String() string            { return proto.CompactTextString(m) }
func (*UserWear) ProtoMessage()               {}
func (*UserWear) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *UserWear) GetPetid() int32 {
	if m != nil {
		return m.Petid
	}
	return 0
}

func (m *UserWear) GetFitFashionId() int32 {
	if m != nil {
		return m.FitFashionId
	}
	return 0
}

type Wears struct {
	FashionWeaponId int32   `protobuf:"varint,1,opt,name=FashionWeaponId,proto3" json:"FashionWeaponId,omitempty"`
	FashionClothId  int32   `protobuf:"varint,2,opt,name=FashionClothId,proto3" json:"FashionClothId,omitempty"`
	AtlasWear       []int32 `protobuf:"varint,3,rep,packed,name=atlasWear" json:"atlasWear,omitempty"`
	WingId          int32   `protobuf:"varint,4,opt,name=wingId,proto3" json:"wingId,omitempty"`
	MagicCircleLvId int32   `protobuf:"varint,5,opt,name=magicCircleLvId,proto3" json:"magicCircleLvId,omitempty"`
}

func (m *Wears) Reset()                    { *m = Wears{} }
func (m *Wears) String() string            { return proto.CompactTextString(m) }
func (*Wears) ProtoMessage()               {}
func (*Wears) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *Wears) GetFashionWeaponId() int32 {
	if m != nil {
		return m.FashionWeaponId
	}
	return 0
}

func (m *Wears) GetFashionClothId() int32 {
	if m != nil {
		return m.FashionClothId
	}
	return 0
}

func (m *Wears) GetAtlasWear() []int32 {
	if m != nil {
		return m.AtlasWear
	}
	return nil
}

func (m *Wears) GetWingId() int32 {
	if m != nil {
		return m.WingId
	}
	return 0
}

func (m *Wears) GetMagicCircleLvId() int32 {
	if m != nil {
		return m.MagicCircleLvId
	}
	return 0
}

// 简短的用户信息，用于聊天，走马灯等 消息。
type BriefUserInfo struct {
	Id     int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sex    int32  `protobuf:"varint,3,opt,name=sex,proto3" json:"sex,omitempty"`
	Lvl    int32  `protobuf:"varint,4,opt,name=lvl,proto3" json:"lvl,omitempty"`
	Vip    int32  `protobuf:"varint,5,opt,name=vip,proto3" json:"vip,omitempty"`
	Combat int64  `protobuf:"varint,6,opt,name=combat,proto3" json:"combat,omitempty"`
	Avatar string `protobuf:"bytes,7,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Job    int32  `protobuf:"varint,8,opt,name=job,proto3" json:"job,omitempty"`
}

func (m *BriefUserInfo) Reset()                    { *m = BriefUserInfo{} }
func (m *BriefUserInfo) String() string            { return proto.CompactTextString(m) }
func (*BriefUserInfo) ProtoMessage()               {}
func (*BriefUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

func (m *BriefUserInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BriefUserInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BriefUserInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *BriefUserInfo) GetLvl() int32 {
	if m != nil {
		return m.Lvl
	}
	return 0
}

func (m *BriefUserInfo) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *BriefUserInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *BriefUserInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *BriefUserInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

type BriefUserInfoWithDisplay struct {
	UserInfo *BriefUserInfo `protobuf:"bytes,1,opt,name=userInfo" json:"userInfo,omitempty"`
	Display  *DisplayNtf    `protobuf:"bytes,14,opt,name=display" json:"display,omitempty"`
}

func (m *BriefUserInfoWithDisplay) Reset()                    { *m = BriefUserInfoWithDisplay{} }
func (m *BriefUserInfoWithDisplay) String() string            { return proto.CompactTextString(m) }
func (*BriefUserInfoWithDisplay) ProtoMessage()               {}
func (*BriefUserInfoWithDisplay) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

func (m *BriefUserInfoWithDisplay) GetUserInfo() *BriefUserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *BriefUserInfoWithDisplay) GetDisplay() *DisplayNtf {
	if m != nil {
		return m.Display
	}
	return nil
}

// 顶级数据变化
type TopDataChangeNtf struct {
	ChangeInfos []*TopDataChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32            `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TopDataChangeNtf) Reset()                    { *m = TopDataChangeNtf{} }
func (m *TopDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*TopDataChangeNtf) ProtoMessage()               {}
func (*TopDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

func (m *TopDataChangeNtf) GetChangeInfos() []*TopDataChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *TopDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 顶级数据变化
type TopDataChange struct {
	Id     int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Change int64 `protobuf:"varint,2,opt,name=change,proto3" json:"change,omitempty"`
	NowNum int64 `protobuf:"varint,3,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
}

func (m *TopDataChange) Reset()                    { *m = TopDataChange{} }
func (m *TopDataChange) String() string            { return proto.CompactTextString(m) }
func (*TopDataChange) ProtoMessage()               {}
func (*TopDataChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{8} }

func (m *TopDataChange) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TopDataChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *TopDataChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

// 背包道具变化
type BagDataChangeNtf struct {
	ChangeInfos []*ItemChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *BagDataChangeNtf) Reset()                    { *m = BagDataChangeNtf{} }
func (m *BagDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BagDataChangeNtf) ProtoMessage()               {}
func (*BagDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{9} }

func (m *BagDataChangeNtf) GetChangeInfos() []*ItemChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *BagDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 背包道具变化
type ItemChange struct {
	Position  int32      `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	ItemId    int32      `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Change    int64      `protobuf:"varint,3,opt,name=change,proto3" json:"change,omitempty"`
	NowNum    int64      `protobuf:"varint,4,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
	GetSource *GetSource `protobuf:"bytes,5,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *ItemChange) Reset()                    { *m = ItemChange{} }
func (m *ItemChange) String() string            { return proto.CompactTextString(m) }
func (*ItemChange) ProtoMessage()               {}
func (*ItemChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{10} }

func (m *ItemChange) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *ItemChange) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *ItemChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

func (m *ItemChange) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

// 背包装备变化
type BagEquipDataChangeNtf struct {
	ChangeInfos []*EquipChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32          `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *BagEquipDataChangeNtf) Reset()                    { *m = BagEquipDataChangeNtf{} }
func (m *BagEquipDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BagEquipDataChangeNtf) ProtoMessage()               {}
func (*BagEquipDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{11} }

func (m *BagEquipDataChangeNtf) GetChangeInfos() []*EquipChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *BagEquipDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 背包道具变化
type EquipChange struct {
	Position  int32      `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	ItemId    int32      `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Change    int64      `protobuf:"varint,3,opt,name=change,proto3" json:"change,omitempty"`
	NowNum    int64      `protobuf:"varint,4,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
	Equip     *EquipUnit `protobuf:"bytes,5,opt,name=equip" json:"equip,omitempty"`
	GetSource *GetSource `protobuf:"bytes,6,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *EquipChange) Reset()                    { *m = EquipChange{} }
func (m *EquipChange) String() string            { return proto.CompactTextString(m) }
func (*EquipChange) ProtoMessage()               {}
func (*EquipChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{12} }

func (m *EquipChange) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *EquipChange) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *EquipChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *EquipChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

func (m *EquipChange) GetEquip() *EquipUnit {
	if m != nil {
		return m.Equip
	}
	return nil
}

func (m *EquipChange) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type Item struct {
	ItemId    int32      `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count     int64      `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Position  int32      `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty"`
	Equip     *EquipUnit `protobuf:"bytes,4,opt,name=equip" json:"equip,omitempty"`
	GetSource *GetSource `protobuf:"bytes,5,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{13} }

func (m *Item) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *Item) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Item) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Item) GetEquip() *EquipUnit {
	if m != nil {
		return m.Equip
	}
	return nil
}

func (m *Item) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type GoodsChangeNtf struct {
	Items []*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *GoodsChangeNtf) Reset()                    { *m = GoodsChangeNtf{} }
func (m *GoodsChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*GoodsChangeNtf) ProtoMessage()               {}
func (*GoodsChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{14} }

func (m *GoodsChangeNtf) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

type ItemUnit struct {
	ItemId int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count  int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ItemUnit) Reset()                    { *m = ItemUnit{} }
func (m *ItemUnit) String() string            { return proto.CompactTextString(m) }
func (*ItemUnit) ProtoMessage()               {}
func (*ItemUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{15} }

func (m *ItemUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemUnit) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EquipUnit struct {
	ItemId     int32            `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	RandProps  []*EquipRandProp `protobuf:"bytes,2,rep,name=randProps" json:"randProps,omitempty"`
	Lock       bool             `protobuf:"varint,3,opt,name=lock,proto3" json:"lock,omitempty"`
	EquipIndex int32            `protobuf:"varint,4,opt,name=equipIndex,proto3" json:"equipIndex,omitempty"`
	Lucky      int32            `protobuf:"varint,5,opt,name=lucky,proto3" json:"lucky,omitempty"`
}

func (m *EquipUnit) Reset()                    { *m = EquipUnit{} }
func (m *EquipUnit) String() string            { return proto.CompactTextString(m) }
func (*EquipUnit) ProtoMessage()               {}
func (*EquipUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{16} }

func (m *EquipUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *EquipUnit) GetRandProps() []*EquipRandProp {
	if m != nil {
		return m.RandProps
	}
	return nil
}

func (m *EquipUnit) GetLock() bool {
	if m != nil {
		return m.Lock
	}
	return false
}

func (m *EquipUnit) GetEquipIndex() int32 {
	if m != nil {
		return m.EquipIndex
	}
	return 0
}

func (m *EquipUnit) GetLucky() int32 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

type EquipRandProp struct {
	PropId int32 `protobuf:"varint,1,opt,name=propId,proto3" json:"propId,omitempty"`
	Color  int32 `protobuf:"varint,2,opt,name=color,proto3" json:"color,omitempty"`
	Value  int32 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EquipRandProp) Reset()                    { *m = EquipRandProp{} }
func (m *EquipRandProp) String() string            { return proto.CompactTextString(m) }
func (*EquipRandProp) ProtoMessage()               {}
func (*EquipRandProp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{17} }

func (m *EquipRandProp) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *EquipRandProp) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *EquipRandProp) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type EquipClearArr struct {
	EquipClearInfo []*EquipClearInfo `protobuf:"bytes,1,rep,name=equipClearInfo" json:"equipClearInfo,omitempty"`
}

func (m *EquipClearArr) Reset()                    { *m = EquipClearArr{} }
func (m *EquipClearArr) String() string            { return proto.CompactTextString(m) }
func (*EquipClearArr) ProtoMessage()               {}
func (*EquipClearArr) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{18} }

func (m *EquipClearArr) GetEquipClearInfo() []*EquipClearInfo {
	if m != nil {
		return m.EquipClearInfo
	}
	return nil
}

type EquipClearInfo struct {
	Grade  int32 `protobuf:"varint,1,opt,name=grade,proto3" json:"grade,omitempty"`
	Color  int32 `protobuf:"varint,2,opt,name=color,proto3" json:"color,omitempty"`
	PropId int32 `protobuf:"varint,3,opt,name=propId,proto3" json:"propId,omitempty"`
	Value  int32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EquipClearInfo) Reset()                    { *m = EquipClearInfo{} }
func (m *EquipClearInfo) String() string            { return proto.CompactTextString(m) }
func (*EquipClearInfo) ProtoMessage()               {}
func (*EquipClearInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{19} }

func (m *EquipClearInfo) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *EquipClearInfo) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *EquipClearInfo) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *EquipClearInfo) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type HeroProp struct {
	Props         map[int32]int64 `protobuf:"bytes,1,rep,name=props" json:"props,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ModulesCombat map[int32]int64 `protobuf:"bytes,2,rep,name=modulesCombat" json:"modulesCombat,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroProp) Reset()                    { *m = HeroProp{} }
func (m *HeroProp) String() string            { return proto.CompactTextString(m) }
func (*HeroProp) ProtoMessage()               {}
func (*HeroProp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{20} }

func (m *HeroProp) GetProps() map[int32]int64 {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *HeroProp) GetModulesCombat() map[int32]int64 {
	if m != nil {
		return m.ModulesCombat
	}
	return nil
}

type TaskInfoNtf struct {
	TaskId  int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Process int32 `protobuf:"varint,2,opt,name=process,proto3" json:"process,omitempty"`
}

func (m *TaskInfoNtf) Reset()                    { *m = TaskInfoNtf{} }
func (m *TaskInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*TaskInfoNtf) ProtoMessage()               {}
func (*TaskInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{21} }

func (m *TaskInfoNtf) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskInfoNtf) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

type DisplayNtf struct {
	Display map[int32]*Display `protobuf:"bytes,1,rep,name=display" json:"display,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DisplayNtf) Reset()                    { *m = DisplayNtf{} }
func (m *DisplayNtf) String() string            { return proto.CompactTextString(m) }
func (*DisplayNtf) ProtoMessage()               {}
func (*DisplayNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{22} }

func (m *DisplayNtf) GetDisplay() map[int32]*Display {
	if m != nil {
		return m.Display
	}
	return nil
}

type EventNtf struct {
	Id       int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts       int32    `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Args     []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	SourceId int32    `protobuf:"varint,4,opt,name=sourceId,proto3" json:"sourceId,omitempty"`
}

func (m *EventNtf) Reset()                    { *m = EventNtf{} }
func (m *EventNtf) String() string            { return proto.CompactTextString(m) }
func (*EventNtf) ProtoMessage()               {}
func (*EventNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{23} }

func (m *EventNtf) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventNtf) GetTs() int32 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *EventNtf) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *EventNtf) GetSourceId() int32 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

type DailyConditionNtf struct {
	DailyConditions map[int32]int32 `protobuf:"bytes,1,rep,name=dailyConditions" json:"dailyConditions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *DailyConditionNtf) Reset()                    { *m = DailyConditionNtf{} }
func (m *DailyConditionNtf) String() string            { return proto.CompactTextString(m) }
func (*DailyConditionNtf) ProtoMessage()               {}
func (*DailyConditionNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{24} }

func (m *DailyConditionNtf) GetDailyConditions() map[int32]int32 {
	if m != nil {
		return m.DailyConditions
	}
	return nil
}

type PropInfo struct {
	Key   int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PropInfo) Reset()                    { *m = PropInfo{} }
func (m *PropInfo) String() string            { return proto.CompactTextString(m) }
func (*PropInfo) ProtoMessage()               {}
func (*PropInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{25} }

func (m *PropInfo) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *PropInfo) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type EquipGrid struct {
	Pos      int32 `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	Strength int32 `protobuf:"varint,2,opt,name=strength,proto3" json:"strength,omitempty"`
}

func (m *EquipGrid) Reset()                    { *m = EquipGrid{} }
func (m *EquipGrid) String() string            { return proto.CompactTextString(m) }
func (*EquipGrid) ProtoMessage()               {}
func (*EquipGrid) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{26} }

func (m *EquipGrid) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *EquipGrid) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

type Fabao struct {
	Id     int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level  int32   `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Exp    int32   `protobuf:"varint,3,opt,name=exp,proto3" json:"exp,omitempty"`
	Skills []int32 `protobuf:"varint,4,rep,packed,name=skills" json:"skills,omitempty"`
}

func (m *Fabao) Reset()                    { *m = Fabao{} }
func (m *Fabao) String() string            { return proto.CompactTextString(m) }
func (*Fabao) ProtoMessage()               {}
func (*Fabao) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{27} }

func (m *Fabao) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Fabao) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Fabao) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *Fabao) GetSkills() []int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

type GodEquip struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *GodEquip) Reset()                    { *m = GodEquip{} }
func (m *GodEquip) String() string            { return proto.CompactTextString(m) }
func (*GodEquip) ProtoMessage()               {}
func (*GodEquip) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{28} }

func (m *GodEquip) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GodEquip) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Juexue struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *Juexue) Reset()                    { *m = Juexue{} }
func (m *Juexue) String() string            { return proto.CompactTextString(m) }
func (*Juexue) ProtoMessage()               {}
func (*Juexue) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{29} }

func (m *Juexue) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Juexue) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Fashion struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *Fashion) Reset()                    { *m = Fashion{} }
func (m *Fashion) String() string            { return proto.CompactTextString(m) }
func (*Fashion) ProtoMessage()               {}
func (*Fashion) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{30} }

func (m *Fashion) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Fashion) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Wing struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Exp int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *Wing) Reset()                    { *m = Wing{} }
func (m *Wing) String() string            { return proto.CompactTextString(m) }
func (*Wing) ProtoMessage()               {}
func (*Wing) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{31} }

func (m *Wing) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Wing) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type WingSpecialNtf struct {
	Order int32 `protobuf:"varint,1,opt,name=order,proto3" json:"order,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *WingSpecialNtf) Reset()                    { *m = WingSpecialNtf{} }
func (m *WingSpecialNtf) String() string            { return proto.CompactTextString(m) }
func (*WingSpecialNtf) ProtoMessage()               {}
func (*WingSpecialNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{32} }

func (m *WingSpecialNtf) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *WingSpecialNtf) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Rein struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Exp int64 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *Rein) Reset()                    { *m = Rein{} }
func (m *Rein) String() string            { return proto.CompactTextString(m) }
func (*Rein) ProtoMessage()               {}
func (*Rein) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{33} }

func (m *Rein) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Rein) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type ReinCost struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num int32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *ReinCost) Reset()                    { *m = ReinCost{} }
func (m *ReinCost) String() string            { return proto.CompactTextString(m) }
func (*ReinCost) ProtoMessage()               {}
func (*ReinCost) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{34} }

func (m *ReinCost) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReinCost) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type Atlas struct {
	Id       int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Star     int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
	IsActive bool  `protobuf:"varint,3,opt,name=isActive,proto3" json:"isActive,omitempty"`
}

func (m *Atlas) Reset()                    { *m = Atlas{} }
func (m *Atlas) String() string            { return proto.CompactTextString(m) }
func (*Atlas) ProtoMessage()               {}
func (*Atlas) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{35} }

func (m *Atlas) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Atlas) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *Atlas) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type AtlasGather struct {
	Id       int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Star     int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
	IsActive bool  `protobuf:"varint,3,opt,name=isActive,proto3" json:"isActive,omitempty"`
}

func (m *AtlasGather) Reset()                    { *m = AtlasGather{} }
func (m *AtlasGather) String() string            { return proto.CompactTextString(m) }
func (*AtlasGather) ProtoMessage()               {}
func (*AtlasGather) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{36} }

func (m *AtlasGather) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AtlasGather) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *AtlasGather) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type Preference struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Preference) Reset()                    { *m = Preference{} }
func (m *Preference) String() string            { return proto.CompactTextString(m) }
func (*Preference) ProtoMessage()               {}
func (*Preference) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{37} }

func (m *Preference) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Preference) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type WorldBossInfoNtf struct {
	Id          int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PrepareTime int32 `protobuf:"varint,2,opt,name=prepareTime,proto3" json:"prepareTime,omitempty"`
	OpenTime    int32 `protobuf:"varint,3,opt,name=openTime,proto3" json:"openTime,omitempty"`
	CloseTime   int32 `protobuf:"varint,4,opt,name=closeTime,proto3" json:"closeTime,omitempty"`
}

func (m *WorldBossInfoNtf) Reset()                    { *m = WorldBossInfoNtf{} }
func (m *WorldBossInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldBossInfoNtf) ProtoMessage()               {}
func (*WorldBossInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{38} }

func (m *WorldBossInfoNtf) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WorldBossInfoNtf) GetPrepareTime() int32 {
	if m != nil {
		return m.PrepareTime
	}
	return 0
}

func (m *WorldBossInfoNtf) GetOpenTime() int32 {
	if m != nil {
		return m.OpenTime
	}
	return 0
}

func (m *WorldBossInfoNtf) GetCloseTime() int32 {
	if m != nil {
		return m.CloseTime
	}
	return 0
}

type VipBoss struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	DareNum int32 `protobuf:"varint,2,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
}

func (m *VipBoss) Reset()                    { *m = VipBoss{} }
func (m *VipBoss) String() string            { return proto.CompactTextString(m) }
func (*VipBoss) ProtoMessage()               {}
func (*VipBoss) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{39} }

func (m *VipBoss) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *VipBoss) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

type ExpStage struct {
	DareNum   int32           `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum    int32           `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	ExpStages map[int32]int64 `protobuf:"bytes,3,rep,name=expStages" json:"expStages,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ExpStage) Reset()                    { *m = ExpStage{} }
func (m *ExpStage) String() string            { return proto.CompactTextString(m) }
func (*ExpStage) ProtoMessage()               {}
func (*ExpStage) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{40} }

func (m *ExpStage) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *ExpStage) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *ExpStage) GetExpStages() map[int32]int64 {
	if m != nil {
		return m.ExpStages
	}
	return nil
}

type Display struct {
	ClothItemId     int32 `protobuf:"varint,1,opt,name=clothItemId,proto3" json:"clothItemId,omitempty"`
	ClothType       int32 `protobuf:"varint,2,opt,name=clothType,proto3" json:"clothType,omitempty"`
	WeaponItemId    int32 `protobuf:"varint,3,opt,name=weaponItemId,proto3" json:"weaponItemId,omitempty"`
	WeaponType      int32 `protobuf:"varint,4,opt,name=weaponType,proto3" json:"weaponType,omitempty"`
	WingId          int32 `protobuf:"varint,5,opt,name=wingId,proto3" json:"wingId,omitempty"`
	MagicCircleLvId int32 `protobuf:"varint,6,opt,name=magicCircleLvId,proto3" json:"magicCircleLvId,omitempty"`
}

func (m *Display) Reset()                    { *m = Display{} }
func (m *Display) String() string            { return proto.CompactTextString(m) }
func (*Display) ProtoMessage()               {}
func (*Display) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{41} }

func (m *Display) GetClothItemId() int32 {
	if m != nil {
		return m.ClothItemId
	}
	return 0
}

func (m *Display) GetClothType() int32 {
	if m != nil {
		return m.ClothType
	}
	return 0
}

func (m *Display) GetWeaponItemId() int32 {
	if m != nil {
		return m.WeaponItemId
	}
	return 0
}

func (m *Display) GetWeaponType() int32 {
	if m != nil {
		return m.WeaponType
	}
	return 0
}

func (m *Display) GetWingId() int32 {
	if m != nil {
		return m.WingId
	}
	return 0
}

func (m *Display) GetMagicCircleLvId() int32 {
	if m != nil {
		return m.MagicCircleLvId
	}
	return 0
}

type SpecialEquipUnit struct {
	ItemId    int32      `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	GetSource *GetSource `protobuf:"bytes,2,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *SpecialEquipUnit) Reset()                    { *m = SpecialEquipUnit{} }
func (m *SpecialEquipUnit) String() string            { return proto.CompactTextString(m) }
func (*SpecialEquipUnit) ProtoMessage()               {}
func (*SpecialEquipUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{42} }

func (m *SpecialEquipUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *SpecialEquipUnit) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type GetSource struct {
	Map       string `protobuf:"bytes,1,opt,name=map,proto3" json:"map,omitempty"`
	Monster   string `protobuf:"bytes,2,opt,name=monster,proto3" json:"monster,omitempty"`
	SkillUser string `protobuf:"bytes,3,opt,name=skillUser,proto3" json:"skillUser,omitempty"`
	SkillDate string `protobuf:"bytes,4,opt,name=skillDate,proto3" json:"skillDate,omitempty"`
}

func (m *GetSource) Reset()                    { *m = GetSource{} }
func (m *GetSource) String() string            { return proto.CompactTextString(m) }
func (*GetSource) ProtoMessage()               {}
func (*GetSource) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{43} }

func (m *GetSource) GetMap() string {
	if m != nil {
		return m.Map
	}
	return ""
}

func (m *GetSource) GetMonster() string {
	if m != nil {
		return m.Monster
	}
	return ""
}

func (m *GetSource) GetSkillUser() string {
	if m != nil {
		return m.SkillUser
	}
	return ""
}

func (m *GetSource) GetSkillDate() string {
	if m != nil {
		return m.SkillDate
	}
	return ""
}

type RankInfo struct {
	Rank     int32          `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	Score    int64          `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	UserInfo *BriefUserInfo `protobuf:"bytes,3,opt,name=userInfo" json:"userInfo,omitempty"`
	Display  *Display       `protobuf:"bytes,4,opt,name=display" json:"display,omitempty"`
}

func (m *RankInfo) Reset()                    { *m = RankInfo{} }
func (m *RankInfo) String() string            { return proto.CompactTextString(m) }
func (*RankInfo) ProtoMessage()               {}
func (*RankInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{44} }

func (m *RankInfo) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *RankInfo) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RankInfo) GetUserInfo() *BriefUserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *RankInfo) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

type SkillUnit struct {
	SkillId   int32 `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	Level     int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	StartTime int64 `protobuf:"varint,3,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *SkillUnit) Reset()                    { *m = SkillUnit{} }
func (m *SkillUnit) String() string            { return proto.CompactTextString(m) }
func (*SkillUnit) ProtoMessage()               {}
func (*SkillUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{45} }

func (m *SkillUnit) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *SkillUnit) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SkillUnit) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *SkillUnit) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type ShopInfo struct {
	ShopItem map[int32]int32 `protobuf:"bytes,1,rep,name=shopItem" json:"shopItem,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ShopInfo) Reset()                    { *m = ShopInfo{} }
func (m *ShopInfo) String() string            { return proto.CompactTextString(m) }
func (*ShopInfo) ProtoMessage()               {}
func (*ShopInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{46} }

func (m *ShopInfo) GetShopItem() map[int32]int32 {
	if m != nil {
		return m.ShopItem
	}
	return nil
}

type DictateInfo struct {
	Type  int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *DictateInfo) Reset()                    { *m = DictateInfo{} }
func (m *DictateInfo) String() string            { return proto.CompactTextString(m) }
func (*DictateInfo) ProtoMessage()               {}
func (*DictateInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{47} }

func (m *DictateInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DictateInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type PanaceaInfo struct {
	Numbers int32 `protobuf:"varint,1,opt,name=numbers,proto3" json:"numbers,omitempty"`
	Number  int32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *PanaceaInfo) Reset()                    { *m = PanaceaInfo{} }
func (m *PanaceaInfo) String() string            { return proto.CompactTextString(m) }
func (*PanaceaInfo) ProtoMessage()               {}
func (*PanaceaInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{48} }

func (m *PanaceaInfo) GetNumbers() int32 {
	if m != nil {
		return m.Numbers
	}
	return 0
}

func (m *PanaceaInfo) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

type JewelInfo struct {
	Left  int32 `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Right int32 `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
	Down  int32 `protobuf:"varint,3,opt,name=down,proto3" json:"down,omitempty"`
}

func (m *JewelInfo) Reset()                    { *m = JewelInfo{} }
func (m *JewelInfo) String() string            { return proto.CompactTextString(m) }
func (*JewelInfo) ProtoMessage()               {}
func (*JewelInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{49} }

func (m *JewelInfo) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *JewelInfo) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *JewelInfo) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 通用每日状态
type DayStateInfo struct {
	RankWorship      int32   `protobuf:"varint,1,opt,name=rankWorship,proto3" json:"rankWorship,omitempty"`
	MonthCardReceive []int32 `protobuf:"varint,2,rep,packed,name=monthCardReceive" json:"monthCardReceive,omitempty"`
}

func (m *DayStateInfo) Reset()                    { *m = DayStateInfo{} }
func (m *DayStateInfo) String() string            { return proto.CompactTextString(m) }
func (*DayStateInfo) ProtoMessage()               {}
func (*DayStateInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{50} }

func (m *DayStateInfo) GetRankWorship() int32 {
	if m != nil {
		return m.RankWorship
	}
	return 0
}

func (m *DayStateInfo) GetMonthCardReceive() []int32 {
	if m != nil {
		return m.MonthCardReceive
	}
	return nil
}

type SignInfo struct {
	SignCount     int32           `protobuf:"varint,1,opt,name=signCount,proto3" json:"signCount,omitempty"`
	SignDay       map[int32]int32 `protobuf:"bytes,2,rep,name=signDay" json:"signDay,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CumulativeDay map[int32]int32 `protobuf:"bytes,3,rep,name=cumulativeDay" json:"cumulativeDay,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *SignInfo) Reset()                    { *m = SignInfo{} }
func (m *SignInfo) String() string            { return proto.CompactTextString(m) }
func (*SignInfo) ProtoMessage()               {}
func (*SignInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{51} }

func (m *SignInfo) GetSignCount() int32 {
	if m != nil {
		return m.SignCount
	}
	return 0
}

func (m *SignInfo) GetSignDay() map[int32]int32 {
	if m != nil {
		return m.SignDay
	}
	return nil
}

func (m *SignInfo) GetCumulativeDay() map[int32]int32 {
	if m != nil {
		return m.CumulativeDay
	}
	return nil
}

type InsideInfo struct {
	Acupoint    map[int32]int32        `protobuf:"bytes,1,rep,name=acupoint" json:"acupoint,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	InsideSkill map[int32]*InsideSkill `protobuf:"bytes,2,rep,name=insideSkill" json:"insideSkill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InsideInfo) Reset()                    { *m = InsideInfo{} }
func (m *InsideInfo) String() string            { return proto.CompactTextString(m) }
func (*InsideInfo) ProtoMessage()               {}
func (*InsideInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{52} }

func (m *InsideInfo) GetAcupoint() map[int32]int32 {
	if m != nil {
		return m.Acupoint
	}
	return nil
}

func (m *InsideInfo) GetInsideSkill() map[int32]*InsideSkill {
	if m != nil {
		return m.InsideSkill
	}
	return nil
}

type InsideSkill struct {
	Level int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Exp   int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *InsideSkill) Reset()                    { *m = InsideSkill{} }
func (m *InsideSkill) String() string            { return proto.CompactTextString(m) }
func (*InsideSkill) ProtoMessage()               {}
func (*InsideSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{53} }

func (m *InsideSkill) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *InsideSkill) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type Holy struct {
	Id     int32           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level  int32           `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Exp    int32           `protobuf:"varint,3,opt,name=exp,proto3" json:"exp,omitempty"`
	Skills map[int32]int32 `protobuf:"bytes,4,rep,name=skills" json:"skills,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Holy) Reset()                    { *m = Holy{} }
func (m *Holy) String() string            { return proto.CompactTextString(m) }
func (*Holy) ProtoMessage()               {}
func (*Holy) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{54} }

func (m *Holy) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Holy) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Holy) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *Holy) GetSkills() map[int32]int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

type Ring struct {
	Rid        int32                  `protobuf:"varint,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Strengthen int32                  `protobuf:"varint,2,opt,name=strengthen,proto3" json:"strengthen,omitempty"`
	Pid        int32                  `protobuf:"varint,3,opt,name=pid,proto3" json:"pid,omitempty"`
	Talent     int32                  `protobuf:"varint,4,opt,name=talent,proto3" json:"talent,omitempty"`
	Phantom    map[int32]*RingPhantom `protobuf:"bytes,5,rep,name=phantom" json:"phantom,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Ring) Reset()                    { *m = Ring{} }
func (m *Ring) String() string            { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()               {}
func (*Ring) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{55} }

func (m *Ring) GetRid() int32 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *Ring) GetStrengthen() int32 {
	if m != nil {
		return m.Strengthen
	}
	return 0
}

func (m *Ring) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Ring) GetTalent() int32 {
	if m != nil {
		return m.Talent
	}
	return 0
}

func (m *Ring) GetPhantom() map[int32]*RingPhantom {
	if m != nil {
		return m.Phantom
	}
	return nil
}

type RingPhantom struct {
	Talent  int32           `protobuf:"varint,1,opt,name=talent,proto3" json:"talent,omitempty"`
	Phantom int32           `protobuf:"varint,2,opt,name=phantom,proto3" json:"phantom,omitempty"`
	Skill   map[int32]int32 `protobuf:"bytes,3,rep,name=skill" json:"skill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *RingPhantom) Reset()                    { *m = RingPhantom{} }
func (m *RingPhantom) String() string            { return proto.CompactTextString(m) }
func (*RingPhantom) ProtoMessage()               {}
func (*RingPhantom) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{56} }

func (m *RingPhantom) GetTalent() int32 {
	if m != nil {
		return m.Talent
	}
	return 0
}

func (m *RingPhantom) GetPhantom() int32 {
	if m != nil {
		return m.Phantom
	}
	return 0
}

func (m *RingPhantom) GetSkill() map[int32]int32 {
	if m != nil {
		return m.Skill
	}
	return nil
}

type PetInfo struct {
	Lv    int32   `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp   int32   `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Grade int32   `protobuf:"varint,3,opt,name=grade,proto3" json:"grade,omitempty"`
	Break int32   `protobuf:"varint,4,opt,name=break,proto3" json:"break,omitempty"`
	Skill []int32 `protobuf:"varint,5,rep,packed,name=skill" json:"skill,omitempty"`
}

func (m *PetInfo) Reset()                    { *m = PetInfo{} }
func (m *PetInfo) String() string            { return proto.CompactTextString(m) }
func (*PetInfo) ProtoMessage()               {}
func (*PetInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{57} }

func (m *PetInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PetInfo) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *PetInfo) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *PetInfo) GetBreak() int32 {
	if m != nil {
		return m.Break
	}
	return 0
}

func (m *PetInfo) GetSkill() []int32 {
	if m != nil {
		return m.Skill
	}
	return nil
}

type ResetNtf struct {
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ResetNtf) Reset()                    { *m = ResetNtf{} }
func (m *ResetNtf) String() string            { return proto.CompactTextString(m) }
func (*ResetNtf) ProtoMessage()               {}
func (*ResetNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{58} }

func (m *ResetNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type FieldFightRivalUserInfo struct {
	RivalUserId    int32 `protobuf:"varint,1,opt,name=rivalUserId,proto3" json:"rivalUserId,omitempty"`
	RivalDifficult int32 `protobuf:"varint,2,opt,name=rivalDifficult,proto3" json:"rivalDifficult,omitempty"`
}

func (m *FieldFightRivalUserInfo) Reset()                    { *m = FieldFightRivalUserInfo{} }
func (m *FieldFightRivalUserInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldFightRivalUserInfo) ProtoMessage()               {}
func (*FieldFightRivalUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{59} }

func (m *FieldFightRivalUserInfo) GetRivalUserId() int32 {
	if m != nil {
		return m.RivalUserId
	}
	return 0
}

func (m *FieldFightRivalUserInfo) GetRivalDifficult() int32 {
	if m != nil {
		return m.RivalDifficult
	}
	return 0
}

type DarkPalaceInfo struct {
	DareNum int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum  int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	HelpNum int32 `protobuf:"varint,3,opt,name=helpNum,proto3" json:"helpNum,omitempty"`
}

func (m *DarkPalaceInfo) Reset()                    { *m = DarkPalaceInfo{} }
func (m *DarkPalaceInfo) String() string            { return proto.CompactTextString(m) }
func (*DarkPalaceInfo) ProtoMessage()               {}
func (*DarkPalaceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{60} }

func (m *DarkPalaceInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *DarkPalaceInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *DarkPalaceInfo) GetHelpNum() int32 {
	if m != nil {
		return m.HelpNum
	}
	return 0
}

type FieldBossInfo struct {
	DareNum int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum  int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
}

func (m *FieldBossInfo) Reset()                    { *m = FieldBossInfo{} }
func (m *FieldBossInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldBossInfo) ProtoMessage()               {}
func (*FieldBossInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{61} }

func (m *FieldBossInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *FieldBossInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

type TalentInfo struct {
	GetPoints     int32                 `protobuf:"varint,1,opt,name=getPoints,proto3" json:"getPoints,omitempty"`
	SurplusPoints int32                 `protobuf:"varint,2,opt,name=surplusPoints,proto3" json:"surplusPoints,omitempty"`
	Talents       map[int32]*TalentUnit `protobuf:"bytes,3,rep,name=talents" json:"talents,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TalentInfo) Reset()                    { *m = TalentInfo{} }
func (m *TalentInfo) String() string            { return proto.CompactTextString(m) }
func (*TalentInfo) ProtoMessage()               {}
func (*TalentInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{62} }

func (m *TalentInfo) GetGetPoints() int32 {
	if m != nil {
		return m.GetPoints
	}
	return 0
}

func (m *TalentInfo) GetSurplusPoints() int32 {
	if m != nil {
		return m.SurplusPoints
	}
	return 0
}

func (m *TalentInfo) GetTalents() map[int32]*TalentUnit {
	if m != nil {
		return m.Talents
	}
	return nil
}

type TalentUnit struct {
	UsePoints int32           `protobuf:"varint,1,opt,name=usePoints,proto3" json:"usePoints,omitempty"`
	Talents   map[int32]int32 `protobuf:"bytes,2,rep,name=talents" json:"talents,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TalentUnit) Reset()                    { *m = TalentUnit{} }
func (m *TalentUnit) String() string            { return proto.CompactTextString(m) }
func (*TalentUnit) ProtoMessage()               {}
func (*TalentUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{63} }

func (m *TalentUnit) GetUsePoints() int32 {
	if m != nil {
		return m.UsePoints
	}
	return 0
}

func (m *TalentUnit) GetTalents() map[int32]int32 {
	if m != nil {
		return m.Talents
	}
	return nil
}

type Fit struct {
	CdStart  int64               `protobuf:"varint,1,opt,name=cdStart,proto3" json:"cdStart,omitempty"`
	CdEnd    int64               `protobuf:"varint,2,opt,name=cdEnd,proto3" json:"cdEnd,omitempty"`
	Fashion  map[int32]int32     `protobuf:"bytes,3,rep,name=fashion" json:"fashion,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SkillBag map[int32]int32     `protobuf:"bytes,4,rep,name=skillBag" json:"skillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Lv       map[int32]int32     `protobuf:"bytes,5,rep,name=lv" json:"lv,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Skills   map[int32]*FitSkill `protobuf:"bytes,6,rep,name=skills" json:"skills,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Fit) Reset()                    { *m = Fit{} }
func (m *Fit) String() string            { return proto.CompactTextString(m) }
func (*Fit) ProtoMessage()               {}
func (*Fit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{64} }

func (m *Fit) GetCdStart() int64 {
	if m != nil {
		return m.CdStart
	}
	return 0
}

func (m *Fit) GetCdEnd() int64 {
	if m != nil {
		return m.CdEnd
	}
	return 0
}

func (m *Fit) GetFashion() map[int32]int32 {
	if m != nil {
		return m.Fashion
	}
	return nil
}

func (m *Fit) GetSkillBag() map[int32]int32 {
	if m != nil {
		return m.SkillBag
	}
	return nil
}

func (m *Fit) GetLv() map[int32]int32 {
	if m != nil {
		return m.Lv
	}
	return nil
}

func (m *Fit) GetSkills() map[int32]*FitSkill {
	if m != nil {
		return m.Skills
	}
	return nil
}

type FitSkill struct {
	Lv   int32 `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Star int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
}

func (m *FitSkill) Reset()                    { *m = FitSkill{} }
func (m *FitSkill) String() string            { return proto.CompactTextString(m) }
func (*FitSkill) ProtoMessage()               {}
func (*FitSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{65} }

func (m *FitSkill) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *FitSkill) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

type MonthCardUnit struct {
	StartTime int64 `protobuf:"varint,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *MonthCardUnit) Reset()                    { *m = MonthCardUnit{} }
func (m *MonthCardUnit) String() string            { return proto.CompactTextString(m) }
func (*MonthCardUnit) ProtoMessage()               {}
func (*MonthCardUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{66} }

func (m *MonthCardUnit) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MonthCardUnit) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type FirstRecharge struct {
	IsRecharge bool    `protobuf:"varint,1,opt,name=isRecharge,proto3" json:"isRecharge,omitempty"`
	Days       []int32 `protobuf:"varint,2,rep,packed,name=days" json:"days,omitempty"`
}

func (m *FirstRecharge) Reset()                    { *m = FirstRecharge{} }
func (m *FirstRecharge) String() string            { return proto.CompactTextString(m) }
func (*FirstRecharge) ProtoMessage()               {}
func (*FirstRecharge) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{67} }

func (m *FirstRecharge) GetIsRecharge() bool {
	if m != nil {
		return m.IsRecharge
	}
	return false
}

func (m *FirstRecharge) GetDays() []int32 {
	if m != nil {
		return m.Days
	}
	return nil
}

type SpendRebates struct {
	CountIngot int32   `protobuf:"varint,1,opt,name=countIngot,proto3" json:"countIngot,omitempty"`
	Ingot      int32   `protobuf:"varint,2,opt,name=ingot,proto3" json:"ingot,omitempty"`
	Reward     []int32 `protobuf:"varint,3,rep,packed,name=reward" json:"reward,omitempty"`
}

func (m *SpendRebates) Reset()                    { *m = SpendRebates{} }
func (m *SpendRebates) String() string            { return proto.CompactTextString(m) }
func (*SpendRebates) ProtoMessage()               {}
func (*SpendRebates) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{68} }

func (m *SpendRebates) GetCountIngot() int32 {
	if m != nil {
		return m.CountIngot
	}
	return 0
}

func (m *SpendRebates) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *SpendRebates) GetReward() []int32 {
	if m != nil {
		return m.Reward
	}
	return nil
}

func init() {
	proto.RegisterType((*ErrorAck)(nil), "pb.ErrorAck")
	proto.RegisterType((*UserLoginInfo)(nil), "pb.UserLoginInfo")
	proto.RegisterType((*HeroInfo)(nil), "pb.HeroInfo")
	proto.RegisterType((*UserWear)(nil), "pb.UserWear")
	proto.RegisterType((*Wears)(nil), "pb.Wears")
	proto.RegisterType((*BriefUserInfo)(nil), "pb.BriefUserInfo")
	proto.RegisterType((*BriefUserInfoWithDisplay)(nil), "pb.BriefUserInfoWithDisplay")
	proto.RegisterType((*TopDataChangeNtf)(nil), "pb.TopDataChangeNtf")
	proto.RegisterType((*TopDataChange)(nil), "pb.TopDataChange")
	proto.RegisterType((*BagDataChangeNtf)(nil), "pb.BagDataChangeNtf")
	proto.RegisterType((*ItemChange)(nil), "pb.ItemChange")
	proto.RegisterType((*BagEquipDataChangeNtf)(nil), "pb.BagEquipDataChangeNtf")
	proto.RegisterType((*EquipChange)(nil), "pb.EquipChange")
	proto.RegisterType((*Item)(nil), "pb.Item")
	proto.RegisterType((*GoodsChangeNtf)(nil), "pb.GoodsChangeNtf")
	proto.RegisterType((*ItemUnit)(nil), "pb.itemUnit")
	proto.RegisterType((*EquipUnit)(nil), "pb.EquipUnit")
	proto.RegisterType((*EquipRandProp)(nil), "pb.EquipRandProp")
	proto.RegisterType((*EquipClearArr)(nil), "pb.EquipClearArr")
	proto.RegisterType((*EquipClearInfo)(nil), "pb.EquipClearInfo")
	proto.RegisterType((*HeroProp)(nil), "pb.HeroProp")
	proto.RegisterType((*TaskInfoNtf)(nil), "pb.TaskInfoNtf")
	proto.RegisterType((*DisplayNtf)(nil), "pb.DisplayNtf")
	proto.RegisterType((*EventNtf)(nil), "pb.EventNtf")
	proto.RegisterType((*DailyConditionNtf)(nil), "pb.DailyConditionNtf")
	proto.RegisterType((*PropInfo)(nil), "pb.PropInfo")
	proto.RegisterType((*EquipGrid)(nil), "pb.EquipGrid")
	proto.RegisterType((*Fabao)(nil), "pb.Fabao")
	proto.RegisterType((*GodEquip)(nil), "pb.GodEquip")
	proto.RegisterType((*Juexue)(nil), "pb.Juexue")
	proto.RegisterType((*Fashion)(nil), "pb.Fashion")
	proto.RegisterType((*Wing)(nil), "pb.Wing")
	proto.RegisterType((*WingSpecialNtf)(nil), "pb.WingSpecialNtf")
	proto.RegisterType((*Rein)(nil), "pb.Rein")
	proto.RegisterType((*ReinCost)(nil), "pb.ReinCost")
	proto.RegisterType((*Atlas)(nil), "pb.Atlas")
	proto.RegisterType((*AtlasGather)(nil), "pb.AtlasGather")
	proto.RegisterType((*Preference)(nil), "pb.Preference")
	proto.RegisterType((*WorldBossInfoNtf)(nil), "pb.WorldBossInfoNtf")
	proto.RegisterType((*VipBoss)(nil), "pb.VipBoss")
	proto.RegisterType((*ExpStage)(nil), "pb.ExpStage")
	proto.RegisterType((*Display)(nil), "pb.Display")
	proto.RegisterType((*SpecialEquipUnit)(nil), "pb.SpecialEquipUnit")
	proto.RegisterType((*GetSource)(nil), "pb.GetSource")
	proto.RegisterType((*RankInfo)(nil), "pb.RankInfo")
	proto.RegisterType((*SkillUnit)(nil), "pb.SkillUnit")
	proto.RegisterType((*ShopInfo)(nil), "pb.ShopInfo")
	proto.RegisterType((*DictateInfo)(nil), "pb.DictateInfo")
	proto.RegisterType((*PanaceaInfo)(nil), "pb.PanaceaInfo")
	proto.RegisterType((*JewelInfo)(nil), "pb.JewelInfo")
	proto.RegisterType((*DayStateInfo)(nil), "pb.DayStateInfo")
	proto.RegisterType((*SignInfo)(nil), "pb.SignInfo")
	proto.RegisterType((*InsideInfo)(nil), "pb.InsideInfo")
	proto.RegisterType((*InsideSkill)(nil), "pb.InsideSkill")
	proto.RegisterType((*Holy)(nil), "pb.Holy")
	proto.RegisterType((*Ring)(nil), "pb.Ring")
	proto.RegisterType((*RingPhantom)(nil), "pb.RingPhantom")
	proto.RegisterType((*PetInfo)(nil), "pb.PetInfo")
	proto.RegisterType((*ResetNtf)(nil), "pb.ResetNtf")
	proto.RegisterType((*FieldFightRivalUserInfo)(nil), "pb.FieldFightRivalUserInfo")
	proto.RegisterType((*DarkPalaceInfo)(nil), "pb.DarkPalaceInfo")
	proto.RegisterType((*FieldBossInfo)(nil), "pb.FieldBossInfo")
	proto.RegisterType((*TalentInfo)(nil), "pb.TalentInfo")
	proto.RegisterType((*TalentUnit)(nil), "pb.TalentUnit")
	proto.RegisterType((*Fit)(nil), "pb.Fit")
	proto.RegisterType((*FitSkill)(nil), "pb.FitSkill")
	proto.RegisterType((*MonthCardUnit)(nil), "pb.MonthCardUnit")
	proto.RegisterType((*FirstRecharge)(nil), "pb.FirstRecharge")
	proto.RegisterType((*SpendRebates)(nil), "pb.SpendRebates")
}
func (m *ErrorAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *UserLoginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLoginInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Userid))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.VipLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VipLevel))
	}
	if m.VipScore != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VipScore))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Gold))
	}
	if m.Ingot != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ingot))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageId))
	}
	if m.StageWave != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageWave))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	if len(m.Heros) > 0 {
		for _, msg := range m.Heros {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rein != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rein.Size()))
		n1, err := m.Rein.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ReinCost) > 0 {
		for _, msg := range m.ReinCost {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Fabao) > 0 {
		for _, msg := range m.Fabao {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FieldBossInfo != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FieldBossInfo.Size()))
		n2, err := m.FieldBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.WorldBossInfo != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WorldBossInfo.Size()))
		n3, err := m.WorldBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ArenaFightNum != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ArenaFightNum))
	}
	if m.FightModel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FightModel))
	}
	if m.Task != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Task.Size()))
		n4, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.ShopInfo) > 0 {
		for k, _ := range m.ShopInfo {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.ShopInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.ChuanqiBi != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChuanqiBi))
	}
	if len(m.MaterialStage) > 0 {
		for k, _ := range m.MaterialStage {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.MaterialStage[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Panaceas) > 0 {
		for k, _ := range m.Panaceas {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.Panaceas[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.SignInfo != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SignInfo.Size()))
		n7, err := m.SignInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DayStateInfo != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DayStateInfo.Size()))
		n8, err := m.DayStateInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Official != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Official))
	}
	if len(m.Holy) > 0 {
		for _, msg := range m.Holy {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Atlases) > 0 {
		for _, msg := range m.Atlases {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AtlasGathers) > 0 {
		for _, msg := range m.AtlasGathers {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MiningWorkTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MiningWorkTime))
	}
	if m.Miner != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Miner))
	}
	if m.ExpStage != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpStage.Size()))
		n9, err := m.ExpStage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Pets) > 0 {
		for k, _ := range m.Pets {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.Pets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	if len(m.Juexues) > 0 {
		for _, msg := range m.Juexues {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UserWear != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserWear.Size()))
		n11, err := m.UserWear.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.IsHaveGetDailyCompetitveReward != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsHaveGetDailyCompetitveReward))
	}
	if m.Honour != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Honour))
	}
	if m.DarkPalaceInfo != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DarkPalaceInfo.Size()))
		n12, err := m.DarkPalaceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.PersonBoss) > 0 {
		for k, _ := range m.PersonBoss {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			v := m.PersonBoss[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.VipBoss) > 0 {
		for k, _ := range m.VipBoss {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x2
			i++
			v := m.VipBoss[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.VipGift) > 0 {
		dAtA14 := make([]byte, len(m.VipGift)*10)
		var j13 int
		for _, num1 := range m.VipGift {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.Fit != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Fit.Size()))
		n15, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.RechargeAll != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RechargeAll))
	}
	if len(m.AccumulativeAllGetIds) > 0 {
		dAtA17 := make([]byte, len(m.AccumulativeAllGetIds)*10)
		var j16 int
		for _, num1 := range m.AccumulativeAllGetIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.MonthCard) > 0 {
		for k, _ := range m.MonthCard {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x3
			i++
			v := m.MonthCard[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	if m.FirstRecharge != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FirstRecharge.Size()))
		n19, err := m.FirstRecharge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.SpendRebates != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SpendRebates.Size()))
		n20, err := m.SpendRebates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.DailyPack) > 0 {
		for k, _ := range m.DailyPack {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3
			i++
			v := m.DailyPack[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *HeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Index))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if len(m.Equips) > 0 {
		for k, _ := range m.Equips {
			dAtA[i] = 0x22
			i++
			v := m.Equips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n21, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	if len(m.EquipGrids) > 0 {
		for _, msg := range m.EquipGrids {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HeroProp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HeroProp.Size()))
		n22, err := m.HeroProp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Wing) > 0 {
		for _, msg := range m.Wing {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Zodiacs) > 0 {
		for k, _ := range m.Zodiacs {
			dAtA[i] = 0x42
			i++
			v := m.Zodiacs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	if len(m.Kingarms) > 0 {
		for k, _ := range m.Kingarms {
			dAtA[i] = 0x4a
			i++
			v := m.Kingarms[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n24, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n24
			}
		}
	}
	if len(m.Dictates) > 0 {
		for _, msg := range m.Dictates {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WingSpecial) > 0 {
		for _, msg := range m.WingSpecial {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Jewels) > 0 {
		for k, _ := range m.Jewels {
			dAtA[i] = 0x62
			i++
			v := m.Jewels[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n25, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n25
			}
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.InsideInfo != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.InsideInfo.Size()))
		n26, err := m.InsideInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Fashions) > 0 {
		for k, _ := range m.Fashions {
			dAtA[i] = 0x7a
			i++
			v := m.Fashions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n27, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n27
			}
		}
	}
	if m.Wears != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Wears.Size()))
		n28, err := m.Wears.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Rings) > 0 {
		for k, _ := range m.Rings {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Rings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n29, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n29
			}
		}
	}
	if len(m.Skills) > 0 {
		for _, msg := range m.Skills {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SkillBag) > 0 {
		for k, _ := range m.SkillBag {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.SkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.UniqueSkills) > 0 {
		for _, msg := range m.UniqueSkills {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UniqueSkillBag) > 0 {
		for k, _ := range m.UniqueSkillBag {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.UniqueSkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.GodEquips) > 0 {
		for k, _ := range m.GodEquips {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.GodEquips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n30, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n30
			}
		}
	}
	if len(m.Area) > 0 {
		for k, _ := range m.Area {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.Area[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.EquipClears) > 0 {
		for k, _ := range m.EquipClears {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.EquipClears[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n31, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n31
			}
		}
	}
	if m.ExpLvl != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpLvl))
	}
	if len(m.DragonEquip) > 0 {
		for k, _ := range m.DragonEquip {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.DragonEquip[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.MagicCircle) > 0 {
		for k, _ := range m.MagicCircle {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.MagicCircle[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.Talents != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talents.Size()))
		n32, err := m.Talents.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *UserWear) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserWear) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Petid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Petid))
	}
	if m.FitFashionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FitFashionId))
	}
	return i, nil
}

func (m *Wears) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wears) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FashionWeaponId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionWeaponId))
	}
	if m.FashionClothId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionClothId))
	}
	if len(m.AtlasWear) > 0 {
		dAtA34 := make([]byte, len(m.AtlasWear)*10)
		var j33 int
		for _, num1 := range m.AtlasWear {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	if m.WingId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MagicCircleLvId))
	}
	return i, nil
}

func (m *BriefUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BriefUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if m.Lvl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lvl))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Vip))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Job != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	return i, nil
}

func (m *BriefUserInfoWithDisplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BriefUserInfoWithDisplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserInfo.Size()))
		n35, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Display != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Display.Size()))
		n36, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *TopDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *TopDataChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopDataChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Change != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	return i, nil
}

func (m *BagDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ItemChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Change != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	if m.GetSource != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n37, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *BagEquipDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagEquipDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *EquipChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Change != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	if m.Equip != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Equip.Size()))
		n38, err := m.Equip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.GetSource != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n39, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Count))
	}
	if m.Position != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.Equip != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Equip.Size()))
		n40, err := m.Equip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.GetSource != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n41, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *GoodsChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ItemUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *EquipUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if len(m.RandProps) > 0 {
		for _, msg := range m.RandProps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lock {
		dAtA[i] = 0x18
		i++
		if m.Lock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EquipIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EquipIndex))
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lucky))
	}
	return i, nil
}

func (m *EquipRandProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipRandProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PropId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PropId))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Color))
	}
	if m.Value != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *EquipClearArr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipClearArr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EquipClearInfo) > 0 {
		for _, msg := range m.EquipClearInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EquipClearInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipClearInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Grade != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Color))
	}
	if m.PropId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PropId))
	}
	if m.Value != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *HeroProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0xa
			i++
			v := m.Props[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.ModulesCombat) > 0 {
		for k, _ := range m.ModulesCombat {
			dAtA[i] = 0x12
			i++
			v := m.ModulesCombat[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TaskInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TaskId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Process))
	}
	return i, nil
}

func (m *DisplayNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisplayNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Display) > 0 {
		for k, _ := range m.Display {
			dAtA[i] = 0xa
			i++
			v := m.Display[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n42, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n42
			}
		}
	}
	return i, nil
}

func (m *EventNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ts))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SourceId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SourceId))
	}
	return i, nil
}

func (m *DailyConditionNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyConditionNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DailyConditions) > 0 {
		for k, _ := range m.DailyConditions {
			dAtA[i] = 0xa
			i++
			v := m.DailyConditions[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PropInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Key))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *EquipGrid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipGrid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pos))
	}
	if m.Strength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Strength))
	}
	return i, nil
}

func (m *Fabao) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fabao) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		dAtA44 := make([]byte, len(m.Skills)*10)
		var j43 int
		for _, num1 := range m.Skills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			dAtA44[j43] = uint8(num)
			j43++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j43))
		i += copy(dAtA[i:], dAtA44[:j43])
	}
	return i, nil
}

func (m *GodEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GodEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Juexue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Juexue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Fashion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fashion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Wing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WingSpecialNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WingSpecialNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Order != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Order))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Rein) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rein) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *ReinCost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReinCost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *Atlas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Atlas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	if m.IsActive {
		dAtA[i] = 0x18
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AtlasGather) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtlasGather) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	if m.IsActive {
		dAtA[i] = 0x18
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Preference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Preference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Key))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *WorldBossInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldBossInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.PrepareTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrepareTime))
	}
	if m.OpenTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenTime))
	}
	if m.CloseTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CloseTime))
	}
	return i, nil
}

func (m *VipBoss) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipBoss) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageId))
	}
	if m.DareNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	return i, nil
}

func (m *ExpStage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if len(m.ExpStages) > 0 {
		for k, _ := range m.ExpStages {
			dAtA[i] = 0x1a
			i++
			v := m.ExpStages[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Display) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Display) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClothItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MagicCircleLvId))
	}
	return i, nil
}

func (m *SpecialEquipUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialEquipUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.GetSource != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n45, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *GetSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Map)))
		i += copy(dAtA[i:], m.Map)
	}
	if len(m.Monster) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Monster)))
		i += copy(dAtA[i:], m.Monster)
	}
	if len(m.SkillUser) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SkillUser)))
		i += copy(dAtA[i:], m.SkillUser)
	}
	if len(m.SkillDate) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SkillDate)))
		i += copy(dAtA[i:], m.SkillDate)
	}
	return i, nil
}

func (m *RankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rank))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Score))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserInfo.Size()))
		n46, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Display != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Display.Size()))
		n47, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *SkillUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SkillId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *ShopInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShopItem) > 0 {
		for k, _ := range m.ShopItem {
			dAtA[i] = 0xa
			i++
			v := m.ShopItem[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DictateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DictateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *PanaceaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PanaceaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Numbers != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Numbers))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *JewelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JewelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Left))
	}
	if m.Right != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Right))
	}
	if m.Down != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Down))
	}
	return i, nil
}

func (m *DayStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DayStateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RankWorship != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RankWorship))
	}
	if len(m.MonthCardReceive) > 0 {
		dAtA49 := make([]byte, len(m.MonthCardReceive)*10)
		var j48 int
		for _, num1 := range m.MonthCardReceive {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j48))
		i += copy(dAtA[i:], dAtA49[:j48])
	}
	return i, nil
}

func (m *SignInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SignCount))
	}
	if len(m.SignDay) > 0 {
		for k, _ := range m.SignDay {
			dAtA[i] = 0x12
			i++
			v := m.SignDay[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.CumulativeDay) > 0 {
		for k, _ := range m.CumulativeDay {
			dAtA[i] = 0x1a
			i++
			v := m.CumulativeDay[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *InsideInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsideInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Acupoint) > 0 {
		for k, _ := range m.Acupoint {
			dAtA[i] = 0xa
			i++
			v := m.Acupoint[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.InsideSkill) > 0 {
		for k, _ := range m.InsideSkill {
			dAtA[i] = 0x12
			i++
			v := m.InsideSkill[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n50, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n50
			}
		}
	}
	return i, nil
}

func (m *InsideSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsideSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *Holy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Holy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, _ := range m.Skills {
			dAtA[i] = 0x22
			i++
			v := m.Skills[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Ring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ring) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rid))
	}
	if m.Strengthen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Strengthen))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pid))
	}
	if m.Talent != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talent))
	}
	if len(m.Phantom) > 0 {
		for k, _ := range m.Phantom {
			dAtA[i] = 0x2a
			i++
			v := m.Phantom[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n51, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n51
			}
		}
	}
	return i, nil
}

func (m *RingPhantom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingPhantom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Talent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talent))
	}
	if m.Phantom != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Phantom))
	}
	if len(m.Skill) > 0 {
		for k, _ := range m.Skill {
			dAtA[i] = 0x1a
			i++
			v := m.Skill[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if m.Grade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	if m.Break != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Break))
	}
	if len(m.Skill) > 0 {
		dAtA53 := make([]byte, len(m.Skill)*10)
		var j52 int
		for _, num1 := range m.Skill {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	return i, nil
}

func (m *ResetNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *FieldFightRivalUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldFightRivalUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RivalUserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RivalUserId))
	}
	if m.RivalDifficult != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RivalDifficult))
	}
	return i, nil
}

func (m *DarkPalaceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DarkPalaceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HelpNum))
	}
	return i, nil
}

func (m *FieldBossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldBossInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	return i, nil
}

func (m *TalentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GetPoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetPoints))
	}
	if m.SurplusPoints != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SurplusPoints))
	}
	if len(m.Talents) > 0 {
		for k, _ := range m.Talents {
			dAtA[i] = 0x1a
			i++
			v := m.Talents[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n54, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n54
			}
		}
	}
	return i, nil
}

func (m *TalentUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalentUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UsePoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UsePoints))
	}
	if len(m.Talents) > 0 {
		for k, _ := range m.Talents {
			dAtA[i] = 0x12
			i++
			v := m.Talents[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Fit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CdStart != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CdStart))
	}
	if m.CdEnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CdEnd))
	}
	if len(m.Fashion) > 0 {
		for k, _ := range m.Fashion {
			dAtA[i] = 0x1a
			i++
			v := m.Fashion[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, _ := range m.SkillBag {
			dAtA[i] = 0x22
			i++
			v := m.SkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Lv) > 0 {
		for k, _ := range m.Lv {
			dAtA[i] = 0x2a
			i++
			v := m.Lv[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Skills) > 0 {
		for k, _ := range m.Skills {
			dAtA[i] = 0x32
			i++
			v := m.Skills[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n55, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n55
			}
		}
	}
	return i, nil
}

func (m *FitSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FitSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *MonthCardUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonthCardUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *FirstRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsRecharge {
		dAtA[i] = 0x8
		i++
		if m.IsRecharge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Days) > 0 {
		dAtA57 := make([]byte, len(m.Days)*10)
		var j56 int
		for _, num1 := range m.Days {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j56))
		i += copy(dAtA[i:], dAtA57[:j56])
	}
	return i, nil
}

func (m *SpendRebates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendRebates) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CountIngot != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CountIngot))
	}
	if m.Ingot != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ingot))
	}
	if len(m.Reward) > 0 {
		dAtA59 := make([]byte, len(m.Reward)*10)
		var j58 int
		for _, num1 := range m.Reward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j58))
		i += copy(dAtA[i:], dAtA59[:j58])
	}
	return i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ErrorAck) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCommon(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *UserLoginInfo) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovCommon(uint64(m.Userid))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.VipLevel != 0 {
		n += 1 + sovCommon(uint64(m.VipLevel))
	}
	if m.VipScore != 0 {
		n += 1 + sovCommon(uint64(m.VipScore))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if m.Gold != 0 {
		n += 1 + sovCommon(uint64(m.Gold))
	}
	if m.Ingot != 0 {
		n += 1 + sovCommon(uint64(m.Ingot))
	}
	if m.CreateTime != 0 {
		n += 1 + sovCommon(uint64(m.CreateTime))
	}
	if m.StageId != 0 {
		n += 1 + sovCommon(uint64(m.StageId))
	}
	if m.StageWave != 0 {
		n += 1 + sovCommon(uint64(m.StageWave))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	if len(m.Heros) > 0 {
		for _, e := range m.Heros {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Rein != nil {
		l = m.Rein.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ReinCost) > 0 {
		for _, e := range m.ReinCost {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Fabao) > 0 {
		for _, e := range m.Fabao {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.FieldBossInfo != nil {
		l = m.FieldBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.WorldBossInfo != nil {
		l = m.WorldBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.ArenaFightNum != 0 {
		n += 2 + sovCommon(uint64(m.ArenaFightNum))
	}
	if m.FightModel != 0 {
		n += 2 + sovCommon(uint64(m.FightModel))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ShopInfo) > 0 {
		for k, v := range m.ShopInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.ChuanqiBi != 0 {
		n += 2 + sovCommon(uint64(m.ChuanqiBi))
	}
	if len(m.MaterialStage) > 0 {
		for k, v := range m.MaterialStage {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Panaceas) > 0 {
		for k, v := range m.Panaceas {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.SignInfo != nil {
		l = m.SignInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.DayStateInfo != nil {
		l = m.DayStateInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.Official != 0 {
		n += 2 + sovCommon(uint64(m.Official))
	}
	if len(m.Holy) > 0 {
		for _, e := range m.Holy {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Atlases) > 0 {
		for _, e := range m.Atlases {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.AtlasGathers) > 0 {
		for _, e := range m.AtlasGathers {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.MiningWorkTime != 0 {
		n += 2 + sovCommon(uint64(m.MiningWorkTime))
	}
	if m.Miner != 0 {
		n += 2 + sovCommon(uint64(m.Miner))
	}
	if m.ExpStage != nil {
		l = m.ExpStage.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Pets) > 0 {
		for k, v := range m.Pets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Juexues) > 0 {
		for _, e := range m.Juexues {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.UserWear != nil {
		l = m.UserWear.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.IsHaveGetDailyCompetitveReward != 0 {
		n += 2 + sovCommon(uint64(m.IsHaveGetDailyCompetitveReward))
	}
	if m.Honour != 0 {
		n += 2 + sovCommon(uint64(m.Honour))
	}
	if m.DarkPalaceInfo != nil {
		l = m.DarkPalaceInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.PersonBoss) > 0 {
		for k, v := range m.PersonBoss {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.VipBoss) > 0 {
		for k, v := range m.VipBoss {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.VipGift) > 0 {
		l = 0
		for _, e := range m.VipGift {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.RechargeAll != 0 {
		n += 2 + sovCommon(uint64(m.RechargeAll))
	}
	if len(m.AccumulativeAllGetIds) > 0 {
		l = 0
		for _, e := range m.AccumulativeAllGetIds {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if len(m.MonthCard) > 0 {
		for k, v := range m.MonthCard {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.FirstRecharge != nil {
		l = m.FirstRecharge.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.SpendRebates != nil {
		l = m.SpendRebates.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.DailyPack) > 0 {
		for k, v := range m.DailyPack {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HeroInfo) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCommon(uint64(m.Index))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.EquipGrids) > 0 {
		for _, e := range m.EquipGrids {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.HeroProp != nil {
		l = m.HeroProp.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Wing) > 0 {
		for _, e := range m.Wing {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Zodiacs) > 0 {
		for k, v := range m.Zodiacs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Kingarms) > 0 {
		for k, v := range m.Kingarms {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Dictates) > 0 {
		for _, e := range m.Dictates {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.WingSpecial) > 0 {
		for _, e := range m.WingSpecial {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Jewels) > 0 {
		for k, v := range m.Jewels {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.InsideInfo != nil {
		l = m.InsideInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Fashions) > 0 {
		for k, v := range m.Fashions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Wears != nil {
		l = m.Wears.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Rings) > 0 {
		for k, v := range m.Rings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Skills) > 0 {
		for _, e := range m.Skills {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, v := range m.SkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.UniqueSkills) > 0 {
		for _, e := range m.UniqueSkills {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.UniqueSkillBag) > 0 {
		for k, v := range m.UniqueSkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.GodEquips) > 0 {
		for k, v := range m.GodEquips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Area) > 0 {
		for k, v := range m.Area {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.EquipClears) > 0 {
		for k, v := range m.EquipClears {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.ExpLvl != 0 {
		n += 2 + sovCommon(uint64(m.ExpLvl))
	}
	if len(m.DragonEquip) > 0 {
		for k, v := range m.DragonEquip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.MagicCircle) > 0 {
		for k, v := range m.MagicCircle {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Talents != nil {
		l = m.Talents.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *UserWear) Size() (n int) {
	var l int
	_ = l
	if m.Petid != 0 {
		n += 1 + sovCommon(uint64(m.Petid))
	}
	if m.FitFashionId != 0 {
		n += 1 + sovCommon(uint64(m.FitFashionId))
	}
	return n
}

func (m *Wears) Size() (n int) {
	var l int
	_ = l
	if m.FashionWeaponId != 0 {
		n += 1 + sovCommon(uint64(m.FashionWeaponId))
	}
	if m.FashionClothId != 0 {
		n += 1 + sovCommon(uint64(m.FashionClothId))
	}
	if len(m.AtlasWear) > 0 {
		l = 0
		for _, e := range m.AtlasWear {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.WingId != 0 {
		n += 1 + sovCommon(uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		n += 1 + sovCommon(uint64(m.MagicCircleLvId))
	}
	return n
}

func (m *BriefUserInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if m.Lvl != 0 {
		n += 1 + sovCommon(uint64(m.Lvl))
	}
	if m.Vip != 0 {
		n += 1 + sovCommon(uint64(m.Vip))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	return n
}

func (m *BriefUserInfoWithDisplay) Size() (n int) {
	var l int
	_ = l
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *TopDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *TopDataChange) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	return n
}

func (m *BagDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *ItemChange) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *BagEquipDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *EquipChange) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	if m.Equip != nil {
		l = m.Equip.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovCommon(uint64(m.Count))
	}
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.Equip != nil {
		l = m.Equip.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GoodsChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ItemUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovCommon(uint64(m.Count))
	}
	return n
}

func (m *EquipUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if len(m.RandProps) > 0 {
		for _, e := range m.RandProps {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Lock {
		n += 2
	}
	if m.EquipIndex != 0 {
		n += 1 + sovCommon(uint64(m.EquipIndex))
	}
	if m.Lucky != 0 {
		n += 1 + sovCommon(uint64(m.Lucky))
	}
	return n
}

func (m *EquipRandProp) Size() (n int) {
	var l int
	_ = l
	if m.PropId != 0 {
		n += 1 + sovCommon(uint64(m.PropId))
	}
	if m.Color != 0 {
		n += 1 + sovCommon(uint64(m.Color))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *EquipClearArr) Size() (n int) {
	var l int
	_ = l
	if len(m.EquipClearInfo) > 0 {
		for _, e := range m.EquipClearInfo {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *EquipClearInfo) Size() (n int) {
	var l int
	_ = l
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Color != 0 {
		n += 1 + sovCommon(uint64(m.Color))
	}
	if m.PropId != 0 {
		n += 1 + sovCommon(uint64(m.PropId))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *HeroProp) Size() (n int) {
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.ModulesCombat) > 0 {
		for k, v := range m.ModulesCombat {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TaskInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovCommon(uint64(m.TaskId))
	}
	if m.Process != 0 {
		n += 1 + sovCommon(uint64(m.Process))
	}
	return n
}

func (m *DisplayNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Display) > 0 {
		for k, v := range m.Display {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventNtf) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Ts != 0 {
		n += 1 + sovCommon(uint64(m.Ts))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.SourceId != 0 {
		n += 1 + sovCommon(uint64(m.SourceId))
	}
	return n
}

func (m *DailyConditionNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.DailyConditions) > 0 {
		for k, v := range m.DailyConditions {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PropInfo) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovCommon(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *EquipGrid) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCommon(uint64(m.Pos))
	}
	if m.Strength != 0 {
		n += 1 + sovCommon(uint64(m.Strength))
	}
	return n
}

func (m *Fabao) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		l = 0
		for _, e := range m.Skills {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *GodEquip) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Juexue) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Fashion) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Wing) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *WingSpecialNtf) Size() (n int) {
	var l int
	_ = l
	if m.Order != 0 {
		n += 1 + sovCommon(uint64(m.Order))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Rein) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *ReinCost) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovCommon(uint64(m.Num))
	}
	return n
}

func (m *Atlas) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *AtlasGather) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *Preference) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovCommon(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *WorldBossInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.PrepareTime != 0 {
		n += 1 + sovCommon(uint64(m.PrepareTime))
	}
	if m.OpenTime != 0 {
		n += 1 + sovCommon(uint64(m.OpenTime))
	}
	if m.CloseTime != 0 {
		n += 1 + sovCommon(uint64(m.CloseTime))
	}
	return n
}

func (m *VipBoss) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovCommon(uint64(m.StageId))
	}
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	return n
}

func (m *ExpStage) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if len(m.ExpStages) > 0 {
		for k, v := range m.ExpStages {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Display) Size() (n int) {
	var l int
	_ = l
	if m.ClothItemId != 0 {
		n += 1 + sovCommon(uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		n += 1 + sovCommon(uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		n += 1 + sovCommon(uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		n += 1 + sovCommon(uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		n += 1 + sovCommon(uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		n += 1 + sovCommon(uint64(m.MagicCircleLvId))
	}
	return n
}

func (m *SpecialEquipUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GetSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Map)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Monster)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SkillUser)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SkillDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *RankInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovCommon(uint64(m.Rank))
	}
	if m.Score != 0 {
		n += 1 + sovCommon(uint64(m.Score))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SkillUnit) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovCommon(uint64(m.SkillId))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	return n
}

func (m *ShopInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ShopItem) > 0 {
		for k, v := range m.ShopItem {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DictateInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *PanaceaInfo) Size() (n int) {
	var l int
	_ = l
	if m.Numbers != 0 {
		n += 1 + sovCommon(uint64(m.Numbers))
	}
	if m.Number != 0 {
		n += 1 + sovCommon(uint64(m.Number))
	}
	return n
}

func (m *JewelInfo) Size() (n int) {
	var l int
	_ = l
	if m.Left != 0 {
		n += 1 + sovCommon(uint64(m.Left))
	}
	if m.Right != 0 {
		n += 1 + sovCommon(uint64(m.Right))
	}
	if m.Down != 0 {
		n += 1 + sovCommon(uint64(m.Down))
	}
	return n
}

func (m *DayStateInfo) Size() (n int) {
	var l int
	_ = l
	if m.RankWorship != 0 {
		n += 1 + sovCommon(uint64(m.RankWorship))
	}
	if len(m.MonthCardReceive) > 0 {
		l = 0
		for _, e := range m.MonthCardReceive {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *SignInfo) Size() (n int) {
	var l int
	_ = l
	if m.SignCount != 0 {
		n += 1 + sovCommon(uint64(m.SignCount))
	}
	if len(m.SignDay) > 0 {
		for k, v := range m.SignDay {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.CumulativeDay) > 0 {
		for k, v := range m.CumulativeDay {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InsideInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Acupoint) > 0 {
		for k, v := range m.Acupoint {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.InsideSkill) > 0 {
		for k, v := range m.InsideSkill {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InsideSkill) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *Holy) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, v := range m.Skills {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Ring) Size() (n int) {
	var l int
	_ = l
	if m.Rid != 0 {
		n += 1 + sovCommon(uint64(m.Rid))
	}
	if m.Strengthen != 0 {
		n += 1 + sovCommon(uint64(m.Strengthen))
	}
	if m.Pid != 0 {
		n += 1 + sovCommon(uint64(m.Pid))
	}
	if m.Talent != 0 {
		n += 1 + sovCommon(uint64(m.Talent))
	}
	if len(m.Phantom) > 0 {
		for k, v := range m.Phantom {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RingPhantom) Size() (n int) {
	var l int
	_ = l
	if m.Talent != 0 {
		n += 1 + sovCommon(uint64(m.Talent))
	}
	if m.Phantom != 0 {
		n += 1 + sovCommon(uint64(m.Phantom))
	}
	if len(m.Skill) > 0 {
		for k, v := range m.Skill {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PetInfo) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Break != 0 {
		n += 1 + sovCommon(uint64(m.Break))
	}
	if len(m.Skill) > 0 {
		l = 0
		for _, e := range m.Skill {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *ResetNtf) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *FieldFightRivalUserInfo) Size() (n int) {
	var l int
	_ = l
	if m.RivalUserId != 0 {
		n += 1 + sovCommon(uint64(m.RivalUserId))
	}
	if m.RivalDifficult != 0 {
		n += 1 + sovCommon(uint64(m.RivalDifficult))
	}
	return n
}

func (m *DarkPalaceInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		n += 1 + sovCommon(uint64(m.HelpNum))
	}
	return n
}

func (m *FieldBossInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	return n
}

func (m *TalentInfo) Size() (n int) {
	var l int
	_ = l
	if m.GetPoints != 0 {
		n += 1 + sovCommon(uint64(m.GetPoints))
	}
	if m.SurplusPoints != 0 {
		n += 1 + sovCommon(uint64(m.SurplusPoints))
	}
	if len(m.Talents) > 0 {
		for k, v := range m.Talents {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TalentUnit) Size() (n int) {
	var l int
	_ = l
	if m.UsePoints != 0 {
		n += 1 + sovCommon(uint64(m.UsePoints))
	}
	if len(m.Talents) > 0 {
		for k, v := range m.Talents {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Fit) Size() (n int) {
	var l int
	_ = l
	if m.CdStart != 0 {
		n += 1 + sovCommon(uint64(m.CdStart))
	}
	if m.CdEnd != 0 {
		n += 1 + sovCommon(uint64(m.CdEnd))
	}
	if len(m.Fashion) > 0 {
		for k, v := range m.Fashion {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, v := range m.SkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Lv) > 0 {
		for k, v := range m.Lv {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Skills) > 0 {
		for k, v := range m.Skills {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FitSkill) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	return n
}

func (m *MonthCardUnit) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	return n
}

func (m *FirstRecharge) Size() (n int) {
	var l int
	_ = l
	if m.IsRecharge {
		n += 2
	}
	if len(m.Days) > 0 {
		l = 0
		for _, e := range m.Days {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *SpendRebates) Size() (n int) {
	var l int
	_ = l
	if m.CountIngot != 0 {
		n += 1 + sovCommon(uint64(m.CountIngot))
	}
	if m.Ingot != 0 {
		n += 1 + sovCommon(uint64(m.Ingot))
	}
	if len(m.Reward) > 0 {
		l = 0
		for _, e := range m.Reward {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ErrorAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLoginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLoginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLoginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			m.VipLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipScore", wireType)
			}
			m.VipScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageWave", wireType)
			}
			m.StageWave = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageWave |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heros = append(m.Heros, &HeroInfo{})
			if err := m.Heros[len(m.Heros)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rein", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rein == nil {
				m.Rein = &Rein{}
			}
			if err := m.Rein.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReinCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReinCost = append(m.ReinCost, &ReinCost{})
			if err := m.ReinCost[len(m.ReinCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fabao", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fabao = append(m.Fabao, &Fabao{})
			if err := m.Fabao[len(m.Fabao)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldBossInfo == nil {
				m.FieldBossInfo = &FieldBossInfo{}
			}
			if err := m.FieldBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorldBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorldBossInfo == nil {
				m.WorldBossInfo = &WorldBossInfoNtf{}
			}
			if err := m.WorldBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaFightNum", wireType)
			}
			m.ArenaFightNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaFightNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightModel", wireType)
			}
			m.FightModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &TaskInfoNtf{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShopInfo == nil {
				m.ShopInfo = make(map[int32]*ShopInfo)
			}
			var mapkey int32
			var mapvalue *ShopInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ShopInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ShopInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChuanqiBi", wireType)
			}
			m.ChuanqiBi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChuanqiBi |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaterialStage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaterialStage == nil {
				m.MaterialStage = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaterialStage[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Panaceas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Panaceas == nil {
				m.Panaceas = make(map[int32]*PanaceaInfo)
			}
			var mapkey int32
			var mapvalue *PanaceaInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PanaceaInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Panaceas[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignInfo == nil {
				m.SignInfo = &SignInfo{}
			}
			if err := m.SignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayStateInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DayStateInfo == nil {
				m.DayStateInfo = &DayStateInfo{}
			}
			if err := m.DayStateInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holy = append(m.Holy, &Holy{})
			if err := m.Holy[len(m.Holy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atlases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Atlases = append(m.Atlases, &Atlas{})
			if err := m.Atlases[len(m.Atlases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtlasGathers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtlasGathers = append(m.AtlasGathers, &AtlasGather{})
			if err := m.AtlasGathers[len(m.AtlasGathers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningWorkTime", wireType)
			}
			m.MiningWorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningWorkTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpStage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpStage == nil {
				m.ExpStage = &ExpStage{}
			}
			if err := m.ExpStage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pets == nil {
				m.Pets = make(map[int32]*PetInfo)
			}
			var mapkey int32
			var mapvalue *PetInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PetInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Pets[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Juexues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Juexues = append(m.Juexues, &Juexue{})
			if err := m.Juexues[len(m.Juexues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserWear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserWear == nil {
				m.UserWear = &UserWear{}
			}
			if err := m.UserWear.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHaveGetDailyCompetitveReward", wireType)
			}
			m.IsHaveGetDailyCompetitveReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsHaveGetDailyCompetitveReward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Honour", wireType)
			}
			m.Honour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Honour |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DarkPalaceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DarkPalaceInfo == nil {
				m.DarkPalaceInfo = &DarkPalaceInfo{}
			}
			if err := m.DarkPalaceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonBoss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PersonBoss == nil {
				m.PersonBoss = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PersonBoss[mapkey] = mapvalue
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipBoss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipBoss == nil {
				m.VipBoss = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VipBoss[mapkey] = mapvalue
			iNdEx = postIndex
		case 45:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VipGift = append(m.VipGift, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VipGift = append(m.VipGift, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipGift", wireType)
			}
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &Fit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeAll", wireType)
			}
			m.RechargeAll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeAll |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AccumulativeAllGetIds = append(m.AccumulativeAllGetIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AccumulativeAllGetIds = append(m.AccumulativeAllGetIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulativeAllGetIds", wireType)
			}
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonthCard == nil {
				m.MonthCard = make(map[int32]*MonthCardUnit)
			}
			var mapkey int32
			var mapvalue *MonthCardUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MonthCardUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonthCard[mapkey] = mapvalue
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstRecharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstRecharge == nil {
				m.FirstRecharge = &FirstRecharge{}
			}
			if err := m.FirstRecharge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendRebates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpendRebates == nil {
				m.SpendRebates = &SpendRebates{}
			}
			if err := m.SpendRebates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyPack == nil {
				m.DailyPack = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DailyPack[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[int32]*EquipUnit)
			}
			var mapkey int32
			var mapvalue *EquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipGrids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipGrids = append(m.EquipGrids, &EquipGrid{})
			if err := m.EquipGrids[len(m.EquipGrids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroProp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroProp == nil {
				m.HeroProp = &HeroProp{}
			}
			if err := m.HeroProp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wing = append(m.Wing, &Wing{})
			if err := m.Wing[len(m.Wing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zodiacs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zodiacs == nil {
				m.Zodiacs = make(map[int32]*SpecialEquipUnit)
			}
			var mapkey int32
			var mapvalue *SpecialEquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpecialEquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Zodiacs[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kingarms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kingarms == nil {
				m.Kingarms = make(map[int32]*SpecialEquipUnit)
			}
			var mapkey int32
			var mapvalue *SpecialEquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpecialEquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kingarms[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dictates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dictates = append(m.Dictates, &DictateInfo{})
			if err := m.Dictates[len(m.Dictates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingSpecial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WingSpecial = append(m.WingSpecial, &WingSpecialNtf{})
			if err := m.WingSpecial[len(m.WingSpecial)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jewels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jewels == nil {
				m.Jewels = make(map[int32]*JewelInfo)
			}
			var mapkey int32
			var mapvalue *JewelInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &JewelInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Jewels[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideInfo == nil {
				m.InsideInfo = &InsideInfo{}
			}
			if err := m.InsideInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fashions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fashions == nil {
				m.Fashions = make(map[int32]*Fashion)
			}
			var mapkey int32
			var mapvalue *Fashion
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Fashion{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fashions[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wears", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wears == nil {
				m.Wears = &Wears{}
			}
			if err := m.Wears.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rings == nil {
				m.Rings = make(map[int32]*Ring)
			}
			var mapkey int32
			var mapvalue *Ring
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ring{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Rings[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skills = append(m.Skills, &SkillUnit{})
			if err := m.Skills[len(m.Skills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBag == nil {
				m.SkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueSkills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueSkills = append(m.UniqueSkills, &SkillUnit{})
			if err := m.UniqueSkills[len(m.UniqueSkills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueSkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniqueSkillBag == nil {
				m.UniqueSkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UniqueSkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GodEquips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GodEquips == nil {
				m.GodEquips = make(map[int32]*GodEquip)
			}
			var mapkey int32
			var mapvalue *GodEquip
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GodEquip{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GodEquips[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Area == nil {
				m.Area = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Area[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipClears", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquipClears == nil {
				m.EquipClears = make(map[int32]*EquipClearArr)
			}
			var mapkey int32
			var mapvalue *EquipClearArr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EquipClearArr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EquipClears[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpLvl", wireType)
			}
			m.ExpLvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpLvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DragonEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DragonEquip == nil {
				m.DragonEquip = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DragonEquip[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MagicCircle == nil {
				m.MagicCircle = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MagicCircle[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = &TalentInfo{}
			}
			if err := m.Talents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserWear) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserWear: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserWear: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Petid", wireType)
			}
			m.Petid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Petid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitFashionId", wireType)
			}
			m.FitFashionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitFashionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Wears) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wears: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wears: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionWeaponId", wireType)
			}
			m.FashionWeaponId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionWeaponId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionClothId", wireType)
			}
			m.FashionClothId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionClothId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtlasWear = append(m.AtlasWear, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtlasWear = append(m.AtlasWear, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtlasWear", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			m.WingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircleLvId", wireType)
			}
			m.MagicCircleLvId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCircleLvId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BriefUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BriefUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BriefUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			m.Lvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BriefUserInfoWithDisplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BriefUserInfoWithDisplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BriefUserInfoWithDisplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &BriefUserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &DisplayNtf{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &TopDataChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopDataChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopDataChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopDataChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &ItemChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagEquipDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagEquipDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagEquipDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &EquipChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = &EquipUnit{}
			}
			if err := m.Equip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = &EquipUnit{}
			}
			if err := m.Equip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: itemUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: itemUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandProps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandProps = append(m.RandProps, &EquipRandProp{})
			if err := m.RandProps[len(m.RandProps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lock = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIndex", wireType)
			}
			m.EquipIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquipIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipRandProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipRandProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipRandProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipClearArr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipClearArr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipClearArr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipClearInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipClearInfo = append(m.EquipClearInfo, &EquipClearInfo{})
			if err := m.EquipClearInfo[len(m.EquipClearInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipClearInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipClearInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipClearInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModulesCombat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModulesCombat == nil {
				m.ModulesCombat = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModulesCombat[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisplayNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisplayNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisplayNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = make(map[int32]*Display)
			}
			var mapkey int32
			var mapvalue *Display
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Display{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Display[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			m.SourceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyConditionNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyConditionNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyConditionNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyConditions == nil {
				m.DailyConditions = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DailyConditions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipGrid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipGrid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipGrid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fabao) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fabao: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fabao: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skills = append(m.Skills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skills = append(m.Skills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GodEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GodEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GodEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Juexue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Juexue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Juexue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fashion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fashion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fashion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Wing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WingSpecialNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WingSpecialNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WingSpecialNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rein) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rein: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rein: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReinCost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReinCost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReinCost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Atlas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Atlas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Atlas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtlasGather) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtlasGather: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtlasGather: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Preference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldBossInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldBossInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldBossInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			m.PrepareTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			m.OpenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			m.CloseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipBoss) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipBoss: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipBoss: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpStages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpStages == nil {
				m.ExpStages = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExpStages[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Display) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Display: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Display: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothItemId", wireType)
			}
			m.ClothItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothType", wireType)
			}
			m.ClothType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponItemId", wireType)
			}
			m.WeaponItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponType", wireType)
			}
			m.WeaponType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			m.WingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircleLvId", wireType)
			}
			m.MagicCircleLvId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCircleLvId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialEquipUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialEquipUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialEquipUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Map = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &BriefUserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShopItem == nil {
				m.ShopItem = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ShopItem[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DictateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DictateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DictateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PanaceaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PanaceaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PanaceaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numbers", wireType)
			}
			m.Numbers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numbers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JewelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JewelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JewelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			m.Down = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Down |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DayStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DayStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DayStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankWorship", wireType)
			}
			m.RankWorship = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankWorship |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MonthCardReceive = append(m.MonthCardReceive, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MonthCardReceive = append(m.MonthCardReceive, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthCardReceive", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCount", wireType)
			}
			m.SignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignDay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignDay == nil {
				m.SignDay = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SignDay[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeDay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CumulativeDay == nil {
				m.CumulativeDay = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CumulativeDay[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsideInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsideInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsideInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acupoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acupoint == nil {
				m.Acupoint = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Acupoint[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSkill == nil {
				m.InsideSkill = make(map[int32]*InsideSkill)
			}
			var mapkey int32
			var mapvalue *InsideSkill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InsideSkill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InsideSkill[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsideSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsideSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsideSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Holy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Holy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Holy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skills == nil {
				m.Skills = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skills[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strengthen", wireType)
			}
			m.Strengthen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strengthen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talent", wireType)
			}
			m.Talent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Talent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phantom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phantom == nil {
				m.Phantom = make(map[int32]*RingPhantom)
			}
			var mapkey int32
			var mapvalue *RingPhantom
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RingPhantom{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Phantom[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingPhantom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingPhantom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingPhantom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talent", wireType)
			}
			m.Talent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Talent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phantom", wireType)
			}
			m.Phantom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phantom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skill == nil {
				m.Skill = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skill[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Break", wireType)
			}
			m.Break = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Break |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skill = append(m.Skill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skill = append(m.Skill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldFightRivalUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldFightRivalUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldFightRivalUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RivalUserId", wireType)
			}
			m.RivalUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RivalUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RivalDifficult", wireType)
			}
			m.RivalDifficult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RivalDifficult |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DarkPalaceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DarkPalaceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DarkPalaceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpNum", wireType)
			}
			m.HelpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldBossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldBossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldBossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPoints", wireType)
			}
			m.GetPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetPoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SurplusPoints", wireType)
			}
			m.SurplusPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SurplusPoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = make(map[int32]*TalentUnit)
			}
			var mapkey int32
			var mapvalue *TalentUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TalentUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Talents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalentUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalentUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalentUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePoints", wireType)
			}
			m.UsePoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsePoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Talents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStart", wireType)
			}
			m.CdStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdEnd", wireType)
			}
			m.CdEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fashion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fashion == nil {
				m.Fashion = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fashion[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBag == nil {
				m.SkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lv == nil {
				m.Lv = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Lv[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skills == nil {
				m.Skills = make(map[int32]*FitSkill)
			}
			var mapkey int32
			var mapvalue *FitSkill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FitSkill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skills[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FitSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FitSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FitSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonthCardUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonthCardUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonthCardUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstRecharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstRecharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecharge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecharge = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Days = append(m.Days, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Days = append(m.Days, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendRebates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendRebates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendRebates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIngot", wireType)
			}
			m.CountIngot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountIngot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Reward = append(m.Reward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Reward = append(m.Reward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 3975 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x7b, 0x4f, 0x73, 0x1b, 0x47,
	0x76, 0xf8, 0x6f, 0x00, 0x82, 0x00, 0x1e, 0x08, 0x88, 0x6e, 0x53, 0xf2, 0x98, 0xab, 0xa5, 0xe9,
	0x91, 0xec, 0xe5, 0x4f, 0xb6, 0x28, 0xd9, 0x92, 0x63, 0x59, 0xeb, 0xb5, 0x97, 0x22, 0x25, 0x8a,
	0xb2, 0xa4, 0xd5, 0x0e, 0xe5, 0x65, 0x6a, 0xb3, 0x95, 0xaa, 0x26, 0xa6, 0x09, 0x8c, 0x39, 0x98,
	0x19, 0xcf, 0x0c, 0x20, 0x31, 0x87, 0xe4, 0x9e, 0xca, 0x3d, 0xb9, 0x24, 0x07, 0x5f, 0x72, 0xd8,
	0xca, 0x31, 0x87, 0x9c, 0xf7, 0x92, 0x5b, 0x52, 0x95, 0x0f, 0x90, 0x2d, 0xe7, 0x6b, 0xe4, 0x90,
	0x7a, 0xaf, 0xbb, 0x67, 0xba, 0x41, 0xd0, 0x24, 0x76, 0x53, 0x39, 0xa1, 0xdf, 0xdf, 0x7e, 0xdd,
	0xd3, 0xfd, 0xde, 0xeb, 0x7e, 0x0d, 0x58, 0xea, 0x27, 0xa3, 0x51, 0x12, 0x6f, 0xa6, 0x59, 0x52,
	0x24, 0xac, 0x96, 0x1e, 0x7a, 0xf7, 0xa0, 0xf5, 0x30, 0xcb, 0x92, 0x6c, 0xab, 0x7f, 0xcc, 0x18,
	0x2c, 0xf4, 0x93, 0x40, 0xb8, 0xce, 0xba, 0xb3, 0xd1, 0xf0, 0xa9, 0xcd, 0x5c, 0x68, 0x8e, 0x44,
	0x9e, 0xf3, 0x81, 0x70, 0x6b, 0xeb, 0xce, 0x46, 0xdb, 0xd7, 0xa0, 0xf7, 0xbb, 0x15, 0xe8, 0x7e,
	0x9d, 0x8b, 0xec, 0x69, 0x32, 0x08, 0xe3, 0xbd, 0xf8, 0x28, 0x61, 0x57, 0x60, 0x71, 0x9c, 0x8b,
	0x2c, 0x0c, 0x94, 0x06, 0x05, 0xb1, 0x55, 0x68, 0xc5, 0x61, 0xff, 0xf8, 0x39, 0x1f, 0x69, 0x25,
	0x25, 0x8c, 0x32, 0x7c, 0xc2, 0x0b, 0x9e, 0xb9, 0x75, 0xa2, 0x28, 0x08, 0x65, 0x26, 0x61, 0xfa,
	0x54, 0x4c, 0x44, 0xe4, 0x2e, 0x90, 0xb6, 0x12, 0x56, 0xb4, 0xfd, 0x7e, 0x92, 0x09, 0xb7, 0x51,
	0xd2, 0x08, 0x66, 0x2b, 0xd0, 0x88, 0x48, 0x68, 0x91, 0x08, 0x12, 0x60, 0xcb, 0x50, 0x17, 0xaf,
	0x53, 0xb7, 0x49, 0x38, 0x6c, 0xe2, 0x58, 0x07, 0x49, 0x14, 0xb8, 0xad, 0x75, 0x67, 0xa3, 0xee,
	0x53, 0x1b, 0x65, 0xc3, 0x78, 0x90, 0x14, 0x6e, 0x5b, 0xca, 0x12, 0xc0, 0xd6, 0x00, 0xfa, 0x99,
	0xe0, 0x85, 0x78, 0x19, 0x8e, 0x84, 0x0b, 0x44, 0x32, 0x30, 0x38, 0x43, 0x79, 0xc1, 0x07, 0x62,
	0x2f, 0x70, 0x3b, 0x44, 0xd4, 0x20, 0xbb, 0x0a, 0x6d, 0x6a, 0x1e, 0xf0, 0x89, 0x70, 0x97, 0x88,
	0x56, 0x21, 0x70, 0xe4, 0xfd, 0x64, 0x74, 0xc8, 0x0b, 0xb7, 0x47, 0x36, 0x28, 0x88, 0x79, 0xd0,
	0x18, 0x8a, 0x2c, 0xc9, 0xdd, 0x4b, 0xeb, 0xf5, 0x8d, 0xce, 0xc7, 0x4b, 0x9b, 0xe9, 0xe1, 0xe6,
	0x63, 0x91, 0x25, 0x38, 0xc5, 0xbe, 0x24, 0xb1, 0xab, 0xb0, 0x90, 0x89, 0x30, 0x76, 0x97, 0xd7,
	0x9d, 0x8d, 0xce, 0xc7, 0x2d, 0x64, 0xf1, 0x45, 0x18, 0xfb, 0x84, 0x65, 0x1b, 0xd0, 0xc2, 0xdf,
	0xed, 0x24, 0x2f, 0xdc, 0x37, 0x2a, 0x25, 0xbe, 0xc2, 0xf9, 0x25, 0x95, 0xbd, 0x03, 0x8d, 0x23,
	0x7e, 0xc8, 0x13, 0x97, 0x11, 0x5b, 0x1b, 0xd9, 0x1e, 0x21, 0xc2, 0x97, 0x78, 0xf6, 0x29, 0x74,
	0x8f, 0x42, 0x11, 0x05, 0x0f, 0x92, 0x3c, 0x47, 0x03, 0xdc, 0x37, 0xa9, 0xc7, 0x37, 0x88, 0xd1,
	0x24, 0xf8, 0x36, 0x1f, 0xbb, 0x0f, 0xdd, 0x57, 0x49, 0x66, 0x08, 0xae, 0x90, 0xe0, 0x0a, 0x0a,
	0x1e, 0x98, 0x84, 0xe7, 0xc5, 0x91, 0x6f, 0xb3, 0xb2, 0xeb, 0xd0, 0xdd, 0xca, 0x44, 0xcc, 0x1f,
	0x85, 0x83, 0x61, 0xf1, 0x7c, 0x3c, 0x72, 0x2f, 0xd3, 0xdc, 0xd9, 0x48, 0xfc, 0x2e, 0x47, 0xd8,
	0x7e, 0x96, 0x04, 0x22, 0x72, 0xaf, 0xc8, 0xef, 0x52, 0x61, 0xd8, 0x35, 0x58, 0x28, 0x78, 0x7e,
	0xec, 0xbe, 0x45, 0x1d, 0x5f, 0xc2, 0x8e, 0x5f, 0xf2, 0xfc, 0x58, 0xf7, 0x49, 0x44, 0xf6, 0x53,
	0x68, 0xe5, 0xc3, 0x24, 0x25, 0x0b, 0x5d, 0x9a, 0x83, 0x77, 0x90, 0xd1, 0x5a, 0xd7, 0x9b, 0xfb,
	0x8a, 0xe3, 0x61, 0x5c, 0x64, 0x27, 0x7e, 0x29, 0x80, 0xdf, 0xb7, 0x3f, 0x1c, 0xf3, 0xf8, 0xdb,
	0xf0, 0x41, 0xe8, 0xbe, 0x2d, 0xbf, 0x6f, 0x89, 0x60, 0x4f, 0xa0, 0x3b, 0xe2, 0x85, 0xc8, 0x42,
	0x1e, 0xed, 0xe3, 0x47, 0x77, 0x57, 0x49, 0xff, 0xf5, 0xd3, 0xfa, 0x9f, 0x99, 0x6c, 0xb2, 0x13,
	0x5b, 0x14, 0xcd, 0x4c, 0x79, 0xcc, 0xfb, 0x82, 0xe7, 0xee, 0x8f, 0xce, 0x32, 0xf3, 0x85, 0xe2,
	0x50, 0x66, 0x6a, 0x01, 0x5c, 0x0e, 0x79, 0x38, 0x20, 0x1e, 0xf7, 0x2a, 0x4d, 0x06, 0x2d, 0x87,
	0x7d, 0x85, 0xf3, 0x4b, 0x2a, 0xbb, 0x0b, 0x4b, 0x01, 0x3f, 0xd9, 0x2f, 0x78, 0x21, 0x88, 0xfb,
	0xc7, 0xc4, 0xbd, 0x8c, 0xdc, 0x3b, 0x06, 0xde, 0xb7, 0xb8, 0x70, 0x3b, 0x26, 0x47, 0x47, 0x61,
	0x3f, 0xe4, 0x91, 0xbb, 0x26, 0xb7, 0xa3, 0x86, 0x71, 0xa1, 0x0e, 0x93, 0xe8, 0xc4, 0x7d, 0x87,
	0x8c, 0xa6, 0x85, 0xfa, 0x38, 0x89, 0x4e, 0x7c, 0xc2, 0xb2, 0x6b, 0xd0, 0xe4, 0x45, 0xc4, 0x73,
	0x91, 0xbb, 0xeb, 0xd5, 0x02, 0xdc, 0x42, 0x94, 0xaf, 0x29, 0xec, 0x0e, 0x2c, 0x51, 0x73, 0x97,
	0x17, 0x43, 0x91, 0xe5, 0xee, 0xbb, 0xc4, 0x79, 0xa9, 0xe4, 0x94, 0x78, 0xdf, 0x62, 0x62, 0xef,
	0x43, 0x6f, 0x14, 0xc6, 0x61, 0x3c, 0x38, 0x48, 0xb2, 0x63, 0xda, 0xb8, 0x1e, 0x6d, 0xb2, 0x29,
	0x2c, 0x6e, 0xf9, 0x51, 0x18, 0x8b, 0xcc, 0xbd, 0x26, 0xb7, 0x3c, 0x01, 0x38, 0x63, 0xe2, 0x75,
	0x2a, 0xbf, 0xda, 0xf5, 0x6a, 0xc6, 0x1e, 0x2a, 0x9c, 0x5f, 0x52, 0xd9, 0x2d, 0x58, 0x48, 0x45,
	0x91, 0xbb, 0xef, 0x91, 0x51, 0x3f, 0x9a, 0xf1, 0x51, 0x44, 0xa1, 0x3e, 0x08, 0x31, 0xb2, 0xeb,
	0xd0, 0xfc, 0x66, 0x2c, 0x5e, 0x8f, 0x45, 0xee, 0xbe, 0x4f, 0x32, 0x80, 0x32, 0x4f, 0x08, 0xe5,
	0x6b, 0x12, 0x1a, 0x80, 0xbe, 0xf3, 0x40, 0xf0, 0xcc, 0xfd, 0x49, 0x65, 0xc0, 0xd7, 0x0a, 0xe7,
	0x97, 0x54, 0xf6, 0x08, 0xd6, 0xc2, 0xfc, 0x31, 0x9f, 0x88, 0x5d, 0x51, 0xec, 0xf0, 0x30, 0x3a,
	0xd9, 0x4e, 0x46, 0xa9, 0x28, 0xc2, 0x62, 0x22, 0x7c, 0xf1, 0x8a, 0x67, 0x81, 0xbb, 0x41, 0x23,
	0x3b, 0x87, 0x0b, 0xbd, 0xd1, 0x30, 0x89, 0x93, 0x71, 0xe6, 0xfe, 0x7f, 0xe9, 0x8d, 0x24, 0xc4,
	0xee, 0x43, 0x2f, 0xe0, 0xd9, 0xf1, 0x0b, 0x1e, 0xf1, 0xbe, 0x5c, 0x14, 0x37, 0xc8, 0x1e, 0x26,
	0x17, 0x85, 0x49, 0xf1, 0xa7, 0x38, 0xd9, 0x16, 0x40, 0x2a, 0xb2, 0x3c, 0x89, 0x71, 0x67, 0xbb,
	0x1f, 0xd0, 0x70, 0xdf, 0x9d, 0x35, 0x45, 0x9a, 0x47, 0x4e, 0x94, 0x21, 0xc4, 0xee, 0x41, 0x73,
	0x12, 0xa6, 0x24, 0xff, 0x21, 0xc9, 0xaf, 0x9d, 0x96, 0xff, 0x95, 0x64, 0x90, 0xc2, 0x9a, 0x1d,
	0xdd, 0xf2, 0x24, 0x4c, 0x77, 0xc3, 0xa3, 0xc2, 0xbd, 0xb9, 0x5e, 0x47, 0xb7, 0xac, 0x40, 0xf6,
	0x36, 0xd4, 0x8f, 0xc2, 0xc2, 0xdd, 0xa4, 0x71, 0x34, 0xa5, 0x27, 0x2b, 0x7c, 0xc4, 0xb1, 0x75,
	0xe8, 0x64, 0xa2, 0x3f, 0xe4, 0xd9, 0x40, 0x6c, 0x45, 0x91, 0x7b, 0x8b, 0xa6, 0xce, 0x44, 0xb1,
	0xbb, 0x70, 0x99, 0xf7, 0xfb, 0xe3, 0xd1, 0x38, 0xe2, 0x45, 0x38, 0x41, 0xd4, 0xae, 0x28, 0xf6,
	0x82, 0xdc, 0xbd, 0x4d, 0x9d, 0xcc, 0x26, 0xb2, 0x2f, 0xa0, 0x3d, 0x4a, 0xe2, 0x62, 0xb8, 0x8d,
	0x1f, 0xe4, 0x23, 0x1a, 0xc8, 0xfa, 0x0c, 0x3f, 0xa0, 0x59, 0xe4, 0x50, 0x2a, 0x11, 0xe9, 0x86,
	0xb3, 0xbc, 0xf0, 0x95, 0x25, 0xee, 0xc7, 0xa6, 0x1b, 0x36, 0x08, 0xbe, 0xcd, 0x87, 0x3b, 0x3a,
	0x4f, 0x45, 0x1c, 0xf8, 0xe2, 0x90, 0x17, 0x22, 0x77, 0xef, 0x54, 0x3b, 0x7a, 0xdf, 0xc0, 0xfb,
	0x16, 0x17, 0x9a, 0x1b, 0xe0, 0x2a, 0x79, 0xc1, 0xfb, 0xc7, 0xee, 0xdd, 0xb3, 0xcc, 0xdd, 0xd1,
	0x2c, 0xca, 0xdc, 0x52, 0x64, 0x75, 0x0f, 0xba, 0x96, 0xcf, 0xc4, 0xf8, 0x7b, 0x2c, 0x4e, 0x54,
	0x5a, 0x80, 0x4d, 0x8c, 0x72, 0x13, 0x1e, 0x8d, 0x65, 0x42, 0xa0, 0x3d, 0x92, 0x92, 0xf1, 0x25,
	0xe9, 0x7e, 0xed, 0x9e, 0xb3, 0xfa, 0x73, 0x60, 0xa7, 0xdd, 0xe3, 0x0c, 0x7d, 0x2b, 0xa6, 0xbe,
	0x86, 0xa9, 0xe1, 0x29, 0x74, 0x2d, 0xcf, 0x38, 0x43, 0xf8, 0x3d, 0xdb, 0x18, 0xf2, 0x2d, 0x4a,
	0x66, 0xda, 0x9e, 0x1d, 0x68, 0x97, 0x5b, 0x7a, 0x86, 0xa6, 0x77, 0x6d, 0x4d, 0x1d, 0xd2, 0x24,
	0x8a, 0x69, 0x2d, 0x3f, 0x83, 0x4b, 0x53, 0xab, 0x7e, 0xae, 0x21, 0xdd, 0x87, 0x25, 0x73, 0xd1,
	0xcf, 0x25, 0xfb, 0x0b, 0xe8, 0xd9, 0xeb, 0x6c, 0x86, 0xf4, 0x4f, 0xec, 0x51, 0xd0, 0x32, 0x2b,
	0x85, 0xbe, 0x8e, 0xc3, 0xc2, 0x54, 0xf8, 0x39, 0xf4, 0xec, 0x95, 0x30, 0x8f, 0x39, 0xde, 0x77,
	0x6f, 0x40, 0x4b, 0x67, 0x37, 0x32, 0x01, 0x0b, 0xc4, 0x6b, 0x25, 0x2a, 0x01, 0x54, 0xf7, 0x4d,
	0x72, 0xa8, 0x44, 0xb1, 0x89, 0x98, 0x5c, 0xbc, 0xa6, 0x8c, 0xb1, 0xe1, 0x63, 0x93, 0xdd, 0x86,
	0x45, 0xf1, 0xed, 0x38, 0x4c, 0x73, 0x77, 0x81, 0x96, 0xab, 0x6b, 0x66, 0x4d, 0x9b, 0x0f, 0x89,
	0x24, 0x97, 0xa9, 0xe2, 0x63, 0x37, 0x01, 0xa8, 0xb5, 0x9b, 0x85, 0x41, 0xee, 0x36, 0x48, 0xaa,
	0x4b, 0x5e, 0x5e, 0x63, 0x7d, 0x83, 0x01, 0x3d, 0x32, 0xa6, 0x5e, 0x2f, 0xb2, 0x24, 0xa5, 0xd4,
	0xd2, 0x48, 0xcc, 0x10, 0xe7, 0x97, 0x54, 0x0c, 0x79, 0xaf, 0xc2, 0x78, 0xe0, 0x36, 0xab, 0x90,
	0x77, 0x10, 0xc6, 0x03, 0x9f, 0xb0, 0xec, 0x0e, 0x34, 0xff, 0x22, 0x09, 0x42, 0xde, 0xcf, 0xdd,
	0x16, 0x31, 0xbc, 0x6d, 0x59, 0xfa, 0x6b, 0x49, 0x53, 0xbe, 0x4c, 0x71, 0xb2, 0x3f, 0x81, 0xd6,
	0x71, 0x18, 0x0f, 0x78, 0x36, 0xca, 0xdd, 0x36, 0x49, 0xad, 0x5a, 0x52, 0x5f, 0x29, 0xa2, 0x8a,
	0xfc, 0x9a, 0x97, 0x7d, 0x00, 0xad, 0x20, 0xec, 0x17, 0xb4, 0xf3, 0xa1, 0x0a, 0x9b, 0x3b, 0x12,
	0x27, 0x83, 0xbf, 0x66, 0x60, 0x77, 0xa1, 0x83, 0x16, 0xee, 0xa7, 0x82, 0x22, 0x79, 0x87, 0xf8,
	0x99, 0x36, 0x5f, 0xa1, 0x31, 0x73, 0x32, 0xd9, 0x70, 0xe2, 0xbf, 0x11, 0xaf, 0x44, 0x94, 0xbb,
	0x4b, 0x33, 0x26, 0xfe, 0x09, 0x91, 0xd4, 0xc4, 0x4b, 0x3e, 0xcc, 0xbc, 0x63, 0x3c, 0x09, 0x74,
	0x29, 0xdf, 0xa7, 0x36, 0xdb, 0x04, 0x08, 0xe3, 0x3c, 0x0c, 0x64, 0x84, 0xe9, 0xd1, 0xfc, 0xf6,
	0x50, 0xd3, 0x5e, 0x89, 0xf5, 0x0d, 0x0e, 0x9c, 0x90, 0x47, 0x3c, 0x1f, 0x86, 0x49, 0xac, 0xd3,
	0x64, 0x7b, 0x42, 0x34, 0x51, 0x4d, 0x88, 0x06, 0x31, 0xdf, 0x7d, 0x25, 0x78, 0x96, 0xab, 0xc4,
	0x99, 0xd2, 0x0d, 0x0c, 0xa3, 0xb9, 0x2f, 0xf1, 0xec, 0x26, 0x34, 0xb2, 0x30, 0x1e, 0xe4, 0x2a,
	0x6f, 0x7e, 0xcb, 0xd2, 0xea, 0x23, 0x45, 0xaa, 0x94, 0x5c, 0xec, 0x3d, 0x58, 0xcc, 0x8f, 0xc3,
	0x28, 0xca, 0x55, 0x02, 0x4d, 0x0b, 0x68, 0x1f, 0x31, 0xb4, 0x4b, 0x14, 0x11, 0xcd, 0xa5, 0xd6,
	0x03, 0x3e, 0x70, 0xdf, 0x9c, 0x61, 0xee, 0xbe, 0x22, 0xea, 0x04, 0x53, 0x81, 0xec, 0x23, 0x58,
	0x1a, 0xc7, 0xe1, 0xb7, 0x63, 0xb1, 0x2f, 0x3b, 0x59, 0x99, 0xd5, 0x89, 0xc5, 0xc2, 0x1e, 0x43,
	0xcf, 0x80, 0xb1, 0xc3, 0xcb, 0x95, 0xff, 0x2e, 0x3b, 0xfc, 0xda, 0x62, 0x91, 0xdd, 0x4e, 0xc9,
	0xb1, 0xcf, 0xa0, 0x3d, 0x48, 0x02, 0xb9, 0x75, 0xdc, 0x2b, 0x55, 0x7e, 0x53, 0x2a, 0xd9, 0xd5,
	0x54, 0xe5, 0xff, 0x4b, 0x6e, 0x76, 0x03, 0x16, 0x78, 0x26, 0xb8, 0xfb, 0x16, 0x49, 0x5d, 0xb1,
	0xa4, 0xb6, 0x32, 0xc1, 0x55, 0x42, 0x84, 0x3c, 0xec, 0x4b, 0xe8, 0xd0, 0x36, 0xdb, 0x8e, 0xe8,
	0xc3, 0xc8, 0x24, 0xfc, 0xc7, 0xa7, 0xb7, 0xaf, 0xa4, 0x4b, 0x49, 0x53, 0x02, 0x33, 0x17, 0xf1,
	0x3a, 0x7d, 0x3a, 0x89, 0x54, 0x0a, 0xae, 0x20, 0x54, 0x1c, 0x64, 0x7c, 0x90, 0xc4, 0x24, 0xae,
	0xb2, 0x6f, 0x5b, 0xf1, 0x4e, 0x45, 0x57, 0x8a, 0x0d, 0x09, 0x54, 0xf0, 0x8c, 0x0f, 0xc2, 0xfe,
	0x76, 0x98, 0xf5, 0x23, 0xa1, 0xf2, 0x6e, 0x5b, 0x81, 0x41, 0x57, 0x0a, 0x0c, 0x0c, 0xdb, 0x80,
	0x66, 0xc1, 0x23, 0x11, 0x17, 0xb9, 0xca, 0xbb, 0x7b, 0xf2, 0x10, 0x82, 0x28, 0x5a, 0xd2, 0x9a,
	0xbc, 0xfa, 0x18, 0x3a, 0xc6, 0x54, 0xce, 0x70, 0xa0, 0xd7, 0x6c, 0x8f, 0x5c, 0x39, 0xaa, 0x69,
	0x6f, 0xfc, 0x02, 0x96, 0x4c, 0x1f, 0x32, 0x43, 0xd5, 0x0d, 0x5b, 0xd5, 0x8a, 0xca, 0x05, 0x70,
	0x37, 0xcf, 0xd4, 0xf8, 0x4b, 0xe8, 0x5a, 0xfe, 0xe5, 0x7f, 0x41, 0xe5, 0x63, 0xe8, 0x18, 0x9e,
	0xe1, 0x82, 0xc3, 0x25, 0x89, 0xe9, 0x40, 0xfa, 0x18, 0xba, 0xd6, 0x5e, 0xbf, 0x60, 0x48, 0x56,
	0x32, 0xa6, 0xa6, 0x07, 0x00, 0xd5, 0xfe, 0x9e, 0xa1, 0x66, 0xcd, 0x56, 0x23, 0xcf, 0xdc, 0xe8,
	0xd7, 0x0d, 0x1d, 0x3f, 0x85, 0xae, 0xb5, 0xa7, 0xe6, 0x0a, 0xcc, 0x5b, 0xf0, 0xe6, 0x8c, 0x6d,
	0x39, 0x97, 0x8a, 0x27, 0xd0, 0xb3, 0x37, 0xe5, 0x05, 0x13, 0x2f, 0x2d, 0x64, 0xea, 0xfa, 0x14,
	0xda, 0xe5, 0x56, 0x9d, 0xcb, 0x88, 0x5f, 0xc2, 0xf2, 0xf4, 0x86, 0xbd, 0x60, 0x8a, 0x51, 0x89,
	0x6d, 0x65, 0x99, 0xa9, 0xf2, 0x0b, 0x58, 0x9e, 0xde, 0xaa, 0x73, 0x99, 0xf4, 0x05, 0x2c, 0x4f,
	0xef, 0xd4, 0xb9, 0x92, 0x94, 0x1d, 0x68, 0xe9, 0xa3, 0x17, 0x72, 0xe1, 0xc9, 0x49, 0xdf, 0x71,
	0x49, 0x80, 0x79, 0xb0, 0x74, 0x14, 0x16, 0x6a, 0x59, 0xed, 0x05, 0x4a, 0x85, 0x85, 0xf3, 0xfe,
	0xc5, 0x81, 0x06, 0x05, 0x1b, 0xb6, 0x01, 0x97, 0x14, 0xfa, 0x40, 0xf0, 0x94, 0x04, 0xa4, 0xb6,
	0x69, 0x34, 0x9e, 0x63, 0x15, 0x6a, 0x3b, 0x4a, 0x8a, 0x61, 0xa9, 0x79, 0x0a, 0xcb, 0xae, 0x42,
	0x9b, 0xce, 0xbf, 0x74, 0x62, 0xac, 0xd3, 0x51, 0xa4, 0x42, 0xa0, 0x8b, 0xc4, 0x98, 0xbd, 0x17,
	0xa8, 0xab, 0x34, 0x05, 0xa1, 0x1d, 0xa3, 0x6a, 0x5e, 0x9e, 0x4e, 0xf6, 0x02, 0x75, 0x9f, 0x36,
	0x8d, 0xf6, 0x7e, 0xeb, 0x40, 0xf7, 0x41, 0x16, 0x8a, 0x23, 0x9c, 0x07, 0x0a, 0xc1, 0x3d, 0xa8,
	0x95, 0x93, 0x50, 0x0b, 0x83, 0x32, 0xac, 0xd7, 0x8c, 0xb0, 0x7e, 0x3a, 0x4f, 0x5b, 0x86, 0x7a,
	0x34, 0xd1, 0x37, 0x7a, 0xd8, 0x44, 0xcc, 0x24, 0x4c, 0x55, 0xbf, 0xd8, 0x34, 0x2e, 0xc6, 0x16,
	0xad, 0x8b, 0xb1, 0xea, 0xaa, 0xb0, 0x69, 0x5d, 0x15, 0xaa, 0xfc, 0xb0, 0x55, 0xe6, 0x87, 0x5e,
	0x0e, 0xae, 0x65, 0xec, 0x41, 0x58, 0x0c, 0x77, 0xc2, 0x3c, 0x8d, 0xf8, 0x09, 0xbb, 0x29, 0x8f,
	0xd6, 0x94, 0x68, 0x38, 0xd5, 0xda, 0xb3, 0xf8, 0xfd, 0x92, 0x05, 0x7d, 0x78, 0x20, 0x25, 0xcd,
	0xb4, 0x44, 0x29, 0xc3, 0x6c, 0x48, 0x93, 0xbd, 0x3f, 0x83, 0xe5, 0x97, 0x49, 0xba, 0xc3, 0x0b,
	0xbe, 0x3d, 0xe4, 0xf1, 0x40, 0x3c, 0x2f, 0x8e, 0xd8, 0x1d, 0xe8, 0xf4, 0x09, 0x40, 0x5d, 0xb9,
	0xeb, 0x50, 0x08, 0xa1, 0xfe, 0x2c, 0x56, 0xdf, 0xe4, 0xc2, 0x99, 0x2c, 0x4e, 0x52, 0xbd, 0x0c,
	0xa9, 0xed, 0xfd, 0x02, 0xba, 0x96, 0xc4, 0xa9, 0xe9, 0xc7, 0x49, 0x23, 0x0a, 0x89, 0xe1, 0xa4,
	0x49, 0xbe, 0x2b, 0xb0, 0x18, 0x27, 0xaf, 0x9e, 0x8f, 0x47, 0xf4, 0x15, 0xea, 0xbe, 0x82, 0xbc,
	0x3f, 0x85, 0xe5, 0x07, 0x7c, 0x60, 0x5b, 0x7b, 0x7b, 0x96, 0xb5, 0x32, 0x0d, 0x2b, 0xc4, 0xe8,
	0xa2, 0xa6, 0xfe, 0xbd, 0x03, 0x50, 0xf1, 0xb3, 0x55, 0x68, 0xa5, 0x49, 0x1e, 0x16, 0x61, 0x12,
	0x2b, 0x73, 0x4b, 0x18, 0x8d, 0x0b, 0x0b, 0x31, 0x2a, 0x57, 0xb5, 0x82, 0x8c, 0xc1, 0xd4, 0xcf,
	0x18, 0xcc, 0x82, 0x39, 0x18, 0xf6, 0x01, 0xb4, 0x07, 0xa2, 0xd8, 0x4f, 0xc6, 0x59, 0x5f, 0xde,
	0x08, 0xab, 0x90, 0xb1, 0xab, 0x91, 0x7e, 0x45, 0xf7, 0xfe, 0x1c, 0x2e, 0xa3, 0x73, 0x45, 0x4f,
	0x62, 0x0f, 0xff, 0xa3, 0x59, 0xc3, 0xbf, 0x54, 0x39, 0xa6, 0x0b, 0x8e, 0xff, 0x77, 0x8e, 0x0a,
	0xe6, 0xff, 0x87, 0x13, 0x70, 0x0d, 0x1a, 0x94, 0x12, 0x99, 0x83, 0x37, 0x22, 0x2f, 0xd1, 0xec,
	0x59, 0x5a, 0x3c, 0x67, 0x96, 0xbe, 0x73, 0x60, 0x01, 0xbf, 0xa2, 0x61, 0xa2, 0x63, 0x99, 0xb8,
	0x02, 0x8d, 0x7e, 0x32, 0x8e, 0x0b, 0xb5, 0xde, 0x24, 0x60, 0x0d, 0xb6, 0x3e, 0x35, 0xd8, 0xd2,
	0xc8, 0x85, 0x8b, 0x1a, 0x79, 0xde, 0xa7, 0xbc, 0x8b, 0xf1, 0x2e, 0x09, 0xf2, 0xea, 0x1b, 0x7a,
	0xd0, 0x40, 0xfb, 0xf4, 0xd7, 0xa3, 0xe8, 0x86, 0x08, 0xd9, 0x05, 0x91, 0xbc, 0x7b, 0xd0, 0xd2,
	0xa8, 0xf9, 0x46, 0xe7, 0xfd, 0x83, 0x03, 0xed, 0xd2, 0xe2, 0x33, 0x65, 0x6f, 0x41, 0x3b, 0xe3,
	0x71, 0x80, 0x87, 0xc1, 0xdc, 0xad, 0x55, 0x5b, 0x5e, 0x86, 0x58, 0x45, 0xf1, 0x2b, 0x1e, 0x5c,
	0x45, 0x51, 0xd2, 0x3f, 0xa6, 0x09, 0x6b, 0xf9, 0xd4, 0x66, 0x6b, 0xea, 0x78, 0xba, 0x47, 0xe7,
	0x61, 0xe9, 0x2f, 0x0d, 0x0c, 0xd5, 0x39, 0xc6, 0xfd, 0xe3, 0x13, 0xe5, 0x38, 0x25, 0xe0, 0xed,
	0x43, 0xd7, 0xea, 0x05, 0x6d, 0x4c, 0xb3, 0x24, 0xad, 0x6c, 0x94, 0x90, 0x1c, 0x5f, 0x94, 0x64,
	0x3a, 0xd6, 0x11, 0x50, 0x45, 0xc0, 0xba, 0x11, 0x01, 0xbd, 0xaf, 0x94, 0x52, 0x1d, 0x99, 0xd9,
	0x7d, 0xe8, 0x55, 0x09, 0xb8, 0x72, 0xa4, 0xe5, 0x61, 0xf1, 0xa1, 0x45, 0xf1, 0xa7, 0x38, 0xbd,
	0x6f, 0xa0, 0x67, 0x73, 0x60, 0xa7, 0x83, 0x8c, 0x97, 0x65, 0x27, 0x09, 0x9c, 0x61, 0x60, 0x35,
	0x9c, 0xfa, 0xf4, 0x70, 0xa4, 0xe1, 0x0b, 0xa6, 0xe1, 0xff, 0xed, 0xc8, 0xbb, 0x05, 0x9a, 0x89,
	0x9b, 0xd0, 0x48, 0xe9, 0x8b, 0x38, 0xf6, 0xc9, 0x0e, 0x89, 0x9b, 0xf4, 0x1d, 0xd4, 0xc9, 0x8e,
	0xb8, 0xd8, 0x43, 0xe8, 0x8e, 0x92, 0x60, 0x1c, 0x89, 0x7c, 0x5b, 0xc6, 0xa2, 0x5a, 0x75, 0xed,
	0x5e, 0x8a, 0x3d, 0x33, 0x39, 0xf4, 0xc5, 0xbd, 0x89, 0x5b, 0xbd, 0x07, 0x50, 0xe9, 0x3e, 0x2f,
	0xe7, 0xa8, 0x4f, 0x5f, 0x7c, 0x9d, 0x52, 0x3f, 0x8f, 0x06, 0xef, 0x4b, 0xe8, 0x18, 0x05, 0x0f,
	0x9c, 0xbb, 0x02, 0xc1, 0x72, 0x29, 0x48, 0x88, 0xb9, 0xd0, 0x4c, 0xb3, 0xa4, 0x2f, 0xf2, 0x5c,
	0xcd, 0xb5, 0x06, 0xbd, 0xbf, 0x71, 0x00, 0xaa, 0x48, 0xc7, 0x3e, 0xa9, 0x42, 0xa1, 0x53, 0x1d,
	0x07, 0x2b, 0x06, 0xdd, 0x54, 0x97, 0x17, 0x8a, 0x77, 0x75, 0x17, 0x96, 0x4c, 0xc2, 0x05, 0x33,
	0x74, 0x25, 0x62, 0x8e, 0xe7, 0xd7, 0xd0, 0x7a, 0x38, 0x11, 0x71, 0x81, 0xb6, 0x4c, 0x87, 0xbf,
	0x1e, 0xd4, 0x0a, 0x6d, 0x7f, 0xad, 0xa0, 0x2d, 0xc5, 0xb3, 0x41, 0x4e, 0xa9, 0x50, 0xdb, 0xa7,
	0x36, 0xfa, 0xa6, 0x9c, 0xfc, 0x46, 0x99, 0x07, 0x95, 0xb0, 0xf7, 0x4f, 0x0e, 0xbc, 0xa1, 0x2e,
	0xc6, 0xe3, 0x80, 0xdc, 0x15, 0xf6, 0xf2, 0x12, 0x2e, 0x05, 0x16, 0x52, 0xaf, 0x9e, 0x1b, 0xf2,
	0xf6, 0x7b, 0x8a, 0x7f, 0x0a, 0xa3, 0x16, 0xd4, 0xb4, 0x8a, 0xd5, 0x07, 0xb0, 0x32, 0x8b, 0x71,
	0xae, 0x8c, 0xf4, 0x63, 0x68, 0xe1, 0xba, 0xa2, 0x0d, 0x74, 0x41, 0x39, 0xef, 0x33, 0xe5, 0xbc,
	0x76, 0xb3, 0x30, 0x40, 0xa1, 0x94, 0x82, 0x1c, 0x09, 0xa5, 0x89, 0x9c, 0x9e, 0x22, 0x13, 0xf1,
	0xa0, 0x18, 0x2a, 0xb9, 0x12, 0xf6, 0x0e, 0xa0, 0x41, 0x65, 0xc1, 0x53, 0xf3, 0x5e, 0x96, 0x5b,
	0x6b, 0x33, 0xca, 0xad, 0xf5, 0xaa, 0xdc, 0x7a, 0xa5, 0xbc, 0x28, 0x59, 0xa0, 0xe4, 0x54, 0x41,
	0xde, 0x6d, 0x68, 0xe9, 0xc3, 0xc7, 0xc5, 0x74, 0x7b, 0x9b, 0xb0, 0x28, 0xab, 0x25, 0x17, 0xe4,
	0xbf, 0x05, 0x4d, 0x95, 0x2b, 0x5f, 0x50, 0x60, 0x03, 0x16, 0x0e, 0xc2, 0x78, 0x70, 0x8a, 0x5b,
	0x0d, 0xaa, 0x56, 0x0e, 0xca, 0xfb, 0x1c, 0x7a, 0xf6, 0xd5, 0x18, 0x6a, 0x4c, 0xb2, 0x40, 0x64,
	0xda, 0x97, 0x11, 0x70, 0x76, 0x3f, 0xbe, 0x08, 0xe3, 0x1f, 0xea, 0xa7, 0x2e, 0xfb, 0xf9, 0x10,
	0x5a, 0xba, 0x76, 0x3b, 0x8b, 0x3b, 0x1e, 0x8f, 0xb4, 0x55, 0xf1, 0x78, 0xe4, 0xed, 0x42, 0x83,
	0xea, 0x62, 0xb3, 0x32, 0xf4, 0x1c, 0xb3, 0x67, 0x95, 0xac, 0xe4, 0xaa, 0xcc, 0x1e, 0xe6, 0x5b,
	0xfd, 0x22, 0x9c, 0x08, 0x15, 0x7e, 0x4a, 0xd8, 0x7b, 0x06, 0x1d, 0xa3, 0xc0, 0xf6, 0x47, 0xab,
	0xbb, 0x8b, 0xae, 0x50, 0x1c, 0x89, 0x4c, 0xc4, 0x7d, 0x71, 0xde, 0xa2, 0x6d, 0xeb, 0x45, 0xfb,
	0x97, 0xb0, 0x3c, 0x5d, 0x2e, 0x3e, 0x65, 0xc9, 0x3a, 0x74, 0xd2, 0x4c, 0xa4, 0x3c, 0x93, 0x25,
	0x7a, 0x69, 0x90, 0x89, 0xa2, 0x12, 0x65, 0x2a, 0x62, 0x22, 0xab, 0xb4, 0x44, 0xc3, 0x54, 0xc5,
	0x8d, 0x92, 0x5c, 0xca, 0x2e, 0xa8, 0x2a, 0xae, 0x46, 0x78, 0x3f, 0x83, 0xe6, 0xaf, 0xaa, 0x8a,
	0x92, 0x2e, 0xf4, 0x3b, 0x76, 0xa1, 0xdf, 0x85, 0x66, 0xc0, 0x33, 0xf1, 0xbc, 0xfc, 0x10, 0x1a,
	0xf4, 0xfe, 0xd9, 0x81, 0x96, 0x2e, 0x1b, 0x9a, 0x6c, 0x8e, 0xc5, 0x86, 0xdb, 0xe3, 0x70, 0x7c,
	0x52, 0xc9, 0x2b, 0x88, 0x7d, 0x06, 0x6d, 0x5d, 0x6a, 0x94, 0xbe, 0x4c, 0x39, 0x5d, 0xad, 0xb2,
	0x6c, 0xe8, 0x3b, 0xb8, 0x92, 0x7b, 0xf5, 0x73, 0xe8, 0xd9, 0xc4, 0xb9, 0x62, 0xc7, 0xbf, 0x39,
	0xd0, 0xd4, 0x27, 0xa6, 0x75, 0xe8, 0xf4, 0xe9, 0x98, 0x69, 0x26, 0x3b, 0x26, 0x4a, 0x4d, 0x61,
	0x31, 0x7c, 0x59, 0xe5, 0xc2, 0x15, 0x02, 0xcf, 0xc6, 0xaf, 0xe4, 0x79, 0x56, 0x2a, 0x90, 0x1f,
	0xc0, 0xc2, 0x61, 0xba, 0x23, 0x61, 0x52, 0xa1, 0xd2, 0x9d, 0x0a, 0x63, 0x9c, 0x60, 0x1b, 0xe7,
	0x9d, 0x60, 0x17, 0x67, 0x9f, 0x60, 0x0f, 0x60, 0x79, 0xfa, 0x4a, 0xea, 0xcc, 0x0c, 0xce, 0x4a,
	0x42, 0x6b, 0xe7, 0x24, 0xa1, 0x39, 0xb4, 0x4b, 0x3c, 0xce, 0xf1, 0x88, 0xa7, 0xa4, 0xae, 0xed,
	0x63, 0x93, 0x1e, 0xd0, 0x24, 0x71, 0x5e, 0x88, 0xac, 0x7c, 0x40, 0x23, 0x41, 0x7a, 0x1e, 0x42,
	0xb7, 0xb8, 0xb9, 0xd0, 0xaf, 0x5f, 0x2a, 0x44, 0x49, 0xdd, 0xe1, 0x85, 0x9c, 0x10, 0x4d, 0x45,
	0x84, 0xf7, 0xd7, 0x0e, 0xb4, 0x7c, 0x1e, 0x53, 0x70, 0xc7, 0x9d, 0x98, 0xf1, 0xf8, 0x58, 0xbf,
	0xdb, 0xc1, 0x36, 0x7e, 0xda, 0x9c, 0x1e, 0xc8, 0xa8, 0x4f, 0x4b, 0x80, 0x75, 0xf8, 0xad, 0x9f,
	0x7f, 0xf8, 0x7d, 0xaf, 0x8a, 0xf8, 0x0b, 0xa7, 0x43, 0x73, 0x79, 0xf2, 0xcd, 0xa1, 0x5d, 0x5e,
	0x47, 0xd3, 0x2e, 0x41, 0xc0, 0xd8, 0x25, 0x12, 0x3c, 0x23, 0x56, 0xc8, 0x47, 0x32, 0x59, 0x51,
	0xee, 0xcd, 0xba, 0x5f, 0x21, 0x50, 0x9b, 0x88, 0x83, 0x72, 0x6b, 0xd6, 0x7d, 0x0d, 0x7a, 0x7f,
	0x05, 0x2d, 0x5d, 0x2f, 0xa4, 0xfb, 0x75, 0x6c, 0x17, 0x62, 0xa4, 0x02, 0xf4, 0xaa, 0x59, 0x4f,
	0x94, 0x8d, 0x42, 0x8c, 0xcc, 0x07, 0x1c, 0x85, 0x18, 0xd1, 0x7d, 0x9d, 0x49, 0x9a, 0x2b, 0x04,
	0x7f, 0x0a, 0x1d, 0xa3, 0x90, 0x52, 0x1e, 0x05, 0x9d, 0xea, 0x28, 0x78, 0x86, 0xe3, 0xff, 0x12,
	0x3a, 0x46, 0x71, 0x11, 0x87, 0x18, 0x8f, 0x47, 0x87, 0x22, 0xd3, 0xd1, 0x58, 0x83, 0x74, 0xda,
	0xa3, 0xa6, 0xf6, 0x0a, 0x12, 0xf2, 0xf6, 0xa0, 0x5d, 0x5e, 0x86, 0xd2, 0xe1, 0x41, 0x1c, 0x15,
	0xba, 0x5f, 0x6c, 0x63, 0xbf, 0x59, 0x38, 0x18, 0x16, 0xba, 0x5f, 0x02, 0x90, 0x33, 0x48, 0x5e,
	0xe9, 0x73, 0x19, 0xb5, 0xbd, 0xdf, 0xc0, 0x92, 0xf9, 0xb2, 0x83, 0x0a, 0xe0, 0x3c, 0x3e, 0x3e,
	0x48, 0xb2, 0x7c, 0x18, 0xa6, 0x7a, 0xaf, 0x1b, 0x28, 0x76, 0x03, 0x96, 0xcb, 0xba, 0xb4, 0x2f,
	0xfa, 0x02, 0x5d, 0x7d, 0x8d, 0x62, 0xfa, 0x29, 0xbc, 0xf7, 0x5d, 0x0d, 0x5a, 0xfa, 0x99, 0x09,
	0x7d, 0xe8, 0x70, 0x10, 0x6f, 0xd3, 0xb1, 0xca, 0x51, 0xaf, 0xa1, 0x34, 0x82, 0xdd, 0x81, 0x26,
	0x02, 0x3b, 0xfc, 0x44, 0x65, 0xda, 0x6f, 0x9b, 0x6f, 0x54, 0xa8, 0xb1, 0x53, 0xa6, 0x96, 0x8a,
	0x13, 0x93, 0xf4, 0xaa, 0xda, 0x8e, 0xa2, 0xf5, 0x2a, 0x49, 0x2f, 0x45, 0xb7, 0x4d, 0x0e, 0x95,
	0xa4, 0x5b, 0x52, 0xab, 0xf7, 0x61, 0xc9, 0xd4, 0x3f, 0xd7, 0xd5, 0xe2, 0xcf, 0x81, 0x9d, 0xee,
	0x60, 0xae, 0x75, 0xf4, 0xb7, 0x35, 0x80, 0xaa, 0xcc, 0xc5, 0xee, 0x41, 0x8b, 0xf7, 0xc7, 0x69,
	0x12, 0xd2, 0x2c, 0xe1, 0x70, 0xae, 0xda, 0x85, 0xb0, 0xcd, 0x2d, 0x45, 0x56, 0xab, 0x59, 0x73,
	0xb3, 0x2d, 0xe8, 0xc8, 0x12, 0x19, 0x6d, 0x46, 0xf3, 0xc0, 0x62, 0x08, 0xef, 0x55, 0x1c, 0xaa,
	0x62, 0x61, 0xc8, 0xe0, 0x86, 0xb0, 0xb4, 0xcf, 0x59, 0x59, 0x5e, 0x9e, 0xd6, 0x7e, 0xc1, 0x5a,
	0xbb, 0x21, 0x66, 0xce, 0xcc, 0x27, 0xd0, 0x31, 0x28, 0xd5, 0x6e, 0x72, 0x66, 0xe4, 0x9a, 0x46,
	0x5a, 0xf6, 0x8f, 0x0e, 0x2c, 0x3c, 0x4e, 0xa2, 0x93, 0x3f, 0x38, 0x59, 0xfd, 0xd0, 0x4a, 0x56,
	0x55, 0x3d, 0x03, 0x35, 0xca, 0xaa, 0x9b, 0xae, 0x67, 0x4a, 0x9e, 0xd5, 0xcf, 0xa0, 0x63, 0xa0,
	0xe7, 0xfa, 0xf4, 0xbf, 0x77, 0x60, 0xc1, 0xc7, 0x5c, 0x73, 0x19, 0xea, 0xd5, 0xb3, 0x49, 0x6c,
	0x62, 0x40, 0xd4, 0xd9, 0xb7, 0x88, 0x95, 0xa4, 0x81, 0xa1, 0xfc, 0x3d, 0xd4, 0xb1, 0x14, 0x9b,
	0xf2, 0x7c, 0x17, 0x89, 0xb8, 0xd0, 0x97, 0xbc, 0x12, 0x62, 0xb7, 0xa0, 0x99, 0x0e, 0x79, 0x5c,
	0x24, 0x23, 0x55, 0xe5, 0xbe, 0xac, 0x4b, 0x17, 0x9b, 0x2f, 0x24, 0x5e, 0xed, 0x2a, 0xc5, 0xb5,
	0xfa, 0x15, 0x2c, 0x99, 0x84, 0x0b, 0x7e, 0x43, 0x54, 0xa8, 0xc4, 0xcc, 0x21, 0xfe, 0xd6, 0x81,
	0x8e, 0x41, 0x32, 0xac, 0x74, 0x2c, 0x2b, 0xdd, 0xca, 0x4a, 0x7d, 0x0a, 0x55, 0x12, 0xb7, 0xa1,
	0x41, 0x33, 0xad, 0x36, 0xf7, 0xea, 0x54, 0x67, 0x9b, 0xc6, 0x5a, 0x96, 0x8c, 0x78, 0xe8, 0xfe,
	0xc1, 0x25, 0x78, 0xf6, 0x07, 0x19, 0x41, 0x53, 0xbd, 0xd6, 0xc0, 0xc5, 0x13, 0x4d, 0xf4, 0xe2,
	0x89, 0x26, 0xa7, 0xd7, 0x59, 0x75, 0x71, 0x51, 0x9f, 0xba, 0xb8, 0x38, 0xcc, 0x04, 0x3f, 0xd6,
	0x57, 0x11, 0x04, 0x50, 0x38, 0xa6, 0x41, 0x34, 0xc8, 0x55, 0x4a, 0xc0, 0x5b, 0xc3, 0xc4, 0x3e,
	0x17, 0x74, 0xa2, 0x9d, 0x11, 0x3f, 0xbc, 0x3e, 0xbc, 0x45, 0x8f, 0x2c, 0xe9, 0xcd, 0xa3, 0x1f,
	0x4e, 0x78, 0x54, 0x5e, 0xbf, 0xa3, 0xa3, 0x2e, 0x11, 0x65, 0x52, 0x66, 0xa0, 0xd8, 0xfb, 0xd0,
	0x23, 0x70, 0x27, 0x3c, 0x3a, 0x0a, 0xfb, 0xe3, 0x48, 0x47, 0x83, 0x29, 0xac, 0xf7, 0x1b, 0xe8,
	0xd9, 0xef, 0xb8, 0xfe, 0x80, 0x3c, 0xd5, 0x85, 0xe6, 0x50, 0x44, 0xa9, 0xbe, 0x66, 0x6e, 0xf8,
	0x1a, 0xf4, 0xb6, 0xa0, 0x6b, 0xbd, 0x13, 0x9d, 0x5f, 0xb9, 0xf7, 0x1f, 0x0e, 0x40, 0x55, 0x34,
	0xc5, 0x38, 0x32, 0x10, 0xc5, 0x0b, 0xf4, 0x51, 0x3a, 0x62, 0x56, 0x08, 0x76, 0x1d, 0xba, 0xf9,
	0x38, 0x4b, 0xa3, 0x71, 0xae, 0x38, 0xa4, 0x2e, 0x1b, 0xc9, 0x3e, 0xa9, 0x2a, 0xb3, 0x46, 0x56,
	0x5d, 0x75, 0xa2, 0x9a, 0xfa, 0x1d, 0x86, 0x2e, 0xd3, 0x3e, 0x81, 0x25, 0x93, 0x30, 0x63, 0x69,
	0x5d, 0xb7, 0x77, 0x86, 0x51, 0xf0, 0x9d, 0xaa, 0x81, 0xd2, 0x35, 0x79, 0x45, 0xc1, 0x51, 0x8d,
	0x73, 0x61, 0x8f, 0xaa, 0x44, 0x98, 0xf6, 0xd6, 0xa6, 0xed, 0x45, 0xf1, 0x33, 0xec, 0xbd, 0x7f,
	0xae, 0xbd, 0x67, 0x6f, 0x85, 0xff, 0xac, 0x43, 0xfd, 0x91, 0xcc, 0xe7, 0xfa, 0xc1, 0x3e, 0x26,
	0x64, 0x24, 0x57, 0xf7, 0x35, 0x48, 0x57, 0x74, 0xc1, 0xc3, 0x38, 0x28, 0xef, 0x48, 0x11, 0x60,
	0x9b, 0xd0, 0x3c, 0x92, 0xe7, 0x6d, 0x35, 0xb5, 0x2b, 0xea, 0x85, 0x9d, 0x2e, 0xba, 0x2a, 0x1b,
	0x15, 0x13, 0xfb, 0xc8, 0x78, 0x1b, 0xb1, 0x50, 0xf9, 0x27, 0x14, 0x38, 0xeb, 0x59, 0xc4, 0x3b,
	0xb4, 0x35, 0x1b, 0xd5, 0xfd, 0x3c, 0x32, 0x3f, 0x9d, 0x48, 0x36, 0xdc, 0xab, 0x1f, 0x94, 0x0e,
	0x7c, 0x91, 0x98, 0xde, 0xb4, 0x34, 0x4e, 0xf9, 0xef, 0xfb, 0xb0, 0x64, 0x5a, 0x36, 0x57, 0xc8,
	0xfb, 0xa3, 0x0a, 0xbe, 0x9f, 0x40, 0x53, 0x19, 0x3d, 0x97, 0xd8, 0xee, 0x79, 0xf1, 0x66, 0x56,
	0x85, 0xf7, 0x51, 0x58, 0x9c, 0x0a, 0xaf, 0x9b, 0xd0, 0xd2, 0xe8, 0x53, 0xde, 0x6e, 0xc6, 0xe1,
	0xde, 0xdb, 0x85, 0xae, 0xf5, 0x08, 0xcc, 0x4e, 0xdd, 0x9d, 0x1f, 0x48, 0xdd, 0x6b, 0x76, 0xea,
	0xbe, 0x8d, 0x3e, 0xc1, 0x7c, 0xa5, 0xb8, 0x06, 0x10, 0xe6, 0xe5, 0xdb, 0x46, 0x87, 0x2e, 0x0e,
	0x0c, 0x0c, 0x65, 0xae, 0xfc, 0x24, 0x57, 0x79, 0x26, 0xb5, 0x31, 0x73, 0x35, 0x5f, 0x30, 0xd2,
	0x33, 0x7d, 0xcc, 0x24, 0xf7, 0xe8, 0x05, 0xbf, 0xa3, 0x9e, 0xe9, 0x97, 0x98, 0xea, 0x71, 0x7f,
	0xcd, 0x7c, 0xdc, 0x7f, 0x05, 0x16, 0x33, 0xf9, 0x4c, 0x56, 0x16, 0x4d, 0x15, 0xf4, 0x60, 0xf9,
	0x5f, 0xbf, 0x5f, 0x73, 0xfe, 0xfd, 0xfb, 0x35, 0xe7, 0xf7, 0xdf, 0xaf, 0x39, 0x7f, 0xf7, 0x5f,
	0x6b, 0xff, 0xef, 0x70, 0x91, 0xfe, 0x33, 0x71, 0xe7, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x48,
	0x8c, 0x35, 0x0a, 0x43, 0x31, 0x00, 0x00,
}
