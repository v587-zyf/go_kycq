// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scene.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Point struct {
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{0} }

func (m *Point) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type SceneObj struct {
	ObjType    int32            `protobuf:"varint,1,opt,name=objType,proto3" json:"objType,omitempty"`
	Point      *Point           `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	Dir        int32            `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	ObjId      int32            `protobuf:"varint,4,opt,name=objId,proto3" json:"objId,omitempty"`
	TeamId     int32            `protobuf:"varint,5,opt,name=teamId,proto3" json:"teamId,omitempty"`
	Hp         int64            `protobuf:"varint,7,opt,name=hp,proto3" json:"hp,omitempty"`
	HpMax      int64            `protobuf:"varint,8,opt,name=hpMax,proto3" json:"hpMax,omitempty"`
	Buffs      []*BuffInfo      `protobuf:"bytes,9,rep,name=buffs" json:"buffs,omitempty"`
	Mp         int64            `protobuf:"varint,10,opt,name=mp,proto3" json:"mp,omitempty"`
	MpMax      int64            `protobuf:"varint,11,opt,name=mpMax,proto3" json:"mpMax,omitempty"`
	User       *SceneUser       `protobuf:"bytes,21,opt,name=user" json:"user,omitempty"`
	Monster    *SceneMonster    `protobuf:"bytes,23,opt,name=monster" json:"monster,omitempty"`
	Item       *SceneItem       `protobuf:"bytes,24,opt,name=item" json:"item,omitempty"`
	Pet        *ScenePet        `protobuf:"bytes,25,opt,name=pet" json:"pet,omitempty"`
	Collection *SceneCollection `protobuf:"bytes,26,opt,name=collection" json:"collection,omitempty"`
	Fit        *SceneFit        `protobuf:"bytes,27,opt,name=fit" json:"fit,omitempty"`
	Summon     *SceneSummon     `protobuf:"bytes,28,opt,name=summon" json:"summon,omitempty"`
}

func (m *SceneObj) Reset()                    { *m = SceneObj{} }
func (m *SceneObj) String() string            { return proto.CompactTextString(m) }
func (*SceneObj) ProtoMessage()               {}
func (*SceneObj) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{1} }

func (m *SceneObj) GetObjType() int32 {
	if m != nil {
		return m.ObjType
	}
	return 0
}

func (m *SceneObj) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneObj) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *SceneObj) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObj) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *SceneObj) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SceneObj) GetHpMax() int64 {
	if m != nil {
		return m.HpMax
	}
	return 0
}

func (m *SceneObj) GetBuffs() []*BuffInfo {
	if m != nil {
		return m.Buffs
	}
	return nil
}

func (m *SceneObj) GetMp() int64 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *SceneObj) GetMpMax() int64 {
	if m != nil {
		return m.MpMax
	}
	return 0
}

func (m *SceneObj) GetUser() *SceneUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SceneObj) GetMonster() *SceneMonster {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *SceneObj) GetItem() *SceneItem {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *SceneObj) GetPet() *ScenePet {
	if m != nil {
		return m.Pet
	}
	return nil
}

func (m *SceneObj) GetCollection() *SceneCollection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *SceneObj) GetFit() *SceneFit {
	if m != nil {
		return m.Fit
	}
	return nil
}

func (m *SceneObj) GetSummon() *SceneSummon {
	if m != nil {
		return m.Summon
	}
	return nil
}

type SceneUser struct {
	UserId    int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Name      string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Display   *Display `protobuf:"bytes,3,opt,name=display" json:"display,omitempty"`
	Vip       int32    `protobuf:"varint,4,opt,name=vip,proto3" json:"vip,omitempty"`
	Lvl       int32    `protobuf:"varint,5,opt,name=lvl,proto3" json:"lvl,omitempty"`
	Sex       int32    `protobuf:"varint,6,opt,name=sex,proto3" json:"sex,omitempty"`
	Combat    int64    `protobuf:"varint,7,opt,name=combat,proto3" json:"combat,omitempty"`
	Avatar    string   `protobuf:"bytes,8,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Job       int32    `protobuf:"varint,9,opt,name=job,proto3" json:"job,omitempty"`
	HeroIndex int32    `protobuf:"varint,10,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	GuildId   int32    `protobuf:"varint,12,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName string   `protobuf:"bytes,13,opt,name=guildName,proto3" json:"guildName,omitempty"`
}

func (m *SceneUser) Reset()                    { *m = SceneUser{} }
func (m *SceneUser) String() string            { return proto.CompactTextString(m) }
func (*SceneUser) ProtoMessage()               {}
func (*SceneUser) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{2} }

func (m *SceneUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneUser) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *SceneUser) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *SceneUser) GetLvl() int32 {
	if m != nil {
		return m.Lvl
	}
	return 0
}

func (m *SceneUser) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *SceneUser) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *SceneUser) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *SceneUser) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *SceneUser) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *SceneUser) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SceneUser) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

type SceneMonster struct {
	Idx int32 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *SceneMonster) Reset()                    { *m = SceneMonster{} }
func (m *SceneMonster) String() string            { return proto.CompactTextString(m) }
func (*SceneMonster) ProtoMessage()               {}
func (*SceneMonster) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{3} }

func (m *SceneMonster) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type ScenePet struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Idx    int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *ScenePet) Reset()                    { *m = ScenePet{} }
func (m *ScenePet) String() string            { return proto.CompactTextString(m) }
func (*ScenePet) ProtoMessage()               {}
func (*ScenePet) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{4} }

func (m *ScenePet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ScenePet) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type SceneCollection struct {
	Id              int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CollectionObjId int32 `protobuf:"varint,2,opt,name=collectionObjId,proto3" json:"collectionObjId,omitempty"`
	ServerTime      int32 `protobuf:"varint,3,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	EndTime         int32 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *SceneCollection) Reset()                    { *m = SceneCollection{} }
func (m *SceneCollection) String() string            { return proto.CompactTextString(m) }
func (*SceneCollection) ProtoMessage()               {}
func (*SceneCollection) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{5} }

func (m *SceneCollection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SceneCollection) GetCollectionObjId() int32 {
	if m != nil {
		return m.CollectionObjId
	}
	return 0
}

func (m *SceneCollection) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *SceneCollection) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type SceneFit struct {
	UserId    int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	FitId     int32  `protobuf:"varint,2,opt,name=fitId,proto3" json:"fitId,omitempty"`
	FashionId int32  `protobuf:"varint,3,opt,name=fashionId,proto3" json:"fashionId,omitempty"`
	FashionLv int32  `protobuf:"varint,4,opt,name=fashionLv,proto3" json:"fashionLv,omitempty"`
	Name      string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	FitLv     int32  `protobuf:"varint,6,opt,name=fitLv,proto3" json:"fitLv,omitempty"`
}

func (m *SceneFit) Reset()                    { *m = SceneFit{} }
func (m *SceneFit) String() string            { return proto.CompactTextString(m) }
func (*SceneFit) ProtoMessage()               {}
func (*SceneFit) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{6} }

func (m *SceneFit) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneFit) GetFitId() int32 {
	if m != nil {
		return m.FitId
	}
	return 0
}

func (m *SceneFit) GetFashionId() int32 {
	if m != nil {
		return m.FashionId
	}
	return 0
}

func (m *SceneFit) GetFashionLv() int32 {
	if m != nil {
		return m.FashionLv
	}
	return 0
}

func (m *SceneFit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneFit) GetFitLv() int32 {
	if m != nil {
		return m.FitLv
	}
	return 0
}

type SceneSummon struct {
	UserId   int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	SummonId int32 `protobuf:"varint,2,opt,name=summonId,proto3" json:"summonId,omitempty"`
	ObjId    int32 `protobuf:"varint,3,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *SceneSummon) Reset()                    { *m = SceneSummon{} }
func (m *SceneSummon) String() string            { return proto.CompactTextString(m) }
func (*SceneSummon) ProtoMessage()               {}
func (*SceneSummon) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{7} }

func (m *SceneSummon) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneSummon) GetSummonId() int32 {
	if m != nil {
		return m.SummonId
	}
	return 0
}

func (m *SceneSummon) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type SceneItem struct {
	ItemId             int32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemNum            int32 `protobuf:"varint,3,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
	Owner              int32 `protobuf:"varint,4,opt,name=owner,proto3" json:"owner,omitempty"`
	OwnerProtectedTime int32 `protobuf:"varint,5,opt,name=ownerProtectedTime,proto3" json:"ownerProtectedTime,omitempty"`
	DisappearTime      int32 `protobuf:"varint,6,opt,name=disappearTime,proto3" json:"disappearTime,omitempty"`
}

func (m *SceneItem) Reset()                    { *m = SceneItem{} }
func (m *SceneItem) String() string            { return proto.CompactTextString(m) }
func (*SceneItem) ProtoMessage()               {}
func (*SceneItem) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{8} }

func (m *SceneItem) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *SceneItem) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *SceneItem) GetOwner() int32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *SceneItem) GetOwnerProtectedTime() int32 {
	if m != nil {
		return m.OwnerProtectedTime
	}
	return 0
}

func (m *SceneItem) GetDisappearTime() int32 {
	if m != nil {
		return m.DisappearTime
	}
	return 0
}

// 角色进入场景
type SceneEnterNtf struct {
	StageId int32       `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Objs    []*SceneObj `protobuf:"bytes,2,rep,name=objs" json:"objs,omitempty"`
}

func (m *SceneEnterNtf) Reset()                    { *m = SceneEnterNtf{} }
func (m *SceneEnterNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneEnterNtf) ProtoMessage()               {}
func (*SceneEnterNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{9} }

func (m *SceneEnterNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *SceneEnterNtf) GetObjs() []*SceneObj {
	if m != nil {
		return m.Objs
	}
	return nil
}

// 角色进入场景完成
type SceneEnterOverNtf struct {
}

func (m *SceneEnterOverNtf) Reset()                    { *m = SceneEnterOverNtf{} }
func (m *SceneEnterOverNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneEnterOverNtf) ProtoMessage()               {}
func (*SceneEnterOverNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{10} }

// 角色离开场景
type SceneLeaveNtf struct {
	ObjIds []int32 `protobuf:"varint,1,rep,packed,name=objIds" json:"objIds,omitempty"`
}

func (m *SceneLeaveNtf) Reset()                    { *m = SceneLeaveNtf{} }
func (m *SceneLeaveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneLeaveNtf) ProtoMessage()               {}
func (*SceneLeaveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{11} }

func (m *SceneLeaveNtf) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

// 角色死亡
type SceneDieNtf struct {
	ObjId     int32       `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	DropItems []*SceneObj `protobuf:"bytes,2,rep,name=dropItems" json:"dropItems,omitempty"`
}

func (m *SceneDieNtf) Reset()                    { *m = SceneDieNtf{} }
func (m *SceneDieNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneDieNtf) ProtoMessage()               {}
func (*SceneDieNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{12} }

func (m *SceneDieNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneDieNtf) GetDropItems() []*SceneObj {
	if m != nil {
		return m.DropItems
	}
	return nil
}

// 客户端攻击移动
type SceneMoveRpt struct {
	ObjId    int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Point    *Point `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	MoveType int32  `protobuf:"varint,3,opt,name=moveType,proto3" json:"moveType,omitempty"`
}

func (m *SceneMoveRpt) Reset()                    { *m = SceneMoveRpt{} }
func (m *SceneMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveRpt) ProtoMessage()               {}
func (*SceneMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{13} }

func (m *SceneMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveRpt) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneMoveRpt) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

// 推送角色移动
type SceneMoveNtf struct {
	ObjId    int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Point    *Point `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	Force    bool   `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	MoveType int32  `protobuf:"varint,4,opt,name=moveType,proto3" json:"moveType,omitempty"`
}

func (m *SceneMoveNtf) Reset()                    { *m = SceneMoveNtf{} }
func (m *SceneMoveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveNtf) ProtoMessage()               {}
func (*SceneMoveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{14} }

func (m *SceneMoveNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveNtf) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneMoveNtf) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *SceneMoveNtf) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

type SceneUserReliveNtf struct {
	Obj        *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
	ReliveType int32     `protobuf:"varint,2,opt,name=reliveType,proto3" json:"reliveType,omitempty"`
}

func (m *SceneUserReliveNtf) Reset()                    { *m = SceneUserReliveNtf{} }
func (m *SceneUserReliveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneUserReliveNtf) ProtoMessage()               {}
func (*SceneUserReliveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{15} }

func (m *SceneUserReliveNtf) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *SceneUserReliveNtf) GetReliveType() int32 {
	if m != nil {
		return m.ReliveType
	}
	return 0
}

type SceneUserUpdateNtf struct {
	ObjId   int32      `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	ObjUser *SceneUser `protobuf:"bytes,2,opt,name=objUser" json:"objUser,omitempty"`
}

func (m *SceneUserUpdateNtf) Reset()                    { *m = SceneUserUpdateNtf{} }
func (m *SceneUserUpdateNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneUserUpdateNtf) ProtoMessage()               {}
func (*SceneUserUpdateNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{16} }

func (m *SceneUserUpdateNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneUserUpdateNtf) GetObjUser() *SceneUser {
	if m != nil {
		return m.ObjUser
	}
	return nil
}

// 客户端攻击请求
type AttackRpt struct {
	SkillId    int32   `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	ObjIds     []int32 `protobuf:"varint,2,rep,packed,name=objIds" json:"objIds,omitempty"`
	Dir        int32   `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	Point      *Point  `protobuf:"bytes,4,opt,name=point" json:"point,omitempty"`
	SkillLevel int32   `protobuf:"varint,5,opt,name=skillLevel,proto3" json:"skillLevel,omitempty"`
	ObjId      int32   `protobuf:"varint,6,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *AttackRpt) Reset()                    { *m = AttackRpt{} }
func (m *AttackRpt) String() string            { return proto.CompactTextString(m) }
func (*AttackRpt) ProtoMessage()               {}
func (*AttackRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{17} }

func (m *AttackRpt) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackRpt) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *AttackRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *AttackRpt) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *AttackRpt) GetSkillLevel() int32 {
	if m != nil {
		return m.SkillLevel
	}
	return 0
}

func (m *AttackRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

// 攻击结果及效果返回
type AttackEffectNtf struct {
	SkillId     int32         `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	AttackerId  int32         `protobuf:"varint,2,opt,name=attackerId,proto3" json:"attackerId,omitempty"`
	Dir         int32         `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	Point       *Point        `protobuf:"bytes,4,opt,name=point" json:"point,omitempty"`
	Hurts       []*HurtEffect `protobuf:"bytes,5,rep,name=hurts" json:"hurts,omitempty"`
	MoveToPoint *Point        `protobuf:"bytes,6,opt,name=MoveToPoint" json:"MoveToPoint,omitempty"`
	SkillLv     int32         `protobuf:"varint,7,opt,name=skillLv,proto3" json:"skillLv,omitempty"`
	Err         int32         `protobuf:"varint,8,opt,name=err,proto3" json:"err,omitempty"`
	SkillStartT int64         `protobuf:"varint,9,opt,name=skillStartT,proto3" json:"skillStartT,omitempty"`
	SkillStopT  int64         `protobuf:"varint,10,opt,name=skillStopT,proto3" json:"skillStopT,omitempty"`
	ServerTime  int64         `protobuf:"varint,11,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	MpNow       int64         `protobuf:"varint,12,opt,name=mpNow,proto3" json:"mpNow,omitempty"`
}

func (m *AttackEffectNtf) Reset()                    { *m = AttackEffectNtf{} }
func (m *AttackEffectNtf) String() string            { return proto.CompactTextString(m) }
func (*AttackEffectNtf) ProtoMessage()               {}
func (*AttackEffectNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{18} }

func (m *AttackEffectNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackEffectNtf) GetAttackerId() int32 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *AttackEffectNtf) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *AttackEffectNtf) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *AttackEffectNtf) GetHurts() []*HurtEffect {
	if m != nil {
		return m.Hurts
	}
	return nil
}

func (m *AttackEffectNtf) GetMoveToPoint() *Point {
	if m != nil {
		return m.MoveToPoint
	}
	return nil
}

func (m *AttackEffectNtf) GetSkillLv() int32 {
	if m != nil {
		return m.SkillLv
	}
	return 0
}

func (m *AttackEffectNtf) GetErr() int32 {
	if m != nil {
		return m.Err
	}
	return 0
}

func (m *AttackEffectNtf) GetSkillStartT() int64 {
	if m != nil {
		return m.SkillStartT
	}
	return 0
}

func (m *AttackEffectNtf) GetSkillStopT() int64 {
	if m != nil {
		return m.SkillStopT
	}
	return 0
}

func (m *AttackEffectNtf) GetServerTime() int64 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *AttackEffectNtf) GetMpNow() int64 {
	if m != nil {
		return m.MpNow
	}
	return 0
}

type HurtEffect struct {
	ObjId       int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Hp          int64  `protobuf:"varint,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ChangHp     int64  `protobuf:"varint,3,opt,name=changHp,proto3" json:"changHp,omitempty"`
	IsDeath     bool   `protobuf:"varint,4,opt,name=isDeath,proto3" json:"isDeath,omitempty"`
	IsDodge     bool   `protobuf:"varint,5,opt,name=isDodge,proto3" json:"isDodge,omitempty"`
	HurtType    int32  `protobuf:"varint,6,opt,name=hurtType,proto3" json:"hurtType,omitempty"`
	Hurt        int64  `protobuf:"varint,7,opt,name=hurt,proto3" json:"hurt,omitempty"`
	Deathblow   int64  `protobuf:"varint,8,opt,name=deathblow,proto3" json:"deathblow,omitempty"`
	CutHurt     int64  `protobuf:"varint,9,opt,name=cutHurt,proto3" json:"cutHurt,omitempty"`
	MoveToPoint *Point `protobuf:"bytes,10,opt,name=MoveToPoint" json:"MoveToPoint,omitempty"`
	UnBlock     int64  `protobuf:"varint,11,opt,name=unBlock,proto3" json:"unBlock,omitempty"`
	Reflex      int64  `protobuf:"varint,12,opt,name=reflex,proto3" json:"reflex,omitempty"`
	ReliveSelf  bool   `protobuf:"varint,13,opt,name=reliveSelf,proto3" json:"reliveSelf,omitempty"`
}

func (m *HurtEffect) Reset()                    { *m = HurtEffect{} }
func (m *HurtEffect) String() string            { return proto.CompactTextString(m) }
func (*HurtEffect) ProtoMessage()               {}
func (*HurtEffect) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{19} }

func (m *HurtEffect) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *HurtEffect) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *HurtEffect) GetChangHp() int64 {
	if m != nil {
		return m.ChangHp
	}
	return 0
}

func (m *HurtEffect) GetIsDeath() bool {
	if m != nil {
		return m.IsDeath
	}
	return false
}

func (m *HurtEffect) GetIsDodge() bool {
	if m != nil {
		return m.IsDodge
	}
	return false
}

func (m *HurtEffect) GetHurtType() int32 {
	if m != nil {
		return m.HurtType
	}
	return 0
}

func (m *HurtEffect) GetHurt() int64 {
	if m != nil {
		return m.Hurt
	}
	return 0
}

func (m *HurtEffect) GetDeathblow() int64 {
	if m != nil {
		return m.Deathblow
	}
	return 0
}

func (m *HurtEffect) GetCutHurt() int64 {
	if m != nil {
		return m.CutHurt
	}
	return 0
}

func (m *HurtEffect) GetMoveToPoint() *Point {
	if m != nil {
		return m.MoveToPoint
	}
	return nil
}

func (m *HurtEffect) GetUnBlock() int64 {
	if m != nil {
		return m.UnBlock
	}
	return 0
}

func (m *HurtEffect) GetReflex() int64 {
	if m != nil {
		return m.Reflex
	}
	return 0
}

func (m *HurtEffect) GetReliveSelf() bool {
	if m != nil {
		return m.ReliveSelf
	}
	return false
}

// 主动推送角色血量
type SceneObjHpNtf struct {
	ObjId    int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Hp       int64 `protobuf:"varint,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ChangeHp int64 `protobuf:"varint,3,opt,name=changeHp,proto3" json:"changeHp,omitempty"`
	TotalHp  int64 `protobuf:"varint,4,opt,name=totalHp,proto3" json:"totalHp,omitempty"`
}

func (m *SceneObjHpNtf) Reset()                    { *m = SceneObjHpNtf{} }
func (m *SceneObjHpNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneObjHpNtf) ProtoMessage()               {}
func (*SceneObjHpNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{20} }

func (m *SceneObjHpNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObjHpNtf) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SceneObjHpNtf) GetChangeHp() int64 {
	if m != nil {
		return m.ChangeHp
	}
	return 0
}

func (m *SceneObjHpNtf) GetTotalHp() int64 {
	if m != nil {
		return m.TotalHp
	}
	return 0
}

// 主动推送角色蓝量
type SceneObjMpNtf struct {
	ObjId    int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Mp       int64 `protobuf:"varint,2,opt,name=Mp,proto3" json:"Mp,omitempty"`
	ChangeMp int64 `protobuf:"varint,3,opt,name=changeMp,proto3" json:"changeMp,omitempty"`
	TotalMp  int64 `protobuf:"varint,4,opt,name=totalMp,proto3" json:"totalMp,omitempty"`
}

func (m *SceneObjMpNtf) Reset()                    { *m = SceneObjMpNtf{} }
func (m *SceneObjMpNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneObjMpNtf) ProtoMessage()               {}
func (*SceneObjMpNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{21} }

func (m *SceneObjMpNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObjMpNtf) GetMp() int64 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *SceneObjMpNtf) GetChangeMp() int64 {
	if m != nil {
		return m.ChangeMp
	}
	return 0
}

func (m *SceneObjMpNtf) GetTotalMp() int64 {
	if m != nil {
		return m.TotalMp
	}
	return 0
}

// 获取战斗伤害排行榜
type FightHurtRankReq struct {
}

func (m *FightHurtRankReq) Reset()                    { *m = FightHurtRankReq{} }
func (m *FightHurtRankReq) String() string            { return proto.CompactTextString(m) }
func (*FightHurtRankReq) ProtoMessage()               {}
func (*FightHurtRankReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{22} }

// 获取战斗伤害排行榜
type FightHurtRankAck struct {
	Ranks  []*FightRankUnit `protobuf:"bytes,1,rep,name=ranks" json:"ranks,omitempty"`
	MyRank *FightRankUnit   `protobuf:"bytes,2,opt,name=myRank" json:"myRank,omitempty"`
}

func (m *FightHurtRankAck) Reset()                    { *m = FightHurtRankAck{} }
func (m *FightHurtRankAck) String() string            { return proto.CompactTextString(m) }
func (*FightHurtRankAck) ProtoMessage()               {}
func (*FightHurtRankAck) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{23} }

func (m *FightHurtRankAck) GetRanks() []*FightRankUnit {
	if m != nil {
		return m.Ranks
	}
	return nil
}

func (m *FightHurtRankAck) GetMyRank() *FightRankUnit {
	if m != nil {
		return m.MyRank
	}
	return nil
}

// 排行榜单元数据
type FightRankUnit struct {
	Rank  int32  `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Score int64  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *FightRankUnit) Reset()                    { *m = FightRankUnit{} }
func (m *FightRankUnit) String() string            { return proto.CompactTextString(m) }
func (*FightRankUnit) ProtoMessage()               {}
func (*FightRankUnit) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{24} }

func (m *FightRankUnit) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *FightRankUnit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FightRankUnit) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 获取boss归属
type GetBossOwnerChangReq struct {
}

func (m *GetBossOwnerChangReq) Reset()                    { *m = GetBossOwnerChangReq{} }
func (m *GetBossOwnerChangReq) String() string            { return proto.CompactTextString(m) }
func (*GetBossOwnerChangReq) ProtoMessage()               {}
func (*GetBossOwnerChangReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{25} }

// 获取boss归属
type BossOwnerChangNtf struct {
	ObjId      int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	OwnerObjId int32 `protobuf:"varint,2,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	UserId     int32 `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *BossOwnerChangNtf) Reset()                    { *m = BossOwnerChangNtf{} }
func (m *BossOwnerChangNtf) String() string            { return proto.CompactTextString(m) }
func (*BossOwnerChangNtf) ProtoMessage()               {}
func (*BossOwnerChangNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{26} }

func (m *BossOwnerChangNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *BossOwnerChangNtf) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BossOwnerChangNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type BuffChangeNtf struct {
	Buff         *BuffInfo      `protobuf:"bytes,1,opt,name=buff" json:"buff,omitempty"`
	DelBuffInfos []*DelBuffInfo `protobuf:"bytes,2,rep,name=delBuffInfos" json:"delBuffInfos,omitempty"`
}

func (m *BuffChangeNtf) Reset()                    { *m = BuffChangeNtf{} }
func (m *BuffChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffChangeNtf) ProtoMessage()               {}
func (*BuffChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{27} }

func (m *BuffChangeNtf) GetBuff() *BuffInfo {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *BuffChangeNtf) GetDelBuffInfos() []*DelBuffInfo {
	if m != nil {
		return m.DelBuffInfos
	}
	return nil
}

type BuffDelNtf struct {
	DelBuffInfos []*DelBuffInfo `protobuf:"bytes,1,rep,name=delBuffInfos" json:"delBuffInfos,omitempty"`
}

func (m *BuffDelNtf) Reset()                    { *m = BuffDelNtf{} }
func (m *BuffDelNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffDelNtf) ProtoMessage()               {}
func (*BuffDelNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{28} }

func (m *BuffDelNtf) GetDelBuffInfos() []*DelBuffInfo {
	if m != nil {
		return m.DelBuffInfos
	}
	return nil
}

type BuffInfo struct {
	OwnerObjId  int32 `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	SourceObjId int32 `protobuf:"varint,2,opt,name=sourceObjId,proto3" json:"sourceObjId,omitempty"`
	Idx         int32 `protobuf:"varint,3,opt,name=idx,proto3" json:"idx,omitempty"`
	BuffId      int32 `protobuf:"varint,4,opt,name=buffId,proto3" json:"buffId,omitempty"`
	TotalTime   int64 `protobuf:"varint,5,opt,name=totalTime,proto3" json:"totalTime,omitempty"`
}

func (m *BuffInfo) Reset()                    { *m = BuffInfo{} }
func (m *BuffInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffInfo) ProtoMessage()               {}
func (*BuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{29} }

func (m *BuffInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BuffInfo) GetSourceObjId() int32 {
	if m != nil {
		return m.SourceObjId
	}
	return 0
}

func (m *BuffInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffInfo) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *BuffInfo) GetTotalTime() int64 {
	if m != nil {
		return m.TotalTime
	}
	return 0
}

type DelBuffInfo struct {
	OwnerObjId int32 `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	Idx        int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *DelBuffInfo) Reset()                    { *m = DelBuffInfo{} }
func (m *DelBuffInfo) String() string            { return proto.CompactTextString(m) }
func (*DelBuffInfo) ProtoMessage()               {}
func (*DelBuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{30} }

func (m *DelBuffInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *DelBuffInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type BuffPropChangeNtf struct {
	ObjId  int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	PropId int32 `protobuf:"varint,2,opt,name=propId,proto3" json:"propId,omitempty"`
	Total  int64 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *BuffPropChangeNtf) Reset()                    { *m = BuffPropChangeNtf{} }
func (m *BuffPropChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffPropChangeNtf) ProtoMessage()               {}
func (*BuffPropChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{31} }

func (m *BuffPropChangeNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *BuffPropChangeNtf) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *BuffPropChangeNtf) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type BuffHpChangeNtf struct {
	BuffHpChangeInfos []*BuffHpChangeInfo `protobuf:"bytes,1,rep,name=buffHpChangeInfos" json:"buffHpChangeInfos,omitempty"`
}

func (m *BuffHpChangeNtf) Reset()                    { *m = BuffHpChangeNtf{} }
func (m *BuffHpChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeNtf) ProtoMessage()               {}
func (*BuffHpChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{32} }

func (m *BuffHpChangeNtf) GetBuffHpChangeInfos() []*BuffHpChangeInfo {
	if m != nil {
		return m.BuffHpChangeInfos
	}
	return nil
}

type BuffHpChangeInfo struct {
	OwnerObjId int32 `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	Idx        int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Death      int32 `protobuf:"varint,3,opt,name=death,proto3" json:"death,omitempty"`
	ChangeHp   int64 `protobuf:"varint,4,opt,name=changeHp,proto3" json:"changeHp,omitempty"`
	TotalHp    int64 `protobuf:"varint,5,opt,name=totalHp,proto3" json:"totalHp,omitempty"`
}

func (m *BuffHpChangeInfo) Reset()                    { *m = BuffHpChangeInfo{} }
func (m *BuffHpChangeInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeInfo) ProtoMessage()               {}
func (*BuffHpChangeInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{33} }

func (m *BuffHpChangeInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BuffHpChangeInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffHpChangeInfo) GetDeath() int32 {
	if m != nil {
		return m.Death
	}
	return 0
}

func (m *BuffHpChangeInfo) GetChangeHp() int64 {
	if m != nil {
		return m.ChangeHp
	}
	return 0
}

func (m *BuffHpChangeInfo) GetTotalHp() int64 {
	if m != nil {
		return m.TotalHp
	}
	return 0
}

type MainCityEnterRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityEnterRpt) Reset()                    { *m = MainCityEnterRpt{} }
func (m *MainCityEnterRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityEnterRpt) ProtoMessage()               {}
func (*MainCityEnterRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{34} }

func (m *MainCityEnterRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type MainCityMoveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Dir   int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *MainCityMoveRpt) Reset()                    { *m = MainCityMoveRpt{} }
func (m *MainCityMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityMoveRpt) ProtoMessage()               {}
func (*MainCityMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{35} }

func (m *MainCityMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *MainCityMoveRpt) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MainCityMoveRpt) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MainCityMoveRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type MainCityLeaveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *MainCityLeaveRpt) Reset()                    { *m = MainCityLeaveRpt{} }
func (m *MainCityLeaveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityLeaveRpt) ProtoMessage()               {}
func (*MainCityLeaveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{36} }

func (m *MainCityLeaveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type MainCityUpdateRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityUpdateRpt) Reset()                    { *m = MainCityUpdateRpt{} }
func (m *MainCityUpdateRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityUpdateRpt) ProtoMessage()               {}
func (*MainCityUpdateRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{37} }

func (m *MainCityUpdateRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type FightEnterOkReq struct {
}

func (m *FightEnterOkReq) Reset()                    { *m = FightEnterOkReq{} }
func (m *FightEnterOkReq) String() string            { return proto.CompactTextString(m) }
func (*FightEnterOkReq) ProtoMessage()               {}
func (*FightEnterOkReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{38} }

type FightStartCountDownNtf struct {
	ServerTime    int32 `protobuf:"varint,1,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	CountDownTime int32 `protobuf:"varint,2,opt,name=countDownTime,proto3" json:"countDownTime,omitempty"`
}

func (m *FightStartCountDownNtf) Reset()                    { *m = FightStartCountDownNtf{} }
func (m *FightStartCountDownNtf) String() string            { return proto.CompactTextString(m) }
func (*FightStartCountDownNtf) ProtoMessage()               {}
func (*FightStartCountDownNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{39} }

func (m *FightStartCountDownNtf) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *FightStartCountDownNtf) GetCountDownTime() int32 {
	if m != nil {
		return m.CountDownTime
	}
	return 0
}

type FightStartCountDownOkReq struct {
}

func (m *FightStartCountDownOkReq) Reset()                    { *m = FightStartCountDownOkReq{} }
func (m *FightStartCountDownOkReq) String() string            { return proto.CompactTextString(m) }
func (*FightStartCountDownOkReq) ProtoMessage()               {}
func (*FightStartCountDownOkReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{40} }

type FightStartNtf struct {
}

func (m *FightStartNtf) Reset()                    { *m = FightStartNtf{} }
func (m *FightStartNtf) String() string            { return proto.CompactTextString(m) }
func (*FightStartNtf) ProtoMessage()               {}
func (*FightStartNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{41} }

type CollectionStatusChangeNtf struct {
	ObjId     int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	UserObjId int32 `protobuf:"varint,2,opt,name=userObjId,proto3" json:"userObjId,omitempty"`
	StartTime int64 `protobuf:"varint,3,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *CollectionStatusChangeNtf) Reset()                    { *m = CollectionStatusChangeNtf{} }
func (m *CollectionStatusChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*CollectionStatusChangeNtf) ProtoMessage()               {}
func (*CollectionStatusChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{42} }

func (m *CollectionStatusChangeNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetUserObjId() int32 {
	if m != nil {
		return m.UserObjId
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// -----------------系统功能模块------------------
type ExpStageKillInfoNtf struct {
	KillMonsterNum int32 `protobuf:"varint,1,opt,name=killMonsterNum,proto3" json:"killMonsterNum,omitempty"`
	GetExp         int32 `protobuf:"varint,2,opt,name=getExp,proto3" json:"getExp,omitempty"`
}

func (m *ExpStageKillInfoNtf) Reset()                    { *m = ExpStageKillInfoNtf{} }
func (m *ExpStageKillInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*ExpStageKillInfoNtf) ProtoMessage()               {}
func (*ExpStageKillInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{43} }

func (m *ExpStageKillInfoNtf) GetKillMonsterNum() int32 {
	if m != nil {
		return m.KillMonsterNum
	}
	return 0
}

func (m *ExpStageKillInfoNtf) GetGetExp() int32 {
	if m != nil {
		return m.GetExp
	}
	return 0
}

// 获取泡点占领者
type PaodianTopUserReq struct {
}

func (m *PaodianTopUserReq) Reset()                    { *m = PaodianTopUserReq{} }
func (m *PaodianTopUserReq) String() string            { return proto.CompactTextString(m) }
func (*PaodianTopUserReq) ProtoMessage()               {}
func (*PaodianTopUserReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{44} }

// 推送泡点占领者
type PaodianTopUserNtf struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=userIds" json:"userIds,omitempty"`
}

func (m *PaodianTopUserNtf) Reset()                    { *m = PaodianTopUserNtf{} }
func (m *PaodianTopUserNtf) String() string            { return proto.CompactTextString(m) }
func (*PaodianTopUserNtf) ProtoMessage()               {}
func (*PaodianTopUserNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{45} }

func (m *PaodianTopUserNtf) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type PaoDianUserNumNtf struct {
	UserNums map[int32]int32 `protobuf:"bytes,1,rep,name=userNums" json:"userNums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *PaoDianUserNumNtf) Reset()                    { *m = PaoDianUserNumNtf{} }
func (m *PaoDianUserNumNtf) String() string            { return proto.CompactTextString(m) }
func (*PaoDianUserNumNtf) ProtoMessage()               {}
func (*PaoDianUserNumNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{46} }

func (m *PaoDianUserNumNtf) GetUserNums() map[int32]int32 {
	if m != nil {
		return m.UserNums
	}
	return nil
}

type PaodianFightEnd struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *PaodianFightEnd) Reset()                    { *m = PaodianFightEnd{} }
func (m *PaodianFightEnd) String() string            { return proto.CompactTextString(m) }
func (*PaodianFightEnd) ProtoMessage()               {}
func (*PaodianFightEnd) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{47} }

func (m *PaodianFightEnd) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

type GetShabakeScoresReq struct {
}

func (m *GetShabakeScoresReq) Reset()                    { *m = GetShabakeScoresReq{} }
func (m *GetShabakeScoresReq) String() string            { return proto.CompactTextString(m) }
func (*GetShabakeScoresReq) ProtoMessage()               {}
func (*GetShabakeScoresReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{48} }

type ShabakeScoreRankNtf struct {
	UserScores  []*ShabakeUserScore  `protobuf:"bytes,1,rep,name=userScores" json:"userScores,omitempty"`
	GuildScores []*ShabakeGuildScore `protobuf:"bytes,2,rep,name=guildScores" json:"guildScores,omitempty"`
}

func (m *ShabakeScoreRankNtf) Reset()                    { *m = ShabakeScoreRankNtf{} }
func (m *ShabakeScoreRankNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeScoreRankNtf) ProtoMessage()               {}
func (*ShabakeScoreRankNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{49} }

func (m *ShabakeScoreRankNtf) GetUserScores() []*ShabakeUserScore {
	if m != nil {
		return m.UserScores
	}
	return nil
}

func (m *ShabakeScoreRankNtf) GetGuildScores() []*ShabakeGuildScore {
	if m != nil {
		return m.GuildScores
	}
	return nil
}

type ShabakeUserScore struct {
	UserId   int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName string `protobuf:"bytes,2,opt,name=userName,proto3" json:"userName,omitempty"`
	Score    int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *ShabakeUserScore) Reset()                    { *m = ShabakeUserScore{} }
func (m *ShabakeUserScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeUserScore) ProtoMessage()               {}
func (*ShabakeUserScore) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{50} }

func (m *ShabakeUserScore) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShabakeUserScore) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShabakeUserScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ShabakeGuildScore struct {
	GuildId   int32  `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName string `protobuf:"bytes,2,opt,name=guildName,proto3" json:"guildName,omitempty"`
	Score     int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *ShabakeGuildScore) Reset()                    { *m = ShabakeGuildScore{} }
func (m *ShabakeGuildScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeGuildScore) ProtoMessage()               {}
func (*ShabakeGuildScore) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{51} }

func (m *ShabakeGuildScore) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeGuildScore) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *ShabakeGuildScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ShabakeOccupiedNtf struct {
	IsOccupy  bool   `protobuf:"varint,1,opt,name=isOccupy,proto3" json:"isOccupy,omitempty"`
	UserId    int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName  string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
	GuildId   int32  `protobuf:"varint,4,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName string `protobuf:"bytes,5,opt,name=guildName,proto3" json:"guildName,omitempty"`
	StartTime int32  `protobuf:"varint,6,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int32  `protobuf:"varint,7,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *ShabakeOccupiedNtf) Reset()                    { *m = ShabakeOccupiedNtf{} }
func (m *ShabakeOccupiedNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeOccupiedNtf) ProtoMessage()               {}
func (*ShabakeOccupiedNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{52} }

func (m *ShabakeOccupiedNtf) GetIsOccupy() bool {
	if m != nil {
		return m.IsOccupy
	}
	return false
}

func (m *ShabakeOccupiedNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShabakeOccupiedNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *ShabakeOccupiedNtf) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func init() {
	proto.RegisterType((*Point)(nil), "pb.Point")
	proto.RegisterType((*SceneObj)(nil), "pb.SceneObj")
	proto.RegisterType((*SceneUser)(nil), "pb.SceneUser")
	proto.RegisterType((*SceneMonster)(nil), "pb.SceneMonster")
	proto.RegisterType((*ScenePet)(nil), "pb.ScenePet")
	proto.RegisterType((*SceneCollection)(nil), "pb.SceneCollection")
	proto.RegisterType((*SceneFit)(nil), "pb.SceneFit")
	proto.RegisterType((*SceneSummon)(nil), "pb.SceneSummon")
	proto.RegisterType((*SceneItem)(nil), "pb.SceneItem")
	proto.RegisterType((*SceneEnterNtf)(nil), "pb.SceneEnterNtf")
	proto.RegisterType((*SceneEnterOverNtf)(nil), "pb.SceneEnterOverNtf")
	proto.RegisterType((*SceneLeaveNtf)(nil), "pb.SceneLeaveNtf")
	proto.RegisterType((*SceneDieNtf)(nil), "pb.SceneDieNtf")
	proto.RegisterType((*SceneMoveRpt)(nil), "pb.SceneMoveRpt")
	proto.RegisterType((*SceneMoveNtf)(nil), "pb.SceneMoveNtf")
	proto.RegisterType((*SceneUserReliveNtf)(nil), "pb.SceneUserReliveNtf")
	proto.RegisterType((*SceneUserUpdateNtf)(nil), "pb.SceneUserUpdateNtf")
	proto.RegisterType((*AttackRpt)(nil), "pb.AttackRpt")
	proto.RegisterType((*AttackEffectNtf)(nil), "pb.AttackEffectNtf")
	proto.RegisterType((*HurtEffect)(nil), "pb.HurtEffect")
	proto.RegisterType((*SceneObjHpNtf)(nil), "pb.SceneObjHpNtf")
	proto.RegisterType((*SceneObjMpNtf)(nil), "pb.SceneObjMpNtf")
	proto.RegisterType((*FightHurtRankReq)(nil), "pb.FightHurtRankReq")
	proto.RegisterType((*FightHurtRankAck)(nil), "pb.FightHurtRankAck")
	proto.RegisterType((*FightRankUnit)(nil), "pb.FightRankUnit")
	proto.RegisterType((*GetBossOwnerChangReq)(nil), "pb.GetBossOwnerChangReq")
	proto.RegisterType((*BossOwnerChangNtf)(nil), "pb.BossOwnerChangNtf")
	proto.RegisterType((*BuffChangeNtf)(nil), "pb.BuffChangeNtf")
	proto.RegisterType((*BuffDelNtf)(nil), "pb.BuffDelNtf")
	proto.RegisterType((*BuffInfo)(nil), "pb.BuffInfo")
	proto.RegisterType((*DelBuffInfo)(nil), "pb.DelBuffInfo")
	proto.RegisterType((*BuffPropChangeNtf)(nil), "pb.BuffPropChangeNtf")
	proto.RegisterType((*BuffHpChangeNtf)(nil), "pb.BuffHpChangeNtf")
	proto.RegisterType((*BuffHpChangeInfo)(nil), "pb.BuffHpChangeInfo")
	proto.RegisterType((*MainCityEnterRpt)(nil), "pb.MainCityEnterRpt")
	proto.RegisterType((*MainCityMoveRpt)(nil), "pb.MainCityMoveRpt")
	proto.RegisterType((*MainCityLeaveRpt)(nil), "pb.MainCityLeaveRpt")
	proto.RegisterType((*MainCityUpdateRpt)(nil), "pb.MainCityUpdateRpt")
	proto.RegisterType((*FightEnterOkReq)(nil), "pb.FightEnterOkReq")
	proto.RegisterType((*FightStartCountDownNtf)(nil), "pb.FightStartCountDownNtf")
	proto.RegisterType((*FightStartCountDownOkReq)(nil), "pb.FightStartCountDownOkReq")
	proto.RegisterType((*FightStartNtf)(nil), "pb.FightStartNtf")
	proto.RegisterType((*CollectionStatusChangeNtf)(nil), "pb.CollectionStatusChangeNtf")
	proto.RegisterType((*ExpStageKillInfoNtf)(nil), "pb.ExpStageKillInfoNtf")
	proto.RegisterType((*PaodianTopUserReq)(nil), "pb.PaodianTopUserReq")
	proto.RegisterType((*PaodianTopUserNtf)(nil), "pb.PaodianTopUserNtf")
	proto.RegisterType((*PaoDianUserNumNtf)(nil), "pb.PaoDianUserNumNtf")
	proto.RegisterType((*PaodianFightEnd)(nil), "pb.PaodianFightEnd")
	proto.RegisterType((*GetShabakeScoresReq)(nil), "pb.GetShabakeScoresReq")
	proto.RegisterType((*ShabakeScoreRankNtf)(nil), "pb.ShabakeScoreRankNtf")
	proto.RegisterType((*ShabakeUserScore)(nil), "pb.ShabakeUserScore")
	proto.RegisterType((*ShabakeGuildScore)(nil), "pb.ShabakeGuildScore")
	proto.RegisterType((*ShabakeOccupiedNtf)(nil), "pb.ShabakeOccupiedNtf")
}
func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Y))
	}
	return i, nil
}

func (m *SceneObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjType))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n1, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TeamId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.HpMax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, msg := range m.Buffs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Mp != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Mp))
	}
	if m.MpMax != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MpMax))
	}
	if m.User != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.User.Size()))
		n2, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Monster != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Monster.Size()))
		n3, err := m.Monster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Item != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Item.Size()))
		n4, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Pet != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Pet.Size()))
		n5, err := m.Pet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Collection != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Collection.Size()))
		n6, err := m.Collection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Fit != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Fit.Size()))
		n7, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Summon != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Summon.Size()))
		n8, err := m.Summon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SceneUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Display != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Display.Size()))
		n9, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Vip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Vip))
	}
	if m.Lvl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Lvl))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Sex))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Combat))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Job != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Job))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HeroIndex))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	return i, nil
}

func (m *SceneMonster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMonster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *ScenePet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScenePet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *SceneCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Id))
	}
	if m.CollectionObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CollectionObjId))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *SceneFit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneFit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.FitId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FitId))
	}
	if m.FashionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FashionLv))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.FitLv != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FitLv))
	}
	return i, nil
}

func (m *SceneSummon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneSummon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.SummonId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SummonId))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *SceneItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ItemNum))
	}
	if m.Owner != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Owner))
	}
	if m.OwnerProtectedTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerProtectedTime))
	}
	if m.DisappearTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.DisappearTime))
	}
	return i, nil
}

func (m *SceneEnterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneEnterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StageId))
	}
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SceneEnterOverNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneEnterOverNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SceneLeaveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneLeaveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		dAtA11 := make([]byte, len(m.ObjIds)*10)
		var j10 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *SceneDieNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneDieNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if len(m.DropItems) > 0 {
		for _, msg := range m.DropItems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SceneMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n12, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveType))
	}
	return i, nil
}

func (m *SceneMoveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n13, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Force {
		dAtA[i] = 0x18
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveType))
	}
	return i, nil
}

func (m *SceneUserReliveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUserReliveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n14, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ReliveType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ReliveType))
	}
	return i, nil
}

func (m *SceneUserUpdateNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUserUpdateNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.ObjUser != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjUser.Size()))
		n15, err := m.ObjUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *AttackRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		dAtA17 := make([]byte, len(m.ObjIds)*10)
		var j16 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.Point != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n18, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.SkillLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillLevel))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *AttackEffectNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackEffectNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.AttackerId))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.Point != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n19, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Hurts) > 0 {
		for _, msg := range m.Hurts {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MoveToPoint != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveToPoint.Size()))
		n20, err := m.MoveToPoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.SkillLv != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillLv))
	}
	if m.Err != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Err))
	}
	if m.SkillStartT != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillStartT))
	}
	if m.SkillStopT != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillStopT))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.MpNow != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MpNow))
	}
	return i, nil
}

func (m *HurtEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HurtEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.ChangHp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangHp))
	}
	if m.IsDeath {
		dAtA[i] = 0x20
		i++
		if m.IsDeath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDodge {
		dAtA[i] = 0x28
		i++
		if m.IsDodge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HurtType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HurtType))
	}
	if m.Hurt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hurt))
	}
	if m.Deathblow != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Deathblow))
	}
	if m.CutHurt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CutHurt))
	}
	if m.MoveToPoint != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveToPoint.Size()))
		n21, err := m.MoveToPoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.UnBlock != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UnBlock))
	}
	if m.Reflex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Reflex))
	}
	if m.ReliveSelf {
		dAtA[i] = 0x68
		i++
		if m.ReliveSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SceneObjHpNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObjHpNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.ChangeHp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalHp))
	}
	return i, nil
}

func (m *SceneObjMpNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObjMpNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Mp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Mp))
	}
	if m.ChangeMp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeMp))
	}
	if m.TotalMp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalMp))
	}
	return i, nil
}

func (m *FightHurtRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightHurtRankReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightHurtRankAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightHurtRankAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		for _, msg := range m.Ranks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MyRank != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MyRank.Size()))
		n22, err := m.MyRank.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *FightRankUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightRankUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Rank))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *GetBossOwnerChangReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBossOwnerChangReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BossOwnerChangNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossOwnerChangNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *BuffChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Buff != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Buff.Size()))
		n23, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.DelBuffInfos) > 0 {
		for _, msg := range m.DelBuffInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffDelNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffDelNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DelBuffInfos) > 0 {
		for _, msg := range m.DelBuffInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.SourceObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SourceObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	if m.BuffId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.BuffId))
	}
	if m.TotalTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalTime))
	}
	return i, nil
}

func (m *DelBuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelBuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *BuffPropChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffPropChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.PropId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.PropId))
	}
	if m.Total != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func (m *BuffHpChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, msg := range m.BuffHpChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffHpChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	if m.Death != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Death))
	}
	if m.ChangeHp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalHp))
	}
	return i, nil
}

func (m *MainCityEnterRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityEnterRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n24, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *MainCityMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Y))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *MainCityLeaveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityLeaveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *MainCityUpdateRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityUpdateRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n25, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *FightEnterOkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightEnterOkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightStartCountDownNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartCountDownNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.CountDownTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CountDownTime))
	}
	return i, nil
}

func (m *FightStartCountDownOkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartCountDownOkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightStartNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CollectionStatusChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionStatusChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.UserObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserObjId))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *ExpStageKillInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStageKillInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KillMonsterNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.KillMonsterNum))
	}
	if m.GetExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GetExp))
	}
	return i, nil
}

func (m *PaodianTopUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianTopUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PaodianTopUserNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianTopUserNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA27 := make([]byte, len(m.UserIds)*10)
		var j26 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	return i, nil
}

func (m *PaoDianUserNumNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaoDianUserNumNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserNums) > 0 {
		for k, _ := range m.UserNums {
			dAtA[i] = 0xa
			i++
			v := m.UserNums[k]
			mapSize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			i = encodeVarintScene(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintScene(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintScene(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PaodianFightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianFightEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *GetShabakeScoresReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShabakeScoresReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShabakeScoreRankNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeScoreRankNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, msg := range m.UserScores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildScores) > 0 {
		for _, msg := range m.GuildScores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeUserScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeUserScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ShabakeGuildScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeGuildScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuildId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ShabakeOccupiedNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeOccupiedNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOccupy {
		dAtA[i] = 0x8
		i++
		if m.IsOccupy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func encodeVarintScene(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovScene(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene(uint64(m.Y))
	}
	return n
}

func (m *SceneObj) Size() (n int) {
	var l int
	_ = l
	if m.ObjType != 0 {
		n += 1 + sovScene(uint64(m.ObjType))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		n += 1 + sovScene(uint64(m.TeamId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.HpMax != 0 {
		n += 1 + sovScene(uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, e := range m.Buffs {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.Mp != 0 {
		n += 1 + sovScene(uint64(m.Mp))
	}
	if m.MpMax != 0 {
		n += 1 + sovScene(uint64(m.MpMax))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Monster != nil {
		l = m.Monster.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Pet != nil {
		l = m.Pet.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Collection != nil {
		l = m.Collection.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Summon != nil {
		l = m.Summon.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	return n
}

func (m *SceneUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovScene(uint64(m.Vip))
	}
	if m.Lvl != 0 {
		n += 1 + sovScene(uint64(m.Lvl))
	}
	if m.Sex != 0 {
		n += 1 + sovScene(uint64(m.Sex))
	}
	if m.Combat != 0 {
		n += 1 + sovScene(uint64(m.Combat))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Job != 0 {
		n += 1 + sovScene(uint64(m.Job))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovScene(uint64(m.HeroIndex))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *SceneMonster) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	return n
}

func (m *ScenePet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	return n
}

func (m *SceneCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScene(uint64(m.Id))
	}
	if m.CollectionObjId != 0 {
		n += 1 + sovScene(uint64(m.CollectionObjId))
	}
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	return n
}

func (m *SceneFit) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.FitId != 0 {
		n += 1 + sovScene(uint64(m.FitId))
	}
	if m.FashionId != 0 {
		n += 1 + sovScene(uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		n += 1 + sovScene(uint64(m.FashionLv))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.FitLv != 0 {
		n += 1 + sovScene(uint64(m.FitLv))
	}
	return n
}

func (m *SceneSummon) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.SummonId != 0 {
		n += 1 + sovScene(uint64(m.SummonId))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	return n
}

func (m *SceneItem) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovScene(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovScene(uint64(m.ItemNum))
	}
	if m.Owner != 0 {
		n += 1 + sovScene(uint64(m.Owner))
	}
	if m.OwnerProtectedTime != 0 {
		n += 1 + sovScene(uint64(m.OwnerProtectedTime))
	}
	if m.DisappearTime != 0 {
		n += 1 + sovScene(uint64(m.DisappearTime))
	}
	return n
}

func (m *SceneEnterNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovScene(uint64(m.StageId))
	}
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *SceneEnterOverNtf) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SceneLeaveNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	return n
}

func (m *SceneDieNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if len(m.DropItems) > 0 {
		for _, e := range m.DropItems {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *SceneMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.MoveType != 0 {
		n += 1 + sovScene(uint64(m.MoveType))
	}
	return n
}

func (m *SceneMoveNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.MoveType != 0 {
		n += 1 + sovScene(uint64(m.MoveType))
	}
	return n
}

func (m *SceneUserReliveNtf) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.ReliveType != 0 {
		n += 1 + sovScene(uint64(m.ReliveType))
	}
	return n
}

func (m *SceneUserUpdateNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.ObjUser != nil {
		l = m.ObjUser.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *AttackRpt) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene(uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.SkillLevel != 0 {
		n += 1 + sovScene(uint64(m.SkillLevel))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	return n
}

func (m *AttackEffectNtf) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene(uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		n += 1 + sovScene(uint64(m.AttackerId))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if len(m.Hurts) > 0 {
		for _, e := range m.Hurts {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.MoveToPoint != nil {
		l = m.MoveToPoint.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.SkillLv != 0 {
		n += 1 + sovScene(uint64(m.SkillLv))
	}
	if m.Err != 0 {
		n += 1 + sovScene(uint64(m.Err))
	}
	if m.SkillStartT != 0 {
		n += 1 + sovScene(uint64(m.SkillStartT))
	}
	if m.SkillStopT != 0 {
		n += 1 + sovScene(uint64(m.SkillStopT))
	}
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.MpNow != 0 {
		n += 1 + sovScene(uint64(m.MpNow))
	}
	return n
}

func (m *HurtEffect) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.ChangHp != 0 {
		n += 1 + sovScene(uint64(m.ChangHp))
	}
	if m.IsDeath {
		n += 2
	}
	if m.IsDodge {
		n += 2
	}
	if m.HurtType != 0 {
		n += 1 + sovScene(uint64(m.HurtType))
	}
	if m.Hurt != 0 {
		n += 1 + sovScene(uint64(m.Hurt))
	}
	if m.Deathblow != 0 {
		n += 1 + sovScene(uint64(m.Deathblow))
	}
	if m.CutHurt != 0 {
		n += 1 + sovScene(uint64(m.CutHurt))
	}
	if m.MoveToPoint != nil {
		l = m.MoveToPoint.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.UnBlock != 0 {
		n += 1 + sovScene(uint64(m.UnBlock))
	}
	if m.Reflex != 0 {
		n += 1 + sovScene(uint64(m.Reflex))
	}
	if m.ReliveSelf {
		n += 2
	}
	return n
}

func (m *SceneObjHpNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.ChangeHp != 0 {
		n += 1 + sovScene(uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		n += 1 + sovScene(uint64(m.TotalHp))
	}
	return n
}

func (m *SceneObjMpNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Mp != 0 {
		n += 1 + sovScene(uint64(m.Mp))
	}
	if m.ChangeMp != 0 {
		n += 1 + sovScene(uint64(m.ChangeMp))
	}
	if m.TotalMp != 0 {
		n += 1 + sovScene(uint64(m.TotalMp))
	}
	return n
}

func (m *FightHurtRankReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightHurtRankAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		for _, e := range m.Ranks {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.MyRank != nil {
		l = m.MyRank.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *FightRankUnit) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovScene(uint64(m.Rank))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	return n
}

func (m *GetBossOwnerChangReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BossOwnerChangNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	return n
}

func (m *BuffChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if len(m.DelBuffInfos) > 0 {
		for _, e := range m.DelBuffInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffDelNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.DelBuffInfos) > 0 {
		for _, e := range m.DelBuffInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.SourceObjId != 0 {
		n += 1 + sovScene(uint64(m.SourceObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	if m.BuffId != 0 {
		n += 1 + sovScene(uint64(m.BuffId))
	}
	if m.TotalTime != 0 {
		n += 1 + sovScene(uint64(m.TotalTime))
	}
	return n
}

func (m *DelBuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	return n
}

func (m *BuffPropChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.PropId != 0 {
		n += 1 + sovScene(uint64(m.PropId))
	}
	if m.Total != 0 {
		n += 1 + sovScene(uint64(m.Total))
	}
	return n
}

func (m *BuffHpChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, e := range m.BuffHpChangeInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffHpChangeInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	if m.Death != 0 {
		n += 1 + sovScene(uint64(m.Death))
	}
	if m.ChangeHp != 0 {
		n += 1 + sovScene(uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		n += 1 + sovScene(uint64(m.TotalHp))
	}
	return n
}

func (m *MainCityEnterRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *MainCityMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.X != 0 {
		n += 1 + sovScene(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene(uint64(m.Y))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	return n
}

func (m *MainCityLeaveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	return n
}

func (m *MainCityUpdateRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *FightEnterOkReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightStartCountDownNtf) Size() (n int) {
	var l int
	_ = l
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.CountDownTime != 0 {
		n += 1 + sovScene(uint64(m.CountDownTime))
	}
	return n
}

func (m *FightStartCountDownOkReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightStartNtf) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CollectionStatusChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.UserObjId != 0 {
		n += 1 + sovScene(uint64(m.UserObjId))
	}
	if m.StartTime != 0 {
		n += 1 + sovScene(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	return n
}

func (m *ExpStageKillInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.KillMonsterNum != 0 {
		n += 1 + sovScene(uint64(m.KillMonsterNum))
	}
	if m.GetExp != 0 {
		n += 1 + sovScene(uint64(m.GetExp))
	}
	return n
}

func (m *PaodianTopUserReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PaodianTopUserNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	return n
}

func (m *PaoDianUserNumNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserNums) > 0 {
		for k, v := range m.UserNums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PaodianFightEnd) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovScene(uint64(m.StageId))
	}
	return n
}

func (m *GetShabakeScoresReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShabakeScoreRankNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, e := range m.UserScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if len(m.GuildScores) > 0 {
		for _, e := range m.GuildScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *ShabakeUserScore) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	return n
}

func (m *ShabakeGuildScore) Size() (n int) {
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	return n
}

func (m *ShabakeOccupiedNtf) Size() (n int) {
	var l int
	_ = l
	if m.IsOccupy {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovScene(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	return n
}

func sovScene(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozScene(x uint64) (n int) {
	return sovScene(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjType", wireType)
			}
			m.ObjType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpMax", wireType)
			}
			m.HpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HpMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffs = append(m.Buffs, &BuffInfo{})
			if err := m.Buffs[len(m.Buffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpMax", wireType)
			}
			m.MpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &SceneUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = &SceneMonster{}
			}
			if err := m.Monster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &SceneItem{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pet == nil {
				m.Pet = &ScenePet{}
			}
			if err := m.Pet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collection == nil {
				m.Collection = &SceneCollection{}
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &SceneFit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summon == nil {
				m.Summon = &SceneSummon{}
			}
			if err := m.Summon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			m.Lvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMonster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMonster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMonster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScenePet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScenePet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScenePet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionObjId", wireType)
			}
			m.CollectionObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneFit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneFit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneFit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitId", wireType)
			}
			m.FitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionId", wireType)
			}
			m.FashionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionLv", wireType)
			}
			m.FashionLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitLv", wireType)
			}
			m.FitLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneSummon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneSummon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneSummon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SummonId", wireType)
			}
			m.SummonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SummonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerProtectedTime", wireType)
			}
			m.OwnerProtectedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerProtectedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisappearTime", wireType)
			}
			m.DisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneEnterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneEnterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneEnterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &SceneObj{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneEnterOverNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneEnterOverNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneEnterOverNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneLeaveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneLeaveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneLeaveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneDieNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneDieNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneDieNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropItems = append(m.DropItems, &SceneObj{})
			if err := m.DropItems[len(m.DropItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUserReliveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUserReliveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUserReliveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveType", wireType)
			}
			m.ReliveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUserUpdateNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUserUpdateNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUserUpdateNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjUser == nil {
				m.ObjUser = &SceneUser{}
			}
			if err := m.ObjUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevel", wireType)
			}
			m.SkillLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackEffectNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackEffectNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackEffectNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hurts = append(m.Hurts, &HurtEffect{})
			if err := m.Hurts[len(m.Hurts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveToPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoveToPoint == nil {
				m.MoveToPoint = &Point{}
			}
			if err := m.MoveToPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLv", wireType)
			}
			m.SkillLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillStartT", wireType)
			}
			m.SkillStartT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillStartT |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillStopT", wireType)
			}
			m.SkillStopT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillStopT |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpNow", wireType)
			}
			m.MpNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpNow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HurtEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HurtEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HurtEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangHp", wireType)
			}
			m.ChangHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeath = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDodge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDodge = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurt", wireType)
			}
			m.Hurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hurt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deathblow", wireType)
			}
			m.Deathblow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deathblow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutHurt", wireType)
			}
			m.CutHurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutHurt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveToPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoveToPoint == nil {
				m.MoveToPoint = &Point{}
			}
			if err := m.MoveToPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBlock", wireType)
			}
			m.UnBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnBlock |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reflex", wireType)
			}
			m.Reflex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reflex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReliveSelf = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObjHpNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObjHpNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObjHpNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHp", wireType)
			}
			m.ChangeHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHp", wireType)
			}
			m.TotalHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObjMpNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObjMpNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObjMpNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeMp", wireType)
			}
			m.ChangeMp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeMp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMp", wireType)
			}
			m.TotalMp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightHurtRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightHurtRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightHurtRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightHurtRankAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightHurtRankAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightHurtRankAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranks = append(m.Ranks, &FightRankUnit{})
			if err := m.Ranks[len(m.Ranks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MyRank == nil {
				m.MyRank = &FightRankUnit{}
			}
			if err := m.MyRank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightRankUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightRankUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightRankUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBossOwnerChangReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBossOwnerChangReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBossOwnerChangReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossOwnerChangNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossOwnerChangNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossOwnerChangNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &BuffInfo{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelBuffInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelBuffInfos = append(m.DelBuffInfos, &DelBuffInfo{})
			if err := m.DelBuffInfos[len(m.DelBuffInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffDelNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffDelNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffDelNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelBuffInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelBuffInfos = append(m.DelBuffInfos, &DelBuffInfo{})
			if err := m.DelBuffInfos[len(m.DelBuffInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceObjId", wireType)
			}
			m.SourceObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTime", wireType)
			}
			m.TotalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelBuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelBuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelBuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffPropChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffPropChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffPropChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffHpChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuffHpChangeInfos = append(m.BuffHpChangeInfos, &BuffHpChangeInfo{})
			if err := m.BuffHpChangeInfos[len(m.BuffHpChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Death", wireType)
			}
			m.Death = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Death |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHp", wireType)
			}
			m.ChangeHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHp", wireType)
			}
			m.TotalHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityEnterRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityEnterRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityEnterRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityLeaveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityLeaveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityLeaveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityUpdateRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityUpdateRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityUpdateRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightEnterOkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightEnterOkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightEnterOkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartCountDownNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartCountDownNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartCountDownNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDownTime", wireType)
			}
			m.CountDownTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDownTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartCountDownOkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartCountDownOkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartCountDownOkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionStatusChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionStatusChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionStatusChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObjId", wireType)
			}
			m.UserObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStageKillInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStageKillInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStageKillInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonsterNum", wireType)
			}
			m.KillMonsterNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillMonsterNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetExp", wireType)
			}
			m.GetExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianTopUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianTopUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianTopUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianTopUserNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianTopUserNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianTopUserNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaoDianUserNumNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaoDianUserNumNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaoDianUserNumNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserNums == nil {
				m.UserNums = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserNums[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianFightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianFightEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianFightEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShabakeScoresReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShabakeScoresReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShabakeScoresReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeScoreRankNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeScoreRankNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeScoreRankNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScores = append(m.UserScores, &ShabakeUserScore{})
			if err := m.UserScores[len(m.UserScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildScores = append(m.GuildScores, &ShabakeGuildScore{})
			if err := m.GuildScores[len(m.GuildScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeUserScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeUserScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeUserScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeGuildScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeGuildScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeGuildScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeOccupiedNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeOccupiedNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeOccupiedNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOccupy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOccupy = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScene(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScene
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthScene
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowScene
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipScene(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthScene = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScene   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("scene.proto", fileDescriptorScene) }

var fileDescriptorScene = []byte{
	// 2065 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x18, 0x4d, 0x4f, 0x23, 0xc9,
	0x35, 0x6d, 0xbb, 0xc1, 0x7e, 0x86, 0x01, 0x1a, 0x86, 0xf4, 0x92, 0x11, 0x21, 0xbd, 0x93, 0x0c,
	0xd9, 0x55, 0x38, 0x30, 0x2b, 0x25, 0x4a, 0x0e, 0xab, 0x61, 0x60, 0x06, 0xb4, 0x18, 0x50, 0x1b,
	0xb4, 0x97, 0x28, 0x52, 0xdb, 0x5d, 0xc6, 0x8d, 0xed, 0xae, 0xde, 0xee, 0xb2, 0x81, 0x7b, 0x56,
	0xb9, 0x26, 0x52, 0x0e, 0x39, 0xe5, 0x18, 0x29, 0x52, 0x7e, 0x48, 0x8e, 0x39, 0xe4, 0x07, 0x44,
	0x93, 0x43, 0x7e, 0x41, 0xee, 0xd1, 0x7b, 0x55, 0xd5, 0x5d, 0x6e, 0x6c, 0x98, 0xec, 0xad, 0xdf,
	0x47, 0xbd, 0xaf, 0x7a, 0x5f, 0xd5, 0xd0, 0xcc, 0xba, 0x2c, 0x66, 0x7b, 0x49, 0xca, 0x05, 0x77,
	0x2a, 0x49, 0x67, 0x6b, 0xa9, 0xcb, 0x47, 0x23, 0x1e, 0x4b, 0x8c, 0xf7, 0x29, 0xd8, 0x17, 0x3c,
	0x8a, 0x85, 0xb3, 0x04, 0xd6, 0x9d, 0x6b, 0xed, 0x58, 0xbb, 0xb6, 0x6f, 0xdd, 0x21, 0x74, 0xef,
	0x56, 0x24, 0x74, 0xef, 0x7d, 0x5b, 0x83, 0x7a, 0x1b, 0xc5, 0x9c, 0x77, 0x6e, 0x1c, 0x17, 0x16,
	0x79, 0xe7, 0xe6, 0xf2, 0x3e, 0x61, 0x8a, 0x5d, 0x83, 0xce, 0x0f, 0xc1, 0x4e, 0x50, 0x16, 0x1d,
	0x6c, 0xee, 0x37, 0xf6, 0x92, 0xce, 0x1e, 0x09, 0xf7, 0x25, 0xde, 0x59, 0x85, 0x6a, 0x18, 0xa5,
	0x6e, 0x95, 0x8e, 0xe1, 0xa7, 0xb3, 0x01, 0x36, 0xef, 0xdc, 0x9c, 0x84, 0x6e, 0x8d, 0x70, 0x12,
	0x70, 0x36, 0x61, 0x41, 0xb0, 0x60, 0x74, 0x12, 0xba, 0x36, 0xa1, 0x15, 0xe4, 0x3c, 0x83, 0x4a,
	0x3f, 0x71, 0x17, 0x77, 0xac, 0xdd, 0xaa, 0x5f, 0xe9, 0x27, 0x78, 0xba, 0x9f, 0xb4, 0x82, 0x3b,
	0xb7, 0x4e, 0x28, 0x09, 0x38, 0x1e, 0xd8, 0x9d, 0x71, 0xaf, 0x97, 0xb9, 0x8d, 0x9d, 0xea, 0x6e,
	0x73, 0x7f, 0x09, 0xcd, 0x38, 0x18, 0xf7, 0x7a, 0x27, 0x71, 0x8f, 0xfb, 0x92, 0x84, 0x92, 0x46,
	0x89, 0x0b, 0x52, 0xd2, 0x88, 0x24, 0x8d, 0x48, 0x52, 0x53, 0x4a, 0x22, 0xc0, 0xf9, 0x11, 0xd4,
	0xc6, 0x19, 0x4b, 0xdd, 0xe7, 0xe4, 0xcf, 0x32, 0x0a, 0xa2, 0x30, 0x5c, 0x65, 0x2c, 0xf5, 0x89,
	0xe4, 0x7c, 0x06, 0x8b, 0x23, 0x1e, 0x67, 0x82, 0xa5, 0xee, 0xf7, 0x89, 0x6b, 0x35, 0xe7, 0x6a,
	0x49, 0xbc, 0xaf, 0x19, 0x50, 0x5c, 0x24, 0xd8, 0xc8, 0x75, 0x4b, 0xe2, 0x4e, 0x04, 0x1b, 0xf9,
	0x44, 0x72, 0xb6, 0xa1, 0x9a, 0x30, 0xe1, 0x7e, 0x42, 0x1c, 0x4b, 0x39, 0xc7, 0x05, 0x13, 0x3e,
	0x12, 0x9c, 0xd7, 0x00, 0x5d, 0x3e, 0x1c, 0xb2, 0xae, 0x88, 0x78, 0xec, 0x6e, 0x11, 0xdb, 0x7a,
	0xce, 0xf6, 0x36, 0x27, 0xf9, 0x06, 0x1b, 0x0a, 0xed, 0x45, 0xc2, 0xfd, 0x41, 0x49, 0xe8, 0xbb,
	0x48, 0xf8, 0x48, 0x70, 0x5e, 0xc1, 0x42, 0x36, 0xc6, 0x9c, 0x70, 0x5f, 0x10, 0xcb, 0x4a, 0xce,
	0xd2, 0x26, 0xb4, 0xaf, 0xc8, 0xde, 0xdf, 0x2a, 0xd0, 0xc8, 0x03, 0x80, 0xb7, 0x84, 0x21, 0x38,
	0x09, 0x55, 0x1e, 0x28, 0xc8, 0x71, 0xa0, 0x16, 0x07, 0x23, 0x46, 0x59, 0xd0, 0xf0, 0xe9, 0xdb,
	0xf9, 0x31, 0x2c, 0x86, 0x51, 0x96, 0x0c, 0x83, 0x7b, 0xba, 0xfd, 0xe6, 0x7e, 0x13, 0x75, 0x1c,
	0x4a, 0x94, 0xaf, 0x69, 0x98, 0x20, 0x93, 0x28, 0x51, 0xc9, 0x80, 0x9f, 0x88, 0x19, 0x4e, 0x86,
	0x2a, 0x0f, 0xf0, 0x13, 0x31, 0x19, 0xbb, 0x73, 0x17, 0x24, 0x26, 0x63, 0x77, 0x68, 0x48, 0x97,
	0x8f, 0x3a, 0x81, 0x50, 0xa9, 0xa1, 0x20, 0xc4, 0x07, 0x93, 0x40, 0x04, 0x29, 0xe5, 0x47, 0xc3,
	0x57, 0x10, 0x4a, 0xb8, 0xe1, 0x1d, 0xb7, 0x21, 0x25, 0xdc, 0xf0, 0x8e, 0xf3, 0x02, 0x1a, 0x7d,
	0x96, 0xf2, 0x93, 0x38, 0x64, 0x77, 0x94, 0x15, 0xb6, 0x5f, 0x20, 0x30, 0xe3, 0xaf, 0xc7, 0xd1,
	0x30, 0x3c, 0x09, 0xdd, 0x25, 0x99, 0xf1, 0x0a, 0xc4, 0x73, 0xf4, 0x79, 0x86, 0xfe, 0x2e, 0x93,
	0x92, 0x02, 0xe1, 0xed, 0xc0, 0x92, 0x99, 0x08, 0xa8, 0x37, 0x0a, 0x75, 0x91, 0xe1, 0xa7, 0xf7,
	0x85, 0xaa, 0xab, 0x0b, 0x26, 0xe6, 0x86, 0x53, 0x9d, 0xaa, 0x14, 0xa7, 0xbe, 0xb5, 0x60, 0xa5,
	0x74, 0xdf, 0x98, 0xd0, 0x91, 0x3e, 0x59, 0x89, 0x42, 0x67, 0x17, 0x56, 0x8a, 0x0c, 0x38, 0xa7,
	0x12, 0x93, 0x12, 0xca, 0x68, 0x67, 0x1b, 0x20, 0x63, 0xe9, 0x84, 0xa5, 0x97, 0xd1, 0x88, 0xa9,
	0xda, 0x34, 0x30, 0xe8, 0x3d, 0x8b, 0x43, 0x22, 0xca, 0x7b, 0xd1, 0xa0, 0xf7, 0x67, 0x4b, 0x99,
	0xff, 0x2e, 0x9a, 0x6f, 0xfe, 0x06, 0xd8, 0xbd, 0x48, 0xe4, 0xea, 0x25, 0x80, 0x81, 0xeb, 0x05,
	0x59, 0x3f, 0xe2, 0xf1, 0x49, 0xa8, 0x74, 0x16, 0x08, 0x83, 0x7a, 0x3a, 0x51, 0x4a, 0x0b, 0x44,
	0x9e, 0x5f, 0xb6, 0x91, 0x5f, 0x52, 0xcb, 0xe9, 0x44, 0xa5, 0x85, 0x04, 0xbc, 0xaf, 0xa1, 0x69,
	0xa4, 0xf1, 0x5c, 0x13, 0xb7, 0xa0, 0x2e, 0x13, 0x3c, 0xb7, 0x32, 0x87, 0x8b, 0x06, 0x55, 0x35,
	0x1a, 0x94, 0xf7, 0x57, 0x4b, 0x15, 0x02, 0x96, 0x2e, 0xca, 0xc5, 0xe2, 0xcd, 0x4f, 0x2b, 0x08,
	0x23, 0x87, 0x5f, 0x67, 0xe3, 0x91, 0x3a, 0xad, 0x41, 0x92, 0x7a, 0x1b, 0xb3, 0x34, 0x6f, 0x7b,
	0x08, 0x38, 0x7b, 0xe0, 0xd0, 0xc7, 0x45, 0xca, 0x05, 0xeb, 0x0a, 0x26, 0x83, 0x2e, 0x53, 0x7f,
	0x06, 0xc5, 0x79, 0x09, 0xcb, 0x61, 0x94, 0x05, 0x49, 0xc2, 0x02, 0x79, 0x79, 0xd2, 0xf9, 0x69,
	0xa4, 0xf7, 0x15, 0x2c, 0x93, 0xa9, 0x47, 0xb1, 0x60, 0xe9, 0x99, 0xe8, 0xa1, 0x59, 0x99, 0x08,
	0xae, 0x59, 0x1e, 0x07, 0x0d, 0x3a, 0x3b, 0x50, 0xe3, 0x9d, 0x9b, 0xcc, 0xad, 0x14, 0x8d, 0x53,
	0xb7, 0x7d, 0x9f, 0x28, 0xde, 0x3a, 0xac, 0x15, 0xc2, 0xce, 0x27, 0x24, 0xd0, 0x7b, 0xa5, 0x34,
	0x9c, 0xb2, 0x60, 0xc2, 0x50, 0xc3, 0x26, 0x2c, 0x50, 0x9c, 0x32, 0xd7, 0xda, 0xa9, 0x62, 0x40,
	0x24, 0xe4, 0x9d, 0xab, 0xfb, 0x38, 0x8c, 0x88, 0x2d, 0x8f, 0xad, 0x65, 0x36, 0xff, 0xcf, 0xa0,
	0x11, 0xa6, 0x3c, 0xc1, 0xc8, 0xce, 0xb6, 0xa4, 0x20, 0x7b, 0x41, 0x5e, 0x61, 0x13, 0xe6, 0x27,
	0x62, 0x8e, 0xc4, 0x27, 0xe7, 0xd2, 0x16, 0xd4, 0x47, 0x7c, 0xc2, 0x68, 0xa6, 0xc9, 0x9b, 0xca,
	0x61, 0xef, 0xd6, 0x50, 0x31, 0xdf, 0xe8, 0x27, 0x55, 0x60, 0x82, 0xf2, 0xb4, 0x2b, 0xe5, 0xd7,
	0x7d, 0x09, 0x4c, 0x29, 0xae, 0x95, 0x14, 0x5f, 0x82, 0x53, 0x0c, 0x1b, 0x36, 0x8c, 0xa4, 0xfa,
	0x6d, 0xa8, 0xf2, 0xce, 0x0d, 0x29, 0x2f, 0xc7, 0x05, 0x09, 0x58, 0xcd, 0x29, 0x31, 0x93, 0x4c,
	0x99, 0x8f, 0x06, 0xc6, 0x6b, 0x1b, 0x52, 0xaf, 0x92, 0x30, 0x10, 0x8f, 0x38, 0xf5, 0x8a, 0x26,
	0x3d, 0x72, 0x2a, 0xb7, 0x4a, 0x13, 0x50, 0x53, 0xbd, 0xbf, 0x58, 0xd0, 0x78, 0x23, 0x44, 0xd0,
	0x1d, 0xe0, 0x25, 0x60, 0x7e, 0x0d, 0xa2, 0xe1, 0xd0, 0xc8, 0x2f, 0x09, 0x1a, 0x79, 0x51, 0x31,
	0xf3, 0x62, 0xc6, 0x5e, 0x90, 0xc7, 0xb3, 0x36, 0x27, 0x9e, 0xd8, 0xb5, 0x50, 0xea, 0x29, 0x9b,
	0x30, 0x3d, 0x1e, 0x0c, 0x4c, 0xe1, 0xd1, 0x82, 0x59, 0xb7, 0xff, 0xad, 0xc0, 0x8a, 0x34, 0xf4,
	0xa8, 0xd7, 0x63, 0x5d, 0xa1, 0xcb, 0x61, 0xb6, 0xb9, 0xdb, 0x00, 0x01, 0x31, 0x53, 0xcf, 0x50,
	0xb1, 0x2c, 0x30, 0xdf, 0xc5, 0xec, 0x97, 0x60, 0xf7, 0xc7, 0xa9, 0xc8, 0x5c, 0x9b, 0x12, 0xfb,
	0x19, 0x32, 0x1c, 0x8f, 0x53, 0x21, 0xcd, 0xf1, 0x25, 0xd1, 0xf9, 0x1c, 0x9a, 0x98, 0x6e, 0x97,
	0x9c, 0xce, 0x92, 0x0b, 0x53, 0xc2, 0x4c, 0x6a, 0x6e, 0xff, 0xe9, 0x84, 0xc6, 0x9f, 0xb6, 0xff,
	0x74, 0x82, 0xf6, 0xb1, 0x54, 0x0e, 0x3f, 0xdb, 0xc7, 0x4f, 0x67, 0x07, 0x9a, 0x44, 0x6c, 0x8b,
	0x20, 0x15, 0x97, 0x34, 0x01, 0xab, 0xbe, 0x89, 0xca, 0xe3, 0xda, 0x16, 0x3c, 0xb9, 0x54, 0x0b,
	0x92, 0x81, 0x29, 0x4d, 0x8b, 0xa6, 0xa2, 0x17, 0xd3, 0x82, 0x16, 0xa9, 0x33, 0x7e, 0x4b, 0x93,
	0x92, 0x16, 0xa9, 0x33, 0x7e, 0xeb, 0xfd, 0xa7, 0x02, 0x50, 0xb8, 0x39, 0x27, 0xdd, 0xe4, 0x76,
	0x57, 0xc9, 0xb7, 0x3b, 0x17, 0x16, 0xbb, 0xfd, 0x20, 0xbe, 0x3e, 0x4e, 0x28, 0xc4, 0x55, 0x5f,
	0x83, 0xd4, 0x58, 0xb3, 0x43, 0x16, 0x88, 0x3e, 0x05, 0xba, 0xee, 0x6b, 0x50, 0x51, 0x78, 0x78,
	0x2d, 0xfb, 0xa6, 0xa4, 0x20, 0x88, 0xa5, 0x86, 0xc1, 0xa5, 0xb2, 0x90, 0x39, 0x91, 0xc3, 0x38,
	0x51, 0xf0, 0x5b, 0xad, 0x0f, 0xf4, 0x8d, 0x33, 0x28, 0x44, 0x91, 0x9d, 0x21, 0xbf, 0x55, 0xfb,
	0x65, 0x81, 0x20, 0xdb, 0xc6, 0x02, 0x5d, 0x52, 0x41, 0xd4, 0x60, 0xf9, 0xee, 0xe0, 0xa9, 0xbb,
	0x1b, 0xc7, 0x07, 0x43, 0xde, 0x1d, 0xa8, 0x50, 0x6a, 0x10, 0x4b, 0x25, 0x65, 0xbd, 0x21, 0xbb,
	0x53, 0x81, 0x54, 0x50, 0x51, 0xdf, 0x6d, 0x36, 0xec, 0xd1, 0xca, 0x51, 0xf7, 0x0d, 0x8c, 0x37,
	0x50, 0xbd, 0xf8, 0xbc, 0x73, 0x73, 0x9c, 0xcc, 0x2f, 0xed, 0x72, 0xac, 0xb7, 0xa0, 0x4e, 0xc1,
	0x65, 0x79, 0xb0, 0x73, 0x18, 0x8d, 0x14, 0x5c, 0x04, 0xc3, 0x63, 0xb9, 0x98, 0x55, 0x7d, 0x0d,
	0x9a, 0xca, 0x5a, 0x8f, 0x2b, 0x6b, 0xe5, 0xca, 0x5a, 0x86, 0xb2, 0x56, 0x49, 0x59, 0xab, 0x50,
	0xd6, 0x9a, 0x56, 0xd6, 0x4a, 0x3c, 0x07, 0x56, 0xdf, 0x45, 0xd7, 0x7d, 0x8a, 0xb2, 0x1f, 0xc4,
	0x03, 0x9f, 0x7d, 0xe3, 0xf5, 0x4a, 0xb8, 0x37, 0xdd, 0x81, 0xf3, 0x0a, 0xec, 0x34, 0x88, 0x07,
	0x72, 0xf6, 0x34, 0xf7, 0xd7, 0x30, 0xf4, 0xc4, 0x84, 0x0c, 0x57, 0x71, 0x24, 0x7c, 0x49, 0x77,
	0x7e, 0x0a, 0x0b, 0xa3, 0x7b, 0x44, 0xaa, 0xee, 0x36, 0x83, 0x53, 0x31, 0x78, 0x2d, 0x58, 0x9e,
	0x22, 0x60, 0xc6, 0xa0, 0x10, 0xe5, 0x27, 0x7d, 0xcf, 0xdc, 0x7b, 0x37, 0xc0, 0xce, 0xba, 0x3c,
	0x65, 0xca, 0x4f, 0x09, 0x78, 0x9b, 0xb0, 0xf1, 0x9e, 0x89, 0x03, 0x9e, 0x65, 0xe7, 0x38, 0xd5,
	0xdf, 0xa2, 0xf3, 0xe8, 0x4e, 0x00, 0x6b, 0xd3, 0xc8, 0xf9, 0x31, 0xdd, 0x06, 0xa0, 0x8d, 0xc0,
	0x5c, 0xed, 0x0c, 0x8c, 0xb1, 0xeb, 0x54, 0xcd, 0x5d, 0xc7, 0xeb, 0xc1, 0x32, 0xbe, 0x85, 0x48,
	0x3a, 0xb5, 0xfe, 0x1d, 0xa8, 0xe1, 0x93, 0xc8, 0x9c, 0x28, 0xf9, 0x63, 0x89, 0x28, 0xce, 0x6b,
	0x58, 0x0a, 0xd9, 0x50, 0x23, 0xf5, 0x4c, 0xa6, 0x47, 0xc2, 0x61, 0x81, 0xf7, 0xa7, 0x98, 0xbc,
	0x37, 0x00, 0x08, 0x1c, 0xb2, 0x21, 0x2a, 0x29, 0x8b, 0xb0, 0x3e, 0x46, 0xc4, 0x1f, 0x2d, 0xa8,
	0x6b, 0xa8, 0xe4, 0xaf, 0xf5, 0xc0, 0x5f, 0xec, 0x6c, 0x7c, 0x9c, 0x76, 0x99, 0x19, 0x10, 0x13,
	0xa5, 0xf7, 0xe8, 0x6a, 0xbe, 0x47, 0x63, 0x8c, 0xd0, 0xc1, 0xfc, 0xf5, 0xa9, 0x20, 0x2c, 0x7d,
	0x4a, 0xba, 0x7c, 0xfd, 0xaa, 0xfa, 0x05, 0xc2, 0xfb, 0x12, 0x9a, 0x86, 0xcd, 0x4f, 0x1a, 0xf6,
	0x70, 0x7d, 0xff, 0x1a, 0xd6, 0xf0, 0xf4, 0x45, 0xca, 0x93, 0xe2, 0x1a, 0x66, 0xdf, 0xf2, 0x26,
	0x2c, 0x24, 0xb8, 0xec, 0xe4, 0x9b, 0xa5, 0x84, 0x90, 0x9b, 0x0c, 0xd2, 0x69, 0x45, 0x80, 0x77,
	0x05, 0x2b, 0x28, 0xf8, 0xd8, 0x10, 0x7b, 0x00, 0x6b, 0x1d, 0x03, 0x65, 0x46, 0x7f, 0x43, 0x5f,
	0xb5, 0x49, 0xf4, 0x1f, 0xb2, 0x7b, 0xbf, 0xb7, 0x60, 0xb5, 0xcc, 0xf7, 0xff, 0xbb, 0x8d, 0x36,
	0x53, 0xff, 0xd4, 0x9b, 0x34, 0x01, 0x53, 0x8d, 0xa7, 0x36, 0xbf, 0xf1, 0xd8, 0xd3, 0x8d, 0x67,
	0x1f, 0x56, 0x5b, 0x41, 0x14, 0xbf, 0x8d, 0xc4, 0x3d, 0x6d, 0xa2, 0xb8, 0x76, 0x3c, 0xb1, 0x19,
	0x61, 0x74, 0xf4, 0x99, 0xc7, 0xd7, 0x45, 0xfa, 0x13, 0x52, 0x99, 0xfa, 0x13, 0x52, 0x55, 0x7f,
	0x42, 0xf4, 0xc8, 0xb7, 0xf3, 0x91, 0xef, 0xed, 0x16, 0xa6, 0xd0, 0xfe, 0x3b, 0x57, 0xae, 0xf7,
	0x1a, 0xd6, 0x34, 0xa7, 0xdc, 0xbc, 0x3e, 0xc6, 0xea, 0x35, 0x58, 0xa1, 0xce, 0x23, 0x17, 0x6e,
	0x6a, 0x7a, 0xbf, 0x81, 0x4d, 0x42, 0xd1, 0xc4, 0x7e, 0xcb, 0xc7, 0xb1, 0x38, 0xe4, 0xb7, 0xb1,
	0x5c, 0x0e, 0xcd, 0xe1, 0x6c, 0x3d, 0x78, 0xca, 0xbd, 0x84, 0xe5, 0xae, 0xe6, 0x27, 0x16, 0xe9,
	0xe5, 0x34, 0xd2, 0xdb, 0x02, 0x77, 0x86, 0x7c, 0xa9, 0x7b, 0x45, 0x35, 0x42, 0xa2, 0xe1, 0xee,
	0xff, 0x3b, 0x0b, 0x3e, 0x29, 0x9e, 0xa1, 0x6d, 0x11, 0x88, 0x71, 0xf6, 0x54, 0x56, 0xbf, 0x80,
	0x06, 0x76, 0x23, 0xb3, 0x52, 0x0b, 0x04, 0x52, 0x33, 0xda, 0x45, 0xf4, 0x73, 0xb4, 0xea, 0x17,
	0x88, 0xf2, 0x6b, 0xb4, 0x5a, 0xbc, 0x46, 0xaf, 0x60, 0xfd, 0xe8, 0x2e, 0x69, 0xe3, 0x53, 0xe6,
	0x2b, 0xdc, 0xdf, 0xe2, 0x1e, 0x47, 0x13, 0x7e, 0x02, 0xcf, 0x70, 0x7b, 0x51, 0x6f, 0x70, 0x7c,
	0x8b, 0x49, 0x5b, 0x4a, 0x58, 0x2c, 0xb5, 0x6b, 0x26, 0x8e, 0xee, 0x12, 0x5d, 0x6a, 0x12, 0xc2,
	0x17, 0xcf, 0x45, 0xc0, 0xc3, 0x28, 0x88, 0x2f, 0x79, 0x22, 0x77, 0xf1, 0x6f, 0xbc, 0x9f, 0x95,
	0x91, 0x6a, 0x91, 0x94, 0x4d, 0x56, 0x3f, 0x7b, 0x34, 0xe8, 0xfd, 0xc1, 0x22, 0xfe, 0xc3, 0x28,
	0x88, 0x89, 0x79, 0x3c, 0x42, 0xfe, 0x2f, 0xa1, 0x3e, 0x96, 0x90, 0x2e, 0xc9, 0x4f, 0x69, 0x4d,
	0x28, 0x33, 0xee, 0xa9, 0xcf, 0xec, 0x28, 0x16, 0xe9, 0xbd, 0x9f, 0x1f, 0xda, 0xfa, 0x15, 0x2c,
	0x4f, 0x91, 0x30, 0x3b, 0x07, 0xec, 0x5e, 0xff, 0x60, 0x18, 0xb0, 0x7b, 0xbc, 0x80, 0x49, 0x30,
	0x1c, 0xeb, 0x9b, 0x96, 0xc0, 0x2f, 0x2b, 0xbf, 0xb0, 0xbc, 0xcf, 0x61, 0x45, 0xb9, 0xa0, 0xf2,
	0x2b, 0x9c, 0xff, 0x30, 0xf4, 0x9e, 0xc3, 0xfa, 0x7b, 0x26, 0xda, 0xfd, 0xa0, 0x13, 0x0c, 0x58,
	0x1b, 0x67, 0x58, 0x86, 0x61, 0xf8, 0xad, 0x05, 0xeb, 0x26, 0x12, 0xc7, 0x23, 0x7a, 0xf6, 0x05,
	0x00, 0x1a, 0x29, 0x19, 0xcd, 0x76, 0xa3, 0x98, 0xaf, 0x34, 0xd1, 0x37, 0xf8, 0x9c, 0x9f, 0x43,
	0x93, 0xfe, 0x9d, 0xa8, 0x63, 0x72, 0xcc, 0x3c, 0x37, 0x8e, 0xbd, 0xcf, 0xa9, 0xbe, 0xc9, 0xe9,
	0xfd, 0x1a, 0x56, 0xcb, 0x82, 0x1f, 0x7b, 0xeb, 0x53, 0xfc, 0x8a, 0x41, 0x9d, 0xc3, 0xd3, 0xc3,
	0xda, 0xd6, 0xc3, 0x3a, 0x80, 0xb5, 0x07, 0xfa, 0xcd, 0x5f, 0x42, 0xd6, 0x23, 0xbf, 0x84, 0x2a,
	0xa5, 0x5f, 0x42, 0x73, 0x54, 0xfc, 0xd3, 0x02, 0x47, 0xe9, 0x38, 0xef, 0x76, 0xc7, 0x49, 0xc4,
	0x42, 0x0c, 0xe3, 0x16, 0xd4, 0xa3, 0x8c, 0x10, 0xf2, 0x4e, 0xeb, 0x7e, 0x0e, 0x1b, 0xfe, 0x55,
	0xe6, 0xfa, 0x57, 0x2d, 0xf9, 0x67, 0x18, 0x5d, 0x7b, 0xc4, 0x68, 0xbb, 0x6c, 0xf4, 0x54, 0x45,
	0xca, 0xdd, 0x79, 0x76, 0x45, 0x2e, 0x4e, 0xfd, 0x1f, 0x3a, 0x58, 0xfd, 0xfb, 0x87, 0x6d, 0xeb,
	0x1f, 0x1f, 0xb6, 0xad, 0x7f, 0x7d, 0xd8, 0xb6, 0xfe, 0xf4, 0xef, 0xed, 0xef, 0x75, 0x16, 0xe8,
	0xa7, 0xf3, 0xeb, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x27, 0x29, 0x26, 0x6a, 0x95, 0x16, 0x00,
	0x00,
}
