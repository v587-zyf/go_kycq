// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: achievement.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		achievement.proto
		area.proto
		arena.proto
		atlas.proto
		auction.proto
		awaken.proto
		bag.proto
		challenge.proto
		chat.proto
		clear.proto
		common.proto
		competitve.proto
		compose.proto
		dailyActivity.proto
		dailyPack.proto
		dailyRank.proto
		dailyTask.proto
		darkPalaceBoss.proto
		dictate.proto
		dragonEquip.proto
		equip.proto
		expPool.proto
		expStage.proto
		fabao.proto
		fashion.proto
		fieldBoss.proto
		fieldFight.proto
		fight.proto
		firstRecharge.proto
		fit.proto
		friend.proto
		gate.proto
		gift.proto
		godEquip.proto
		guild.proto
		guildBonfire.proto
		holyarms.proto
		inside.proto
		jewel.proto
		juexue.proto
		magicCircle.proto
		mail.proto
		materialStage.proto
		mining.proto
		monthCard.proto
		official.proto
		offline.proto
		online.proto
		panacea.proto
		personBoss.proto
		pet.proto
		rank.proto
		rechargeAll.proto
		rein.proto
		ring.proto
		scene.proto
		shabake.proto
		shop.proto
		sign.proto
		skill.proto
		specialEquip.proto
		spendRebates.proto
		stage.proto
		system.proto
		talent.proto
		task.proto
		tower.proto
		user.proto
		vip.proto
		vipBoss.proto
		wing.proto
		worldBoss.proto

	It has these top-level messages:
		AchievementLoadReq
		AchievementLoadAck
		AchievementGetAwardReq
		AchievementGetAwardAck
		ActiveMedalReq
		ActiveMedalAck
		AchievementInfo
		AchievementTaskInfoNtf
		AreaUpLvReq
		AreaUpLvAck
		ArenaOpenReq
		ArenaOpenAck
		EnterArenaFightReq
		ArenaFightNtf
		BuyArenaFightNumReq
		BuyArenaFightNumAck
		RefArenaRankReq
		RefArenaRankAck
		ArenaRank
		AtlasActiveReq
		AtlasActiveAck
		AtlasUpStarReq
		AtlasUpStarAck
		AtlasGatherActiveReq
		AtlasGatherActiveAck
		AtlasGatherUpStarReq
		AtlasGatherUpStarAck
		AtlasWearChangeReq
		AtlasWearChangeAck
		AuctionInfoReq
		AuctionInfoNtf
		AuctionItemInfo
		BidInfoReq
		BidInfoNtf
		BidReq
		BidNtf
		MyBidReq
		MyBidNtf
		BidItemUpdateNtf
		AuctionPutawayItemReq
		AuctionPutawayItemNtf
		BidSuccessInfo
		BidSuccessNoticeNtf
		AuctionBuyTimesReq
		AuctionBuyTimesAck
		MyPutAwayItemInfoReq
		MyPutAwayItemInfoAck
		MyBidInfoItemReq
		MyBidInfoItemAck
		AuctionBidInfo
		AwakenLoadReq
		AwakenLoadAck
		AwakenReq
		AwakenAck
		AwakenUnit
		BagInfoReq
		BagInfoNtf
		BagSpaceAddReq
		BagSpaceAddAck
		BagSortReq
		BagSortAck
		GiftUseReq
		GiftUseAck
		EquipRecoverReq
		EquipRecoverAck
		ItemUseReq
		ItemUseAck
		EquipDestroyReq
		EquipDestroyAck
		WarehouseInfoReq
		WarehouseInfoNtf
		WareHouseSpaceAddReq
		WareHouseSpaceAddAck
		WarehouseAddReq
		WarehouseAddAck
		WarehouseShiftOutReq
		WarehouseShiftOutAck
		WarehouseSortReq
		WarehouseSortAck
		ChallengeInfoReq
		ChallengeInfoAck
		ApplyChallengeReq
		ApplyChallengeAck
		ChallengeEachRoundPeopleReq
		ChallengeEachRoundPeopleAck
		PeopleInfos
		BottomPourReq
		BottomPourAck
		PeopleInfo
		ChallengeOpenNtf
		ChatMessageNtf
		ChatMessageListReq
		ChatMessageListAck
		ChatSendReq
		ChatSendAck
		ClearReq
		ClearAck
		ErrorAck
		UserLoginInfo
		HeroInfo
		UserWear
		Wears
		BriefUserInfo
		BriefUserInfoWithDisplay
		TopDataChangeNtf
		TopDataChange
		BagDataChangeNtf
		ItemChange
		BagEquipDataChangeNtf
		EquipChange
		Item
		GoodsChangeNtf
		ItemUnit
		EquipUnit
		EquipRandProp
		EquipClearArr
		EquipClearInfo
		HeroProp
		TaskInfoNtf
		DisplayNtf
		EventNtf
		DailyConditionNtf
		PropInfo
		EquipGrid
		Fabao
		GodEquip
		Juexue
		Fashion
		Wing
		WingSpecialNtf
		Rein
		ReinCost
		Atlas
		AtlasGather
		Preference
		WorldBossInfoNtf
		VipBoss
		ExpStage
		Display
		SpecialEquipUnit
		GetSource
		RankInfo
		SkillUnit
		ShopInfo
		DictateInfo
		PanaceaInfo
		JewelInfo
		DayStateInfo
		SignInfo
		InsideInfo
		InsideSkill
		Holy
		Ring
		RingPhantom
		PetInfo
		ResetNtf
		FieldFightRivalUserInfo
		DarkPalaceInfo
		FieldBossInfo
		TalentInfo
		TalentUnit
		Fit
		FitSkill
		MonthCardUnit
		FirstRecharge
		SpendRebates
		CompetitveLoadReq
		CompetitveLoadAck
		EnterCompetitveFightReq
		CompetitveFightNtf
		BuyCompetitveChallengeTimesReq
		BuyCompetitveChallengeTimesAck
		RefCompetitveRankReq
		RefCompetitveRankAck
		CompetitveRankInfo
		GetCompetitveDailyRewardReq
		GetCompetitveDailyRewardAck
		ComposeReq
		ComposeAck
		ComposeEquipReq
		ComposeEquipAck
		EnterDailyActivityReq
		DailyActivityResultNtf
		DailyActivityListReq
		DailyActivityListAck
		DailyActivityInfo
		DailyPackBuyReq
		DailyPackBuyAck
		DailyRankLoadReq
		DailyRankLoadAck
		DailyTaskLoadReq
		DailyTaskLoadAck
		BuyChallengeTimeReq
		BuyChallengeTimeAck
		GetExpReq
		GetExpAck
		GetAwardReq
		GetAwardAck
		ResourcesBackGetRewardReq
		ResourcesBackGetRewardAck
		HaveChallengeTime
		ResourcesBackInfo
		DarkPalaceLoadReq
		DarkPalaceLoadAck
		EnterDarkPalaceFightReq
		DarkPalaceFightResultNtf
		DarkPalaceBuyNumReq
		DarkPalaceBuyNumAck
		DarkPalaceBossNtf
		EnterDarkPalaceHelpFightReq
		DarkPalaceHelpFightResultNtf
		DictateUpReq
		DictateUpAck
		DragonEquipUpLvReq
		DragonEquipUpLvAck
		EquipChangeReq
		EquipChangeAck
		EquipLockReq
		EquipLockAck
		EquipStrengthenReq
		EquipStrengthenAck
		EquipRemoveReq
		EquipRemoveAck
		EquipBlessNtf
		ExpPoolLoadReq
		ExpPoolLoadAck
		ExpPoolUpGradeReq
		ExpPoolUpGradeAck
		ExpStageFightReq
		ExpStageDareNumNtf
		ExpStageFightResultNtf
		ExpStageDoubleReq
		ExpStageDoubleAck
		ExpStageRefNtf
		ExpStageBuyNumNtf
		FabaoActiveReq
		FabaoActiveAck
		FabaoUpLevelReq
		FabaoUpLevelAck
		FabaoSkillActiveReq
		FabaoSkillActiveAck
		FashionUpLevelReq
		FashionUpLevelAck
		FashionWearReq
		FashionWearAck
		FieldBossLoadReq
		FieldBossLoadAck
		EnterFieldBossFightReq
		FieldBossFightResultNtf
		FieldBossBuyNumReq
		FieldBossBuyNumAck
		FieldBossNtf
		FieldFightLoadReq
		FieldFightLoadAck
		EnterFieldFightReq
		FieldFightNtf
		BuyFieldFightChallengeTimesReq
		BuyFieldFightChallengeTimesAck
		RefFieldFightRivalUserReq
		RefFieldFightRivalUserAck
		FieldFightListInfo
		FieldFightBeatBackUserInfo
		EnterPublicCopyReq
		EnterPublicCopyAck
		FightItemUseReq
		FightItemUseAck
		FightUserReliveReq
		FightUserReliveAck
		FightPickUpReq
		FightPickUpAck
		FightGetCheerNumReq
		FightGetCheerNumNtf
		FightCheerReq
		FightCheerAck
		FightPotionReq
		FightPotionAck
		FightCollectionReq
		FightCollectionAck
		FightCollectionNtf
		FirstRechargeRewardReq
		FirstRechargeRewardAck
		FirstRechargeNtf
		FitUpLvReq
		FitUpLvAck
		FitSkillUpLvReq
		FitSkillUpLvAck
		FitSkillUpStarReq
		FitSkillUpStarAck
		FitSkillChangeReq
		FitSkillChangeAck
		FitSkillResetReq
		FitSkillResetAck
		FitFashionUpLvReq
		FitFashionUpLvAck
		FitFashionChangeReq
		FitFashionChangeAck
		FitSkillActiveReq
		FitSkillActiveAck
		FitEnterReq
		FitEnterAck
		FitCancleReq
		FitCancleAck
		FriendListReq
		FriendListAck
		FriendAddReq
		FriendAddAck
		FriendDelReq
		FriendDelAck
		FriendBlockAddReq
		FriendBlockAddAck
		FriendSearchReq
		FriendSearchAck
		FriendBlockListReq
		FriendBlockListAck
		FriendBlockDelReq
		FriendBlockDelAck
		FriendInfo
		MsgLog
		ReportGtNoReq
		ReportGtNoAck
		GsBroadCastNtf
		GsMsgNtf
		ReConnectReq
		ReConnectAck
		LogoutReq
		LogoutAck
		OfflineReq
		ChatReq
		ChatRsp
		OnlineNumReq
		OnlineNumAck
		MsgNtf
		PreJumpGsReq
		DoJumpGsReq
		JumpGsReq
		BenchMarkReq
		BenchMarkAck
		KeepAliveRpt
		OpenGiftReq
		OpenGiftAck
		GiftCodeRewardReq
		GiftCodeRewardAck
		LimitedGiftNtf
		LimitedGiftBuyReq
		LimitedGiftBuyAck
		LimitedGiftReq
		GodEquipActiveReq
		GodEquipActiveAck
		GodEquipUpLevelReq
		GodEquipUpLevelAck
		GuildLoadInfoReq
		GuildLoadInfoAck
		CreateGuildReq
		CreateGuildAck
		JoinGuildCombatLimitReq
		JoinGuildCombatLimitAck
		ModifyBulletinReq
		ModifyBulletinAck
		QuitGuildReq
		QuitGuildAck
		KickOutReq
		KickOutAck
		ImpeachPresidentReq
		ImpeachPresidentAck
		GuildCheckMemberInfoReq
		GuildCheckMemberInfoAck
		ApplyJoinGuildReq
		ApplyJoinGuildAck
		GuildAssignReq
		GuildAssignAck
		AllGuildInfosReq
		AllGuildInfosAck
		DissolveGuildReq
		DissolveGuildAck
		JoinGuildDisposeReq
		JoinGuildDisposeAck
		GetApplyUserListReq
		GetApplyUserListAck
		GuildInfo
		GuildMenberInfo
		JoinGuildSuccessNtf
		GuildBonfireLoadReq
		GuildBonfireLoadAck
		GuildBonfireAddExpReq
		GuildBonfireAddExpAck
		WoodPeople
		EnterGuildBonfireFightReq
		GuildBonfireFightNtf
		GuildBonfireOpenStateNtf
		HolyActiveReq
		HolyActiveAck
		HolyUpLevelReq
		HolyUpLevelAck
		HolySkillActiveReq
		HolySkillActiveAck
		HolySkillUpLvReq
		HolySkillUpLvAck
		InsideUpStarReq
		InsideUpStarAck
		InsideUpGradeReq
		InsideUpGradeAck
		InsideUpOrderReq
		InsideUpOrderAck
		InsideSkillUpLvReq
		InsideSkillUpLvAck
		JewelMakeReq
		JewelMakeAck
		JewelUpLvReq
		JewelUpLvAck
		JewelChangeReq
		JewelChangeAck
		JewelRemoveReq
		JewelRemoveAck
		JewelMakeAllReq
		JewelMakeAllAck
		JuexueUpLevelReq
		JuexueUpLevelAck
		MagicCircleUpLvReq
		MagicCircleUpLvAck
		MagicCircleChangeWearReq
		MagicCircleChangeWearAck
		MailReadReq
		MailReadAck
		MailRedeemReq
		MailRedeemAck
		MailRedeemAllReq
		MailRedeemAllAck
		MailNtf
		MailLoadReq
		MailLoadAck
		MailDeleteReq
		MailDeleteAck
		MailDeleteAllReq
		MailDeleteAllAck
		MaterialStageLoadReq
		MaterialStageLoadAck
		EnterMaterialStageFightReq
		MaterialStageFightResultNtf
		MiningLoadReq
		MiningLoadAck
		MiningUpMinerReq
		MiningUpMinerAck
		MiningBuyNumReq
		MiningBuyNumAck
		MiningStartReq
		MiningStartAck
		MiningRobReq
		MiningRobAck
		MiningRobFightAck
		MiningRobBackReq
		MiningRobBackAck
		MiningRobBackFightAck
		MiningRobListReq
		MiningRobListAck
		MiningListReq
		MiningListAck
		MiningDrawLoadReq
		MiningDrawLoadAck
		MiningDrawReq
		MiningDrawAck
		MiningInReq
		MiningInAck
		MiningInfo
		MiningRob
		MiningListInfo
		MonthCardBuyReq
		MonthCardBuyAck
		MonthCardDailyRewardReq
		MonthCardDailyRewardAck
		OfficialUpLevelReq
		OfficialUpLevelAck
		OfflineAwardLoadReq
		OfflineAwardLoadAck
		OfflineAwardGetReq
		OfflineAwardGetAck
		GetOnlineAwardInfoReq
		GetOnlineAwardInfoAck
		GetOnlineAwardReq
		GetOnlineAwardAck
		PanaceaUseReq
		PanaceaUseAck
		PersonBossLoadReq
		PersonBossLoadAck
		EnterPersonBossFightReq
		PersonBossFightResultNtf
		PetActiveReq
		PetActiveAck
		PetUpLvReq
		PetUpLvAck
		PetUpGradeReq
		PetUpGradeAck
		PetBreakReq
		PetBreakAck
		PetChangeWearReq
		PetChangeWearAck
		RankLoadReq
		RankLoadAck
		RankWorshipReq
		RankWorshipAck
		RechargeAllGetReq
		RechargeAllGetAck
		ReinActiveReq
		ReinActiveAck
		ReincarnationReq
		ReincarnationAck
		ReinCostBuyReq
		ReinCostBuyAck
		ReinCostUseReq
		ReinCostUseAck
		ReinCostBuyNumRefNtf
		RingWearReq
		RingWearAck
		RingRemoveReq
		RingRemoveAck
		RingStrengthenReq
		RingStrengthenAck
		RingPhantomReq
		RingPhantomAck
		RingSkillUpReq
		RingSkillUpAck
		RingFuseReq
		RingFuseAck
		RingSkillResetReq
		RingSkillResetAck
		Point
		SceneObj
		SceneUser
		SceneMonster
		ScenePet
		SceneCollection
		SceneFit
		SceneSummon
		SceneItem
		SceneEnterNtf
		SceneEnterOverNtf
		SceneLeaveNtf
		SceneDieNtf
		SceneMoveRpt
		SceneMoveNtf
		SceneUserReliveNtf
		SceneUserUpdateNtf
		AttackRpt
		AttackEffectNtf
		HurtEffect
		SceneObjHpNtf
		SceneObjMpNtf
		FightHurtRankReq
		FightHurtRankAck
		FightRankUnit
		GetBossOwnerChangReq
		BossOwnerChangNtf
		BuffChangeNtf
		BuffDelNtf
		BuffInfo
		DelBuffInfo
		BuffPropChangeNtf
		BuffHpChangeNtf
		BuffHpChangeInfo
		MainCityEnterRpt
		MainCityMoveRpt
		MainCityLeaveRpt
		MainCityUpdateRpt
		FightEnterOkReq
		FightStartCountDownNtf
		FightStartCountDownOkReq
		FightStartNtf
		CollectionStatusChangeNtf
		ExpStageKillInfoNtf
		PaodianTopUserReq
		PaodianTopUserNtf
		PaoDianUserNumNtf
		PaodianFightEnd
		GetShabakeScoresReq
		ShabakeScoreRankNtf
		ShabakeUserScore
		ShabakeGuildScore
		ShabakeOccupiedNtf
		ShaBaKeInfoReq
		ShaBaKeInfoAck
		UserInfo
		EnterShaBaKeFightReq
		ShaBaKeFightResultNtf
		ShabakeIsOpenNtf
		ShopListReq
		ShopListAck
		ShopBuyReq
		ShopBuyAck
		SignReq
		SignAck
		SignRepairReq
		SignRepairAck
		CumulativeSignReq
		CumulativeSignAck
		SkillUpLvReq
		SkillUpLvAck
		SkillChangePosReq
		SkillChangePosAck
		SkillChangeWearReq
		SkillChangeWearAck
		SkillResetReq
		SkillResetAck
		SkillUseReq
		SkillUseNtf
		ClearSkillCdNtf
		SpecialEquipChangeReq
		SpecialEquipChangeAck
		SpecialEquipRemoveReq
		SpecialEquipRemoveAck
		SpendRebatesRewardReq
		SpendRebatesRewardAck
		SpendRebatesNtf
		StageFightStartReq
		StageFightStartAck
		StageFightEndReq
		StageFightEndNtf
		LeaveFightReq
		LeaveFightAck
		KillMonsterReq
		KillMonsterAck
		StartStageBossFightReq
		PingReq
		PingAck
		PreferenceSetReq
		PreferenceSetAck
		PreferenceLoadReq
		PreferenceLoadAck
		TalentUpLvReq
		TalentUpLvAck
		TalentResetReq
		TalentResetAck
		TaskDoneReq
		TaskDoneAck
		TaskNpcStateReq
		TaskNpcStateAck
		OpenTowerReq
		OpenTowerAck
		ToweryDayAwardReq
		ToweryDayAwardAck
		TowerLotteryReq
		TowerLotteryAck
		EnterTowerFightReq
		TowerFightResultNtf
		TowerFightContinueReq
		EnterGameReq
		EnterGameAck
		CreateUserReq
		CreateUserAck
		RandNameReq
		RandNameAck
		CreateHeroReq
		CreateHeroAck
		KickUserNtf
		UserPropertyNtf
		DebugAddGoodsReq
		DebugAddGoodsAck
		ChangeFightModelReq
		ChangeFightModelAck
		ChangeHeroNameReq
		ChangeHeroNameAck
		UserRechargeNumNtf
		VipGiftGetReq
		VipGiftGetAck
		VipBossLoadReq
		VipBossLoadAck
		EnterVipBossFightReq
		VipBossFightResultNtf
		WingUpLevelReq
		WingUpLevelAck
		WingUseMaterialReq
		WingUseMaterialAck
		WingSpecialUpReq
		WingSpecialUpAck
		WingWearReq
		WingWearAck
		EnterWorldBossFightReq
		WorldBossFightResultNtf
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AchievementLoadReq struct {
}

func (m *AchievementLoadReq) Reset()                    { *m = AchievementLoadReq{} }
func (m *AchievementLoadReq) String() string            { return proto.CompactTextString(m) }
func (*AchievementLoadReq) ProtoMessage()               {}
func (*AchievementLoadReq) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{0} }

type AchievementLoadAck struct {
	AchievementInfo []*AchievementInfo `protobuf:"bytes,1,rep,name=achievementInfo" json:"achievementInfo,omitempty"`
	AllPoint        int32              `protobuf:"varint,2,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
	Medal           []int32            `protobuf:"varint,3,rep,packed,name=Medal" json:"Medal,omitempty"`
}

func (m *AchievementLoadAck) Reset()                    { *m = AchievementLoadAck{} }
func (m *AchievementLoadAck) String() string            { return proto.CompactTextString(m) }
func (*AchievementLoadAck) ProtoMessage()               {}
func (*AchievementLoadAck) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{1} }

func (m *AchievementLoadAck) GetAchievementInfo() []*AchievementInfo {
	if m != nil {
		return m.AchievementInfo
	}
	return nil
}

func (m *AchievementLoadAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

func (m *AchievementLoadAck) GetMedal() []int32 {
	if m != nil {
		return m.Medal
	}
	return nil
}

// 领奖
type AchievementGetAwardReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AchievementGetAwardReq) Reset()         { *m = AchievementGetAwardReq{} }
func (m *AchievementGetAwardReq) String() string { return proto.CompactTextString(m) }
func (*AchievementGetAwardReq) ProtoMessage()    {}
func (*AchievementGetAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{2}
}

func (m *AchievementGetAwardReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type AchievementGetAwardAck struct {
	AchievementInfo []*AchievementInfo `protobuf:"bytes,1,rep,name=achievementInfo" json:"achievementInfo,omitempty"`
	AllPoint        int32              `protobuf:"varint,2,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
}

func (m *AchievementGetAwardAck) Reset()         { *m = AchievementGetAwardAck{} }
func (m *AchievementGetAwardAck) String() string { return proto.CompactTextString(m) }
func (*AchievementGetAwardAck) ProtoMessage()    {}
func (*AchievementGetAwardAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{3}
}

func (m *AchievementGetAwardAck) GetAchievementInfo() []*AchievementInfo {
	if m != nil {
		return m.AchievementInfo
	}
	return nil
}

func (m *AchievementGetAwardAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

// 激活徽章
type ActiveMedalReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ActiveMedalReq) Reset()                    { *m = ActiveMedalReq{} }
func (m *ActiveMedalReq) String() string            { return proto.CompactTextString(m) }
func (*ActiveMedalReq) ProtoMessage()               {}
func (*ActiveMedalReq) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{4} }

func (m *ActiveMedalReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ActiveMedalAck struct {
	AllPoint int32   `protobuf:"varint,1,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
	Medal    []int32 `protobuf:"varint,2,rep,packed,name=Medal" json:"Medal,omitempty"`
}

func (m *ActiveMedalAck) Reset()                    { *m = ActiveMedalAck{} }
func (m *ActiveMedalAck) String() string            { return proto.CompactTextString(m) }
func (*ActiveMedalAck) ProtoMessage()               {}
func (*ActiveMedalAck) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{5} }

func (m *ActiveMedalAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

func (m *ActiveMedalAck) GetMedal() []int32 {
	if m != nil {
		return m.Medal
	}
	return nil
}

type AchievementInfo struct {
	ConditionType int32 `protobuf:"varint,1,opt,name=conditionType,proto3" json:"conditionType,omitempty"`
	CanGetId      int32 `protobuf:"varint,2,opt,name=canGetId,proto3" json:"canGetId,omitempty"`
	Process       int32 `protobuf:"varint,3,opt,name=process,proto3" json:"process,omitempty"`
	IsGetAllAward int32 `protobuf:"varint,4,opt,name=isGetAllAward,proto3" json:"isGetAllAward,omitempty"`
}

func (m *AchievementInfo) Reset()                    { *m = AchievementInfo{} }
func (m *AchievementInfo) String() string            { return proto.CompactTextString(m) }
func (*AchievementInfo) ProtoMessage()               {}
func (*AchievementInfo) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{6} }

func (m *AchievementInfo) GetConditionType() int32 {
	if m != nil {
		return m.ConditionType
	}
	return 0
}

func (m *AchievementInfo) GetCanGetId() int32 {
	if m != nil {
		return m.CanGetId
	}
	return 0
}

func (m *AchievementInfo) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

func (m *AchievementInfo) GetIsGetAllAward() int32 {
	if m != nil {
		return m.IsGetAllAward
	}
	return 0
}

type AchievementTaskInfoNtf struct {
	TaskId        int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Process       int32 `protobuf:"varint,2,opt,name=process,proto3" json:"process,omitempty"`
	ConditionType int32 `protobuf:"varint,3,opt,name=conditionType,proto3" json:"conditionType,omitempty"`
}

func (m *AchievementTaskInfoNtf) Reset()         { *m = AchievementTaskInfoNtf{} }
func (m *AchievementTaskInfoNtf) String() string { return proto.CompactTextString(m) }
func (*AchievementTaskInfoNtf) ProtoMessage()    {}
func (*AchievementTaskInfoNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{7}
}

func (m *AchievementTaskInfoNtf) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *AchievementTaskInfoNtf) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

func (m *AchievementTaskInfoNtf) GetConditionType() int32 {
	if m != nil {
		return m.ConditionType
	}
	return 0
}

func init() {
	proto.RegisterType((*AchievementLoadReq)(nil), "pb.AchievementLoadReq")
	proto.RegisterType((*AchievementLoadAck)(nil), "pb.AchievementLoadAck")
	proto.RegisterType((*AchievementGetAwardReq)(nil), "pb.AchievementGetAwardReq")
	proto.RegisterType((*AchievementGetAwardAck)(nil), "pb.AchievementGetAwardAck")
	proto.RegisterType((*ActiveMedalReq)(nil), "pb.ActiveMedalReq")
	proto.RegisterType((*ActiveMedalAck)(nil), "pb.ActiveMedalAck")
	proto.RegisterType((*AchievementInfo)(nil), "pb.AchievementInfo")
	proto.RegisterType((*AchievementTaskInfoNtf)(nil), "pb.AchievementTaskInfoNtf")
}
func (m *AchievementLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AchievementLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, msg := range m.AchievementInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAchievement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AllPoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		dAtA2 := make([]byte, len(m.Medal)*10)
		var j1 int
		for _, num1 := range m.Medal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *AchievementGetAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementGetAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *AchievementGetAwardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementGetAwardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, msg := range m.AchievementInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAchievement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AllPoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	return i, nil
}

func (m *ActiveMedalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveMedalReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ActiveMedalAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveMedalAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllPoint != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		dAtA4 := make([]byte, len(m.Medal)*10)
		var j3 int
		for _, num1 := range m.Medal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *AchievementInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConditionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.ConditionType))
	}
	if m.CanGetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.CanGetId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Process))
	}
	if m.IsGetAllAward != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.IsGetAllAward))
	}
	return i, nil
}

func (m *AchievementTaskInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementTaskInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.TaskId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Process))
	}
	if m.ConditionType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.ConditionType))
	}
	return i, nil
}

func encodeVarintAchievement(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AchievementLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AchievementLoadAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, e := range m.AchievementInfo {
			l = e.Size()
			n += 1 + l + sovAchievement(uint64(l))
		}
	}
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		l = 0
		for _, e := range m.Medal {
			l += sovAchievement(uint64(e))
		}
		n += 1 + sovAchievement(uint64(l)) + l
	}
	return n
}

func (m *AchievementGetAwardReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAchievement(uint64(m.Id))
	}
	return n
}

func (m *AchievementGetAwardAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, e := range m.AchievementInfo {
			l = e.Size()
			n += 1 + l + sovAchievement(uint64(l))
		}
	}
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	return n
}

func (m *ActiveMedalReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAchievement(uint64(m.Id))
	}
	return n
}

func (m *ActiveMedalAck) Size() (n int) {
	var l int
	_ = l
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		l = 0
		for _, e := range m.Medal {
			l += sovAchievement(uint64(e))
		}
		n += 1 + sovAchievement(uint64(l)) + l
	}
	return n
}

func (m *AchievementInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConditionType != 0 {
		n += 1 + sovAchievement(uint64(m.ConditionType))
	}
	if m.CanGetId != 0 {
		n += 1 + sovAchievement(uint64(m.CanGetId))
	}
	if m.Process != 0 {
		n += 1 + sovAchievement(uint64(m.Process))
	}
	if m.IsGetAllAward != 0 {
		n += 1 + sovAchievement(uint64(m.IsGetAllAward))
	}
	return n
}

func (m *AchievementTaskInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovAchievement(uint64(m.TaskId))
	}
	if m.Process != 0 {
		n += 1 + sovAchievement(uint64(m.Process))
	}
	if m.ConditionType != 0 {
		n += 1 + sovAchievement(uint64(m.ConditionType))
	}
	return n
}

func sovAchievement(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAchievement(x uint64) (n int) {
	return sovAchievement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AchievementLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAchievement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementInfo = append(m.AchievementInfo, &AchievementInfo{})
			if err := m.AchievementInfo[len(m.AchievementInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medal = append(m.Medal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAchievement
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAchievement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medal = append(m.Medal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medal", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementGetAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementGetAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementGetAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementGetAwardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementGetAwardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementGetAwardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAchievement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementInfo = append(m.AchievementInfo, &AchievementInfo{})
			if err := m.AchievementInfo[len(m.AchievementInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveMedalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveMedalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveMedalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveMedalAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveMedalAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveMedalAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medal = append(m.Medal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAchievement
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAchievement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medal = append(m.Medal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medal", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGetId", wireType)
			}
			m.CanGetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanGetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGetAllAward", wireType)
			}
			m.IsGetAllAward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsGetAllAward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementTaskInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementTaskInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementTaskInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAchievement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAchievement
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAchievement(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAchievement = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAchievement   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("achievement.proto", fileDescriptorAchievement) }

var fileDescriptorAchievement = []byte{
	// 333 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0xb1, 0x4e, 0xf3, 0x30,
	0x14, 0x85, 0x7f, 0x27, 0x7f, 0x0b, 0xba, 0x88, 0x16, 0x4c, 0x55, 0x59, 0x0c, 0x51, 0x14, 0x31,
	0x64, 0xea, 0x00, 0x33, 0x43, 0xba, 0x54, 0x95, 0x00, 0xa1, 0xa8, 0x2f, 0xe0, 0xc6, 0xae, 0xb0,
	0x1a, 0x6c, 0xd3, 0x58, 0x45, 0x3c, 0x00, 0x4f, 0xc0, 0xc2, 0x23, 0x31, 0xf2, 0x08, 0xa8, 0xbc,
	0x08, 0x72, 0xda, 0x40, 0xdc, 0x86, 0x91, 0xf1, 0xdc, 0x7b, 0x75, 0xce, 0xe7, 0x23, 0xc3, 0x31,
	0xcd, 0xee, 0x04, 0x5f, 0xf2, 0x7b, 0x2e, 0xcd, 0x40, 0x2f, 0x94, 0x51, 0xd8, 0xd3, 0xd3, 0xa8,
	0x07, 0x38, 0xf9, 0x59, 0x5c, 0x29, 0xca, 0x52, 0xfe, 0x10, 0x3d, 0xa3, 0x9d, 0x71, 0x92, 0xcd,
	0xf1, 0x25, 0x74, 0x6b, 0x2e, 0x63, 0x39, 0x53, 0x04, 0x85, 0x7e, 0x7c, 0x70, 0x7e, 0x32, 0xd0,
	0xd3, 0x41, 0xe2, 0xae, 0xd2, 0xed, 0x5b, 0x7c, 0x0a, 0xfb, 0x34, 0xcf, 0x6f, 0x95, 0x90, 0x86,
	0x78, 0x21, 0x8a, 0x5b, 0xe9, 0xb7, 0xc6, 0x3d, 0x68, 0x5d, 0x73, 0x46, 0x73, 0xe2, 0x87, 0x7e,
	0xdc, 0x4a, 0xd7, 0x22, 0x8a, 0xa1, 0x5f, 0x73, 0x1d, 0x71, 0x93, 0x3c, 0xd2, 0x85, 0x25, 0xc4,
	0x1d, 0xf0, 0x04, 0x23, 0xa8, 0x74, 0xf1, 0x04, 0x8b, 0x8a, 0xc6, 0xcb, 0xbf, 0x85, 0x8e, 0x42,
	0xe8, 0x24, 0x99, 0x11, 0x4b, 0x5e, 0xd2, 0x36, 0x61, 0x0d, 0x9d, 0x0b, 0x8b, 0x53, 0xf7, 0x43,
	0xbf, 0x95, 0xe0, 0xd5, 0x4b, 0x78, 0x41, 0xd0, 0xdd, 0xc2, 0xc4, 0x67, 0x70, 0x98, 0x29, 0xc9,
	0x84, 0x11, 0x4a, 0x4e, 0x9e, 0x34, 0xdf, 0x58, 0xb9, 0x43, 0x9b, 0x95, 0x51, 0x39, 0xe2, 0x66,
	0xcc, 0x2a, 0xf6, 0x4a, 0x63, 0x02, 0x7b, 0x7a, 0xa1, 0x32, 0x5e, 0x14, 0xc4, 0x2f, 0x57, 0x95,
	0xb4, 0xde, 0xa2, 0xb0, 0x0d, 0xe6, 0x79, 0x59, 0x22, 0xf9, 0xbf, 0xf6, 0x76, 0x86, 0x91, 0x76,
	0x0a, 0x9f, 0xd0, 0x62, 0x6e, 0xc1, 0x6e, 0xcc, 0x0c, 0xf7, 0xa1, 0x6d, 0xac, 0xac, 0x7a, 0xd8,
	0xa8, 0x7a, 0xa2, 0xb7, 0x93, 0xe8, 0xbe, 0xc6, 0x6f, 0x78, 0xcd, 0xf0, 0xe8, 0x6d, 0x15, 0xa0,
	0xf7, 0x55, 0x80, 0x3e, 0x56, 0x01, 0x7a, 0xfd, 0x0c, 0xfe, 0x4d, 0xdb, 0xe5, 0x3f, 0xbe, 0xf8,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0x56, 0x8d, 0x76, 0xa1, 0xdc, 0x02, 0x00, 0x00,
}
