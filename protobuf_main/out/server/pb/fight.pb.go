// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fight.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EnterPublicCopyReq struct {
	StageId   int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Condition int32 `protobuf:"varint,2,opt,name=condition,proto3" json:"condition,omitempty"`
}

func (m *EnterPublicCopyReq) Reset()                    { *m = EnterPublicCopyReq{} }
func (m *EnterPublicCopyReq) String() string            { return proto.CompactTextString(m) }
func (*EnterPublicCopyReq) ProtoMessage()               {}
func (*EnterPublicCopyReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{0} }

func (m *EnterPublicCopyReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *EnterPublicCopyReq) GetCondition() int32 {
	if m != nil {
		return m.Condition
	}
	return 0
}

type EnterPublicCopyAck struct {
	FailReason string `protobuf:"bytes,1,opt,name=failReason,proto3" json:"failReason,omitempty"`
}

func (m *EnterPublicCopyAck) Reset()                    { *m = EnterPublicCopyAck{} }
func (m *EnterPublicCopyAck) String() string            { return proto.CompactTextString(m) }
func (*EnterPublicCopyAck) ProtoMessage()               {}
func (*EnterPublicCopyAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{1} }

func (m *EnterPublicCopyAck) GetFailReason() string {
	if m != nil {
		return m.FailReason
	}
	return ""
}

// 战斗申请道具使用
type FightItemUseReq struct {
	ItemId int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
}

func (m *FightItemUseReq) Reset()                    { *m = FightItemUseReq{} }
func (m *FightItemUseReq) String() string            { return proto.CompactTextString(m) }
func (*FightItemUseReq) ProtoMessage()               {}
func (*FightItemUseReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{2} }

func (m *FightItemUseReq) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

// 战斗申请道具使用
type FightItemUseAck struct {
	ItemId   int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	UseTimes int32 `protobuf:"varint,2,opt,name=useTimes,proto3" json:"useTimes,omitempty"`
}

func (m *FightItemUseAck) Reset()                    { *m = FightItemUseAck{} }
func (m *FightItemUseAck) String() string            { return proto.CompactTextString(m) }
func (*FightItemUseAck) ProtoMessage()               {}
func (*FightItemUseAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{3} }

func (m *FightItemUseAck) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *FightItemUseAck) GetUseTimes() int32 {
	if m != nil {
		return m.UseTimes
	}
	return 0
}

// 战斗申请复活
type FightUserReliveReq struct {
	SafeRelive bool `protobuf:"varint,1,opt,name=safeRelive,proto3" json:"safeRelive,omitempty"`
}

func (m *FightUserReliveReq) Reset()                    { *m = FightUserReliveReq{} }
func (m *FightUserReliveReq) String() string            { return proto.CompactTextString(m) }
func (*FightUserReliveReq) ProtoMessage()               {}
func (*FightUserReliveReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{4} }

func (m *FightUserReliveReq) GetSafeRelive() bool {
	if m != nil {
		return m.SafeRelive
	}
	return false
}

// 战斗申请复活
type FightUserReliveAck struct {
	ReliveTimes        int32 `protobuf:"varint,1,opt,name=reliveTimes,proto3" json:"reliveTimes,omitempty"`
	ReliveByIngotTimes int32 `protobuf:"varint,2,opt,name=reliveByIngotTimes,proto3" json:"reliveByIngotTimes,omitempty"`
}

func (m *FightUserReliveAck) Reset()                    { *m = FightUserReliveAck{} }
func (m *FightUserReliveAck) String() string            { return proto.CompactTextString(m) }
func (*FightUserReliveAck) ProtoMessage()               {}
func (*FightUserReliveAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{5} }

func (m *FightUserReliveAck) GetReliveTimes() int32 {
	if m != nil {
		return m.ReliveTimes
	}
	return 0
}

func (m *FightUserReliveAck) GetReliveByIngotTimes() int32 {
	if m != nil {
		return m.ReliveByIngotTimes
	}
	return 0
}

// 掉落物品拾取
type FightPickUpReq struct {
	DropItemIds []int32 `protobuf:"varint,1,rep,packed,name=dropItemIds" json:"dropItemIds,omitempty"`
}

func (m *FightPickUpReq) Reset()                    { *m = FightPickUpReq{} }
func (m *FightPickUpReq) String() string            { return proto.CompactTextString(m) }
func (*FightPickUpReq) ProtoMessage()               {}
func (*FightPickUpReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{6} }

func (m *FightPickUpReq) GetDropItemIds() []int32 {
	if m != nil {
		return m.DropItemIds
	}
	return nil
}

// 掉落物品拾取
type FightPickUpAck struct {
	Items map[int32]*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FightPickUpAck) Reset()                    { *m = FightPickUpAck{} }
func (m *FightPickUpAck) String() string            { return proto.CompactTextString(m) }
func (*FightPickUpAck) ProtoMessage()               {}
func (*FightPickUpAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{7} }

func (m *FightPickUpAck) GetItems() map[int32]*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

// 获取鼓舞次数
type FightGetCheerNumReq struct {
}

func (m *FightGetCheerNumReq) Reset()                    { *m = FightGetCheerNumReq{} }
func (m *FightGetCheerNumReq) String() string            { return proto.CompactTextString(m) }
func (*FightGetCheerNumReq) ProtoMessage()               {}
func (*FightGetCheerNumReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{8} }

type FightGetCheerNumNtf struct {
	CheerNum int32 `protobuf:"varint,1,opt,name=cheerNum,proto3" json:"cheerNum,omitempty"`
}

func (m *FightGetCheerNumNtf) Reset()                    { *m = FightGetCheerNumNtf{} }
func (m *FightGetCheerNumNtf) String() string            { return proto.CompactTextString(m) }
func (*FightGetCheerNumNtf) ProtoMessage()               {}
func (*FightGetCheerNumNtf) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{9} }

func (m *FightGetCheerNumNtf) GetCheerNum() int32 {
	if m != nil {
		return m.CheerNum
	}
	return 0
}

// 鼓舞申请
type FightCheerReq struct {
}

func (m *FightCheerReq) Reset()                    { *m = FightCheerReq{} }
func (m *FightCheerReq) String() string            { return proto.CompactTextString(m) }
func (*FightCheerReq) ProtoMessage()               {}
func (*FightCheerReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{10} }

type FightCheerAck struct {
	CheerNum int32 `protobuf:"varint,1,opt,name=cheerNum,proto3" json:"cheerNum,omitempty"`
}

func (m *FightCheerAck) Reset()                    { *m = FightCheerAck{} }
func (m *FightCheerAck) String() string            { return proto.CompactTextString(m) }
func (*FightCheerAck) ProtoMessage()               {}
func (*FightCheerAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{11} }

func (m *FightCheerAck) GetCheerNum() int32 {
	if m != nil {
		return m.CheerNum
	}
	return 0
}

// 药水使用
type FightPotionReq struct {
}

func (m *FightPotionReq) Reset()                    { *m = FightPotionReq{} }
func (m *FightPotionReq) String() string            { return proto.CompactTextString(m) }
func (*FightPotionReq) ProtoMessage()               {}
func (*FightPotionReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{12} }

type FightPotionAck struct {
	CoolDown   int32 `protobuf:"varint,1,opt,name=coolDown,proto3" json:"coolDown,omitempty"`
	ServerTime int32 `protobuf:"varint,2,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	EndTime    int32 `protobuf:"varint,3,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *FightPotionAck) Reset()                    { *m = FightPotionAck{} }
func (m *FightPotionAck) String() string            { return proto.CompactTextString(m) }
func (*FightPotionAck) ProtoMessage()               {}
func (*FightPotionAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{13} }

func (m *FightPotionAck) GetCoolDown() int32 {
	if m != nil {
		return m.CoolDown
	}
	return 0
}

func (m *FightPotionAck) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *FightPotionAck) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type FightCollectionReq struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *FightCollectionReq) Reset()                    { *m = FightCollectionReq{} }
func (m *FightCollectionReq) String() string            { return proto.CompactTextString(m) }
func (*FightCollectionReq) ProtoMessage()               {}
func (*FightCollectionReq) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{14} }

func (m *FightCollectionReq) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type FightCollectionAck struct {
	StartTime int64 `protobuf:"varint,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	ObjId     int32 `protobuf:"varint,3,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *FightCollectionAck) Reset()                    { *m = FightCollectionAck{} }
func (m *FightCollectionAck) String() string            { return proto.CompactTextString(m) }
func (*FightCollectionAck) ProtoMessage()               {}
func (*FightCollectionAck) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{15} }

func (m *FightCollectionAck) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *FightCollectionAck) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *FightCollectionAck) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

// 推送玩家采集结束
type FightCollectionNtf struct {
	Goods *GoodsChangeNtf `protobuf:"bytes,1,opt,name=goods" json:"goods,omitempty"`
}

func (m *FightCollectionNtf) Reset()                    { *m = FightCollectionNtf{} }
func (m *FightCollectionNtf) String() string            { return proto.CompactTextString(m) }
func (*FightCollectionNtf) ProtoMessage()               {}
func (*FightCollectionNtf) Descriptor() ([]byte, []int) { return fileDescriptorFight, []int{16} }

func (m *FightCollectionNtf) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func init() {
	proto.RegisterType((*EnterPublicCopyReq)(nil), "pb.EnterPublicCopyReq")
	proto.RegisterType((*EnterPublicCopyAck)(nil), "pb.EnterPublicCopyAck")
	proto.RegisterType((*FightItemUseReq)(nil), "pb.FightItemUseReq")
	proto.RegisterType((*FightItemUseAck)(nil), "pb.FightItemUseAck")
	proto.RegisterType((*FightUserReliveReq)(nil), "pb.FightUserReliveReq")
	proto.RegisterType((*FightUserReliveAck)(nil), "pb.FightUserReliveAck")
	proto.RegisterType((*FightPickUpReq)(nil), "pb.FightPickUpReq")
	proto.RegisterType((*FightPickUpAck)(nil), "pb.FightPickUpAck")
	proto.RegisterType((*FightGetCheerNumReq)(nil), "pb.FightGetCheerNumReq")
	proto.RegisterType((*FightGetCheerNumNtf)(nil), "pb.FightGetCheerNumNtf")
	proto.RegisterType((*FightCheerReq)(nil), "pb.FightCheerReq")
	proto.RegisterType((*FightCheerAck)(nil), "pb.FightCheerAck")
	proto.RegisterType((*FightPotionReq)(nil), "pb.FightPotionReq")
	proto.RegisterType((*FightPotionAck)(nil), "pb.FightPotionAck")
	proto.RegisterType((*FightCollectionReq)(nil), "pb.FightCollectionReq")
	proto.RegisterType((*FightCollectionAck)(nil), "pb.FightCollectionAck")
	proto.RegisterType((*FightCollectionNtf)(nil), "pb.FightCollectionNtf")
}
func (m *EnterPublicCopyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterPublicCopyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.StageId))
	}
	if m.Condition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.Condition))
	}
	return i, nil
}

func (m *EnterPublicCopyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterPublicCopyAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FailReason) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFight(dAtA, i, uint64(len(m.FailReason)))
		i += copy(dAtA[i:], m.FailReason)
	}
	return i, nil
}

func (m *FightItemUseReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightItemUseReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *FightItemUseAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightItemUseAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ItemId))
	}
	if m.UseTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.UseTimes))
	}
	return i, nil
}

func (m *FightUserReliveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightUserReliveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SafeRelive {
		dAtA[i] = 0x8
		i++
		if m.SafeRelive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FightUserReliveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightUserReliveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ReliveByIngotTimes))
	}
	return i, nil
}

func (m *FightPickUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightPickUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DropItemIds) > 0 {
		dAtA2 := make([]byte, len(m.DropItemIds)*10)
		var j1 int
		for _, num1 := range m.DropItemIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintFight(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *FightPickUpAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightPickUpAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0xa
			i++
			v := m.Items[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFight(uint64(msgSize))
			}
			mapSize := 1 + sovFight(uint64(k)) + msgSize
			i = encodeVarintFight(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFight(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFight(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *FightGetCheerNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightGetCheerNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightGetCheerNumNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightGetCheerNumNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CheerNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.CheerNum))
	}
	return i, nil
}

func (m *FightCheerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightCheerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightCheerAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightCheerAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CheerNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.CheerNum))
	}
	return i, nil
}

func (m *FightPotionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightPotionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightPotionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightPotionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoolDown != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.CoolDown))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *FightCollectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightCollectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *FightCollectionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightCollectionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.EndTime))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *FightCollectionNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightCollectionNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFight(dAtA, i, uint64(m.Goods.Size()))
		n4, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func encodeVarintFight(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EnterPublicCopyReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFight(uint64(m.StageId))
	}
	if m.Condition != 0 {
		n += 1 + sovFight(uint64(m.Condition))
	}
	return n
}

func (m *EnterPublicCopyAck) Size() (n int) {
	var l int
	_ = l
	l = len(m.FailReason)
	if l > 0 {
		n += 1 + l + sovFight(uint64(l))
	}
	return n
}

func (m *FightItemUseReq) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovFight(uint64(m.ItemId))
	}
	return n
}

func (m *FightItemUseAck) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovFight(uint64(m.ItemId))
	}
	if m.UseTimes != 0 {
		n += 1 + sovFight(uint64(m.UseTimes))
	}
	return n
}

func (m *FightUserReliveReq) Size() (n int) {
	var l int
	_ = l
	if m.SafeRelive {
		n += 2
	}
	return n
}

func (m *FightUserReliveAck) Size() (n int) {
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		n += 1 + sovFight(uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		n += 1 + sovFight(uint64(m.ReliveByIngotTimes))
	}
	return n
}

func (m *FightPickUpReq) Size() (n int) {
	var l int
	_ = l
	if len(m.DropItemIds) > 0 {
		l = 0
		for _, e := range m.DropItemIds {
			l += sovFight(uint64(e))
		}
		n += 1 + sovFight(uint64(l)) + l
	}
	return n
}

func (m *FightPickUpAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFight(uint64(l))
			}
			mapEntrySize := 1 + sovFight(uint64(k)) + l
			n += mapEntrySize + 1 + sovFight(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FightGetCheerNumReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightGetCheerNumNtf) Size() (n int) {
	var l int
	_ = l
	if m.CheerNum != 0 {
		n += 1 + sovFight(uint64(m.CheerNum))
	}
	return n
}

func (m *FightCheerReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightCheerAck) Size() (n int) {
	var l int
	_ = l
	if m.CheerNum != 0 {
		n += 1 + sovFight(uint64(m.CheerNum))
	}
	return n
}

func (m *FightPotionReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightPotionAck) Size() (n int) {
	var l int
	_ = l
	if m.CoolDown != 0 {
		n += 1 + sovFight(uint64(m.CoolDown))
	}
	if m.ServerTime != 0 {
		n += 1 + sovFight(uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFight(uint64(m.EndTime))
	}
	return n
}

func (m *FightCollectionReq) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovFight(uint64(m.ObjId))
	}
	return n
}

func (m *FightCollectionAck) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovFight(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFight(uint64(m.EndTime))
	}
	if m.ObjId != 0 {
		n += 1 + sovFight(uint64(m.ObjId))
	}
	return n
}

func (m *FightCollectionNtf) Size() (n int) {
	var l int
	_ = l
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovFight(uint64(l))
	}
	return n
}

func sovFight(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFight(x uint64) (n int) {
	return sovFight(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EnterPublicCopyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterPublicCopyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterPublicCopyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			m.Condition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Condition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterPublicCopyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterPublicCopyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterPublicCopyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFight
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightItemUseReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightItemUseReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightItemUseReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightItemUseAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightItemUseAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightItemUseAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTimes", wireType)
			}
			m.UseTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightUserReliveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightUserReliveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightUserReliveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeRelive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SafeRelive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightUserReliveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightUserReliveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightUserReliveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTimes", wireType)
			}
			m.ReliveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveByIngotTimes", wireType)
			}
			m.ReliveByIngotTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveByIngotTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightPickUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightPickUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightPickUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFight
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DropItemIds = append(m.DropItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFight
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFight
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFight
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DropItemIds = append(m.DropItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DropItemIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightPickUpAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightPickUpAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightPickUpAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFight
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]*ItemUnit)
			}
			var mapkey int32
			var mapvalue *ItemUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFight
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFight
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFight
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFight
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFight
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFight(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFight
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightGetCheerNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightGetCheerNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightGetCheerNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightGetCheerNumNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightGetCheerNumNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightGetCheerNumNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheerNum", wireType)
			}
			m.CheerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightCheerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightCheerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightCheerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightCheerAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightCheerAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightCheerAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheerNum", wireType)
			}
			m.CheerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightPotionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightPotionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightPotionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightPotionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightPotionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightPotionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoolDown", wireType)
			}
			m.CoolDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoolDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightCollectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightCollectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightCollectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightCollectionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightCollectionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightCollectionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightCollectionNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightCollectionNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightCollectionNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFight
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFight(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFight
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFight
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFight
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFight
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFight
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFight(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFight = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFight   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fight.proto", fileDescriptorFight) }

var fileDescriptorFight = []byte{
	// 546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xdf, 0x8e, 0xd2, 0x4e,
	0x14, 0xfe, 0x15, 0xc2, 0xfe, 0x96, 0xd3, 0xd5, 0x25, 0xe3, 0x9f, 0x10, 0xb2, 0x36, 0x64, 0xae,
	0x56, 0x4d, 0x48, 0x64, 0xbd, 0x30, 0x5e, 0x98, 0xb8, 0xc8, 0x6e, 0x48, 0x0c, 0xd9, 0x4c, 0xe4,
	0x01, 0xda, 0x72, 0x0a, 0x95, 0x76, 0xa6, 0xdb, 0x0e, 0x18, 0x1e, 0xc2, 0x7b, 0x1f, 0xc9, 0x4b,
	0x1f, 0xc1, 0xe0, 0x8b, 0x98, 0x33, 0x53, 0xa0, 0x04, 0xf5, 0x8e, 0xef, 0x3b, 0xe7, 0x3b, 0xdf,
	0x37, 0x33, 0xa7, 0x80, 0x1b, 0xc5, 0xb3, 0xb9, 0xee, 0x65, 0xb9, 0xd2, 0x8a, 0xd5, 0xb2, 0xa0,
	0x73, 0x16, 0xaa, 0x34, 0x55, 0xd2, 0x32, 0xfc, 0x23, 0xb0, 0xa1, 0xd4, 0x98, 0xdf, 0x2d, 0x83,
	0x24, 0x0e, 0x07, 0x2a, 0x5b, 0x0b, 0xbc, 0x67, 0x6d, 0xf8, 0xbf, 0xd0, 0xfe, 0x0c, 0x47, 0xd3,
	0xb6, 0xd3, 0x75, 0x2e, 0x1b, 0x62, 0x0b, 0xd9, 0x05, 0x34, 0x43, 0x25, 0xa7, 0xb1, 0x8e, 0x95,
	0x6c, 0xd7, 0x4c, 0x6d, 0x4f, 0xf0, 0xd7, 0x47, 0xd3, 0xde, 0x87, 0x0b, 0xe6, 0x01, 0x44, 0x7e,
	0x9c, 0x08, 0xf4, 0x0b, 0x25, 0xcd, 0xc0, 0xa6, 0xa8, 0x30, 0xfc, 0x39, 0x9c, 0xdf, 0x50, 0xc8,
	0x91, 0xc6, 0x74, 0x52, 0x20, 0x05, 0x78, 0x0a, 0x27, 0xb1, 0xc6, 0x74, 0xe7, 0x5f, 0x22, 0x3e,
	0x3c, 0x6c, 0xa5, 0xe9, 0x7f, 0x69, 0x65, 0x1d, 0x38, 0x5d, 0x16, 0xf8, 0x29, 0x4e, 0xb1, 0x28,
	0x83, 0xee, 0x30, 0xe5, 0x34, 0x63, 0x26, 0x05, 0xe6, 0x02, 0x93, 0x78, 0x65, 0x4c, 0x3d, 0x80,
	0xc2, 0x8f, 0xd0, 0x12, 0x66, 0xda, 0xa9, 0xa8, 0x30, 0x3c, 0x3a, 0x52, 0x91, 0x7f, 0x17, 0xdc,
	0xdc, 0x00, 0x6b, 0x65, 0x43, 0x54, 0x29, 0xd6, 0x03, 0x66, 0xe1, 0xf5, 0x7a, 0x24, 0x67, 0x4a,
	0x57, 0x33, 0xfd, 0xa1, 0xc2, 0xfb, 0xf0, 0xd0, 0xf8, 0xdc, 0xc5, 0xe1, 0x62, 0x92, 0x51, 0xb2,
	0x2e, 0xb8, 0xd3, 0x5c, 0x65, 0x23, 0x73, 0x32, 0xf2, 0xa8, 0x93, 0x47, 0x85, 0xe2, 0x5f, 0x9d,
	0x03, 0x11, 0x05, 0xbb, 0x82, 0x06, 0x5d, 0x85, 0x6d, 0x77, 0xfb, 0xcf, 0x7a, 0x59, 0xd0, 0x3b,
	0x6c, 0xe9, 0x91, 0xba, 0x18, 0x4a, 0x9d, 0xaf, 0x85, 0xed, 0xed, 0xdc, 0x00, 0xec, 0x49, 0xd6,
	0x82, 0xfa, 0x02, 0xd7, 0xe5, 0x99, 0xe8, 0x27, 0xe3, 0xd0, 0x58, 0xf9, 0xc9, 0x12, 0x4d, 0x7c,
	0xb7, 0x7f, 0x46, 0x43, 0x49, 0x39, 0x91, 0xb1, 0x16, 0xb6, 0xf4, 0xb6, 0xf6, 0xc6, 0xe1, 0x4f,
	0xe0, 0x91, 0xf1, 0xba, 0x45, 0x3d, 0x98, 0x23, 0xe6, 0xe3, 0x65, 0x2a, 0xf0, 0x9e, 0xbf, 0x3a,
	0xa6, 0xc7, 0x3a, 0xa2, 0xb7, 0x0a, 0x4b, 0x58, 0x9a, 0xed, 0x30, 0x3f, 0x87, 0x07, 0x46, 0x62,
	0xfa, 0x69, 0xc6, 0xcb, 0x2a, 0x41, 0x07, 0xfd, 0x97, 0xba, 0xb5, 0xbd, 0x16, 0x45, 0x0b, 0x4a,
	0xf2, 0xe8, 0x80, 0xd9, 0xea, 0x95, 0x4a, 0x3e, 0xa8, 0x2f, 0x72, 0xa7, 0x2f, 0xb1, 0xd9, 0x09,
	0xcc, 0x57, 0x98, 0xd3, 0xd3, 0x94, 0x6f, 0x56, 0x61, 0xe8, 0x4b, 0x41, 0x39, 0x35, 0xc5, 0xba,
	0xfd, 0x52, 0x4a, 0xc8, 0x5f, 0x94, 0xdb, 0x32, 0x50, 0x49, 0x82, 0x61, 0xe9, 0xce, 0x1e, 0x43,
	0x43, 0x05, 0x9f, 0x77, 0xcb, 0x6a, 0x01, 0x0f, 0x8e, 0x7a, 0x29, 0xd7, 0x05, 0x34, 0x0b, 0xed,
	0xe7, 0x66, 0x2b, 0x4c, 0x7f, 0x5d, 0xec, 0x89, 0xaa, 0x73, 0xcd, 0xd4, 0xb6, 0x70, 0xef, 0x51,
	0xaf, 0x7a, 0xbc, 0x3b, 0xf2, 0xa0, 0x9b, 0xbf, 0x84, 0xc6, 0x4c, 0xa9, 0xa9, 0xdd, 0x5b, 0xb7,
	0xcf, 0xe8, 0x3d, 0x6f, 0x89, 0x18, 0xcc, 0x7d, 0x39, 0xc3, 0xb1, 0x8e, 0x84, 0x6d, 0xb8, 0x6e,
	0x7d, 0xdf, 0x78, 0xce, 0x8f, 0x8d, 0xe7, 0xfc, 0xdc, 0x78, 0xce, 0xb7, 0x5f, 0xde, 0x7f, 0xc1,
	0x89, 0xf9, 0x0b, 0xb9, 0xfa, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x19, 0x5a, 0x72, 0x2f, 0x63, 0x04,
	0x00, 0x00,
}
