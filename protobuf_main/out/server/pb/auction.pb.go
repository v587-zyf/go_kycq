// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: auction.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AuctionInfoReq struct {
	AuctionType int32 `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
}

func (m *AuctionInfoReq) Reset()                    { *m = AuctionInfoReq{} }
func (m *AuctionInfoReq) String() string            { return proto.CompactTextString(m) }
func (*AuctionInfoReq) ProtoMessage()               {}
func (*AuctionInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{0} }

func (m *AuctionInfoReq) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

type AuctionInfoNtf struct {
	AuctionType  int32              `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionInfos []*AuctionItemInfo `protobuf:"bytes,2,rep,name=auctionInfos" json:"auctionInfos,omitempty"`
}

func (m *AuctionInfoNtf) Reset()                    { *m = AuctionInfoNtf{} }
func (m *AuctionInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*AuctionInfoNtf) ProtoMessage()               {}
func (*AuctionInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{1} }

func (m *AuctionInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *AuctionInfoNtf) GetAuctionInfos() []*AuctionItemInfo {
	if m != nil {
		return m.AuctionInfos
	}
	return nil
}

// 竞拍物品信息
type AuctionItemInfo struct {
	AuctionId         int64   `protobuf:"varint,1,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	ItemId            int32   `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	AuctionTime       int64   `protobuf:"varint,3,opt,name=auctionTime,proto3" json:"auctionTime,omitempty"`
	AuctionDuration   int32   `protobuf:"varint,4,opt,name=auctionDuration,proto3" json:"auctionDuration,omitempty"`
	NowBidPrice       int32   `protobuf:"varint,5,opt,name=nowBidPrice,proto3" json:"nowBidPrice,omitempty"`
	NowBidUserId      int64   `protobuf:"varint,6,opt,name=nowBidUserId,proto3" json:"nowBidUserId,omitempty"`
	AuctionType       int32   `protobuf:"varint,7,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	NowBidderNickname string  `protobuf:"bytes,8,opt,name=nowBidderNickname,proto3" json:"nowBidderNickname,omitempty"`
	NowBidderAvatar   string  `protobuf:"bytes,9,opt,name=nowBidderAvatar,proto3" json:"nowBidderAvatar,omitempty"`
	AuctionSrc        int32   `protobuf:"varint,10,opt,name=auctionSrc,proto3" json:"auctionSrc,omitempty"`
	BidGuildId        []int32 `protobuf:"varint,12,rep,packed,name=bidGuildId" json:"bidGuildId,omitempty"`
	DropState         int32   `protobuf:"varint,13,opt,name=dropState,proto3" json:"dropState,omitempty"`
	HaveBidUsers      []int32 `protobuf:"varint,14,rep,packed,name=haveBidUsers" json:"haveBidUsers,omitempty"`
}

func (m *AuctionItemInfo) Reset()                    { *m = AuctionItemInfo{} }
func (m *AuctionItemInfo) String() string            { return proto.CompactTextString(m) }
func (*AuctionItemInfo) ProtoMessage()               {}
func (*AuctionItemInfo) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{2} }

func (m *AuctionItemInfo) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionItemInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionTime() int64 {
	if m != nil {
		return m.AuctionTime
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionDuration() int32 {
	if m != nil {
		return m.AuctionDuration
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidPrice() int32 {
	if m != nil {
		return m.NowBidPrice
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidUserId() int64 {
	if m != nil {
		return m.NowBidUserId
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidderNickname() string {
	if m != nil {
		return m.NowBidderNickname
	}
	return ""
}

func (m *AuctionItemInfo) GetNowBidderAvatar() string {
	if m != nil {
		return m.NowBidderAvatar
	}
	return ""
}

func (m *AuctionItemInfo) GetAuctionSrc() int32 {
	if m != nil {
		return m.AuctionSrc
	}
	return 0
}

func (m *AuctionItemInfo) GetBidGuildId() []int32 {
	if m != nil {
		return m.BidGuildId
	}
	return nil
}

func (m *AuctionItemInfo) GetDropState() int32 {
	if m != nil {
		return m.DropState
	}
	return 0
}

func (m *AuctionItemInfo) GetHaveBidUsers() []int32 {
	if m != nil {
		return m.HaveBidUsers
	}
	return nil
}

// 竞拍物品信息请求
type BidInfoReq struct {
	AuctionId   int32 `protobuf:"varint,1,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	AuctionType int32 `protobuf:"varint,2,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
}

func (m *BidInfoReq) Reset()                    { *m = BidInfoReq{} }
func (m *BidInfoReq) String() string            { return proto.CompactTextString(m) }
func (*BidInfoReq) ProtoMessage()               {}
func (*BidInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{3} }

func (m *BidInfoReq) GetAuctionId() int32 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *BidInfoReq) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

// 竞拍物品信息结果ntf
type BidInfoNtf struct {
	AuctionType int32            `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionInfo *AuctionItemInfo `protobuf:"bytes,2,opt,name=auctionInfo" json:"auctionInfo,omitempty"`
}

func (m *BidInfoNtf) Reset()                    { *m = BidInfoNtf{} }
func (m *BidInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*BidInfoNtf) ProtoMessage()               {}
func (*BidInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{4} }

func (m *BidInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *BidInfoNtf) GetAuctionInfo() *AuctionItemInfo {
	if m != nil {
		return m.AuctionInfo
	}
	return nil
}

// 竞拍请求
type BidReq struct {
	AuctionType int32 `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionId   int64 `protobuf:"varint,2,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	IsBuyNow    int32 `protobuf:"varint,3,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
}

func (m *BidReq) Reset()                    { *m = BidReq{} }
func (m *BidReq) String() string            { return proto.CompactTextString(m) }
func (*BidReq) ProtoMessage()               {}
func (*BidReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{5} }

func (m *BidReq) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *BidReq) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *BidReq) GetIsBuyNow() int32 {
	if m != nil {
		return m.IsBuyNow
	}
	return 0
}

// 竞拍结果ntf
type BidNtf struct {
	AuctionType int32            `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionInfo *AuctionItemInfo `protobuf:"bytes,2,opt,name=auctionInfo" json:"auctionInfo,omitempty"`
	Code        int32            `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	IsBuyNow    int32            `protobuf:"varint,4,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
	AuctionId   int32            `protobuf:"varint,5,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
}

func (m *BidNtf) Reset()                    { *m = BidNtf{} }
func (m *BidNtf) String() string            { return proto.CompactTextString(m) }
func (*BidNtf) ProtoMessage()               {}
func (*BidNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{6} }

func (m *BidNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *BidNtf) GetAuctionInfo() *AuctionItemInfo {
	if m != nil {
		return m.AuctionInfo
	}
	return nil
}

func (m *BidNtf) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *BidNtf) GetIsBuyNow() int32 {
	if m != nil {
		return m.IsBuyNow
	}
	return 0
}

func (m *BidNtf) GetAuctionId() int32 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

// 我的竞拍物品req
type MyBidReq struct {
}

func (m *MyBidReq) Reset()                    { *m = MyBidReq{} }
func (m *MyBidReq) String() string            { return proto.CompactTextString(m) }
func (*MyBidReq) ProtoMessage()               {}
func (*MyBidReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{7} }

// 我的竞拍物品ntf
type MyBidNtf struct {
	MyBidInfos []*AuctionItemInfo `protobuf:"bytes,1,rep,name=myBidInfos" json:"myBidInfos,omitempty"`
}

func (m *MyBidNtf) Reset()                    { *m = MyBidNtf{} }
func (m *MyBidNtf) String() string            { return proto.CompactTextString(m) }
func (*MyBidNtf) ProtoMessage()               {}
func (*MyBidNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{8} }

func (m *MyBidNtf) GetMyBidInfos() []*AuctionItemInfo {
	if m != nil {
		return m.MyBidInfos
	}
	return nil
}

// 竞拍物品价格更新ntf
type BidItemUpdateNtf struct {
	NewInfo       *AuctionItemInfo `protobuf:"bytes,1,opt,name=newInfo" json:"newInfo,omitempty"`
	ItemStatus    int32            `protobuf:"varint,2,opt,name=itemStatus,proto3" json:"itemStatus,omitempty"`
	LastBidUserId int32            `protobuf:"varint,3,opt,name=lastBidUserId,proto3" json:"lastBidUserId,omitempty"`
	AuctionId     int32            `protobuf:"varint,4,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	AuctionType   int32            `protobuf:"varint,5,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
}

func (m *BidItemUpdateNtf) Reset()                    { *m = BidItemUpdateNtf{} }
func (m *BidItemUpdateNtf) String() string            { return proto.CompactTextString(m) }
func (*BidItemUpdateNtf) ProtoMessage()               {}
func (*BidItemUpdateNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{9} }

func (m *BidItemUpdateNtf) GetNewInfo() *AuctionItemInfo {
	if m != nil {
		return m.NewInfo
	}
	return nil
}

func (m *BidItemUpdateNtf) GetItemStatus() int32 {
	if m != nil {
		return m.ItemStatus
	}
	return 0
}

func (m *BidItemUpdateNtf) GetLastBidUserId() int32 {
	if m != nil {
		return m.LastBidUserId
	}
	return 0
}

func (m *BidItemUpdateNtf) GetAuctionId() int32 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *BidItemUpdateNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

// 拍卖物品req
type AuctionPutawayItemReq struct {
	ItemId   int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Position int32 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *AuctionPutawayItemReq) Reset()                    { *m = AuctionPutawayItemReq{} }
func (m *AuctionPutawayItemReq) String() string            { return proto.CompactTextString(m) }
func (*AuctionPutawayItemReq) ProtoMessage()               {}
func (*AuctionPutawayItemReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{10} }

func (m *AuctionPutawayItemReq) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AuctionPutawayItemReq) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

// 拍卖物品ntf
type AuctionPutawayItemNtf struct {
	AuctionId int64           `protobuf:"varint,1,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	Code      int32           `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	ItemId    int32           `protobuf:"varint,3,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Goods     *GoodsChangeNtf `protobuf:"bytes,4,opt,name=goods" json:"goods,omitempty"`
}

func (m *AuctionPutawayItemNtf) Reset()                    { *m = AuctionPutawayItemNtf{} }
func (m *AuctionPutawayItemNtf) String() string            { return proto.CompactTextString(m) }
func (*AuctionPutawayItemNtf) ProtoMessage()               {}
func (*AuctionPutawayItemNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{11} }

func (m *AuctionPutawayItemNtf) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionPutawayItemNtf) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *AuctionPutawayItemNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AuctionPutawayItemNtf) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 竞拍成功公告
type BidSuccessInfo struct {
	Nickname    string `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	BidItemName string `protobuf:"bytes,2,opt,name=bidItemName,proto3" json:"bidItemName,omitempty"`
}

func (m *BidSuccessInfo) Reset()                    { *m = BidSuccessInfo{} }
func (m *BidSuccessInfo) String() string            { return proto.CompactTextString(m) }
func (*BidSuccessInfo) ProtoMessage()               {}
func (*BidSuccessInfo) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{12} }

func (m *BidSuccessInfo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *BidSuccessInfo) GetBidItemName() string {
	if m != nil {
		return m.BidItemName
	}
	return ""
}

type BidSuccessNoticeNtf struct {
	NoticeInfos []*BidSuccessInfo `protobuf:"bytes,1,rep,name=noticeInfos" json:"noticeInfos,omitempty"`
}

func (m *BidSuccessNoticeNtf) Reset()                    { *m = BidSuccessNoticeNtf{} }
func (m *BidSuccessNoticeNtf) String() string            { return proto.CompactTextString(m) }
func (*BidSuccessNoticeNtf) ProtoMessage()               {}
func (*BidSuccessNoticeNtf) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{13} }

func (m *BidSuccessNoticeNtf) GetNoticeInfos() []*BidSuccessInfo {
	if m != nil {
		return m.NoticeInfos
	}
	return nil
}

// 拍卖次数购买
type AuctionBuyTimesReq struct {
	ItemId int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
}

func (m *AuctionBuyTimesReq) Reset()                    { *m = AuctionBuyTimesReq{} }
func (m *AuctionBuyTimesReq) String() string            { return proto.CompactTextString(m) }
func (*AuctionBuyTimesReq) ProtoMessage()               {}
func (*AuctionBuyTimesReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{14} }

func (m *AuctionBuyTimesReq) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

type AuctionBuyTimesAck struct {
	CanBuyTimes int32           `protobuf:"varint,1,opt,name=CanBuyTimes,proto3" json:"CanBuyTimes,omitempty"`
	Goods       *GoodsChangeNtf `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
}

func (m *AuctionBuyTimesAck) Reset()                    { *m = AuctionBuyTimesAck{} }
func (m *AuctionBuyTimesAck) String() string            { return proto.CompactTextString(m) }
func (*AuctionBuyTimesAck) ProtoMessage()               {}
func (*AuctionBuyTimesAck) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{15} }

func (m *AuctionBuyTimesAck) GetCanBuyTimes() int32 {
	if m != nil {
		return m.CanBuyTimes
	}
	return 0
}

func (m *AuctionBuyTimesAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 我的竞拍物品req
type MyPutAwayItemInfoReq struct {
}

func (m *MyPutAwayItemInfoReq) Reset()                    { *m = MyPutAwayItemInfoReq{} }
func (m *MyPutAwayItemInfoReq) String() string            { return proto.CompactTextString(m) }
func (*MyPutAwayItemInfoReq) ProtoMessage()               {}
func (*MyPutAwayItemInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{16} }

// 我的竞拍物品ntf
type MyPutAwayItemInfoAck struct {
	MyBidInfosNotInBid []*AuctionItemInfo `protobuf:"bytes,1,rep,name=myBidInfosNotInBid" json:"myBidInfosNotInBid,omitempty"`
	MyBidInfosInBid    []*AuctionItemInfo `protobuf:"bytes,2,rep,name=myBidInfosInBid" json:"myBidInfosInBid,omitempty"`
}

func (m *MyPutAwayItemInfoAck) Reset()                    { *m = MyPutAwayItemInfoAck{} }
func (m *MyPutAwayItemInfoAck) String() string            { return proto.CompactTextString(m) }
func (*MyPutAwayItemInfoAck) ProtoMessage()               {}
func (*MyPutAwayItemInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{17} }

func (m *MyPutAwayItemInfoAck) GetMyBidInfosNotInBid() []*AuctionItemInfo {
	if m != nil {
		return m.MyBidInfosNotInBid
	}
	return nil
}

func (m *MyPutAwayItemInfoAck) GetMyBidInfosInBid() []*AuctionItemInfo {
	if m != nil {
		return m.MyBidInfosInBid
	}
	return nil
}

// 我竞拍过物品的信息
type MyBidInfoItemReq struct {
}

func (m *MyBidInfoItemReq) Reset()                    { *m = MyBidInfoItemReq{} }
func (m *MyBidInfoItemReq) String() string            { return proto.CompactTextString(m) }
func (*MyBidInfoItemReq) ProtoMessage()               {}
func (*MyBidInfoItemReq) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{18} }

// 我竞拍过物品的信息
type MyBidInfoItemAck struct {
	MyBidInfos []*AuctionBidInfo `protobuf:"bytes,1,rep,name=myBidInfos" json:"myBidInfos,omitempty"`
}

func (m *MyBidInfoItemAck) Reset()                    { *m = MyBidInfoItemAck{} }
func (m *MyBidInfoItemAck) String() string            { return proto.CompactTextString(m) }
func (*MyBidInfoItemAck) ProtoMessage()               {}
func (*MyBidInfoItemAck) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{19} }

func (m *MyBidInfoItemAck) GetMyBidInfos() []*AuctionBidInfo {
	if m != nil {
		return m.MyBidInfos
	}
	return nil
}

// 竞拍物品信息
type AuctionBidInfo struct {
	Id             int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	UserId         int32 `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
	AuctionId      int32 `protobuf:"varint,3,opt,name=AuctionId,proto3" json:"AuctionId,omitempty"`
	AuctionType    int32 `protobuf:"varint,4,opt,name=AuctionType,proto3" json:"AuctionType,omitempty"`
	ItemId         int32 `protobuf:"varint,5,opt,name=ItemId,proto3" json:"ItemId,omitempty"`
	FirstBidTime   int64 `protobuf:"varint,6,opt,name=FirstBidTime,proto3" json:"FirstBidTime,omitempty"`
	FinallyBidTime int64 `protobuf:"varint,7,opt,name=FinallyBidTime,proto3" json:"FinallyBidTime,omitempty"`
	State          int32 `protobuf:"varint,8,opt,name=State,proto3" json:"State,omitempty"`
	ExpireTime     int64 `protobuf:"varint,9,opt,name=ExpireTime,proto3" json:"ExpireTime,omitempty"`
}

func (m *AuctionBidInfo) Reset()                    { *m = AuctionBidInfo{} }
func (m *AuctionBidInfo) String() string            { return proto.CompactTextString(m) }
func (*AuctionBidInfo) ProtoMessage()               {}
func (*AuctionBidInfo) Descriptor() ([]byte, []int) { return fileDescriptorAuction, []int{20} }

func (m *AuctionBidInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AuctionBidInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AuctionBidInfo) GetAuctionId() int32 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionBidInfo) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *AuctionBidInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AuctionBidInfo) GetFirstBidTime() int64 {
	if m != nil {
		return m.FirstBidTime
	}
	return 0
}

func (m *AuctionBidInfo) GetFinallyBidTime() int64 {
	if m != nil {
		return m.FinallyBidTime
	}
	return 0
}

func (m *AuctionBidInfo) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *AuctionBidInfo) GetExpireTime() int64 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func init() {
	proto.RegisterType((*AuctionInfoReq)(nil), "pb.AuctionInfoReq")
	proto.RegisterType((*AuctionInfoNtf)(nil), "pb.AuctionInfoNtf")
	proto.RegisterType((*AuctionItemInfo)(nil), "pb.AuctionItemInfo")
	proto.RegisterType((*BidInfoReq)(nil), "pb.BidInfoReq")
	proto.RegisterType((*BidInfoNtf)(nil), "pb.BidInfoNtf")
	proto.RegisterType((*BidReq)(nil), "pb.BidReq")
	proto.RegisterType((*BidNtf)(nil), "pb.BidNtf")
	proto.RegisterType((*MyBidReq)(nil), "pb.MyBidReq")
	proto.RegisterType((*MyBidNtf)(nil), "pb.MyBidNtf")
	proto.RegisterType((*BidItemUpdateNtf)(nil), "pb.BidItemUpdateNtf")
	proto.RegisterType((*AuctionPutawayItemReq)(nil), "pb.AuctionPutawayItemReq")
	proto.RegisterType((*AuctionPutawayItemNtf)(nil), "pb.AuctionPutawayItemNtf")
	proto.RegisterType((*BidSuccessInfo)(nil), "pb.BidSuccessInfo")
	proto.RegisterType((*BidSuccessNoticeNtf)(nil), "pb.BidSuccessNoticeNtf")
	proto.RegisterType((*AuctionBuyTimesReq)(nil), "pb.AuctionBuyTimesReq")
	proto.RegisterType((*AuctionBuyTimesAck)(nil), "pb.AuctionBuyTimesAck")
	proto.RegisterType((*MyPutAwayItemInfoReq)(nil), "pb.MyPutAwayItemInfoReq")
	proto.RegisterType((*MyPutAwayItemInfoAck)(nil), "pb.MyPutAwayItemInfoAck")
	proto.RegisterType((*MyBidInfoItemReq)(nil), "pb.MyBidInfoItemReq")
	proto.RegisterType((*MyBidInfoItemAck)(nil), "pb.MyBidInfoItemAck")
	proto.RegisterType((*AuctionBidInfo)(nil), "pb.AuctionBidInfo")
}
func (m *AuctionInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	return i, nil
}

func (m *AuctionInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if len(m.AuctionInfos) > 0 {
		for _, msg := range m.AuctionInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuctionItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionItemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.AuctionTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionTime))
	}
	if m.AuctionDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionDuration))
	}
	if m.NowBidPrice != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.NowBidPrice))
	}
	if m.NowBidUserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.NowBidUserId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if len(m.NowBidderNickname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAuction(dAtA, i, uint64(len(m.NowBidderNickname)))
		i += copy(dAtA[i:], m.NowBidderNickname)
	}
	if len(m.NowBidderAvatar) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAuction(dAtA, i, uint64(len(m.NowBidderAvatar)))
		i += copy(dAtA[i:], m.NowBidderAvatar)
	}
	if m.AuctionSrc != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionSrc))
	}
	if len(m.BidGuildId) > 0 {
		dAtA2 := make([]byte, len(m.BidGuildId)*10)
		var j1 int
		for _, num1 := range m.BidGuildId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintAuction(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.DropState != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.DropState))
	}
	if len(m.HaveBidUsers) > 0 {
		dAtA4 := make([]byte, len(m.HaveBidUsers)*10)
		var j3 int
		for _, num1 := range m.HaveBidUsers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintAuction(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *BidInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	return i, nil
}

func (m *BidInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionInfo.Size()))
		n5, err := m.AuctionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.IsBuyNow != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.IsBuyNow))
	}
	return i, nil
}

func (m *BidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionInfo.Size()))
		n6, err := m.AuctionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Code != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Code))
	}
	if m.IsBuyNow != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.IsBuyNow))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	return i, nil
}

func (m *MyBidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyBidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MyBidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyBidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MyBidInfos) > 0 {
		for _, msg := range m.MyBidInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BidItemUpdateNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidItemUpdateNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.NewInfo.Size()))
		n7, err := m.NewInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ItemStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemStatus))
	}
	if m.LastBidUserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.LastBidUserId))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	return i, nil
}

func (m *AuctionPutawayItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionPutawayItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.Position != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Position))
	}
	return i, nil
}

func (m *AuctionPutawayItemNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionPutawayItemNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Code))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.Goods != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Goods.Size()))
		n8, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *BidSuccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidSuccessInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nickname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuction(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.BidItemName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuction(dAtA, i, uint64(len(m.BidItemName)))
		i += copy(dAtA[i:], m.BidItemName)
	}
	return i, nil
}

func (m *BidSuccessNoticeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidSuccessNoticeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NoticeInfos) > 0 {
		for _, msg := range m.NoticeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuctionBuyTimesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionBuyTimesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *AuctionBuyTimesAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionBuyTimesAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CanBuyTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.CanBuyTimes))
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Goods.Size()))
		n9, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *MyPutAwayItemInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyPutAwayItemInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MyPutAwayItemInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyPutAwayItemInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MyBidInfosNotInBid) > 0 {
		for _, msg := range m.MyBidInfosNotInBid {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MyBidInfosInBid) > 0 {
		for _, msg := range m.MyBidInfosInBid {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MyBidInfoItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyBidInfoItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MyBidInfoItemAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyBidInfoItemAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MyBidInfos) > 0 {
		for _, msg := range m.MyBidInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuctionBidInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionBidInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.UserId))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.FirstBidTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.FirstBidTime))
	}
	if m.FinallyBidTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.FinallyBidTime))
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.State))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAuction(dAtA, i, uint64(m.ExpireTime))
	}
	return i, nil
}

func encodeVarintAuction(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuctionInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	return n
}

func (m *AuctionInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	if len(m.AuctionInfos) > 0 {
		for _, e := range m.AuctionInfos {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionItemInfo) Size() (n int) {
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		n += 1 + sovAuction(uint64(m.ItemId))
	}
	if m.AuctionTime != 0 {
		n += 1 + sovAuction(uint64(m.AuctionTime))
	}
	if m.AuctionDuration != 0 {
		n += 1 + sovAuction(uint64(m.AuctionDuration))
	}
	if m.NowBidPrice != 0 {
		n += 1 + sovAuction(uint64(m.NowBidPrice))
	}
	if m.NowBidUserId != 0 {
		n += 1 + sovAuction(uint64(m.NowBidUserId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	l = len(m.NowBidderNickname)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.NowBidderAvatar)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.AuctionSrc != 0 {
		n += 1 + sovAuction(uint64(m.AuctionSrc))
	}
	if len(m.BidGuildId) > 0 {
		l = 0
		for _, e := range m.BidGuildId {
			l += sovAuction(uint64(e))
		}
		n += 1 + sovAuction(uint64(l)) + l
	}
	if m.DropState != 0 {
		n += 1 + sovAuction(uint64(m.DropState))
	}
	if len(m.HaveBidUsers) > 0 {
		l = 0
		for _, e := range m.HaveBidUsers {
			l += sovAuction(uint64(e))
		}
		n += 1 + sovAuction(uint64(l)) + l
	}
	return n
}

func (m *BidInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	return n
}

func (m *BidInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		l = m.AuctionInfo.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *BidReq) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.IsBuyNow != 0 {
		n += 1 + sovAuction(uint64(m.IsBuyNow))
	}
	return n
}

func (m *BidNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		l = m.AuctionInfo.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovAuction(uint64(m.Code))
	}
	if m.IsBuyNow != 0 {
		n += 1 + sovAuction(uint64(m.IsBuyNow))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	return n
}

func (m *MyBidReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MyBidNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.MyBidInfos) > 0 {
		for _, e := range m.MyBidInfos {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *BidItemUpdateNtf) Size() (n int) {
	var l int
	_ = l
	if m.NewInfo != nil {
		l = m.NewInfo.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.ItemStatus != 0 {
		n += 1 + sovAuction(uint64(m.ItemStatus))
	}
	if m.LastBidUserId != 0 {
		n += 1 + sovAuction(uint64(m.LastBidUserId))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	return n
}

func (m *AuctionPutawayItemReq) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovAuction(uint64(m.ItemId))
	}
	if m.Position != 0 {
		n += 1 + sovAuction(uint64(m.Position))
	}
	return n
}

func (m *AuctionPutawayItemNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.Code != 0 {
		n += 1 + sovAuction(uint64(m.Code))
	}
	if m.ItemId != 0 {
		n += 1 + sovAuction(uint64(m.ItemId))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *BidSuccessInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.BidItemName)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *BidSuccessNoticeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.NoticeInfos) > 0 {
		for _, e := range m.NoticeInfos {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionBuyTimesReq) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovAuction(uint64(m.ItemId))
	}
	return n
}

func (m *AuctionBuyTimesAck) Size() (n int) {
	var l int
	_ = l
	if m.CanBuyTimes != 0 {
		n += 1 + sovAuction(uint64(m.CanBuyTimes))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *MyPutAwayItemInfoReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MyPutAwayItemInfoAck) Size() (n int) {
	var l int
	_ = l
	if len(m.MyBidInfosNotInBid) > 0 {
		for _, e := range m.MyBidInfosNotInBid {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	if len(m.MyBidInfosInBid) > 0 {
		for _, e := range m.MyBidInfosInBid {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *MyBidInfoItemReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MyBidInfoItemAck) Size() (n int) {
	var l int
	_ = l
	if len(m.MyBidInfos) > 0 {
		for _, e := range m.MyBidInfos {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionBidInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAuction(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovAuction(uint64(m.UserId))
	}
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovAuction(uint64(m.AuctionType))
	}
	if m.ItemId != 0 {
		n += 1 + sovAuction(uint64(m.ItemId))
	}
	if m.FirstBidTime != 0 {
		n += 1 + sovAuction(uint64(m.FirstBidTime))
	}
	if m.FinallyBidTime != 0 {
		n += 1 + sovAuction(uint64(m.FinallyBidTime))
	}
	if m.State != 0 {
		n += 1 + sovAuction(uint64(m.State))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovAuction(uint64(m.ExpireTime))
	}
	return n
}

func sovAuction(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuction(x uint64) (n int) {
	return sovAuction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuctionInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuctionInfos = append(m.AuctionInfos, &AuctionItemInfo{})
			if err := m.AuctionInfos[len(m.AuctionInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionTime", wireType)
			}
			m.AuctionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionDuration", wireType)
			}
			m.AuctionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidPrice", wireType)
			}
			m.NowBidPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowBidPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidUserId", wireType)
			}
			m.NowBidUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowBidUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidderNickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NowBidderNickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidderAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NowBidderAvatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionSrc", wireType)
			}
			m.AuctionSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionSrc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BidGuildId = append(m.BidGuildId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BidGuildId = append(m.BidGuildId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BidGuildId", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropState", wireType)
			}
			m.DropState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HaveBidUsers = append(m.HaveBidUsers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HaveBidUsers = append(m.HaveBidUsers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveBidUsers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionInfo == nil {
				m.AuctionInfo = &AuctionItemInfo{}
			}
			if err := m.AuctionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			m.IsBuyNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBuyNow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionInfo == nil {
				m.AuctionInfo = &AuctionItemInfo{}
			}
			if err := m.AuctionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			m.IsBuyNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBuyNow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyBidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyBidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyBidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyBidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyBidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyBidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyBidInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyBidInfos = append(m.MyBidInfos, &AuctionItemInfo{})
			if err := m.MyBidInfos[len(m.MyBidInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidItemUpdateNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidItemUpdateNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidItemUpdateNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewInfo == nil {
				m.NewInfo = &AuctionItemInfo{}
			}
			if err := m.NewInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemStatus", wireType)
			}
			m.ItemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBidUserId", wireType)
			}
			m.LastBidUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBidUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionPutawayItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionPutawayItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionPutawayItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionPutawayItemNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionPutawayItemNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionPutawayItemNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidSuccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidSuccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidSuccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidItemName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidItemName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidSuccessNoticeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidSuccessNoticeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidSuccessNoticeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoticeInfos = append(m.NoticeInfos, &BidSuccessInfo{})
			if err := m.NoticeInfos[len(m.NoticeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionBuyTimesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionBuyTimesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionBuyTimesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionBuyTimesAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionBuyTimesAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionBuyTimesAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBuyTimes", wireType)
			}
			m.CanBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanBuyTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyPutAwayItemInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyPutAwayItemInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyPutAwayItemInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyPutAwayItemInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyPutAwayItemInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyPutAwayItemInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyBidInfosNotInBid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyBidInfosNotInBid = append(m.MyBidInfosNotInBid, &AuctionItemInfo{})
			if err := m.MyBidInfosNotInBid[len(m.MyBidInfosNotInBid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyBidInfosInBid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyBidInfosInBid = append(m.MyBidInfosInBid, &AuctionItemInfo{})
			if err := m.MyBidInfosInBid[len(m.MyBidInfosInBid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyBidInfoItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyBidInfoItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyBidInfoItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyBidInfoItemAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyBidInfoItemAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyBidInfoItemAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyBidInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyBidInfos = append(m.MyBidInfos, &AuctionBidInfo{})
			if err := m.MyBidInfos[len(m.MyBidInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionBidInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionBidInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionBidInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstBidTime", wireType)
			}
			m.FirstBidTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstBidTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinallyBidTime", wireType)
			}
			m.FinallyBidTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinallyBidTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuction
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuction
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuction(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuction = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuction   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("auction.proto", fileDescriptorAuction) }

var fileDescriptorAuction = []byte{
	// 879 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x4e, 0xdd, 0xa6, 0xaf, 0x6d, 0x5a, 0x66, 0x97, 0x95, 0x15, 0xa1, 0x28, 0x1a, 0x21,
	0x94, 0xc3, 0xd2, 0x43, 0x16, 0xc4, 0x09, 0xa1, 0xb8, 0xd0, 0x55, 0xb4, 0x34, 0xaa, 0x52, 0xf6,
	0x8e, 0xe3, 0x99, 0xdd, 0x1d, 0x35, 0xb1, 0x8d, 0xff, 0x6c, 0xf0, 0x67, 0xe0, 0xc6, 0x09, 0xf1,
	0x25, 0xf8, 0x18, 0x70, 0xe4, 0xc2, 0x1d, 0x95, 0x2f, 0x82, 0xde, 0xcc, 0xd8, 0x1e, 0x3b, 0x69,
	0xda, 0x0b, 0xa7, 0x64, 0x7e, 0xf3, 0xfe, 0xbf, 0xdf, 0x7b, 0x63, 0x38, 0xf1, 0xf3, 0x20, 0x13,
	0x51, 0x78, 0x1e, 0x27, 0x51, 0x16, 0x11, 0x3b, 0x5e, 0xf4, 0x8f, 0x83, 0x68, 0xb5, 0x2a, 0x11,
	0x3a, 0x86, 0xde, 0x44, 0x89, 0x4c, 0xc3, 0x37, 0xd1, 0x9c, 0xff, 0x48, 0x86, 0x70, 0xa4, 0x95,
	0xbe, 0x2f, 0x62, 0xee, 0x5a, 0x43, 0x6b, 0xe4, 0xcc, 0x4d, 0x88, 0xde, 0x36, 0x74, 0x66, 0xd9,
	0x9b, 0x87, 0x75, 0xc8, 0x97, 0x70, 0xec, 0xd7, 0x3a, 0xa9, 0x6b, 0x0f, 0x3b, 0xa3, 0xa3, 0xf1,
	0x93, 0xf3, 0x78, 0x71, 0x5e, 0xda, 0xca, 0xf8, 0x4a, 0xc6, 0xd0, 0x10, 0xa4, 0x7f, 0x77, 0xe0,
	0xb4, 0x25, 0x41, 0x3e, 0x86, 0xc3, 0x52, 0x86, 0x49, 0x67, 0x9d, 0x79, 0x0d, 0x90, 0x67, 0xb0,
	0x2f, 0x50, 0x92, 0xb9, 0xb6, 0x8c, 0x43, 0x9f, 0xcc, 0x20, 0xc5, 0x8a, 0xbb, 0x1d, 0xa9, 0x67,
	0x42, 0x64, 0x04, 0xa7, 0xfa, 0xf8, 0x4d, 0x9e, 0xf8, 0xf8, 0xeb, 0xee, 0x49, 0x13, 0x6d, 0x18,
	0x6d, 0x85, 0xd1, 0xda, 0x13, 0xec, 0x3a, 0x11, 0x01, 0x77, 0x1d, 0x95, 0xb0, 0x01, 0x11, 0x0a,
	0xc7, 0xea, 0xf8, 0x3a, 0xe5, 0xc9, 0x94, 0xb9, 0xfb, 0xd2, 0x5d, 0x03, 0x6b, 0x97, 0xed, 0x60,
	0xb3, 0x6c, 0xcf, 0xe1, 0x43, 0xa5, 0xc1, 0x78, 0x32, 0x13, 0xc1, 0x6d, 0xe8, 0xaf, 0xb8, 0xdb,
	0x1d, 0x5a, 0xa3, 0xc3, 0xf9, 0xe6, 0x05, 0xc6, 0x5f, 0x81, 0x93, 0xf7, 0x7e, 0xe6, 0x27, 0xee,
	0xa1, 0x94, 0x6d, 0xc3, 0x64, 0x00, 0xa0, 0xdd, 0xdc, 0x24, 0x81, 0x0b, 0xd2, 0xb1, 0x81, 0xe0,
	0xfd, 0x42, 0xb0, 0x97, 0xb9, 0x58, 0xb2, 0x29, 0x73, 0x8f, 0x87, 0x1d, 0xbc, 0xaf, 0x11, 0xec,
	0x00, 0x4b, 0xa2, 0xf8, 0x26, 0xf3, 0x33, 0xee, 0x9e, 0x48, 0xf5, 0x1a, 0xc0, 0xdc, 0xdf, 0xf9,
	0xef, 0xb9, 0x4e, 0x34, 0x75, 0x7b, 0x52, 0xbf, 0x81, 0xd1, 0xef, 0x00, 0x3c, 0xc1, 0x4a, 0xd2,
	0x6d, 0x74, 0xd4, 0x31, 0x3b, 0xda, 0xaa, 0x93, 0xbd, 0x49, 0x49, 0x5e, 0x59, 0x7b, 0x1c, 0x1d,
	0xbf, 0xa8, 0x24, 0x50, 0x47, 0x5a, 0xbc, 0x87, 0x8d, 0xa6, 0x1c, 0x65, 0xb0, 0xef, 0x09, 0xf6,
	0xa8, 0x29, 0x69, 0xa6, 0x64, 0xb7, 0x49, 0xda, 0x87, 0xae, 0x48, 0xbd, 0xbc, 0x98, 0x45, 0x6b,
	0xc9, 0x44, 0x67, 0x5e, 0x9d, 0xe9, 0xef, 0x96, 0x74, 0xf3, 0x7f, 0x66, 0x42, 0x08, 0xec, 0x05,
	0x11, 0xe3, 0xda, 0xb7, 0xfc, 0xdf, 0x88, 0x69, 0xaf, 0x19, 0x53, 0x33, 0x1b, 0xa7, 0xd5, 0x20,
	0x0a, 0xd0, 0xbd, 0x2a, 0x54, 0x65, 0xe8, 0xd7, 0xfa, 0x3f, 0x86, 0xff, 0x02, 0x60, 0x55, 0xe8,
	0xc6, 0xa4, 0xae, 0x75, 0xff, 0xcc, 0x1b, 0x62, 0xf4, 0x0f, 0x0b, 0xce, 0xf0, 0x90, 0xf1, 0xd5,
	0xeb, 0x98, 0xf9, 0x19, 0x47, 0x4b, 0x9f, 0xc1, 0x41, 0xc8, 0xd7, 0x32, 0x45, 0xeb, 0xfe, 0x14,
	0x4b, 0x19, 0xe4, 0x2f, 0x4e, 0x3d, 0xd2, 0x31, 0x4f, 0x35, 0x61, 0x0c, 0x84, 0x7c, 0x02, 0x27,
	0x4b, 0x3f, 0xcd, 0xea, 0xf1, 0x54, 0x75, 0x68, 0x82, 0xcd, 0xa4, 0xf7, 0x1e, 0x60, 0xa5, 0xb3,
	0xc9, 0xca, 0x57, 0xf0, 0x91, 0x8e, 0xf0, 0x3a, 0xcf, 0xfc, 0xb5, 0x5f, 0x60, 0xa0, 0xc8, 0x9e,
	0x7a, 0x45, 0x59, 0x8d, 0x15, 0xd5, 0x87, 0x6e, 0x1c, 0xa5, 0x42, 0x6e, 0x1e, 0x15, 0x74, 0x75,
	0xa6, 0x3f, 0x5b, 0xdb, 0xac, 0x61, 0x6d, 0x76, 0xaf, 0xc3, 0xb2, 0xd3, 0xb6, 0xd1, 0xe9, 0xda,
	0x7f, 0xa7, 0xe1, 0x7f, 0x04, 0xce, 0xdb, 0x28, 0x62, 0xa9, 0x4c, 0xf6, 0x68, 0x4c, 0xb0, 0xc6,
	0x2f, 0x11, 0xb8, 0x78, 0xe7, 0x87, 0x6f, 0xb1, 0x11, 0x73, 0x25, 0x40, 0x67, 0xd0, 0xf3, 0x04,
	0xbb, 0xc9, 0x83, 0x80, 0xa7, 0xa9, 0x2c, 0x79, 0x1f, 0xba, 0x61, 0xb9, 0xa1, 0x2c, 0xb9, 0x75,
	0xaa, 0x33, 0x96, 0x6a, 0xa1, 0x3a, 0x3a, 0xc3, 0x6b, 0x5b, 0x5e, 0x9b, 0x10, 0x7d, 0x05, 0x4f,
	0x6a, 0x7b, 0xb3, 0x28, 0x13, 0x81, 0x6c, 0xfb, 0xe7, 0xb8, 0x67, 0xf1, 0x60, 0x32, 0x48, 0x86,
	0xd5, 0xf4, 0x3e, 0x37, 0xc5, 0xe8, 0x73, 0x20, 0xba, 0x52, 0x5e, 0x5e, 0xe0, 0x66, 0x4f, 0x77,
	0x14, 0x9d, 0xfe, 0xb0, 0x21, 0x3d, 0x09, 0x6e, 0x31, 0xe4, 0x0b, 0xbf, 0x42, 0xca, 0xc9, 0x33,
	0xa0, 0xba, 0x58, 0xf6, 0x43, 0xc5, 0x7a, 0x06, 0x4f, 0xaf, 0x8a, 0xeb, 0x3c, 0x9b, 0xe8, 0xa6,
	0xe9, 0xad, 0x47, 0x7f, 0xb3, 0xb6, 0x5c, 0xa0, 0xf3, 0x0b, 0x20, 0xf5, 0x40, 0xcc, 0xa2, 0x6c,
	0x1a, 0x7a, 0x82, 0xed, 0x9a, 0x9f, 0x2d, 0xe2, 0xe4, 0x2b, 0x38, 0xad, 0x51, 0x65, 0x61, 0xc7,
	0xab, 0xdb, 0x96, 0xa5, 0x04, 0xce, 0xae, 0x4a, 0x48, 0xf3, 0x96, 0x5e, 0xb6, 0x30, 0x8c, 0x75,
	0xbc, 0x65, 0xc6, 0x89, 0xe1, 0xa1, 0xdc, 0xf2, 0xe6, 0x88, 0xff, 0x62, 0x57, 0x9f, 0x10, 0x1a,
	0x23, 0x3d, 0xb0, 0x2b, 0xf6, 0xda, 0xea, 0x15, 0xd7, 0xa3, 0xa9, 0x5f, 0xf1, 0x7a, 0x26, 0x27,
	0x15, 0xd9, 0x15, 0x7b, 0x6b, 0x00, 0xbb, 0x36, 0x31, 0x66, 0x52, 0xcd, 0xac, 0x09, 0xa1, 0xdd,
	0xa9, 0x62, 0x81, 0x1a, 0x58, 0x7d, 0xc2, 0x37, 0xeb, 0x52, 0x24, 0x72, 0xfa, 0xe5, 0xe7, 0x81,
	0x7e, 0xaf, 0x4d, 0x8c, 0x7c, 0x0a, 0xbd, 0x4b, 0x11, 0xfa, 0xcb, 0x65, 0x51, 0x4a, 0x1d, 0x48,
	0xa9, 0x16, 0x4a, 0x9e, 0x82, 0xa3, 0x5e, 0xc6, 0xae, 0x74, 0xa1, 0x0e, 0xb8, 0x93, 0xbe, 0xfd,
	0x29, 0x16, 0x09, 0x97, 0x9a, 0x87, 0x52, 0xd3, 0x40, 0xbc, 0xb3, 0x3f, 0xef, 0x06, 0xd6, 0x5f,
	0x77, 0x03, 0xeb, 0x9f, 0xbb, 0x81, 0xf5, 0xeb, 0xbf, 0x83, 0x0f, 0x16, 0xfb, 0xf2, 0x1b, 0xed,
	0xc5, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x04, 0x14, 0xef, 0x03, 0xc6, 0x09, 0x00, 0x00,
}
