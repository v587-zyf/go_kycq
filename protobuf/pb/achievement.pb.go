// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: achievement.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		achievement.proto
		ancientBoss.proto
		ancientSkill.proto
		ancientTreasures.proto
		applets.proto
		area.proto
		arena.proto
		atlas.proto
		auction.proto
		awaken.proto
		bag.proto
		bossFamily.proto
		cardActivity.proto
		challenge.proto
		chat.proto
		chaunshi.proto
		clear.proto
		common.proto
		competitve.proto
		compose.proto
		cutTreasure.proto
		dabao.proto
		dailyActivity.proto
		dailyPack.proto
		dailyRank.proto
		dailyTask.proto
		darkPalaceBoss.proto
		dictate.proto
		dragonEquip.proto
		elf.proto
		equip.proto
		expPool.proto
		expStage.proto
		fabao.proto
		fashion.proto
		fieldBoss.proto
		fieldFight.proto
		fight.proto
		firstDrop.proto
		firstRecharge.proto
		fit.proto
		fitHolyEquip.proto
		friend.proto
		gate.proto
		gift.proto
		godEquip.proto
		growFund.proto
		guardPillar.proto
		guild.proto
		guildActivity.proto
		guildBonfire.proto
		hellBoss.proto
		holyarms.proto
		holyBeast.proto
		inside.proto
		jewel.proto
		juexue.proto
		killMonster.proto
		label.proto
		lottery.proto
		magicCircle.proto
		magicTower.proto
		mail.proto
		materialStage.proto
		miJi.proto
		mining.proto
		monthCard.proto
		official.proto
		offline.proto
		online.proto
		panacea.proto
		personBoss.proto
		pet.proto
		previewFunction.proto
		privilege.proto
		rank.proto
		recharge.proto
		rechargeAll.proto
		rein.proto
		ring.proto
		scene.proto
		sevenInvestment.proto
		shabake.proto
		shabakeCross.proto
		shop.proto
		sign.proto
		skill.proto
		specialEquip.proto
		spendRebates.proto
		stage.proto
		system.proto
		talent.proto
		task.proto
		title.proto
		tower.proto
		treasure.proto
		treasureShop.proto
		trialTask.proto
		user.proto
		vip.proto
		vipBoss.proto
		warOrder.proto
		wing.proto
		worldBoss.proto
		worldLeader.proto

	It has these top-level messages:
		AchievementLoadReq
		AchievementLoadAck
		AchievementGetAwardReq
		AchievementGetAwardAck
		ActiveMedalReq
		ActiveMedalAck
		AchievementInfo
		AchievementTaskInfoNtf
		AncientBossLoadReq
		AncientBossLoadAck
		AncientBossBuyNumReq
		AncientBossBuyNumAck
		EnterAncientBossFightReq
		EnterAncientBossFightAck
		AncientBossFightResultNtf
		AncientBossOwnerReq
		AncientBossOwnerAck
		AncientBossOwnerInfo
		AncientBossNtf
		AncientSkillActiveReq
		AncientSkillActiveAck
		AncientSkillUpLvReq
		AncientSkillUpLvAck
		AncientSkillUpGradeReq
		AncientSkillUpGradeAck
		AncientTreasuresLoadReq
		AncientTreasuresLoadAck
		AncientTreasuresInfo
		AncientTreasuresActivateReq
		AncientTreasuresActivateAck
		AncientTreasuresZhuLinReq
		AncientTreasuresZhuLinAck
		AncientTreasuresUpStarReq
		AncientTreasuresUpStarAck
		AncientTreasuresJueXingReq
		AncientTreasuresJueXingAck
		AncientTreasuresResertReq
		AncientTreasuresResertAck
		AncientTreasuresCondotionInfosReq
		AncientTreasuresCondotionInfosAck
		EnterAppletsReq
		AppletsEnergyNtf
		AppletsReceiveReq
		AppletsReceiveAck
		CronGetAwardReq
		CronGetAwardAck
		EndResultReq
		EndResultAck
		AreaUpLvReq
		AreaUpLvAck
		ArenaOpenReq
		ArenaOpenAck
		EnterArenaFightReq
		ArenaFightNtf
		BuyArenaFightNumReq
		BuyArenaFightNumAck
		RefArenaRankReq
		RefArenaRankAck
		ArenaRank
		AtlasActiveReq
		AtlasActiveAck
		AtlasUpStarReq
		AtlasUpStarAck
		AtlasGatherActiveReq
		AtlasGatherActiveAck
		AtlasGatherUpStarReq
		AtlasGatherUpStarAck
		AtlasWearChangeReq
		AtlasWearChangeAck
		AuctionInfoReq
		AuctionInfoNtf
		AuctionItemInfo
		BidInfoReq
		BidInfoNtf
		BidReq
		BidNtf
		MyBidReq
		MyBidNtf
		BidItemUpdateNtf
		AuctionPutawayItemReq
		AuctionPutawayItemNtf
		BidSuccessInfo
		BidSuccessNoticeNtf
		AuctionBuyTimesReq
		AuctionBuyTimesAck
		MyPutAwayItemInfoReq
		MyPutAwayItemInfoAck
		MyBidInfoItemReq
		MyBidInfoItemAck
		AuctionBidInfo
		RedPointStateNtf
		ConversionGoldIngotReq
		ConversionGoldIngotAck
		AwakenLoadReq
		AwakenLoadAck
		AwakenReq
		AwakenAck
		AwakenUnit
		BagInfoReq
		BagInfoNtf
		BagSpaceAddReq
		BagSpaceAddAck
		BagSortReq
		BagSortAck
		GiftUseReq
		GiftUseAck
		EquipRecoverReq
		EquipRecoverAck
		ItemUseReq
		ItemUseAck
		EquipDestroyReq
		EquipDestroyAck
		WarehouseInfoReq
		WarehouseInfoNtf
		WareHouseSpaceAddReq
		WareHouseSpaceAddAck
		WarehouseAddReq
		WarehouseAddAck
		WarehouseShiftOutReq
		WarehouseShiftOutAck
		WarehouseSortReq
		WarehouseSortAck
		GetBossFamilyInfoReq
		GetBossFamilyInfoAck
		EnterBossFamilyReq
		CardActivityApplyGetReq
		CardActivityApplyGetAck
		CardActivityInfosReq
		CardActivityInfosAck
		CardInfoUnit
		CardInfoNtf
		GetIntegralAwardReq
		GetIntegralAwardAck
		CardCloseNtf
		ChallengeInfoReq
		ChallengeInfoAck
		ApplyChallengeReq
		ApplyChallengeAck
		ChallengeEachRoundPeopleReq
		ChallengeEachRoundPeopleAck
		PeopleInfos
		BottomPourReq
		BottomPourAck
		PeopleInfo
		ChallengeOpenNtf
		ChallengeRoundEndNtf
		ChallengeApplyUserInfoNtf
		ChatMessageNtf
		ChatMessageListReq
		ChatMessageListAck
		ChatSendReq
		ChatSendAck
		ChatBanNtf
		ChatBanRemoveNtf
		ChuanShiWearReq
		ChuanShiWearAck
		ChuanShiRemoveReq
		ChuanShiRemoveAck
		ChuanShiDeComposeReq
		ChuanShiDeComposeAck
		ChuanshiStrengthenReq
		ChuanshiStrengthenAck
		ClearReq
		ClearAck
		ErrorAck
		UserLoginInfo
		AppletsInfo
		AncientTreasureInfo
		MiJiInfo
		AnnouncementInfo
		HeroInfo
		UserWear
		Wears
		BriefUserInfo
		BriefUserInfoWithDisplay
		TopDataChangeNtf
		TopDataChange
		BagDataChangeNtf
		ItemChange
		BagEquipDataChangeNtf
		EquipChange
		Item
		GoodsChangeNtf
		ItemUnit
		EquipUnit
		EquipRandProp
		EquipClearArr
		EquipClearInfo
		HeroProp
		TaskInfoNtf
		DisplayNtf
		EventNtf
		DailyConditionNtf
		PropInfo
		EquipGrid
		Fabao
		GodEquip
		Juexue
		Fashion
		Wing
		WingSpecialNtf
		Rein
		ReinCost
		Atlas
		AtlasGather
		Preference
		WorldBossInfoNtf
		VipBoss
		ExpStage
		MaterialStage
		Display
		SpecialEquipUnit
		GetSource
		RankInfo
		SkillUnit
		ShopInfo
		DictateInfo
		PanaceaInfo
		JewelInfo
		DayStateInfo
		SignInfo
		InsideInfo
		InsideSkill
		Holy
		Ring
		RingPhantom
		PetInfo
		ResetNtf
		FieldFightRivalUserInfo
		DarkPalaceInfo
		HellBossInfo
		FieldBossInfo
		AncientBossInfo
		TalentInfo
		TalentUnit
		Fit
		FitSkill
		MonthCardUnit
		FirstRecharge
		SpendRebates
		GrowFund
		WarOrderTaskUnit
		WarOrderTaskInfo
		WarOrderTask
		WarOrderReward
		WarOrder
		Elf
		FriendUserInfo
		FriendHeroInfo
		FitHolyEquipUnit
		FitHolyEquip
		ContRecharge
		PaoMaDengInfo
		PaoMaDengNtf
		AncientSkill
		Title
		BriefServerInfo
		Label
		CompetitveLoadReq
		CompetitveLoadAck
		EnterCompetitveFightReq
		CompetitveFightNtf
		BuyCompetitveChallengeTimesReq
		BuyCompetitveChallengeTimesAck
		RefCompetitveRankReq
		RefCompetitveRankAck
		CompetitveRankInfo
		GetCompetitveDailyRewardReq
		GetCompetitveDailyRewardAck
		CompetitveMultipleClaimReq
		CompetitveMultipleClaimAck
		ComposeReq
		ComposeAck
		ComposeEquipReq
		ComposeEquipAck
		ComposeChuanShiEquipReq
		ComposeChuanShiEquipAck
		CutTreasureUpLvReq
		CutTreasureUpLvAck
		CutTreasureUseReq
		CutTreasureUseAck
		DaBaoEquipUpReq
		DaBaoEquipUpAck
		EnterDaBaoMysteryReq
		DaBaoMysteryResultNtf
		DaBaoMysteryEnergyItemBuyReq
		DaBaoMysteryEnergyAddReq
		DaBaoMysteryEnergyAddAck
		DaBaoMysteryEnergyNtf
		EnterDailyActivityReq
		DailyActivityResultNtf
		DailyActivityListReq
		DailyActivityListAck
		DailyActivityInfo
		DailyPackBuyReq
		DailyPackBuyAck
		DailyRankLoadReq
		DailyRankLoadAck
		DailyRankGetMarkRewardReq
		DailyRankGetMarkRewardAck
		DailyRankBuyGiftReq
		DailyRankBuyGiftAck
		DailyTaskLoadReq
		DailyTaskLoadAck
		BuyChallengeTimeReq
		BuyChallengeTimeAck
		GetExpReq
		GetExpAck
		GetAwardReq
		GetAwardAck
		ResourcesBackGetRewardReq
		ResourcesBackGetRewardAck
		ResourcesBackGetAllRewardReq
		ResourcesBackGetAllRewardAck
		HaveChallengeTime
		ResourcesBackInfo
		DarkPalaceLoadReq
		DarkPalaceLoadAck
		EnterDarkPalaceFightReq
		DarkPalaceFightResultNtf
		DarkPalaceBuyNumReq
		DarkPalaceBuyNumAck
		DarkPalaceBossNtf
		EnterDarkPalaceHelpFightReq
		DarkPalaceHelpFightResultNtf
		DarkPalaceDareNumNtf
		DictateUpReq
		DictateUpAck
		DragonEquipUpLvReq
		DragonEquipUpLvAck
		ElfFeedReq
		ElfFeedAck
		ElfSkillUpLvReq
		ElfSkillUpLvAck
		ElfSkillChangePosReq
		ElfSkillChangePosAck
		EquipChangeReq
		EquipChangeAck
		EquipLockReq
		EquipLockAck
		EquipStrengthenReq
		EquipStrengthenAck
		EquipRemoveReq
		EquipRemoveAck
		EquipBlessNtf
		EquipStrengthenAutoReq
		EquipStrengthenAutoAck
		ExpPoolLoadReq
		ExpPoolLoadAck
		ExpPoolUpGradeReq
		ExpPoolUpGradeAck
		ExpStageFightReq
		ExpStageDareNumNtf
		ExpStageFightResultNtf
		ExpStageDoubleReq
		ExpStageDoubleAck
		ExpStageRefNtf
		ExpStageBuyNumNtf
		ExpStageSweepReq
		ExpStageSweepAck
		ExpStageBuyNumReq
		ExpStageBuyNumAck
		FabaoActiveReq
		FabaoActiveAck
		FabaoUpLevelReq
		FabaoUpLevelAck
		FabaoSkillActiveReq
		FabaoSkillActiveAck
		FashionUpLevelReq
		FashionUpLevelAck
		FashionWearReq
		FashionWearAck
		FieldBossLoadReq
		FieldBossLoadAck
		EnterFieldBossFightReq
		EnterFieldBossFightAck
		FieldBossFightResultNtf
		FieldBossBuyNumReq
		FieldBossBuyNumAck
		FieldBossFirstReq
		FieldBossFirstAck
		FieldBossNtf
		FieldFightLoadReq
		FieldFightLoadAck
		EnterFieldFightReq
		FieldFightNtf
		BuyFieldFightChallengeTimesReq
		BuyFieldFightChallengeTimesAck
		RefFieldFightRivalUserReq
		RefFieldFightRivalUserAck
		FieldFightListInfo
		FieldFightBeatBackUserInfo
		BeatBackInfoNtf
		EnterPublicCopyReq
		EnterPublicCopyAck
		FightItemUseReq
		FightItemUseAck
		FightUserReliveReq
		FightUserReliveAck
		FightPickUpReq
		FightPickUpAck
		FightGetCheerNumReq
		FightGetCheerNumNtf
		FightCheerReq
		FightCheerAck
		FightCheerNumChangeNtf
		FightPotionReq
		FightPotionAck
		FightPotionCdReq
		FightPotionCdAck
		FightCollectionReq
		FightCollectionAck
		FightCollectionNtf
		FightCollectionCancelReq
		FightCollectionCancelAck
		FightApplyForHelpReq
		FightApplyForHelpAck
		FightApplyForHelpNtf
		FightAskForHelpResultReq
		FightAskForHelpResultAck
		FightAskForHelpResultNtf
		FightItemsAddNtf
		FirstDropLoadReq
		FirstDropLoadAck
		GetFirstDropAwardReq
		GetFirstDropAwardAck
		GetAllFirstDropAwardReq
		GetAllFirstDropAwardAck
		GetAllRedPacketReq
		GetAllRedPacketAck
		GetAllFirstDropAwardNtf
		FirstDropRedPointNtf
		FirstRechargeRewardReq
		FirstRechargeRewardAck
		FirstRechargeNtf
		FitUpLvReq
		FitUpLvAck
		FitSkillUpLvReq
		FitSkillUpLvAck
		FitSkillUpStarReq
		FitSkillUpStarAck
		FitSkillChangeReq
		FitSkillChangeAck
		FitSkillResetReq
		FitSkillResetAck
		FitFashionUpLvReq
		FitFashionUpLvAck
		FitFashionChangeReq
		FitFashionChangeAck
		FitSkillActiveReq
		FitSkillActiveAck
		FitEnterReq
		FitEnterAck
		FitCancleReq
		FitCancleAck
		FitHolyEquipComposeReq
		FitHolyEquipComposeAck
		FitHolyEquipDeComposeReq
		FitHolyEquipDeComposeAck
		FitHolyEquipWearReq
		FitHolyEquipWearAck
		FitHolyEquipRemoveReq
		FitHolyEquipRemoveAck
		FitHolyEquipSuitSkillChangeReq
		FitHolyEquipSuitSkillChangeAck
		FriendListReq
		FriendListAck
		FriendAddReq
		FriendAddAck
		FriendDelReq
		FriendDelAck
		FriendBlockAddReq
		FriendBlockAddAck
		FriendSearchReq
		FriendSearchAck
		FriendBlockListReq
		FriendBlockListAck
		FriendBlockDelReq
		FriendBlockDelAck
		FriendMsgReadReq
		FriendMsgReadAck
		FriendUserInfoReq
		FriendUserInfoAck
		FriendMsgReq
		FriendMsgAck
		FriendApplyAddReq
		FriendApplyAddNtf
		FriendApplyAgreeReq
		FriendApplyAgreeNtf
		FriendApplyRefuseReq
		FriendApplyRefuseNtf
		FriendApplyListReq
		FriendApplyListAck
		FriendInfo
		MsgLog
		FriendApplyInfo
		ReportGtNoReq
		ReportGtNoAck
		GsBroadCastNtf
		GsMsgNtf
		ReConnectReq
		ReConnectAck
		LogoutReq
		LogoutAck
		OfflineReq
		ChatReq
		ChatRsp
		OnlineNumReq
		OnlineNumAck
		MsgNtf
		PreJumpGsReq
		DoJumpGsReq
		JumpGsReq
		BenchMarkReq
		BenchMarkAck
		KeepAliveRpt
		OpenGiftReq
		OpenGiftAck
		GiftCodeRewardReq
		GiftCodeRewardAck
		LimitedGiftNtf
		LimitedGiftBuyReq
		LimitedGiftBuyAck
		LimitedGiftReq
		LimitedGiftInfo
		OpenGiftBuyNtf
		OpenGiftEndTimeReq
		OpenGiftEndTimeAck
		GodEquipActiveReq
		GodEquipActiveAck
		GodEquipUpLevelReq
		GodEquipUpLevelAck
		GodEquipBloodReq
		GodEquipBloodAck
		GrowFundBuyReq
		GrowFundBuyAck
		GrowFundRewardReq
		GrowFundRewardAck
		EnterGuardPillarReq
		GuardPillarResultNtf
		GuildLoadInfoReq
		GuildLoadInfoAck
		CreateGuildReq
		CreateGuildAck
		JoinGuildCombatLimitReq
		JoinGuildCombatLimitAck
		ModifyBulletinReq
		ModifyBulletinAck
		QuitGuildReq
		QuitGuildAck
		KickOutReq
		KickOutAck
		ImpeachPresidentReq
		ImpeachPresidentAck
		GuildCheckMemberInfoReq
		GuildCheckMemberInfoAck
		ApplyJoinGuildReq
		ApplyJoinGuildAck
		GuildAssignReq
		GuildAssignAck
		AllGuildInfosReq
		AllGuildInfosAck
		DissolveGuildReq
		DissolveGuildAck
		JoinGuildDisposeReq
		JoinGuildDisposeAck
		GetApplyUserListReq
		GetApplyUserListAck
		GuildInfo
		GuildMenberInfo
		JoinGuildSuccessNtf
		AllJoinGuildDisposeReq
		AllJoinGuildDisposeAck
		ApplyJoinGuildReDotNtf
		ImpeachPresidentNtf
		BroadcastGuildChangeNtf
		GuildActivityOpenNtf
		GuildActivityLoadReq
		GuildActivityLoadAck
		GuildBonfireLoadReq
		GuildBonfireLoadAck
		GuildBonfireAddExpReq
		GuildBonfireAddExpAck
		WoodPeople
		EnterGuildBonfireFightReq
		GuildBonfireFightNtf
		GuildBonfireOpenStateNtf
		HellBossLoadReq
		HellBossLoadAck
		HellBossBuyNumReq
		HellBossBuyNumAck
		HellBossDareNumNtf
		EnterHellBossFightReq
		HellBossFightResultNtf
		HellBossNtf
		HolyActiveReq
		HolyActiveAck
		HolyUpLevelReq
		HolyUpLevelAck
		HolySkillActiveReq
		HolySkillActiveAck
		HolySkillUpLvReq
		HolySkillUpLvAck
		HolyBeastLoadInfoReq
		HolyBeastLoadInfoAck
		HolyBeastActivateReq
		HolyBeastActivateAck
		HolyBeastUpStarReq
		HolyBeastUpStarAck
		HolyBeastPointAddReq
		HolyBeastPointAddAck
		HolyBeastChoosePropReq
		HolyBeastChoosePropAck
		HolyBeastRestReq
		HolyBeastRestAck
		HolyBeastInfos
		HolyBeastInfo
		InsideUpStarReq
		InsideUpStarAck
		InsideUpGradeReq
		InsideUpGradeAck
		InsideUpOrderReq
		InsideUpOrderAck
		InsideSkillUpLvReq
		InsideSkillUpLvAck
		InsideAutoUpReq
		InsideAutoUpAck
		JewelMakeReq
		JewelMakeAck
		JewelUpLvReq
		JewelUpLvAck
		JewelChangeReq
		JewelChangeAck
		JewelRemoveReq
		JewelRemoveAck
		JewelMakeAllReq
		JewelMakeAllAck
		JuexueUpLevelReq
		JuexueUpLevelAck
		KillMonsterUniLoadReq
		KillMonsterUniLoadAck
		KillMonsterUniFirstDrawReq
		KillMonsterUniFirstDrawAck
		KillMonsterUniDrawReq
		KillMonsterUniDrawAck
		KillMonsterUniKillNtf
		KillMonsterPerLoadReq
		KillMonsterPerLoadAck
		KillMonsterPerDrawReq
		KillMonsterPerDrawAck
		KillMonsterPerKillNtf
		KillMonsterMilLoadReq
		KillMonsterMilLoadAck
		KillMonsterMilDrawReq
		KillMonsterMilDrawAck
		KillMonsterMilKillNtf
		KillMonsterUniInfo
		KillMonsterPerInfo
		KillMonsterMilInfo
		LabelUpReq
		LabelUpAck
		LabelTransferReq
		LabelTransferAck
		LabelDayRewardReq
		LabelDayRewardAck
		LabelTaskReq
		LabelTaskNtf
		LabelTaskUnit
		LotteryInfoReq
		LotteryInfoAck
		GetGoodLuckReq
		GetGoodLuckAck
		SetLotteryPopUpStateReq
		SetLotteryPopUpStateAck
		LotteryBuyNumsReq
		LotteryBuyNumsAck
		BrocastBuyNumsNtf
		LotteryInfo
		LotteryEnd
		LotteryInfo1Req
		LotteryInfo1Ack
		LotteryGetEndAwardReq
		LotteryGetEndAwardAck
		MagicCircleUpLvReq
		MagicCircleUpLvAck
		MagicCircleChangeWearReq
		MagicCircleChangeWearAck
		MagicTowerEndNtf
		MagicTowerGetUserInfoReq
		MagicTowerGetUserInfoAck
		MagicTowerlayerAwardReq
		MagicTowerlayerAwardAck
		MailReadReq
		MailReadAck
		MailRedeemReq
		MailRedeemAck
		MailRedeemAllReq
		MailRedeemAllAck
		MailNtf
		MailLoadReq
		MailLoadAck
		MailDeleteReq
		MailDeleteAck
		MailDeleteAllReq
		MailDeleteAllAck
		MaterialStageLoadReq
		MaterialStageLoadAck
		EnterMaterialStageFightReq
		MaterialStageFightResultNtf
		MaterialStageSweepReq
		MaterialStageSweepAck
		MaterialStageBuyNumNtf
		MaterialStageBuyNumReq
		MaterialStageBuyNumAck
		MiJiUpReq
		MiJiUpAck
		MiningLoadReq
		MiningLoadAck
		MiningUpMinerReq
		MiningUpMinerAck
		MiningBuyNumReq
		MiningBuyNumAck
		MiningStartReq
		MiningStartAck
		MiningRobReq
		MiningRobAck
		MiningRobFightAck
		MiningRobBackReq
		MiningRobBackAck
		MiningRobBackFightAck
		MiningRobListReq
		MiningRobListAck
		MiningListReq
		MiningListAck
		MiningDrawLoadReq
		MiningDrawLoadAck
		MiningDrawReq
		MiningDrawAck
		MiningInReq
		MiningInAck
		MiningInfo
		MiningRob
		MiningListInfo
		MonthCardBuyReq
		MonthCardBuyAck
		MonthCardDailyRewardReq
		MonthCardDailyRewardAck
		OfficialUpLevelReq
		OfficialUpLevelAck
		OfflineAwardLoadReq
		OfflineAwardLoadAck
		OfflineAwardGetReq
		OfflineAwardGetAck
		GetOnlineAwardInfoReq
		GetOnlineAwardInfoAck
		GetOnlineAwardReq
		GetOnlineAwardAck
		PanaceaUseReq
		PanaceaUseAck
		PersonBossLoadReq
		PersonBossLoadAck
		EnterPersonBossFightReq
		EnterPersonBossFightAck
		PersonBossFightResultNtf
		PersonBossSweepReq
		PersonBossSweepAck
		PersonBossDareNumNtf
		PetActiveReq
		PetActiveAck
		PetUpLvReq
		PetUpLvAck
		PetUpGradeReq
		PetUpGradeAck
		PetBreakReq
		PetBreakAck
		PetChangeWearReq
		PetChangeWearAck
		PetAppendageReq
		PetAppendageAck
		PreviewFunctionLoadReq
		PreviewFunctionLoadAck
		PreviewFunctionGetReq
		PreviewFunctionGetAck
		PreviewFunctionPointReq
		PreviewFunctionPointAck
		PrivilegeBuyReq
		PrivilegeBuyAck
		RankLoadReq
		RankLoadAck
		RankWorshipReq
		RankWorshipAck
		RechargFulfilledNtf
		RechargeApplyPayReq
		RechargeApplyPayAck
		MoneyPayReq
		MoneyPayAck
		RechargeResetNtf
		ContRechargeCycleNtf
		ContRechargeNtf
		ContRechargeReceiveReq
		ContRechargeReceiveAck
		RechargeAllGetReq
		RechargeAllGetAck
		ReinActiveReq
		ReinActiveAck
		ReincarnationReq
		ReincarnationAck
		ReinCostBuyReq
		ReinCostBuyAck
		ReinCostUseReq
		ReinCostUseAck
		ReinCostBuyNumRefNtf
		RingWearReq
		RingWearAck
		RingRemoveReq
		RingRemoveAck
		RingStrengthenReq
		RingStrengthenAck
		RingPhantomReq
		RingPhantomAck
		RingSkillUpReq
		RingSkillUpAck
		RingFuseReq
		RingFuseAck
		RingSkillResetReq
		RingSkillResetAck
		Point
		SceneObj
		SceneUser
		SceneMonster
		ScenePet
		SceneCollection
		SceneFit
		SceneSummon
		SceneItem
		SceneBuff
		SceneEnterNtf
		SceneEnterOverNtf
		SceneLeaveNtf
		SceneDieNtf
		SceneMoveRpt
		SceneMoveNtf
		SceneUserReliveNtf
		SceneUserUpdateNtf
		SceneUserElfUpdateNtf
		AttackRpt
		AttackEffectNtf
		HurtEffect
		SceneObjHpNtf
		SceneObjMpNtf
		FightHurtRankReq
		FightHurtRankAck
		FightRankUnit
		GetBossOwnerChangReq
		BossOwnerChangNtf
		BuffChangeNtf
		BuffDelNtf
		BuffInfo
		DelBuffInfo
		BuffPropChangeNtf
		BuffHpChangeNtf
		BuffHpChangeInfo
		MainCityEnterRpt
		MainCityMoveRpt
		MainCityLeaveRpt
		MainCityUpdateRpt
		FightEnterOkReq
		FightStartCountDownNtf
		FightStartCountDownOkReq
		FightStartNtf
		CollectionStatusChangeNtf
		FightTeamChangeNtf
		FightUserChangeToHelperNtf
		FightNpcEventReq
		ExpStageKillInfoNtf
		PaodianTopUserReq
		PaodianTopUserNtf
		PaoDianUserNumNtf
		PaodianFightEnd
		GetShabakeScoresReq
		ShabakeScoreRankNtf
		ShabakeUserScore
		ShabakeGuildScore
		ShabakeOccupiedNtf
		GetShabakeCrossScoresReq
		ShabakeCrossScoreRankNtf
		ShabakeCrossServerScore
		ShabakeCrossOccupiedNtf
		GuardPillarFightNtf
		MagicTowerBossInfo
		MagicTowerFightNtf
		FightUserScoreNtf
		GetFightBossInfosReq
		GetFightBossInfosAck
		FightBossInfoUnit
		BossReliveNtf
		SevenInvestmentLoadReq
		SevenInvestmentLoadAck
		GetSevenInvestmentAwardReq
		GetSevenInvestmentAwardAck
		ShaBaKeInfoReq
		ShaBaKeInfoAck
		EnterShaBaKeFightReq
		ShaBaKeFightResultNtf
		ShabakeIsOpenNtf
		ShaBaKeInfoCrossReq
		ShaBaKeInfoCrossAck
		Info
		EnterCrossShaBaKeFightReq
		EnterCrossShaBaKeFightAck
		CrossShaBaKeFightEndNtf
		CrossShabakeOpenNtf
		ShabakeRankScore
		ShopListReq
		ShopListAck
		ShopBuyReq
		ShopBuyAck
		ShopWeekResetNtf
		SignReq
		SignAck
		SignRepairReq
		SignRepairAck
		CumulativeSignReq
		CumulativeSignAck
		SignResetNtf
		SkillUpLvReq
		SkillUpLvAck
		SkillChangePosReq
		SkillChangePosAck
		SkillChangeWearReq
		SkillChangeWearAck
		SkillResetReq
		SkillResetAck
		SkillUseReq
		SkillUseNtf
		ClearSkillCdNtf
		SpecialEquipChangeReq
		SpecialEquipChangeAck
		SpecialEquipRemoveReq
		SpecialEquipRemoveAck
		SpendRebatesRewardReq
		SpendRebatesRewardAck
		SpendRebatesNtf
		StageFightStartReq
		StageFightStartAck
		StageFightEndReq
		StageFightEndNtf
		LeaveFightReq
		LeaveFightAck
		KillMonsterReq
		KillMonsterAck
		StartStageBossFightReq
		StageBagChangeNtf
		StageGetHookMapRewardReq
		StageGetHookMapRewardAck
		PingReq
		PingAck
		PreferenceSetReq
		PreferenceSetAck
		PreferenceLoadReq
		PreferenceLoadAck
		FuncStateCloseNtf
		TalentUpLvReq
		TalentUpLvAck
		TalentResetReq
		TalentResetAck
		TaskDoneReq
		TaskDoneAck
		TaskNpcStateReq
		TaskNpcStateAck
		SetTaskInfoReq
		SetTaskInfoAck
		TitleActiveReq
		TitleActiveAck
		TitleWearReq
		TitleWearAck
		TitleRemoveReq
		TitleRemoveAck
		TitleLookReq
		TitleLookAck
		TitleAutoActiveNtf
		TitleExpireNtf
		OpenTowerReq
		OpenTowerAck
		ToweryDayAwardReq
		ToweryDayAwardAck
		TowerLotteryReq
		TowerLotteryAck
		EnterTowerFightReq
		TowerFightResultNtf
		TowerFightContinueReq
		TowerSweepReq
		TowerSweepAck
		TowerRankRewardReq
		TowerRankRewardAck
		TowerLvNtf
		SetTreasurePopUpStateReq
		SetTreasurePopUpStateAck
		ChooseTreasureAwardReq
		ChooseTreasureAwardAck
		ChooseInfo
		BuyTreasureItemReq
		BuyTreasureItemAck
		TreasureApplyGetReq
		TreasureApplyGetAck
		TreasureInfosReq
		TreasureInfosAck
		TreasureInfoUnit
		TreasureInfoNtf
		GetTreasureIntegralAwardReq
		GetTreasureIntegralAwardAck
		TreasureDrawInfoReq
		TreasureDrawInfoAck
		TreasureCloseNtf
		TreasureShopLoadReq
		TreasureShopLoadAck
		TreasureShopCarChangeReq
		TreasureShopCarChangeAck
		TreasureShopBuyReq
		TreasureShopBuyAck
		TreasureShopRefreshReq
		TreasureShopRefreshNtf
		TrialTaskInfoReq
		TrialTaskInfoAck
		TrialTaskInfo
		TrialTaskGetAwardReq
		TrialTaskGetAwardAck
		TrialTaskGetStageAwardReq
		TrialTaskGetStageAwardAck
		TrialTaskInfoNtf
		EnterGameReq
		EnterGameAck
		CreateUserReq
		CreateUserAck
		RandNameReq
		RandNameAck
		CreateHeroReq
		CreateHeroAck
		KickUserNtf
		UserPropertyNtf
		DebugAddGoodsReq
		DebugAddGoodsAck
		ChangeFightModelReq
		ChangeFightModelAck
		ChangeHeroNameReq
		ChangeHeroNameAck
		UserRechargeNumNtf
		UserRedPacketGetNumNtf
		UserOnlineNtf
		UserOffLineNtf
		VipCustomerReq
		VipCustomerAck
		UserInGameOkReq
		CrossFightOpenNtf
		UserSubscribeReq
		UserSubscribeAck
		VipGiftGetReq
		VipGiftGetAck
		VipBossLoadReq
		VipBossLoadAck
		EnterVipBossFightReq
		EnterVipBossFightAck
		VipBossFightResultNtf
		VipBossSweepReq
		VipBossSweepAck
		VipBossDareNumNtf
		WarOrderTaskNtf
		WarOrderOpenReq
		WarOrderOpenAck
		WarOrderTaskFinishReq
		WarOrderTaskFinishAck
		WarOrderTaskRewardReq
		WarOrderTaskRewardAck
		WarOrderBuyLuxuryReq
		WarOrderBuyLuxuryAck
		WarOrderBuyExpReq
		WarOrderBuyExpAck
		WarOrderLvRewardReq
		WarOrderLvRewardAck
		WarOrderExchangeReq
		WarOrderExchangeAck
		WarOrderLvNtf
		WarOrderResetNtf
		WingUpLevelReq
		WingUpLevelAck
		WingUseMaterialReq
		WingUseMaterialAck
		WingSpecialUpReq
		WingSpecialUpAck
		WingWearReq
		WingWearAck
		EnterWorldBossFightReq
		WorldBossFightResultNtf
		LoadWorldLeaderReq
		LoadWorldLeaderAck
		WorldLeaderInfo
		GetWorldLeaderRankInfoReq
		GetWorldLeaderRankInfoAck
		WorldLeaderStartNtf
		WorldLeaderEnterReq
		WorldLeaderEnterAck
		WorldLeaderEndRewardNtf
		WorldLeaderRankUnit
		WorldLeaderBossHpNtf
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AchievementLoadReq struct {
}

func (m *AchievementLoadReq) Reset()                    { *m = AchievementLoadReq{} }
func (m *AchievementLoadReq) String() string            { return proto.CompactTextString(m) }
func (*AchievementLoadReq) ProtoMessage()               {}
func (*AchievementLoadReq) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{0} }

type AchievementLoadAck struct {
	AchievementInfo []*AchievementInfo `protobuf:"bytes,1,rep,name=achievementInfo" json:"achievementInfo,omitempty"`
	AllPoint        int32              `protobuf:"varint,2,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
	Medal           []int32            `protobuf:"varint,3,rep,packed,name=Medal" json:"Medal,omitempty"`
}

func (m *AchievementLoadAck) Reset()                    { *m = AchievementLoadAck{} }
func (m *AchievementLoadAck) String() string            { return proto.CompactTextString(m) }
func (*AchievementLoadAck) ProtoMessage()               {}
func (*AchievementLoadAck) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{1} }

func (m *AchievementLoadAck) GetAchievementInfo() []*AchievementInfo {
	if m != nil {
		return m.AchievementInfo
	}
	return nil
}

func (m *AchievementLoadAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

func (m *AchievementLoadAck) GetMedal() []int32 {
	if m != nil {
		return m.Medal
	}
	return nil
}

// 领奖
type AchievementGetAwardReq struct {
	Id []int32 `protobuf:"varint,1,rep,packed,name=id" json:"id,omitempty"`
}

func (m *AchievementGetAwardReq) Reset()         { *m = AchievementGetAwardReq{} }
func (m *AchievementGetAwardReq) String() string { return proto.CompactTextString(m) }
func (*AchievementGetAwardReq) ProtoMessage()    {}
func (*AchievementGetAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{2}
}

func (m *AchievementGetAwardReq) GetId() []int32 {
	if m != nil {
		return m.Id
	}
	return nil
}

type AchievementGetAwardAck struct {
	AchievementInfo []*AchievementInfo `protobuf:"bytes,1,rep,name=achievementInfo" json:"achievementInfo,omitempty"`
	AllPoint        int32              `protobuf:"varint,2,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
}

func (m *AchievementGetAwardAck) Reset()         { *m = AchievementGetAwardAck{} }
func (m *AchievementGetAwardAck) String() string { return proto.CompactTextString(m) }
func (*AchievementGetAwardAck) ProtoMessage()    {}
func (*AchievementGetAwardAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{3}
}

func (m *AchievementGetAwardAck) GetAchievementInfo() []*AchievementInfo {
	if m != nil {
		return m.AchievementInfo
	}
	return nil
}

func (m *AchievementGetAwardAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

// 激活徽章
type ActiveMedalReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ActiveMedalReq) Reset()                    { *m = ActiveMedalReq{} }
func (m *ActiveMedalReq) String() string            { return proto.CompactTextString(m) }
func (*ActiveMedalReq) ProtoMessage()               {}
func (*ActiveMedalReq) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{4} }

func (m *ActiveMedalReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ActiveMedalAck struct {
	AllPoint int32   `protobuf:"varint,1,opt,name=allPoint,proto3" json:"allPoint,omitempty"`
	Medal    []int32 `protobuf:"varint,2,rep,packed,name=Medal" json:"Medal,omitempty"`
}

func (m *ActiveMedalAck) Reset()                    { *m = ActiveMedalAck{} }
func (m *ActiveMedalAck) String() string            { return proto.CompactTextString(m) }
func (*ActiveMedalAck) ProtoMessage()               {}
func (*ActiveMedalAck) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{5} }

func (m *ActiveMedalAck) GetAllPoint() int32 {
	if m != nil {
		return m.AllPoint
	}
	return 0
}

func (m *ActiveMedalAck) GetMedal() []int32 {
	if m != nil {
		return m.Medal
	}
	return nil
}

type AchievementInfo struct {
	ConditionType int32 `protobuf:"varint,1,opt,name=conditionType,proto3" json:"conditionType,omitempty"`
	CanGetId      int32 `protobuf:"varint,2,opt,name=canGetId,proto3" json:"canGetId,omitempty"`
	Process       int32 `protobuf:"varint,3,opt,name=process,proto3" json:"process,omitempty"`
	IsGetAllAward int32 `protobuf:"varint,4,opt,name=isGetAllAward,proto3" json:"isGetAllAward,omitempty"`
}

func (m *AchievementInfo) Reset()                    { *m = AchievementInfo{} }
func (m *AchievementInfo) String() string            { return proto.CompactTextString(m) }
func (*AchievementInfo) ProtoMessage()               {}
func (*AchievementInfo) Descriptor() ([]byte, []int) { return fileDescriptorAchievement, []int{6} }

func (m *AchievementInfo) GetConditionType() int32 {
	if m != nil {
		return m.ConditionType
	}
	return 0
}

func (m *AchievementInfo) GetCanGetId() int32 {
	if m != nil {
		return m.CanGetId
	}
	return 0
}

func (m *AchievementInfo) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

func (m *AchievementInfo) GetIsGetAllAward() int32 {
	if m != nil {
		return m.IsGetAllAward
	}
	return 0
}

type AchievementTaskInfoNtf struct {
	TaskId        int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Process       int32 `protobuf:"varint,2,opt,name=process,proto3" json:"process,omitempty"`
	ConditionType int32 `protobuf:"varint,3,opt,name=conditionType,proto3" json:"conditionType,omitempty"`
}

func (m *AchievementTaskInfoNtf) Reset()         { *m = AchievementTaskInfoNtf{} }
func (m *AchievementTaskInfoNtf) String() string { return proto.CompactTextString(m) }
func (*AchievementTaskInfoNtf) ProtoMessage()    {}
func (*AchievementTaskInfoNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorAchievement, []int{7}
}

func (m *AchievementTaskInfoNtf) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *AchievementTaskInfoNtf) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

func (m *AchievementTaskInfoNtf) GetConditionType() int32 {
	if m != nil {
		return m.ConditionType
	}
	return 0
}

func init() {
	proto.RegisterType((*AchievementLoadReq)(nil), "pb.AchievementLoadReq")
	proto.RegisterType((*AchievementLoadAck)(nil), "pb.AchievementLoadAck")
	proto.RegisterType((*AchievementGetAwardReq)(nil), "pb.AchievementGetAwardReq")
	proto.RegisterType((*AchievementGetAwardAck)(nil), "pb.AchievementGetAwardAck")
	proto.RegisterType((*ActiveMedalReq)(nil), "pb.ActiveMedalReq")
	proto.RegisterType((*ActiveMedalAck)(nil), "pb.ActiveMedalAck")
	proto.RegisterType((*AchievementInfo)(nil), "pb.AchievementInfo")
	proto.RegisterType((*AchievementTaskInfoNtf)(nil), "pb.AchievementTaskInfoNtf")
}
func (m *AchievementLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AchievementLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, msg := range m.AchievementInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAchievement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AllPoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		dAtA2 := make([]byte, len(m.Medal)*10)
		var j1 int
		for _, num1 := range m.Medal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *AchievementGetAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementGetAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA4 := make([]byte, len(m.Id)*10)
		var j3 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *AchievementGetAwardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementGetAwardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, msg := range m.AchievementInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAchievement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AllPoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	return i, nil
}

func (m *ActiveMedalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveMedalReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ActiveMedalAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveMedalAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllPoint != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		dAtA6 := make([]byte, len(m.Medal)*10)
		var j5 int
		for _, num1 := range m.Medal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *AchievementInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConditionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.ConditionType))
	}
	if m.CanGetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.CanGetId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Process))
	}
	if m.IsGetAllAward != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.IsGetAllAward))
	}
	return i, nil
}

func (m *AchievementTaskInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchievementTaskInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.TaskId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.Process))
	}
	if m.ConditionType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAchievement(dAtA, i, uint64(m.ConditionType))
	}
	return i, nil
}

func encodeVarintAchievement(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AchievementLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AchievementLoadAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, e := range m.AchievementInfo {
			l = e.Size()
			n += 1 + l + sovAchievement(uint64(l))
		}
	}
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		l = 0
		for _, e := range m.Medal {
			l += sovAchievement(uint64(e))
		}
		n += 1 + sovAchievement(uint64(l)) + l
	}
	return n
}

func (m *AchievementGetAwardReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovAchievement(uint64(e))
		}
		n += 1 + sovAchievement(uint64(l)) + l
	}
	return n
}

func (m *AchievementGetAwardAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AchievementInfo) > 0 {
		for _, e := range m.AchievementInfo {
			l = e.Size()
			n += 1 + l + sovAchievement(uint64(l))
		}
	}
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	return n
}

func (m *ActiveMedalReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAchievement(uint64(m.Id))
	}
	return n
}

func (m *ActiveMedalAck) Size() (n int) {
	var l int
	_ = l
	if m.AllPoint != 0 {
		n += 1 + sovAchievement(uint64(m.AllPoint))
	}
	if len(m.Medal) > 0 {
		l = 0
		for _, e := range m.Medal {
			l += sovAchievement(uint64(e))
		}
		n += 1 + sovAchievement(uint64(l)) + l
	}
	return n
}

func (m *AchievementInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConditionType != 0 {
		n += 1 + sovAchievement(uint64(m.ConditionType))
	}
	if m.CanGetId != 0 {
		n += 1 + sovAchievement(uint64(m.CanGetId))
	}
	if m.Process != 0 {
		n += 1 + sovAchievement(uint64(m.Process))
	}
	if m.IsGetAllAward != 0 {
		n += 1 + sovAchievement(uint64(m.IsGetAllAward))
	}
	return n
}

func (m *AchievementTaskInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovAchievement(uint64(m.TaskId))
	}
	if m.Process != 0 {
		n += 1 + sovAchievement(uint64(m.Process))
	}
	if m.ConditionType != 0 {
		n += 1 + sovAchievement(uint64(m.ConditionType))
	}
	return n
}

func sovAchievement(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAchievement(x uint64) (n int) {
	return sovAchievement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AchievementLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAchievement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementInfo = append(m.AchievementInfo, &AchievementInfo{})
			if err := m.AchievementInfo[len(m.AchievementInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medal = append(m.Medal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAchievement
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAchievement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medal = append(m.Medal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medal", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementGetAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementGetAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementGetAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAchievement
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAchievement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementGetAwardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementGetAwardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementGetAwardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAchievement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementInfo = append(m.AchievementInfo, &AchievementInfo{})
			if err := m.AchievementInfo[len(m.AchievementInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveMedalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveMedalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveMedalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveMedalAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveMedalAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveMedalAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPoint", wireType)
			}
			m.AllPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medal = append(m.Medal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAchievement
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAchievement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medal = append(m.Medal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medal", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGetId", wireType)
			}
			m.CanGetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanGetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGetAllAward", wireType)
			}
			m.IsGetAllAward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsGetAllAward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchievementTaskInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchievementTaskInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchievementTaskInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			m.ConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConditionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAchievement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAchievement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAchievement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAchievement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAchievement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAchievement
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAchievement
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAchievement(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAchievement = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAchievement   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("achievement.proto", fileDescriptorAchievement) }

var fileDescriptorAchievement = []byte{
	// 336 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0xb1, 0x4e, 0xf3, 0x30,
	0x14, 0x85, 0x7f, 0x27, 0x7f, 0x0a, 0xba, 0x88, 0x16, 0x4c, 0x55, 0x45, 0x0c, 0x51, 0x14, 0x31,
	0x64, 0xea, 0x00, 0x33, 0x43, 0xba, 0x54, 0x95, 0x00, 0xa1, 0xa8, 0x2f, 0xe0, 0xc6, 0xae, 0xb0,
	0x1a, 0x6c, 0xd3, 0x58, 0x45, 0x3c, 0x00, 0x4f, 0xc0, 0xc2, 0x23, 0x31, 0xf2, 0x08, 0xa8, 0xbc,
	0x08, 0x72, 0xda, 0x80, 0xdd, 0x96, 0x91, 0xf1, 0xdc, 0x7b, 0x75, 0xce, 0xe7, 0x23, 0xc3, 0x31,
	0x29, 0xee, 0x38, 0x5b, 0xb0, 0x7b, 0x26, 0x74, 0x5f, 0xcd, 0xa5, 0x96, 0xd8, 0x53, 0x93, 0xa4,
	0x0b, 0x38, 0xfb, 0x59, 0x5c, 0x49, 0x42, 0x73, 0xf6, 0x90, 0x3c, 0xa3, 0xad, 0x71, 0x56, 0xcc,
	0xf0, 0x25, 0x74, 0x2c, 0x97, 0x91, 0x98, 0xca, 0x10, 0xc5, 0x7e, 0x7a, 0x70, 0x7e, 0xd2, 0x57,
	0x93, 0x7e, 0xe6, 0xae, 0xf2, 0xcd, 0x5b, 0x7c, 0x0a, 0xfb, 0xa4, 0x2c, 0x6f, 0x25, 0x17, 0x3a,
	0xf4, 0x62, 0x94, 0x06, 0xf9, 0xb7, 0xc6, 0x5d, 0x08, 0xae, 0x19, 0x25, 0x65, 0xe8, 0xc7, 0x7e,
	0x1a, 0xe4, 0x2b, 0x91, 0xa4, 0xd0, 0xb3, 0x5c, 0x87, 0x4c, 0x67, 0x8f, 0x64, 0x6e, 0x08, 0x71,
	0x1b, 0x3c, 0x4e, 0xeb, 0xf4, 0x20, 0xf7, 0x38, 0x4d, 0xaa, 0x9d, 0x97, 0x7f, 0x0b, 0x9d, 0xc4,
	0xd0, 0xce, 0x0a, 0xcd, 0x17, 0xac, 0xa6, 0xb5, 0xb1, 0xd0, 0x1a, 0x6b, 0xe0, 0x5c, 0x18, 0x1c,
	0xdb, 0x0f, 0xfd, 0x56, 0x82, 0x67, 0x97, 0xf0, 0x82, 0xa0, 0xb3, 0x81, 0x89, 0xcf, 0xe0, 0xb0,
	0x90, 0x82, 0x72, 0xcd, 0xa5, 0x18, 0x3f, 0x29, 0xb6, 0xb6, 0x72, 0x87, 0x26, 0xab, 0x20, 0x62,
	0xc8, 0xf4, 0x88, 0x36, 0xec, 0x8d, 0xc6, 0x21, 0xec, 0xa9, 0xb9, 0x2c, 0x58, 0x55, 0x85, 0x7e,
	0xbd, 0x6a, 0xa4, 0xf1, 0xe6, 0x95, 0x69, 0xb0, 0x2c, 0xeb, 0x12, 0xc3, 0xff, 0x2b, 0x6f, 0x67,
	0x98, 0x28, 0xa7, 0xf0, 0x31, 0xa9, 0x66, 0x06, 0xec, 0x46, 0x4f, 0x71, 0x0f, 0x5a, 0xda, 0xc8,
	0xa6, 0x87, 0xb5, 0xb2, 0x13, 0xbd, 0xad, 0x44, 0xf7, 0x35, 0xfe, 0x8e, 0xd7, 0x0c, 0x8e, 0xde,
	0x96, 0x11, 0x7a, 0x5f, 0x46, 0xe8, 0x63, 0x19, 0xa1, 0xd7, 0xcf, 0xe8, 0xdf, 0xa4, 0x55, 0xff,
	0xe3, 0x8b, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x37, 0x27, 0xcf, 0xb3, 0xdc, 0x02, 0x00, 0x00,
}
