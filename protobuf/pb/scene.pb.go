// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scene.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Point struct {
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{0} }

func (m *Point) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type SceneObj struct {
	ObjType    int32            `protobuf:"varint,1,opt,name=objType,proto3" json:"objType,omitempty"`
	Point      *Point           `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	Dir        int32            `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	ObjId      int32            `protobuf:"varint,4,opt,name=objId,proto3" json:"objId,omitempty"`
	TeamId     int32            `protobuf:"varint,5,opt,name=teamId,proto3" json:"teamId,omitempty"`
	Hp         int64            `protobuf:"varint,7,opt,name=hp,proto3" json:"hp,omitempty"`
	HpMax      int64            `protobuf:"varint,8,opt,name=hpMax,proto3" json:"hpMax,omitempty"`
	Buffs      []*BuffInfo      `protobuf:"bytes,9,rep,name=buffs" json:"buffs,omitempty"`
	Mp         int64            `protobuf:"varint,10,opt,name=mp,proto3" json:"mp,omitempty"`
	MpMax      int64            `protobuf:"varint,11,opt,name=mpMax,proto3" json:"mpMax,omitempty"`
	ServerId   int32            `protobuf:"varint,12,opt,name=serverId,proto3" json:"serverId,omitempty"`
	User       *SceneUser       `protobuf:"bytes,21,opt,name=user" json:"user,omitempty"`
	Monster    *SceneMonster    `protobuf:"bytes,23,opt,name=monster" json:"monster,omitempty"`
	Item       *SceneItem       `protobuf:"bytes,24,opt,name=item" json:"item,omitempty"`
	Pet        *ScenePet        `protobuf:"bytes,25,opt,name=pet" json:"pet,omitempty"`
	Collection *SceneCollection `protobuf:"bytes,26,opt,name=collection" json:"collection,omitempty"`
	Fit        *SceneFit        `protobuf:"bytes,27,opt,name=fit" json:"fit,omitempty"`
	Summon     *SceneSummon     `protobuf:"bytes,28,opt,name=summon" json:"summon,omitempty"`
	Buff       *SceneBuff       `protobuf:"bytes,29,opt,name=buff" json:"buff,omitempty"`
}

func (m *SceneObj) Reset()                    { *m = SceneObj{} }
func (m *SceneObj) String() string            { return proto.CompactTextString(m) }
func (*SceneObj) ProtoMessage()               {}
func (*SceneObj) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{1} }

func (m *SceneObj) GetObjType() int32 {
	if m != nil {
		return m.ObjType
	}
	return 0
}

func (m *SceneObj) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneObj) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *SceneObj) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObj) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *SceneObj) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SceneObj) GetHpMax() int64 {
	if m != nil {
		return m.HpMax
	}
	return 0
}

func (m *SceneObj) GetBuffs() []*BuffInfo {
	if m != nil {
		return m.Buffs
	}
	return nil
}

func (m *SceneObj) GetMp() int64 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *SceneObj) GetMpMax() int64 {
	if m != nil {
		return m.MpMax
	}
	return 0
}

func (m *SceneObj) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *SceneObj) GetUser() *SceneUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SceneObj) GetMonster() *SceneMonster {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *SceneObj) GetItem() *SceneItem {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *SceneObj) GetPet() *ScenePet {
	if m != nil {
		return m.Pet
	}
	return nil
}

func (m *SceneObj) GetCollection() *SceneCollection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *SceneObj) GetFit() *SceneFit {
	if m != nil {
		return m.Fit
	}
	return nil
}

func (m *SceneObj) GetSummon() *SceneSummon {
	if m != nil {
		return m.Summon
	}
	return nil
}

func (m *SceneObj) GetBuff() *SceneBuff {
	if m != nil {
		return m.Buff
	}
	return nil
}

type SceneUser struct {
	UserId       int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Name         string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Display      *Display `protobuf:"bytes,3,opt,name=display" json:"display,omitempty"`
	Vip          int32    `protobuf:"varint,4,opt,name=vip,proto3" json:"vip,omitempty"`
	Lvl          int32    `protobuf:"varint,5,opt,name=lvl,proto3" json:"lvl,omitempty"`
	Sex          int32    `protobuf:"varint,6,opt,name=sex,proto3" json:"sex,omitempty"`
	Combat       int64    `protobuf:"varint,7,opt,name=combat,proto3" json:"combat,omitempty"`
	Avatar       string   `protobuf:"bytes,8,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Job          int32    `protobuf:"varint,9,opt,name=job,proto3" json:"job,omitempty"`
	HeroIndex    int32    `protobuf:"varint,10,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	GuildId      int32    `protobuf:"varint,12,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName    string   `protobuf:"bytes,13,opt,name=guildName,proto3" json:"guildName,omitempty"`
	ElfLv        int32    `protobuf:"varint,14,opt,name=elfLv,proto3" json:"elfLv,omitempty"`
	Username     string   `protobuf:"bytes,15,opt,name=username,proto3" json:"username,omitempty"`
	Usersex      int32    `protobuf:"varint,16,opt,name=usersex,proto3" json:"usersex,omitempty"`
	Userjob      int32    `protobuf:"varint,17,opt,name=userjob,proto3" json:"userjob,omitempty"`
	UserHpTotal  int64    `protobuf:"varint,18,opt,name=userHpTotal,proto3" json:"userHpTotal,omitempty"`
	ToHelpUserId int32    `protobuf:"varint,19,opt,name=toHelpUserId,proto3" json:"toHelpUserId,omitempty"`
}

func (m *SceneUser) Reset()                    { *m = SceneUser{} }
func (m *SceneUser) String() string            { return proto.CompactTextString(m) }
func (*SceneUser) ProtoMessage()               {}
func (*SceneUser) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{2} }

func (m *SceneUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneUser) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *SceneUser) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *SceneUser) GetLvl() int32 {
	if m != nil {
		return m.Lvl
	}
	return 0
}

func (m *SceneUser) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *SceneUser) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *SceneUser) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *SceneUser) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *SceneUser) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *SceneUser) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SceneUser) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *SceneUser) GetElfLv() int32 {
	if m != nil {
		return m.ElfLv
	}
	return 0
}

func (m *SceneUser) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SceneUser) GetUsersex() int32 {
	if m != nil {
		return m.Usersex
	}
	return 0
}

func (m *SceneUser) GetUserjob() int32 {
	if m != nil {
		return m.Userjob
	}
	return 0
}

func (m *SceneUser) GetUserHpTotal() int64 {
	if m != nil {
		return m.UserHpTotal
	}
	return 0
}

func (m *SceneUser) GetToHelpUserId() int32 {
	if m != nil {
		return m.ToHelpUserId
	}
	return 0
}

type SceneMonster struct {
	Idx           int32  `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	OwnerUseId    int32  `protobuf:"varint,2,opt,name=ownerUseId,proto3" json:"ownerUseId,omitempty"`
	OwnerUserName string `protobuf:"bytes,3,opt,name=ownerUserName,proto3" json:"ownerUserName,omitempty"`
}

func (m *SceneMonster) Reset()                    { *m = SceneMonster{} }
func (m *SceneMonster) String() string            { return proto.CompactTextString(m) }
func (*SceneMonster) ProtoMessage()               {}
func (*SceneMonster) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{3} }

func (m *SceneMonster) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *SceneMonster) GetOwnerUseId() int32 {
	if m != nil {
		return m.OwnerUseId
	}
	return 0
}

func (m *SceneMonster) GetOwnerUserName() string {
	if m != nil {
		return m.OwnerUserName
	}
	return ""
}

type ScenePet struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Idx    int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *ScenePet) Reset()                    { *m = ScenePet{} }
func (m *ScenePet) String() string            { return proto.CompactTextString(m) }
func (*ScenePet) ProtoMessage()               {}
func (*ScenePet) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{4} }

func (m *ScenePet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ScenePet) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type SceneCollection struct {
	Id              int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CollectionObjId int32 `protobuf:"varint,2,opt,name=collectionObjId,proto3" json:"collectionObjId,omitempty"`
	ServerTime      int32 `protobuf:"varint,3,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	EndTime         int32 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *SceneCollection) Reset()                    { *m = SceneCollection{} }
func (m *SceneCollection) String() string            { return proto.CompactTextString(m) }
func (*SceneCollection) ProtoMessage()               {}
func (*SceneCollection) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{5} }

func (m *SceneCollection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SceneCollection) GetCollectionObjId() int32 {
	if m != nil {
		return m.CollectionObjId
	}
	return 0
}

func (m *SceneCollection) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *SceneCollection) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type SceneFit struct {
	UserId    int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	FitId     int32  `protobuf:"varint,2,opt,name=fitId,proto3" json:"fitId,omitempty"`
	FashionId int32  `protobuf:"varint,3,opt,name=fashionId,proto3" json:"fashionId,omitempty"`
	FashionLv int32  `protobuf:"varint,4,opt,name=fashionLv,proto3" json:"fashionLv,omitempty"`
	Name      string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	FitLv     int32  `protobuf:"varint,6,opt,name=fitLv,proto3" json:"fitLv,omitempty"`
	GuildId   int32  `protobuf:"varint,7,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName string `protobuf:"bytes,8,opt,name=guildName,proto3" json:"guildName,omitempty"`
	LeaderJob int32  `protobuf:"varint,9,opt,name=leaderJob,proto3" json:"leaderJob,omitempty"`
	LeaderSex int32  `protobuf:"varint,10,opt,name=leaderSex,proto3" json:"leaderSex,omitempty"`
}

func (m *SceneFit) Reset()                    { *m = SceneFit{} }
func (m *SceneFit) String() string            { return proto.CompactTextString(m) }
func (*SceneFit) ProtoMessage()               {}
func (*SceneFit) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{6} }

func (m *SceneFit) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneFit) GetFitId() int32 {
	if m != nil {
		return m.FitId
	}
	return 0
}

func (m *SceneFit) GetFashionId() int32 {
	if m != nil {
		return m.FashionId
	}
	return 0
}

func (m *SceneFit) GetFashionLv() int32 {
	if m != nil {
		return m.FashionLv
	}
	return 0
}

func (m *SceneFit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SceneFit) GetFitLv() int32 {
	if m != nil {
		return m.FitLv
	}
	return 0
}

func (m *SceneFit) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SceneFit) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *SceneFit) GetLeaderJob() int32 {
	if m != nil {
		return m.LeaderJob
	}
	return 0
}

func (m *SceneFit) GetLeaderSex() int32 {
	if m != nil {
		return m.LeaderSex
	}
	return 0
}

type SceneSummon struct {
	UserId   int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	SummonId int32 `protobuf:"varint,2,opt,name=summonId,proto3" json:"summonId,omitempty"`
	ObjId    int32 `protobuf:"varint,3,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *SceneSummon) Reset()                    { *m = SceneSummon{} }
func (m *SceneSummon) String() string            { return proto.CompactTextString(m) }
func (*SceneSummon) ProtoMessage()               {}
func (*SceneSummon) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{7} }

func (m *SceneSummon) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneSummon) GetSummonId() int32 {
	if m != nil {
		return m.SummonId
	}
	return 0
}

func (m *SceneSummon) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type SceneItem struct {
	ItemId             int32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemNum            int32 `protobuf:"varint,3,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
	Owner              int32 `protobuf:"varint,4,opt,name=owner,proto3" json:"owner,omitempty"`
	OwnerProtectedTime int32 `protobuf:"varint,5,opt,name=ownerProtectedTime,proto3" json:"ownerProtectedTime,omitempty"`
	DisappearTime      int32 `protobuf:"varint,6,opt,name=disappearTime,proto3" json:"disappearTime,omitempty"`
}

func (m *SceneItem) Reset()                    { *m = SceneItem{} }
func (m *SceneItem) String() string            { return proto.CompactTextString(m) }
func (*SceneItem) ProtoMessage()               {}
func (*SceneItem) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{8} }

func (m *SceneItem) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *SceneItem) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *SceneItem) GetOwner() int32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *SceneItem) GetOwnerProtectedTime() int32 {
	if m != nil {
		return m.OwnerProtectedTime
	}
	return 0
}

func (m *SceneItem) GetDisappearTime() int32 {
	if m != nil {
		return m.DisappearTime
	}
	return 0
}

type SceneBuff struct {
	BuffId int32 `protobuf:"varint,1,opt,name=buffId,proto3" json:"buffId,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *SceneBuff) Reset()                    { *m = SceneBuff{} }
func (m *SceneBuff) String() string            { return proto.CompactTextString(m) }
func (*SceneBuff) ProtoMessage()               {}
func (*SceneBuff) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{9} }

func (m *SceneBuff) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *SceneBuff) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 角色进入场景
type SceneEnterNtf struct {
	StageId   int32       `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Objs      []*SceneObj `protobuf:"bytes,2,rep,name=objs" json:"objs,omitempty"`
	EnterType int32       `protobuf:"varint,3,opt,name=enterType,proto3" json:"enterType,omitempty"`
	IsTower   bool        `protobuf:"varint,4,opt,name=isTower,proto3" json:"isTower,omitempty"`
}

func (m *SceneEnterNtf) Reset()                    { *m = SceneEnterNtf{} }
func (m *SceneEnterNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneEnterNtf) ProtoMessage()               {}
func (*SceneEnterNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{10} }

func (m *SceneEnterNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *SceneEnterNtf) GetObjs() []*SceneObj {
	if m != nil {
		return m.Objs
	}
	return nil
}

func (m *SceneEnterNtf) GetEnterType() int32 {
	if m != nil {
		return m.EnterType
	}
	return 0
}

func (m *SceneEnterNtf) GetIsTower() bool {
	if m != nil {
		return m.IsTower
	}
	return false
}

// 角色进入场景完成
type SceneEnterOverNtf struct {
}

func (m *SceneEnterOverNtf) Reset()                    { *m = SceneEnterOverNtf{} }
func (m *SceneEnterOverNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneEnterOverNtf) ProtoMessage()               {}
func (*SceneEnterOverNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{11} }

// 角色离开场景
type SceneLeaveNtf struct {
	ObjIds    []int32 `protobuf:"varint,1,rep,packed,name=objIds" json:"objIds,omitempty"`
	LeaveType int32   `protobuf:"varint,2,opt,name=leaveType,proto3" json:"leaveType,omitempty"`
	IsTower   bool    `protobuf:"varint,4,opt,name=isTower,proto3" json:"isTower,omitempty"`
}

func (m *SceneLeaveNtf) Reset()                    { *m = SceneLeaveNtf{} }
func (m *SceneLeaveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneLeaveNtf) ProtoMessage()               {}
func (*SceneLeaveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{12} }

func (m *SceneLeaveNtf) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *SceneLeaveNtf) GetLeaveType() int32 {
	if m != nil {
		return m.LeaveType
	}
	return 0
}

func (m *SceneLeaveNtf) GetIsTower() bool {
	if m != nil {
		return m.IsTower
	}
	return false
}

// 角色死亡
type SceneDieNtf struct {
	ObjId     int32       `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	DropItems []*SceneObj `protobuf:"bytes,2,rep,name=dropItems" json:"dropItems,omitempty"`
}

func (m *SceneDieNtf) Reset()                    { *m = SceneDieNtf{} }
func (m *SceneDieNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneDieNtf) ProtoMessage()               {}
func (*SceneDieNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{13} }

func (m *SceneDieNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneDieNtf) GetDropItems() []*SceneObj {
	if m != nil {
		return m.DropItems
	}
	return nil
}

// 客户端攻击移动
type SceneMoveRpt struct {
	ObjId    int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Point    *Point `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	MoveType int32  `protobuf:"varint,3,opt,name=moveType,proto3" json:"moveType,omitempty"`
}

func (m *SceneMoveRpt) Reset()                    { *m = SceneMoveRpt{} }
func (m *SceneMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveRpt) ProtoMessage()               {}
func (*SceneMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{14} }

func (m *SceneMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveRpt) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneMoveRpt) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

// 推送角色移动
type SceneMoveNtf struct {
	ObjId    int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Point    *Point `protobuf:"bytes,2,opt,name=point" json:"point,omitempty"`
	Force    bool   `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	MoveType int32  `protobuf:"varint,4,opt,name=moveType,proto3" json:"moveType,omitempty"`
}

func (m *SceneMoveNtf) Reset()                    { *m = SceneMoveNtf{} }
func (m *SceneMoveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneMoveNtf) ProtoMessage()               {}
func (*SceneMoveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{15} }

func (m *SceneMoveNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneMoveNtf) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *SceneMoveNtf) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *SceneMoveNtf) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

type SceneUserReliveNtf struct {
	Obj        *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
	ReliveType int32     `protobuf:"varint,2,opt,name=reliveType,proto3" json:"reliveType,omitempty"`
}

func (m *SceneUserReliveNtf) Reset()                    { *m = SceneUserReliveNtf{} }
func (m *SceneUserReliveNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneUserReliveNtf) ProtoMessage()               {}
func (*SceneUserReliveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{16} }

func (m *SceneUserReliveNtf) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *SceneUserReliveNtf) GetReliveType() int32 {
	if m != nil {
		return m.ReliveType
	}
	return 0
}

type SceneUserUpdateNtf struct {
	ObjId   int32      `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	ObjUser *SceneUser `protobuf:"bytes,2,opt,name=objUser" json:"objUser,omitempty"`
}

func (m *SceneUserUpdateNtf) Reset()                    { *m = SceneUserUpdateNtf{} }
func (m *SceneUserUpdateNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneUserUpdateNtf) ProtoMessage()               {}
func (*SceneUserUpdateNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{17} }

func (m *SceneUserUpdateNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneUserUpdateNtf) GetObjUser() *SceneUser {
	if m != nil {
		return m.ObjUser
	}
	return nil
}

type SceneUserElfUpdateNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ElfLv  int32 `protobuf:"varint,2,opt,name=elfLv,proto3" json:"elfLv,omitempty"`
}

func (m *SceneUserElfUpdateNtf) Reset()                    { *m = SceneUserElfUpdateNtf{} }
func (m *SceneUserElfUpdateNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneUserElfUpdateNtf) ProtoMessage()               {}
func (*SceneUserElfUpdateNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{18} }

func (m *SceneUserElfUpdateNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneUserElfUpdateNtf) GetElfLv() int32 {
	if m != nil {
		return m.ElfLv
	}
	return 0
}

// 客户端攻击请求
type AttackRpt struct {
	SkillId    int32   `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	ObjIds     []int32 `protobuf:"varint,2,rep,packed,name=objIds" json:"objIds,omitempty"`
	Dir        int32   `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	Point      *Point  `protobuf:"bytes,4,opt,name=point" json:"point,omitempty"`
	SkillLevel int32   `protobuf:"varint,5,opt,name=skillLevel,proto3" json:"skillLevel,omitempty"`
	ObjId      int32   `protobuf:"varint,6,opt,name=objId,proto3" json:"objId,omitempty"`
	IsElf      bool    `protobuf:"varint,7,opt,name=isElf,proto3" json:"isElf,omitempty"`
}

func (m *AttackRpt) Reset()                    { *m = AttackRpt{} }
func (m *AttackRpt) String() string            { return proto.CompactTextString(m) }
func (*AttackRpt) ProtoMessage()               {}
func (*AttackRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{19} }

func (m *AttackRpt) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackRpt) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *AttackRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *AttackRpt) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *AttackRpt) GetSkillLevel() int32 {
	if m != nil {
		return m.SkillLevel
	}
	return 0
}

func (m *AttackRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *AttackRpt) GetIsElf() bool {
	if m != nil {
		return m.IsElf
	}
	return false
}

// 攻击结果及效果返回
type AttackEffectNtf struct {
	SkillId      int32         `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	AttackerId   int32         `protobuf:"varint,2,opt,name=attackerId,proto3" json:"attackerId,omitempty"`
	Dir          int32         `protobuf:"varint,3,opt,name=dir,proto3" json:"dir,omitempty"`
	Point        *Point        `protobuf:"bytes,4,opt,name=point" json:"point,omitempty"`
	Hurts        []*HurtEffect `protobuf:"bytes,5,rep,name=hurts" json:"hurts,omitempty"`
	MoveToPoint  *Point        `protobuf:"bytes,6,opt,name=MoveToPoint" json:"MoveToPoint,omitempty"`
	SkillLv      int32         `protobuf:"varint,7,opt,name=skillLv,proto3" json:"skillLv,omitempty"`
	Err          int32         `protobuf:"varint,8,opt,name=err,proto3" json:"err,omitempty"`
	SkillStartT  int64         `protobuf:"varint,9,opt,name=skillStartT,proto3" json:"skillStartT,omitempty"`
	SkillStopT   int64         `protobuf:"varint,10,opt,name=skillStopT,proto3" json:"skillStopT,omitempty"`
	ServerTime   int64         `protobuf:"varint,11,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	MpNow        int64         `protobuf:"varint,12,opt,name=mpNow,proto3" json:"mpNow,omitempty"`
	IsElf        bool          `protobuf:"varint,13,opt,name=isElf,proto3" json:"isElf,omitempty"`
	AttackerName string        `protobuf:"bytes,14,opt,name=attackerName,proto3" json:"attackerName,omitempty"`
	HpNow        int64         `protobuf:"varint,15,opt,name=hpNow,proto3" json:"hpNow,omitempty"`
}

func (m *AttackEffectNtf) Reset()                    { *m = AttackEffectNtf{} }
func (m *AttackEffectNtf) String() string            { return proto.CompactTextString(m) }
func (*AttackEffectNtf) ProtoMessage()               {}
func (*AttackEffectNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{20} }

func (m *AttackEffectNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AttackEffectNtf) GetAttackerId() int32 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *AttackEffectNtf) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (m *AttackEffectNtf) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *AttackEffectNtf) GetHurts() []*HurtEffect {
	if m != nil {
		return m.Hurts
	}
	return nil
}

func (m *AttackEffectNtf) GetMoveToPoint() *Point {
	if m != nil {
		return m.MoveToPoint
	}
	return nil
}

func (m *AttackEffectNtf) GetSkillLv() int32 {
	if m != nil {
		return m.SkillLv
	}
	return 0
}

func (m *AttackEffectNtf) GetErr() int32 {
	if m != nil {
		return m.Err
	}
	return 0
}

func (m *AttackEffectNtf) GetSkillStartT() int64 {
	if m != nil {
		return m.SkillStartT
	}
	return 0
}

func (m *AttackEffectNtf) GetSkillStopT() int64 {
	if m != nil {
		return m.SkillStopT
	}
	return 0
}

func (m *AttackEffectNtf) GetServerTime() int64 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *AttackEffectNtf) GetMpNow() int64 {
	if m != nil {
		return m.MpNow
	}
	return 0
}

func (m *AttackEffectNtf) GetIsElf() bool {
	if m != nil {
		return m.IsElf
	}
	return false
}

func (m *AttackEffectNtf) GetAttackerName() string {
	if m != nil {
		return m.AttackerName
	}
	return ""
}

func (m *AttackEffectNtf) GetHpNow() int64 {
	if m != nil {
		return m.HpNow
	}
	return 0
}

type HurtEffect struct {
	ObjId       int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Hp          int64  `protobuf:"varint,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ChangHp     int64  `protobuf:"varint,3,opt,name=changHp,proto3" json:"changHp,omitempty"`
	IsDeath     bool   `protobuf:"varint,4,opt,name=isDeath,proto3" json:"isDeath,omitempty"`
	IsDodge     bool   `protobuf:"varint,5,opt,name=isDodge,proto3" json:"isDodge,omitempty"`
	HurtType    int32  `protobuf:"varint,6,opt,name=hurtType,proto3" json:"hurtType,omitempty"`
	Hurt        int64  `protobuf:"varint,7,opt,name=hurt,proto3" json:"hurt,omitempty"`
	Deathblow   int64  `protobuf:"varint,8,opt,name=deathblow,proto3" json:"deathblow,omitempty"`
	CutHurt     int64  `protobuf:"varint,9,opt,name=cutHurt,proto3" json:"cutHurt,omitempty"`
	MoveToPoint *Point `protobuf:"bytes,10,opt,name=MoveToPoint" json:"MoveToPoint,omitempty"`
	UnBlock     int64  `protobuf:"varint,11,opt,name=unBlock,proto3" json:"unBlock,omitempty"`
	Reflex      int64  `protobuf:"varint,12,opt,name=reflex,proto3" json:"reflex,omitempty"`
	ReliveSelf  bool   `protobuf:"varint,13,opt,name=reliveSelf,proto3" json:"reliveSelf,omitempty"`
	IsWuDi      bool   `protobuf:"varint,14,opt,name=isWuDi,proto3" json:"isWuDi,omitempty"`
	KillHurt    int64  `protobuf:"varint,15,opt,name=killHurt,proto3" json:"killHurt,omitempty"`
}

func (m *HurtEffect) Reset()                    { *m = HurtEffect{} }
func (m *HurtEffect) String() string            { return proto.CompactTextString(m) }
func (*HurtEffect) ProtoMessage()               {}
func (*HurtEffect) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{21} }

func (m *HurtEffect) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *HurtEffect) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *HurtEffect) GetChangHp() int64 {
	if m != nil {
		return m.ChangHp
	}
	return 0
}

func (m *HurtEffect) GetIsDeath() bool {
	if m != nil {
		return m.IsDeath
	}
	return false
}

func (m *HurtEffect) GetIsDodge() bool {
	if m != nil {
		return m.IsDodge
	}
	return false
}

func (m *HurtEffect) GetHurtType() int32 {
	if m != nil {
		return m.HurtType
	}
	return 0
}

func (m *HurtEffect) GetHurt() int64 {
	if m != nil {
		return m.Hurt
	}
	return 0
}

func (m *HurtEffect) GetDeathblow() int64 {
	if m != nil {
		return m.Deathblow
	}
	return 0
}

func (m *HurtEffect) GetCutHurt() int64 {
	if m != nil {
		return m.CutHurt
	}
	return 0
}

func (m *HurtEffect) GetMoveToPoint() *Point {
	if m != nil {
		return m.MoveToPoint
	}
	return nil
}

func (m *HurtEffect) GetUnBlock() int64 {
	if m != nil {
		return m.UnBlock
	}
	return 0
}

func (m *HurtEffect) GetReflex() int64 {
	if m != nil {
		return m.Reflex
	}
	return 0
}

func (m *HurtEffect) GetReliveSelf() bool {
	if m != nil {
		return m.ReliveSelf
	}
	return false
}

func (m *HurtEffect) GetIsWuDi() bool {
	if m != nil {
		return m.IsWuDi
	}
	return false
}

func (m *HurtEffect) GetKillHurt() int64 {
	if m != nil {
		return m.KillHurt
	}
	return 0
}

// 主动推送角色血量
type SceneObjHpNtf struct {
	ObjId       int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Hp          int64  `protobuf:"varint,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ChangeHp    int64  `protobuf:"varint,3,opt,name=changeHp,proto3" json:"changeHp,omitempty"`
	TotalHp     int64  `protobuf:"varint,4,opt,name=totalHp,proto3" json:"totalHp,omitempty"`
	KillerId    int32  `protobuf:"varint,5,opt,name=killerId,proto3" json:"killerId,omitempty"`
	KillerName  string `protobuf:"bytes,6,opt,name=killerName,proto3" json:"killerName,omitempty"`
	UserId      int32  `protobuf:"varint,7,opt,name=userId,proto3" json:"userId,omitempty"`
	UserHpTotal int64  `protobuf:"varint,8,opt,name=userHpTotal,proto3" json:"userHpTotal,omitempty"`
}

func (m *SceneObjHpNtf) Reset()                    { *m = SceneObjHpNtf{} }
func (m *SceneObjHpNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneObjHpNtf) ProtoMessage()               {}
func (*SceneObjHpNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{22} }

func (m *SceneObjHpNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObjHpNtf) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *SceneObjHpNtf) GetChangeHp() int64 {
	if m != nil {
		return m.ChangeHp
	}
	return 0
}

func (m *SceneObjHpNtf) GetTotalHp() int64 {
	if m != nil {
		return m.TotalHp
	}
	return 0
}

func (m *SceneObjHpNtf) GetKillerId() int32 {
	if m != nil {
		return m.KillerId
	}
	return 0
}

func (m *SceneObjHpNtf) GetKillerName() string {
	if m != nil {
		return m.KillerName
	}
	return ""
}

func (m *SceneObjHpNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SceneObjHpNtf) GetUserHpTotal() int64 {
	if m != nil {
		return m.UserHpTotal
	}
	return 0
}

// 主动推送角色蓝量
type SceneObjMpNtf struct {
	ObjId    int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	Mp       int64 `protobuf:"varint,2,opt,name=Mp,proto3" json:"Mp,omitempty"`
	ChangeMp int64 `protobuf:"varint,3,opt,name=changeMp,proto3" json:"changeMp,omitempty"`
	TotalMp  int64 `protobuf:"varint,4,opt,name=totalMp,proto3" json:"totalMp,omitempty"`
}

func (m *SceneObjMpNtf) Reset()                    { *m = SceneObjMpNtf{} }
func (m *SceneObjMpNtf) String() string            { return proto.CompactTextString(m) }
func (*SceneObjMpNtf) ProtoMessage()               {}
func (*SceneObjMpNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{23} }

func (m *SceneObjMpNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *SceneObjMpNtf) GetMp() int64 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *SceneObjMpNtf) GetChangeMp() int64 {
	if m != nil {
		return m.ChangeMp
	}
	return 0
}

func (m *SceneObjMpNtf) GetTotalMp() int64 {
	if m != nil {
		return m.TotalMp
	}
	return 0
}

// 获取战斗伤害排行榜
type FightHurtRankReq struct {
}

func (m *FightHurtRankReq) Reset()                    { *m = FightHurtRankReq{} }
func (m *FightHurtRankReq) String() string            { return proto.CompactTextString(m) }
func (*FightHurtRankReq) ProtoMessage()               {}
func (*FightHurtRankReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{24} }

// 获取战斗伤害排行榜
type FightHurtRankAck struct {
	Ranks  []*FightRankUnit `protobuf:"bytes,1,rep,name=ranks" json:"ranks,omitempty"`
	MyRank *FightRankUnit   `protobuf:"bytes,2,opt,name=myRank" json:"myRank,omitempty"`
}

func (m *FightHurtRankAck) Reset()                    { *m = FightHurtRankAck{} }
func (m *FightHurtRankAck) String() string            { return proto.CompactTextString(m) }
func (*FightHurtRankAck) ProtoMessage()               {}
func (*FightHurtRankAck) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{25} }

func (m *FightHurtRankAck) GetRanks() []*FightRankUnit {
	if m != nil {
		return m.Ranks
	}
	return nil
}

func (m *FightHurtRankAck) GetMyRank() *FightRankUnit {
	if m != nil {
		return m.MyRank
	}
	return nil
}

// 排行榜单元数据
type FightRankUnit struct {
	Rank       int32  `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Score      int64  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	ServerName string `protobuf:"bytes,4,opt,name=serverName,proto3" json:"serverName,omitempty"`
	UserId     int32  `protobuf:"varint,5,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *FightRankUnit) Reset()                    { *m = FightRankUnit{} }
func (m *FightRankUnit) String() string            { return proto.CompactTextString(m) }
func (*FightRankUnit) ProtoMessage()               {}
func (*FightRankUnit) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{26} }

func (m *FightRankUnit) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *FightRankUnit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FightRankUnit) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *FightRankUnit) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *FightRankUnit) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 获取boss归属
type GetBossOwnerChangReq struct {
}

func (m *GetBossOwnerChangReq) Reset()                    { *m = GetBossOwnerChangReq{} }
func (m *GetBossOwnerChangReq) String() string            { return proto.CompactTextString(m) }
func (*GetBossOwnerChangReq) ProtoMessage()               {}
func (*GetBossOwnerChangReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{27} }

// 获取boss归属
type BossOwnerChangNtf struct {
	ObjId      int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	OwnerObjId int32  `protobuf:"varint,2,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	UserId     int32  `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName   string `protobuf:"bytes,4,opt,name=userName,proto3" json:"userName,omitempty"`
}

func (m *BossOwnerChangNtf) Reset()                    { *m = BossOwnerChangNtf{} }
func (m *BossOwnerChangNtf) String() string            { return proto.CompactTextString(m) }
func (*BossOwnerChangNtf) ProtoMessage()               {}
func (*BossOwnerChangNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{28} }

func (m *BossOwnerChangNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *BossOwnerChangNtf) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BossOwnerChangNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BossOwnerChangNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type BuffChangeNtf struct {
	Buff         *BuffInfo      `protobuf:"bytes,1,opt,name=buff" json:"buff,omitempty"`
	DelBuffInfos []*DelBuffInfo `protobuf:"bytes,2,rep,name=delBuffInfos" json:"delBuffInfos,omitempty"`
}

func (m *BuffChangeNtf) Reset()                    { *m = BuffChangeNtf{} }
func (m *BuffChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffChangeNtf) ProtoMessage()               {}
func (*BuffChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{29} }

func (m *BuffChangeNtf) GetBuff() *BuffInfo {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *BuffChangeNtf) GetDelBuffInfos() []*DelBuffInfo {
	if m != nil {
		return m.DelBuffInfos
	}
	return nil
}

type BuffDelNtf struct {
	DelBuffInfos []*DelBuffInfo `protobuf:"bytes,1,rep,name=delBuffInfos" json:"delBuffInfos,omitempty"`
}

func (m *BuffDelNtf) Reset()                    { *m = BuffDelNtf{} }
func (m *BuffDelNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffDelNtf) ProtoMessage()               {}
func (*BuffDelNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{30} }

func (m *BuffDelNtf) GetDelBuffInfos() []*DelBuffInfo {
	if m != nil {
		return m.DelBuffInfos
	}
	return nil
}

type BuffInfo struct {
	OwnerObjId   int32 `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	SourceObjId  int32 `protobuf:"varint,2,opt,name=sourceObjId,proto3" json:"sourceObjId,omitempty"`
	Idx          int32 `protobuf:"varint,3,opt,name=idx,proto3" json:"idx,omitempty"`
	BuffId       int32 `protobuf:"varint,4,opt,name=buffId,proto3" json:"buffId,omitempty"`
	TotalTime    int64 `protobuf:"varint,5,opt,name=totalTime,proto3" json:"totalTime,omitempty"`
	OwnerUserId  int32 `protobuf:"varint,6,opt,name=ownerUserId,proto3" json:"ownerUserId,omitempty"`
	SourceUserId int32 `protobuf:"varint,7,opt,name=sourceUserId,proto3" json:"sourceUserId,omitempty"`
}

func (m *BuffInfo) Reset()                    { *m = BuffInfo{} }
func (m *BuffInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffInfo) ProtoMessage()               {}
func (*BuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{31} }

func (m *BuffInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BuffInfo) GetSourceObjId() int32 {
	if m != nil {
		return m.SourceObjId
	}
	return 0
}

func (m *BuffInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffInfo) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *BuffInfo) GetTotalTime() int64 {
	if m != nil {
		return m.TotalTime
	}
	return 0
}

func (m *BuffInfo) GetOwnerUserId() int32 {
	if m != nil {
		return m.OwnerUserId
	}
	return 0
}

func (m *BuffInfo) GetSourceUserId() int32 {
	if m != nil {
		return m.SourceUserId
	}
	return 0
}

type DelBuffInfo struct {
	OwnerObjId int32 `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	Idx        int32 `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (m *DelBuffInfo) Reset()                    { *m = DelBuffInfo{} }
func (m *DelBuffInfo) String() string            { return proto.CompactTextString(m) }
func (*DelBuffInfo) ProtoMessage()               {}
func (*DelBuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{32} }

func (m *DelBuffInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *DelBuffInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type BuffPropChangeNtf struct {
	ObjId  int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	PropId int32 `protobuf:"varint,2,opt,name=propId,proto3" json:"propId,omitempty"`
	Total  int64 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *BuffPropChangeNtf) Reset()                    { *m = BuffPropChangeNtf{} }
func (m *BuffPropChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffPropChangeNtf) ProtoMessage()               {}
func (*BuffPropChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{33} }

func (m *BuffPropChangeNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *BuffPropChangeNtf) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *BuffPropChangeNtf) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type BuffHpChangeNtf struct {
	BuffHpChangeInfos []*BuffHpChangeInfo `protobuf:"bytes,1,rep,name=buffHpChangeInfos" json:"buffHpChangeInfos,omitempty"`
}

func (m *BuffHpChangeNtf) Reset()                    { *m = BuffHpChangeNtf{} }
func (m *BuffHpChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeNtf) ProtoMessage()               {}
func (*BuffHpChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{34} }

func (m *BuffHpChangeNtf) GetBuffHpChangeInfos() []*BuffHpChangeInfo {
	if m != nil {
		return m.BuffHpChangeInfos
	}
	return nil
}

type BuffHpChangeInfo struct {
	OwnerObjId int32  `protobuf:"varint,1,opt,name=ownerObjId,proto3" json:"ownerObjId,omitempty"`
	Idx        int32  `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Death      int32  `protobuf:"varint,3,opt,name=death,proto3" json:"death,omitempty"`
	ChangeHp   int64  `protobuf:"varint,4,opt,name=changeHp,proto3" json:"changeHp,omitempty"`
	TotalHp    int64  `protobuf:"varint,5,opt,name=totalHp,proto3" json:"totalHp,omitempty"`
	KillerId   int32  `protobuf:"varint,6,opt,name=killerId,proto3" json:"killerId,omitempty"`
	KillerName string `protobuf:"bytes,7,opt,name=killerName,proto3" json:"killerName,omitempty"`
}

func (m *BuffHpChangeInfo) Reset()                    { *m = BuffHpChangeInfo{} }
func (m *BuffHpChangeInfo) String() string            { return proto.CompactTextString(m) }
func (*BuffHpChangeInfo) ProtoMessage()               {}
func (*BuffHpChangeInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{35} }

func (m *BuffHpChangeInfo) GetOwnerObjId() int32 {
	if m != nil {
		return m.OwnerObjId
	}
	return 0
}

func (m *BuffHpChangeInfo) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *BuffHpChangeInfo) GetDeath() int32 {
	if m != nil {
		return m.Death
	}
	return 0
}

func (m *BuffHpChangeInfo) GetChangeHp() int64 {
	if m != nil {
		return m.ChangeHp
	}
	return 0
}

func (m *BuffHpChangeInfo) GetTotalHp() int64 {
	if m != nil {
		return m.TotalHp
	}
	return 0
}

func (m *BuffHpChangeInfo) GetKillerId() int32 {
	if m != nil {
		return m.KillerId
	}
	return 0
}

func (m *BuffHpChangeInfo) GetKillerName() string {
	if m != nil {
		return m.KillerName
	}
	return ""
}

type MainCityEnterRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityEnterRpt) Reset()                    { *m = MainCityEnterRpt{} }
func (m *MainCityEnterRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityEnterRpt) ProtoMessage()               {}
func (*MainCityEnterRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{36} }

func (m *MainCityEnterRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type MainCityMoveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Dir   int32 `protobuf:"varint,5,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *MainCityMoveRpt) Reset()                    { *m = MainCityMoveRpt{} }
func (m *MainCityMoveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityMoveRpt) ProtoMessage()               {}
func (*MainCityMoveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{37} }

func (m *MainCityMoveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *MainCityMoveRpt) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MainCityMoveRpt) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MainCityMoveRpt) GetDir() int32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

type MainCityLeaveRpt struct {
	ObjId int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *MainCityLeaveRpt) Reset()                    { *m = MainCityLeaveRpt{} }
func (m *MainCityLeaveRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityLeaveRpt) ProtoMessage()               {}
func (*MainCityLeaveRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{38} }

func (m *MainCityLeaveRpt) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type MainCityUpdateRpt struct {
	Obj *SceneObj `protobuf:"bytes,1,opt,name=obj" json:"obj,omitempty"`
}

func (m *MainCityUpdateRpt) Reset()                    { *m = MainCityUpdateRpt{} }
func (m *MainCityUpdateRpt) String() string            { return proto.CompactTextString(m) }
func (*MainCityUpdateRpt) ProtoMessage()               {}
func (*MainCityUpdateRpt) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{39} }

func (m *MainCityUpdateRpt) GetObj() *SceneObj {
	if m != nil {
		return m.Obj
	}
	return nil
}

type FightEnterOkReq struct {
}

func (m *FightEnterOkReq) Reset()                    { *m = FightEnterOkReq{} }
func (m *FightEnterOkReq) String() string            { return proto.CompactTextString(m) }
func (*FightEnterOkReq) ProtoMessage()               {}
func (*FightEnterOkReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{40} }

type FightStartCountDownNtf struct {
	ServerTime    int32 `protobuf:"varint,1,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
	CountDownTime int32 `protobuf:"varint,2,opt,name=countDownTime,proto3" json:"countDownTime,omitempty"`
}

func (m *FightStartCountDownNtf) Reset()                    { *m = FightStartCountDownNtf{} }
func (m *FightStartCountDownNtf) String() string            { return proto.CompactTextString(m) }
func (*FightStartCountDownNtf) ProtoMessage()               {}
func (*FightStartCountDownNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{41} }

func (m *FightStartCountDownNtf) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *FightStartCountDownNtf) GetCountDownTime() int32 {
	if m != nil {
		return m.CountDownTime
	}
	return 0
}

type FightStartCountDownOkReq struct {
}

func (m *FightStartCountDownOkReq) Reset()                    { *m = FightStartCountDownOkReq{} }
func (m *FightStartCountDownOkReq) String() string            { return proto.CompactTextString(m) }
func (*FightStartCountDownOkReq) ProtoMessage()               {}
func (*FightStartCountDownOkReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{42} }

type FightStartNtf struct {
}

func (m *FightStartNtf) Reset()                    { *m = FightStartNtf{} }
func (m *FightStartNtf) String() string            { return proto.CompactTextString(m) }
func (*FightStartNtf) ProtoMessage()               {}
func (*FightStartNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{43} }

type CollectionStatusChangeNtf struct {
	ObjId     int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	UserObjId int32 `protobuf:"varint,2,opt,name=userObjId,proto3" json:"userObjId,omitempty"`
	StartTime int64 `protobuf:"varint,3,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *CollectionStatusChangeNtf) Reset()                    { *m = CollectionStatusChangeNtf{} }
func (m *CollectionStatusChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*CollectionStatusChangeNtf) ProtoMessage()               {}
func (*CollectionStatusChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{44} }

func (m *CollectionStatusChangeNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetUserObjId() int32 {
	if m != nil {
		return m.UserObjId
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *CollectionStatusChangeNtf) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type FightTeamChangeNtf struct {
	UserTeamIndex map[int32]int32 `protobuf:"bytes,1,rep,name=userTeamIndex" json:"userTeamIndex,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FightTeamChangeNtf) Reset()                    { *m = FightTeamChangeNtf{} }
func (m *FightTeamChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*FightTeamChangeNtf) ProtoMessage()               {}
func (*FightTeamChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{45} }

func (m *FightTeamChangeNtf) GetUserTeamIndex() map[int32]int32 {
	if m != nil {
		return m.UserTeamIndex
	}
	return nil
}

type FightUserChangeToHelperNtf struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	TeamIndex int32 `protobuf:"varint,2,opt,name=teamIndex,proto3" json:"teamIndex,omitempty"`
}

func (m *FightUserChangeToHelperNtf) Reset()                    { *m = FightUserChangeToHelperNtf{} }
func (m *FightUserChangeToHelperNtf) String() string            { return proto.CompactTextString(m) }
func (*FightUserChangeToHelperNtf) ProtoMessage()               {}
func (*FightUserChangeToHelperNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{46} }

func (m *FightUserChangeToHelperNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FightUserChangeToHelperNtf) GetTeamIndex() int32 {
	if m != nil {
		return m.TeamIndex
	}
	return 0
}

type FightNpcEventReq struct {
	NpcId int32 `protobuf:"varint,1,opt,name=npcId,proto3" json:"npcId,omitempty"`
}

func (m *FightNpcEventReq) Reset()                    { *m = FightNpcEventReq{} }
func (m *FightNpcEventReq) String() string            { return proto.CompactTextString(m) }
func (*FightNpcEventReq) ProtoMessage()               {}
func (*FightNpcEventReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{47} }

func (m *FightNpcEventReq) GetNpcId() int32 {
	if m != nil {
		return m.NpcId
	}
	return 0
}

// -----------------系统功能模块------------------
type ExpStageKillInfoNtf struct {
	KillMonsterNum int32 `protobuf:"varint,1,opt,name=killMonsterNum,proto3" json:"killMonsterNum,omitempty"`
	GetExp         int32 `protobuf:"varint,2,opt,name=getExp,proto3" json:"getExp,omitempty"`
}

func (m *ExpStageKillInfoNtf) Reset()                    { *m = ExpStageKillInfoNtf{} }
func (m *ExpStageKillInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*ExpStageKillInfoNtf) ProtoMessage()               {}
func (*ExpStageKillInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{48} }

func (m *ExpStageKillInfoNtf) GetKillMonsterNum() int32 {
	if m != nil {
		return m.KillMonsterNum
	}
	return 0
}

func (m *ExpStageKillInfoNtf) GetGetExp() int32 {
	if m != nil {
		return m.GetExp
	}
	return 0
}

// 获取泡点占领者
type PaodianTopUserReq struct {
}

func (m *PaodianTopUserReq) Reset()                    { *m = PaodianTopUserReq{} }
func (m *PaodianTopUserReq) String() string            { return proto.CompactTextString(m) }
func (*PaodianTopUserReq) ProtoMessage()               {}
func (*PaodianTopUserReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{49} }

// 推送泡点占领者
type PaodianTopUserNtf struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=userIds" json:"userIds,omitempty"`
}

func (m *PaodianTopUserNtf) Reset()                    { *m = PaodianTopUserNtf{} }
func (m *PaodianTopUserNtf) String() string            { return proto.CompactTextString(m) }
func (*PaodianTopUserNtf) ProtoMessage()               {}
func (*PaodianTopUserNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{50} }

func (m *PaodianTopUserNtf) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type PaoDianUserNumNtf struct {
	UserNums map[int32]int32 `protobuf:"bytes,1,rep,name=userNums" json:"userNums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *PaoDianUserNumNtf) Reset()                    { *m = PaoDianUserNumNtf{} }
func (m *PaoDianUserNumNtf) String() string            { return proto.CompactTextString(m) }
func (*PaoDianUserNumNtf) ProtoMessage()               {}
func (*PaoDianUserNumNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{51} }

func (m *PaoDianUserNumNtf) GetUserNums() map[int32]int32 {
	if m != nil {
		return m.UserNums
	}
	return nil
}

type PaodianFightEnd struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *PaodianFightEnd) Reset()                    { *m = PaodianFightEnd{} }
func (m *PaodianFightEnd) String() string            { return proto.CompactTextString(m) }
func (*PaodianFightEnd) ProtoMessage()               {}
func (*PaodianFightEnd) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{52} }

func (m *PaodianFightEnd) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

type GetShabakeScoresReq struct {
}

func (m *GetShabakeScoresReq) Reset()                    { *m = GetShabakeScoresReq{} }
func (m *GetShabakeScoresReq) String() string            { return proto.CompactTextString(m) }
func (*GetShabakeScoresReq) ProtoMessage()               {}
func (*GetShabakeScoresReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{53} }

type ShabakeScoreRankNtf struct {
	UserScores  []*ShabakeUserScore  `protobuf:"bytes,1,rep,name=userScores" json:"userScores,omitempty"`
	GuildScores []*ShabakeGuildScore `protobuf:"bytes,2,rep,name=guildScores" json:"guildScores,omitempty"`
}

func (m *ShabakeScoreRankNtf) Reset()                    { *m = ShabakeScoreRankNtf{} }
func (m *ShabakeScoreRankNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeScoreRankNtf) ProtoMessage()               {}
func (*ShabakeScoreRankNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{54} }

func (m *ShabakeScoreRankNtf) GetUserScores() []*ShabakeUserScore {
	if m != nil {
		return m.UserScores
	}
	return nil
}

func (m *ShabakeScoreRankNtf) GetGuildScores() []*ShabakeGuildScore {
	if m != nil {
		return m.GuildScores
	}
	return nil
}

type ShabakeUserScore struct {
	UserId   int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName string `protobuf:"bytes,2,opt,name=userName,proto3" json:"userName,omitempty"`
	Score    int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	Rank     int32  `protobuf:"varint,4,opt,name=rank,proto3" json:"rank,omitempty"`
}

func (m *ShabakeUserScore) Reset()                    { *m = ShabakeUserScore{} }
func (m *ShabakeUserScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeUserScore) ProtoMessage()               {}
func (*ShabakeUserScore) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{55} }

func (m *ShabakeUserScore) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShabakeUserScore) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShabakeUserScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ShabakeUserScore) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

type ShabakeGuildScore struct {
	GuildId    int32  `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName  string `protobuf:"bytes,2,opt,name=guildName,proto3" json:"guildName,omitempty"`
	Score      int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	ServerId   int32  `protobuf:"varint,4,opt,name=serverId,proto3" json:"serverId,omitempty"`
	ServerName string `protobuf:"bytes,5,opt,name=serverName,proto3" json:"serverName,omitempty"`
}

func (m *ShabakeGuildScore) Reset()                    { *m = ShabakeGuildScore{} }
func (m *ShabakeGuildScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeGuildScore) ProtoMessage()               {}
func (*ShabakeGuildScore) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{56} }

func (m *ShabakeGuildScore) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeGuildScore) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *ShabakeGuildScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ShabakeGuildScore) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *ShabakeGuildScore) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

type ShabakeOccupiedNtf struct {
	IsOccupy    bool   `protobuf:"varint,1,opt,name=isOccupy,proto3" json:"isOccupy,omitempty"`
	UserId      int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName    string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
	GuildId     int32  `protobuf:"varint,4,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName   string `protobuf:"bytes,5,opt,name=guildName,proto3" json:"guildName,omitempty"`
	StartTime   int32  `protobuf:"varint,6,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime     int32  `protobuf:"varint,7,opt,name=endTime,proto3" json:"endTime,omitempty"`
	FightStatus int32  `protobuf:"varint,8,opt,name=fightStatus,proto3" json:"fightStatus,omitempty"`
}

func (m *ShabakeOccupiedNtf) Reset()                    { *m = ShabakeOccupiedNtf{} }
func (m *ShabakeOccupiedNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeOccupiedNtf) ProtoMessage()               {}
func (*ShabakeOccupiedNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{57} }

func (m *ShabakeOccupiedNtf) GetIsOccupy() bool {
	if m != nil {
		return m.IsOccupy
	}
	return false
}

func (m *ShabakeOccupiedNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShabakeOccupiedNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *ShabakeOccupiedNtf) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ShabakeOccupiedNtf) GetFightStatus() int32 {
	if m != nil {
		return m.FightStatus
	}
	return 0
}

type GetShabakeCrossScoresReq struct {
}

func (m *GetShabakeCrossScoresReq) Reset()                    { *m = GetShabakeCrossScoresReq{} }
func (m *GetShabakeCrossScoresReq) String() string            { return proto.CompactTextString(m) }
func (*GetShabakeCrossScoresReq) ProtoMessage()               {}
func (*GetShabakeCrossScoresReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{58} }

type ShabakeCrossScoreRankNtf struct {
	ServerScores []*ShabakeCrossServerScore `protobuf:"bytes,1,rep,name=serverScores" json:"serverScores,omitempty"`
	GuildScores  []*ShabakeGuildScore       `protobuf:"bytes,2,rep,name=guildScores" json:"guildScores,omitempty"`
}

func (m *ShabakeCrossScoreRankNtf) Reset()                    { *m = ShabakeCrossScoreRankNtf{} }
func (m *ShabakeCrossScoreRankNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeCrossScoreRankNtf) ProtoMessage()               {}
func (*ShabakeCrossScoreRankNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{59} }

func (m *ShabakeCrossScoreRankNtf) GetServerScores() []*ShabakeCrossServerScore {
	if m != nil {
		return m.ServerScores
	}
	return nil
}

func (m *ShabakeCrossScoreRankNtf) GetGuildScores() []*ShabakeGuildScore {
	if m != nil {
		return m.GuildScores
	}
	return nil
}

type ShabakeCrossServerScore struct {
	ServerId   int32  `protobuf:"varint,1,opt,name=serverId,proto3" json:"serverId,omitempty"`
	ServerName string `protobuf:"bytes,2,opt,name=serverName,proto3" json:"serverName,omitempty"`
	Score      int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *ShabakeCrossServerScore) Reset()                    { *m = ShabakeCrossServerScore{} }
func (m *ShabakeCrossServerScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeCrossServerScore) ProtoMessage()               {}
func (*ShabakeCrossServerScore) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{60} }

func (m *ShabakeCrossServerScore) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *ShabakeCrossServerScore) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ShabakeCrossServerScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ShabakeCrossOccupiedNtf struct {
	IsOccupy   bool   `protobuf:"varint,1,opt,name=isOccupy,proto3" json:"isOccupy,omitempty"`
	UserId     int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName   string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
	GuildId    int32  `protobuf:"varint,4,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName  string `protobuf:"bytes,5,opt,name=guildName,proto3" json:"guildName,omitempty"`
	StartTime  int32  `protobuf:"varint,6,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime    int32  `protobuf:"varint,7,opt,name=endTime,proto3" json:"endTime,omitempty"`
	ServerId   int32  `protobuf:"varint,8,opt,name=serverId,proto3" json:"serverId,omitempty"`
	ServerName string `protobuf:"bytes,9,opt,name=serverName,proto3" json:"serverName,omitempty"`
}

func (m *ShabakeCrossOccupiedNtf) Reset()                    { *m = ShabakeCrossOccupiedNtf{} }
func (m *ShabakeCrossOccupiedNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeCrossOccupiedNtf) ProtoMessage()               {}
func (*ShabakeCrossOccupiedNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{61} }

func (m *ShabakeCrossOccupiedNtf) GetIsOccupy() bool {
	if m != nil {
		return m.IsOccupy
	}
	return false
}

func (m *ShabakeCrossOccupiedNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShabakeCrossOccupiedNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShabakeCrossOccupiedNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeCrossOccupiedNtf) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *ShabakeCrossOccupiedNtf) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ShabakeCrossOccupiedNtf) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ShabakeCrossOccupiedNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *ShabakeCrossOccupiedNtf) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

type GuardPillarFightNtf struct {
	Rank         *FightHurtRankAck `protobuf:"bytes,1,opt,name=rank" json:"rank,omitempty"`
	Wave         int32             `protobuf:"varint,2,opt,name=wave,proto3" json:"wave,omitempty"`
	NextTime     int32             `protobuf:"varint,3,opt,name=nextTime,proto3" json:"nextTime,omitempty"`
	MonsterTotal int32             `protobuf:"varint,4,opt,name=monsterTotal,proto3" json:"monsterTotal,omitempty"`
	Monsterless  int32             `protobuf:"varint,5,opt,name=monsterless,proto3" json:"monsterless,omitempty"`
	FightEndTime int32             `protobuf:"varint,6,opt,name=fightEndTime,proto3" json:"fightEndTime,omitempty"`
}

func (m *GuardPillarFightNtf) Reset()                    { *m = GuardPillarFightNtf{} }
func (m *GuardPillarFightNtf) String() string            { return proto.CompactTextString(m) }
func (*GuardPillarFightNtf) ProtoMessage()               {}
func (*GuardPillarFightNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{62} }

func (m *GuardPillarFightNtf) GetRank() *FightHurtRankAck {
	if m != nil {
		return m.Rank
	}
	return nil
}

func (m *GuardPillarFightNtf) GetWave() int32 {
	if m != nil {
		return m.Wave
	}
	return 0
}

func (m *GuardPillarFightNtf) GetNextTime() int32 {
	if m != nil {
		return m.NextTime
	}
	return 0
}

func (m *GuardPillarFightNtf) GetMonsterTotal() int32 {
	if m != nil {
		return m.MonsterTotal
	}
	return 0
}

func (m *GuardPillarFightNtf) GetMonsterless() int32 {
	if m != nil {
		return m.Monsterless
	}
	return 0
}

func (m *GuardPillarFightNtf) GetFightEndTime() int32 {
	if m != nil {
		return m.FightEndTime
	}
	return 0
}

type MagicTowerBossInfo struct {
	BossName     string `protobuf:"bytes,1,opt,name=bossName,proto3" json:"bossName,omitempty"`
	Layer        int32  `protobuf:"varint,2,opt,name=layer,proto3" json:"layer,omitempty"`
	Status       int32  `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	RefreshTime  int32  `protobuf:"varint,4,opt,name=refreshTime,proto3" json:"refreshTime,omitempty"`
	MonsterId    int32  `protobuf:"varint,5,opt,name=monsterId,proto3" json:"monsterId,omitempty"`
	OwnerUseId   int32  `protobuf:"varint,6,opt,name=ownerUseId,proto3" json:"ownerUseId,omitempty"`
	OwnerName    string `protobuf:"bytes,7,opt,name=ownerName,proto3" json:"ownerName,omitempty"`
	MonsterObjId int32  `protobuf:"varint,8,opt,name=monsterObjId,proto3" json:"monsterObjId,omitempty"`
}

func (m *MagicTowerBossInfo) Reset()                    { *m = MagicTowerBossInfo{} }
func (m *MagicTowerBossInfo) String() string            { return proto.CompactTextString(m) }
func (*MagicTowerBossInfo) ProtoMessage()               {}
func (*MagicTowerBossInfo) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{63} }

func (m *MagicTowerBossInfo) GetBossName() string {
	if m != nil {
		return m.BossName
	}
	return ""
}

func (m *MagicTowerBossInfo) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *MagicTowerBossInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MagicTowerBossInfo) GetRefreshTime() int32 {
	if m != nil {
		return m.RefreshTime
	}
	return 0
}

func (m *MagicTowerBossInfo) GetMonsterId() int32 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *MagicTowerBossInfo) GetOwnerUseId() int32 {
	if m != nil {
		return m.OwnerUseId
	}
	return 0
}

func (m *MagicTowerBossInfo) GetOwnerName() string {
	if m != nil {
		return m.OwnerName
	}
	return ""
}

func (m *MagicTowerBossInfo) GetMonsterObjId() int32 {
	if m != nil {
		return m.MonsterObjId
	}
	return 0
}

type MagicTowerFightNtf struct {
	UserScores []*ShabakeUserScore   `protobuf:"bytes,1,rep,name=userScores" json:"userScores,omitempty"`
	BossInfos  []*MagicTowerBossInfo `protobuf:"bytes,2,rep,name=bossInfos" json:"bossInfos,omitempty"`
}

func (m *MagicTowerFightNtf) Reset()                    { *m = MagicTowerFightNtf{} }
func (m *MagicTowerFightNtf) String() string            { return proto.CompactTextString(m) }
func (*MagicTowerFightNtf) ProtoMessage()               {}
func (*MagicTowerFightNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{64} }

func (m *MagicTowerFightNtf) GetUserScores() []*ShabakeUserScore {
	if m != nil {
		return m.UserScores
	}
	return nil
}

func (m *MagicTowerFightNtf) GetBossInfos() []*MagicTowerBossInfo {
	if m != nil {
		return m.BossInfos
	}
	return nil
}

type FightUserScoreNtf struct {
	Score       int32 `protobuf:"varint,1,opt,name=score,proto3" json:"score,omitempty"`
	ChangeScore int32 `protobuf:"varint,2,opt,name=changeScore,proto3" json:"changeScore,omitempty"`
	RankScore   int32 `protobuf:"varint,3,opt,name=rankScore,proto3" json:"rankScore,omitempty"`
}

func (m *FightUserScoreNtf) Reset()                    { *m = FightUserScoreNtf{} }
func (m *FightUserScoreNtf) String() string            { return proto.CompactTextString(m) }
func (*FightUserScoreNtf) ProtoMessage()               {}
func (*FightUserScoreNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{65} }

func (m *FightUserScoreNtf) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *FightUserScoreNtf) GetChangeScore() int32 {
	if m != nil {
		return m.ChangeScore
	}
	return 0
}

func (m *FightUserScoreNtf) GetRankScore() int32 {
	if m != nil {
		return m.RankScore
	}
	return 0
}

type GetFightBossInfosReq struct {
}

func (m *GetFightBossInfosReq) Reset()                    { *m = GetFightBossInfosReq{} }
func (m *GetFightBossInfosReq) String() string            { return proto.CompactTextString(m) }
func (*GetFightBossInfosReq) ProtoMessage()               {}
func (*GetFightBossInfosReq) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{66} }

type GetFightBossInfosAck struct {
	BossInfos []*FightBossInfoUnit `protobuf:"bytes,1,rep,name=bossInfos" json:"bossInfos,omitempty"`
}

func (m *GetFightBossInfosAck) Reset()                    { *m = GetFightBossInfosAck{} }
func (m *GetFightBossInfosAck) String() string            { return proto.CompactTextString(m) }
func (*GetFightBossInfosAck) ProtoMessage()               {}
func (*GetFightBossInfosAck) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{67} }

func (m *GetFightBossInfosAck) GetBossInfos() []*FightBossInfoUnit {
	if m != nil {
		return m.BossInfos
	}
	return nil
}

type FightBossInfoUnit struct {
	ObjId     int32  `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	MonsterId int32  `protobuf:"varint,2,opt,name=monsterId,proto3" json:"monsterId,omitempty"`
	Point     *Point `protobuf:"bytes,3,opt,name=point" json:"point,omitempty"`
	ReliveCD  int32  `protobuf:"varint,4,opt,name=reliveCD,proto3" json:"reliveCD,omitempty"`
	Hp        int64  `protobuf:"varint,5,opt,name=hp,proto3" json:"hp,omitempty"`
}

func (m *FightBossInfoUnit) Reset()                    { *m = FightBossInfoUnit{} }
func (m *FightBossInfoUnit) String() string            { return proto.CompactTextString(m) }
func (*FightBossInfoUnit) ProtoMessage()               {}
func (*FightBossInfoUnit) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{68} }

func (m *FightBossInfoUnit) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *FightBossInfoUnit) GetMonsterId() int32 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *FightBossInfoUnit) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *FightBossInfoUnit) GetReliveCD() int32 {
	if m != nil {
		return m.ReliveCD
	}
	return 0
}

func (m *FightBossInfoUnit) GetHp() int64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

type BossReliveNtf struct {
	ObjId    int32 `protobuf:"varint,1,opt,name=objId,proto3" json:"objId,omitempty"`
	ReliveCd int32 `protobuf:"varint,2,opt,name=reliveCd,proto3" json:"reliveCd,omitempty"`
}

func (m *BossReliveNtf) Reset()                    { *m = BossReliveNtf{} }
func (m *BossReliveNtf) String() string            { return proto.CompactTextString(m) }
func (*BossReliveNtf) ProtoMessage()               {}
func (*BossReliveNtf) Descriptor() ([]byte, []int) { return fileDescriptorScene, []int{69} }

func (m *BossReliveNtf) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *BossReliveNtf) GetReliveCd() int32 {
	if m != nil {
		return m.ReliveCd
	}
	return 0
}

func init() {
	proto.RegisterType((*Point)(nil), "pb.Point")
	proto.RegisterType((*SceneObj)(nil), "pb.SceneObj")
	proto.RegisterType((*SceneUser)(nil), "pb.SceneUser")
	proto.RegisterType((*SceneMonster)(nil), "pb.SceneMonster")
	proto.RegisterType((*ScenePet)(nil), "pb.ScenePet")
	proto.RegisterType((*SceneCollection)(nil), "pb.SceneCollection")
	proto.RegisterType((*SceneFit)(nil), "pb.SceneFit")
	proto.RegisterType((*SceneSummon)(nil), "pb.SceneSummon")
	proto.RegisterType((*SceneItem)(nil), "pb.SceneItem")
	proto.RegisterType((*SceneBuff)(nil), "pb.SceneBuff")
	proto.RegisterType((*SceneEnterNtf)(nil), "pb.SceneEnterNtf")
	proto.RegisterType((*SceneEnterOverNtf)(nil), "pb.SceneEnterOverNtf")
	proto.RegisterType((*SceneLeaveNtf)(nil), "pb.SceneLeaveNtf")
	proto.RegisterType((*SceneDieNtf)(nil), "pb.SceneDieNtf")
	proto.RegisterType((*SceneMoveRpt)(nil), "pb.SceneMoveRpt")
	proto.RegisterType((*SceneMoveNtf)(nil), "pb.SceneMoveNtf")
	proto.RegisterType((*SceneUserReliveNtf)(nil), "pb.SceneUserReliveNtf")
	proto.RegisterType((*SceneUserUpdateNtf)(nil), "pb.SceneUserUpdateNtf")
	proto.RegisterType((*SceneUserElfUpdateNtf)(nil), "pb.SceneUserElfUpdateNtf")
	proto.RegisterType((*AttackRpt)(nil), "pb.AttackRpt")
	proto.RegisterType((*AttackEffectNtf)(nil), "pb.AttackEffectNtf")
	proto.RegisterType((*HurtEffect)(nil), "pb.HurtEffect")
	proto.RegisterType((*SceneObjHpNtf)(nil), "pb.SceneObjHpNtf")
	proto.RegisterType((*SceneObjMpNtf)(nil), "pb.SceneObjMpNtf")
	proto.RegisterType((*FightHurtRankReq)(nil), "pb.FightHurtRankReq")
	proto.RegisterType((*FightHurtRankAck)(nil), "pb.FightHurtRankAck")
	proto.RegisterType((*FightRankUnit)(nil), "pb.FightRankUnit")
	proto.RegisterType((*GetBossOwnerChangReq)(nil), "pb.GetBossOwnerChangReq")
	proto.RegisterType((*BossOwnerChangNtf)(nil), "pb.BossOwnerChangNtf")
	proto.RegisterType((*BuffChangeNtf)(nil), "pb.BuffChangeNtf")
	proto.RegisterType((*BuffDelNtf)(nil), "pb.BuffDelNtf")
	proto.RegisterType((*BuffInfo)(nil), "pb.BuffInfo")
	proto.RegisterType((*DelBuffInfo)(nil), "pb.DelBuffInfo")
	proto.RegisterType((*BuffPropChangeNtf)(nil), "pb.BuffPropChangeNtf")
	proto.RegisterType((*BuffHpChangeNtf)(nil), "pb.BuffHpChangeNtf")
	proto.RegisterType((*BuffHpChangeInfo)(nil), "pb.BuffHpChangeInfo")
	proto.RegisterType((*MainCityEnterRpt)(nil), "pb.MainCityEnterRpt")
	proto.RegisterType((*MainCityMoveRpt)(nil), "pb.MainCityMoveRpt")
	proto.RegisterType((*MainCityLeaveRpt)(nil), "pb.MainCityLeaveRpt")
	proto.RegisterType((*MainCityUpdateRpt)(nil), "pb.MainCityUpdateRpt")
	proto.RegisterType((*FightEnterOkReq)(nil), "pb.FightEnterOkReq")
	proto.RegisterType((*FightStartCountDownNtf)(nil), "pb.FightStartCountDownNtf")
	proto.RegisterType((*FightStartCountDownOkReq)(nil), "pb.FightStartCountDownOkReq")
	proto.RegisterType((*FightStartNtf)(nil), "pb.FightStartNtf")
	proto.RegisterType((*CollectionStatusChangeNtf)(nil), "pb.CollectionStatusChangeNtf")
	proto.RegisterType((*FightTeamChangeNtf)(nil), "pb.FightTeamChangeNtf")
	proto.RegisterType((*FightUserChangeToHelperNtf)(nil), "pb.FightUserChangeToHelperNtf")
	proto.RegisterType((*FightNpcEventReq)(nil), "pb.FightNpcEventReq")
	proto.RegisterType((*ExpStageKillInfoNtf)(nil), "pb.ExpStageKillInfoNtf")
	proto.RegisterType((*PaodianTopUserReq)(nil), "pb.PaodianTopUserReq")
	proto.RegisterType((*PaodianTopUserNtf)(nil), "pb.PaodianTopUserNtf")
	proto.RegisterType((*PaoDianUserNumNtf)(nil), "pb.PaoDianUserNumNtf")
	proto.RegisterType((*PaodianFightEnd)(nil), "pb.PaodianFightEnd")
	proto.RegisterType((*GetShabakeScoresReq)(nil), "pb.GetShabakeScoresReq")
	proto.RegisterType((*ShabakeScoreRankNtf)(nil), "pb.ShabakeScoreRankNtf")
	proto.RegisterType((*ShabakeUserScore)(nil), "pb.ShabakeUserScore")
	proto.RegisterType((*ShabakeGuildScore)(nil), "pb.ShabakeGuildScore")
	proto.RegisterType((*ShabakeOccupiedNtf)(nil), "pb.ShabakeOccupiedNtf")
	proto.RegisterType((*GetShabakeCrossScoresReq)(nil), "pb.GetShabakeCrossScoresReq")
	proto.RegisterType((*ShabakeCrossScoreRankNtf)(nil), "pb.ShabakeCrossScoreRankNtf")
	proto.RegisterType((*ShabakeCrossServerScore)(nil), "pb.ShabakeCrossServerScore")
	proto.RegisterType((*ShabakeCrossOccupiedNtf)(nil), "pb.ShabakeCrossOccupiedNtf")
	proto.RegisterType((*GuardPillarFightNtf)(nil), "pb.GuardPillarFightNtf")
	proto.RegisterType((*MagicTowerBossInfo)(nil), "pb.MagicTowerBossInfo")
	proto.RegisterType((*MagicTowerFightNtf)(nil), "pb.MagicTowerFightNtf")
	proto.RegisterType((*FightUserScoreNtf)(nil), "pb.FightUserScoreNtf")
	proto.RegisterType((*GetFightBossInfosReq)(nil), "pb.GetFightBossInfosReq")
	proto.RegisterType((*GetFightBossInfosAck)(nil), "pb.GetFightBossInfosAck")
	proto.RegisterType((*FightBossInfoUnit)(nil), "pb.FightBossInfoUnit")
	proto.RegisterType((*BossReliveNtf)(nil), "pb.BossReliveNtf")
}
func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Y))
	}
	return i, nil
}

func (m *SceneObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjType))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n1, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TeamId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.HpMax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, msg := range m.Buffs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Mp != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Mp))
	}
	if m.MpMax != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MpMax))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerId))
	}
	if m.User != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.User.Size()))
		n2, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Monster != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Monster.Size()))
		n3, err := m.Monster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Item != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Item.Size()))
		n4, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Pet != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Pet.Size()))
		n5, err := m.Pet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Collection != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Collection.Size()))
		n6, err := m.Collection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Fit != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Fit.Size()))
		n7, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Summon != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Summon.Size()))
		n8, err := m.Summon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Buff != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Buff.Size()))
		n9, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *SceneUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Display != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Display.Size()))
		n10, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Vip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Vip))
	}
	if m.Lvl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Lvl))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Sex))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Combat))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Job != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Job))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HeroIndex))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.ElfLv != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ElfLv))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Usersex != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Usersex))
	}
	if m.Userjob != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Userjob))
	}
	if m.UserHpTotal != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserHpTotal))
	}
	if m.ToHelpUserId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ToHelpUserId))
	}
	return i, nil
}

func (m *SceneMonster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMonster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	if m.OwnerUseId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerUseId))
	}
	if len(m.OwnerUserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.OwnerUserName)))
		i += copy(dAtA[i:], m.OwnerUserName)
	}
	return i, nil
}

func (m *ScenePet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScenePet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *SceneCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Id))
	}
	if m.CollectionObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CollectionObjId))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *SceneFit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneFit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.FitId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FitId))
	}
	if m.FashionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FashionLv))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.FitLv != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FitLv))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.LeaderJob != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.LeaderJob))
	}
	if m.LeaderSex != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.LeaderSex))
	}
	return i, nil
}

func (m *SceneSummon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneSummon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.SummonId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SummonId))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *SceneItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ItemNum))
	}
	if m.Owner != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Owner))
	}
	if m.OwnerProtectedTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerProtectedTime))
	}
	if m.DisappearTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.DisappearTime))
	}
	return i, nil
}

func (m *SceneBuff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneBuff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuffId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.BuffId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SceneEnterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneEnterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StageId))
	}
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EnterType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EnterType))
	}
	if m.IsTower {
		dAtA[i] = 0x20
		i++
		if m.IsTower {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SceneEnterOverNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneEnterOverNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SceneLeaveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneLeaveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		dAtA12 := make([]byte, len(m.ObjIds)*10)
		var j11 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.LeaveType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.LeaveType))
	}
	if m.IsTower {
		dAtA[i] = 0x20
		i++
		if m.IsTower {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SceneDieNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneDieNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if len(m.DropItems) > 0 {
		for _, msg := range m.DropItems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SceneMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n13, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveType))
	}
	return i, nil
}

func (m *SceneMoveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneMoveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n14, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Force {
		dAtA[i] = 0x18
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveType))
	}
	return i, nil
}

func (m *SceneUserReliveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUserReliveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n15, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ReliveType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ReliveType))
	}
	return i, nil
}

func (m *SceneUserUpdateNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUserUpdateNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.ObjUser != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjUser.Size()))
		n16, err := m.ObjUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SceneUserElfUpdateNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneUserElfUpdateNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.ElfLv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ElfLv))
	}
	return i, nil
}

func (m *AttackRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		dAtA18 := make([]byte, len(m.ObjIds)*10)
		var j17 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.Point != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n19, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.SkillLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillLevel))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.IsElf {
		dAtA[i] = 0x38
		i++
		if m.IsElf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AttackEffectNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackEffectNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.AttackerId))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	if m.Point != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n20, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Hurts) > 0 {
		for _, msg := range m.Hurts {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MoveToPoint != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveToPoint.Size()))
		n21, err := m.MoveToPoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.SkillLv != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillLv))
	}
	if m.Err != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Err))
	}
	if m.SkillStartT != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillStartT))
	}
	if m.SkillStopT != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SkillStopT))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.MpNow != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MpNow))
	}
	if m.IsElf {
		dAtA[i] = 0x68
		i++
		if m.IsElf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AttackerName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.AttackerName)))
		i += copy(dAtA[i:], m.AttackerName)
	}
	if m.HpNow != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HpNow))
	}
	return i, nil
}

func (m *HurtEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HurtEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.ChangHp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangHp))
	}
	if m.IsDeath {
		dAtA[i] = 0x20
		i++
		if m.IsDeath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDodge {
		dAtA[i] = 0x28
		i++
		if m.IsDodge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HurtType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.HurtType))
	}
	if m.Hurt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hurt))
	}
	if m.Deathblow != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Deathblow))
	}
	if m.CutHurt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CutHurt))
	}
	if m.MoveToPoint != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MoveToPoint.Size()))
		n22, err := m.MoveToPoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.UnBlock != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UnBlock))
	}
	if m.Reflex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Reflex))
	}
	if m.ReliveSelf {
		dAtA[i] = 0x68
		i++
		if m.ReliveSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsWuDi {
		dAtA[i] = 0x70
		i++
		if m.IsWuDi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KillHurt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.KillHurt))
	}
	return i, nil
}

func (m *SceneObjHpNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObjHpNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	if m.ChangeHp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalHp))
	}
	if m.KillerId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.KillerId))
	}
	if len(m.KillerName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.KillerName)))
		i += copy(dAtA[i:], m.KillerName)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.UserHpTotal != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserHpTotal))
	}
	return i, nil
}

func (m *SceneObjMpNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneObjMpNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.Mp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Mp))
	}
	if m.ChangeMp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeMp))
	}
	if m.TotalMp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalMp))
	}
	return i, nil
}

func (m *FightHurtRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightHurtRankReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightHurtRankAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightHurtRankAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		for _, msg := range m.Ranks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MyRank != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MyRank.Size()))
		n23, err := m.MyRank.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *FightRankUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightRankUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Rank))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetBossOwnerChangReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBossOwnerChangReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BossOwnerChangNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossOwnerChangNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	return i, nil
}

func (m *BuffChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Buff != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Buff.Size()))
		n24, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.DelBuffInfos) > 0 {
		for _, msg := range m.DelBuffInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffDelNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffDelNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DelBuffInfos) > 0 {
		for _, msg := range m.DelBuffInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.SourceObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SourceObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	if m.BuffId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.BuffId))
	}
	if m.TotalTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalTime))
	}
	if m.OwnerUserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerUserId))
	}
	if m.SourceUserId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.SourceUserId))
	}
	return i, nil
}

func (m *DelBuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelBuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	return i, nil
}

func (m *BuffPropChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffPropChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.PropId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.PropId))
	}
	if m.Total != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func (m *BuffHpChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, msg := range m.BuffHpChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffHpChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffHpChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Idx))
	}
	if m.Death != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Death))
	}
	if m.ChangeHp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TotalHp))
	}
	if m.KillerId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.KillerId))
	}
	if len(m.KillerName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.KillerName)))
		i += copy(dAtA[i:], m.KillerName)
	}
	return i, nil
}

func (m *MainCityEnterRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityEnterRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n25, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *MainCityMoveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityMoveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Y))
	}
	if m.Dir != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Dir))
	}
	return i, nil
}

func (m *MainCityLeaveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityLeaveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *MainCityUpdateRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainCityUpdateRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Obj != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Obj.Size()))
		n26, err := m.Obj.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *FightEnterOkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightEnterOkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightStartCountDownNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartCountDownNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerTime))
	}
	if m.CountDownTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.CountDownTime))
	}
	return i, nil
}

func (m *FightStartCountDownOkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartCountDownOkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FightStartNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightStartNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CollectionStatusChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionStatusChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.UserObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserObjId))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *FightTeamChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightTeamChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserTeamIndex) > 0 {
		for k, _ := range m.UserTeamIndex {
			dAtA[i] = 0xa
			i++
			v := m.UserTeamIndex[k]
			mapSize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			i = encodeVarintScene(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintScene(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintScene(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *FightUserChangeToHelperNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightUserChangeToHelperNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if m.TeamIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.TeamIndex))
	}
	return i, nil
}

func (m *FightNpcEventReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightNpcEventReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NpcId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.NpcId))
	}
	return i, nil
}

func (m *ExpStageKillInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStageKillInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KillMonsterNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.KillMonsterNum))
	}
	if m.GetExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GetExp))
	}
	return i, nil
}

func (m *PaodianTopUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianTopUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PaodianTopUserNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianTopUserNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA28 := make([]byte, len(m.UserIds)*10)
		var j27 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	return i, nil
}

func (m *PaoDianUserNumNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaoDianUserNumNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserNums) > 0 {
		for k, _ := range m.UserNums {
			dAtA[i] = 0xa
			i++
			v := m.UserNums[k]
			mapSize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			i = encodeVarintScene(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintScene(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintScene(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PaodianFightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianFightEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *GetShabakeScoresReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShabakeScoresReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShabakeScoreRankNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeScoreRankNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, msg := range m.UserScores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildScores) > 0 {
		for _, msg := range m.GuildScores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeUserScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeUserScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Rank))
	}
	return i, nil
}

func (m *ShabakeGuildScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeGuildScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuildId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerId))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	return i, nil
}

func (m *ShabakeOccupiedNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeOccupiedNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOccupy {
		dAtA[i] = 0x8
		i++
		if m.IsOccupy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	if m.FightStatus != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FightStatus))
	}
	return i, nil
}

func (m *GetShabakeCrossScoresReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShabakeCrossScoresReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ShabakeCrossScoreRankNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeCrossScoreRankNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerScores) > 0 {
		for _, msg := range m.ServerScores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildScores) > 0 {
		for _, msg := range m.GuildScores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeCrossServerScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeCrossServerScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerId))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ShabakeCrossOccupiedNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeCrossOccupiedNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOccupy {
		dAtA[i] = 0x8
		i++
		if m.IsOccupy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.EndTime))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ServerId))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	return i, nil
}

func (m *GuardPillarFightNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuardPillarFightNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Rank.Size()))
		n29, err := m.Rank.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Wave != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Wave))
	}
	if m.NextTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.NextTime))
	}
	if m.MonsterTotal != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MonsterTotal))
	}
	if m.Monsterless != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Monsterless))
	}
	if m.FightEndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.FightEndTime))
	}
	return i, nil
}

func (m *MagicTowerBossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MagicTowerBossInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BossName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.BossName)))
		i += copy(dAtA[i:], m.BossName)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Layer))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Status))
	}
	if m.RefreshTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.RefreshTime))
	}
	if m.MonsterId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MonsterId))
	}
	if m.OwnerUseId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.OwnerUseId))
	}
	if len(m.OwnerName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScene(dAtA, i, uint64(len(m.OwnerName)))
		i += copy(dAtA[i:], m.OwnerName)
	}
	if m.MonsterObjId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MonsterObjId))
	}
	return i, nil
}

func (m *MagicTowerFightNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MagicTowerFightNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, msg := range m.UserScores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BossInfos) > 0 {
		for _, msg := range m.BossInfos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FightUserScoreNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightUserScoreNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Score))
	}
	if m.ChangeScore != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ChangeScore))
	}
	if m.RankScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.RankScore))
	}
	return i, nil
}

func (m *GetFightBossInfosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFightBossInfosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetFightBossInfosAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFightBossInfosAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BossInfos) > 0 {
		for _, msg := range m.BossInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintScene(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FightBossInfoUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightBossInfoUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.MonsterId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.MonsterId))
	}
	if m.Point != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Point.Size()))
		n30, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.ReliveCD != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ReliveCD))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.Hp))
	}
	return i, nil
}

func (m *BossReliveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossReliveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ObjId))
	}
	if m.ReliveCd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScene(dAtA, i, uint64(m.ReliveCd))
	}
	return i, nil
}

func encodeVarintScene(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovScene(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene(uint64(m.Y))
	}
	return n
}

func (m *SceneObj) Size() (n int) {
	var l int
	_ = l
	if m.ObjType != 0 {
		n += 1 + sovScene(uint64(m.ObjType))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.TeamId != 0 {
		n += 1 + sovScene(uint64(m.TeamId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.HpMax != 0 {
		n += 1 + sovScene(uint64(m.HpMax))
	}
	if len(m.Buffs) > 0 {
		for _, e := range m.Buffs {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.Mp != 0 {
		n += 1 + sovScene(uint64(m.Mp))
	}
	if m.MpMax != 0 {
		n += 1 + sovScene(uint64(m.MpMax))
	}
	if m.ServerId != 0 {
		n += 1 + sovScene(uint64(m.ServerId))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Monster != nil {
		l = m.Monster.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Pet != nil {
		l = m.Pet.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Collection != nil {
		l = m.Collection.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Summon != nil {
		l = m.Summon.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 2 + l + sovScene(uint64(l))
	}
	return n
}

func (m *SceneUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovScene(uint64(m.Vip))
	}
	if m.Lvl != 0 {
		n += 1 + sovScene(uint64(m.Lvl))
	}
	if m.Sex != 0 {
		n += 1 + sovScene(uint64(m.Sex))
	}
	if m.Combat != 0 {
		n += 1 + sovScene(uint64(m.Combat))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Job != 0 {
		n += 1 + sovScene(uint64(m.Job))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovScene(uint64(m.HeroIndex))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.ElfLv != 0 {
		n += 1 + sovScene(uint64(m.ElfLv))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Usersex != 0 {
		n += 2 + sovScene(uint64(m.Usersex))
	}
	if m.Userjob != 0 {
		n += 2 + sovScene(uint64(m.Userjob))
	}
	if m.UserHpTotal != 0 {
		n += 2 + sovScene(uint64(m.UserHpTotal))
	}
	if m.ToHelpUserId != 0 {
		n += 2 + sovScene(uint64(m.ToHelpUserId))
	}
	return n
}

func (m *SceneMonster) Size() (n int) {
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	if m.OwnerUseId != 0 {
		n += 1 + sovScene(uint64(m.OwnerUseId))
	}
	l = len(m.OwnerUserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *ScenePet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	return n
}

func (m *SceneCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScene(uint64(m.Id))
	}
	if m.CollectionObjId != 0 {
		n += 1 + sovScene(uint64(m.CollectionObjId))
	}
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	return n
}

func (m *SceneFit) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.FitId != 0 {
		n += 1 + sovScene(uint64(m.FitId))
	}
	if m.FashionId != 0 {
		n += 1 + sovScene(uint64(m.FashionId))
	}
	if m.FashionLv != 0 {
		n += 1 + sovScene(uint64(m.FashionLv))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.FitLv != 0 {
		n += 1 + sovScene(uint64(m.FitLv))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.LeaderJob != 0 {
		n += 1 + sovScene(uint64(m.LeaderJob))
	}
	if m.LeaderSex != 0 {
		n += 1 + sovScene(uint64(m.LeaderSex))
	}
	return n
}

func (m *SceneSummon) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.SummonId != 0 {
		n += 1 + sovScene(uint64(m.SummonId))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	return n
}

func (m *SceneItem) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovScene(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovScene(uint64(m.ItemNum))
	}
	if m.Owner != 0 {
		n += 1 + sovScene(uint64(m.Owner))
	}
	if m.OwnerProtectedTime != 0 {
		n += 1 + sovScene(uint64(m.OwnerProtectedTime))
	}
	if m.DisappearTime != 0 {
		n += 1 + sovScene(uint64(m.DisappearTime))
	}
	return n
}

func (m *SceneBuff) Size() (n int) {
	var l int
	_ = l
	if m.BuffId != 0 {
		n += 1 + sovScene(uint64(m.BuffId))
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	return n
}

func (m *SceneEnterNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovScene(uint64(m.StageId))
	}
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.EnterType != 0 {
		n += 1 + sovScene(uint64(m.EnterType))
	}
	if m.IsTower {
		n += 2
	}
	return n
}

func (m *SceneEnterOverNtf) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SceneLeaveNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	if m.LeaveType != 0 {
		n += 1 + sovScene(uint64(m.LeaveType))
	}
	if m.IsTower {
		n += 2
	}
	return n
}

func (m *SceneDieNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if len(m.DropItems) > 0 {
		for _, e := range m.DropItems {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *SceneMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.MoveType != 0 {
		n += 1 + sovScene(uint64(m.MoveType))
	}
	return n
}

func (m *SceneMoveNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.MoveType != 0 {
		n += 1 + sovScene(uint64(m.MoveType))
	}
	return n
}

func (m *SceneUserReliveNtf) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.ReliveType != 0 {
		n += 1 + sovScene(uint64(m.ReliveType))
	}
	return n
}

func (m *SceneUserUpdateNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.ObjUser != nil {
		l = m.ObjUser.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *SceneUserElfUpdateNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.ElfLv != 0 {
		n += 1 + sovScene(uint64(m.ElfLv))
	}
	return n
}

func (m *AttackRpt) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene(uint64(m.SkillId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.SkillLevel != 0 {
		n += 1 + sovScene(uint64(m.SkillLevel))
	}
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.IsElf {
		n += 2
	}
	return n
}

func (m *AttackEffectNtf) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovScene(uint64(m.SkillId))
	}
	if m.AttackerId != 0 {
		n += 1 + sovScene(uint64(m.AttackerId))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if len(m.Hurts) > 0 {
		for _, e := range m.Hurts {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.MoveToPoint != nil {
		l = m.MoveToPoint.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.SkillLv != 0 {
		n += 1 + sovScene(uint64(m.SkillLv))
	}
	if m.Err != 0 {
		n += 1 + sovScene(uint64(m.Err))
	}
	if m.SkillStartT != 0 {
		n += 1 + sovScene(uint64(m.SkillStartT))
	}
	if m.SkillStopT != 0 {
		n += 1 + sovScene(uint64(m.SkillStopT))
	}
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.MpNow != 0 {
		n += 1 + sovScene(uint64(m.MpNow))
	}
	if m.IsElf {
		n += 2
	}
	l = len(m.AttackerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.HpNow != 0 {
		n += 1 + sovScene(uint64(m.HpNow))
	}
	return n
}

func (m *HurtEffect) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.ChangHp != 0 {
		n += 1 + sovScene(uint64(m.ChangHp))
	}
	if m.IsDeath {
		n += 2
	}
	if m.IsDodge {
		n += 2
	}
	if m.HurtType != 0 {
		n += 1 + sovScene(uint64(m.HurtType))
	}
	if m.Hurt != 0 {
		n += 1 + sovScene(uint64(m.Hurt))
	}
	if m.Deathblow != 0 {
		n += 1 + sovScene(uint64(m.Deathblow))
	}
	if m.CutHurt != 0 {
		n += 1 + sovScene(uint64(m.CutHurt))
	}
	if m.MoveToPoint != nil {
		l = m.MoveToPoint.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.UnBlock != 0 {
		n += 1 + sovScene(uint64(m.UnBlock))
	}
	if m.Reflex != 0 {
		n += 1 + sovScene(uint64(m.Reflex))
	}
	if m.ReliveSelf {
		n += 2
	}
	if m.IsWuDi {
		n += 2
	}
	if m.KillHurt != 0 {
		n += 1 + sovScene(uint64(m.KillHurt))
	}
	return n
}

func (m *SceneObjHpNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	if m.ChangeHp != 0 {
		n += 1 + sovScene(uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		n += 1 + sovScene(uint64(m.TotalHp))
	}
	if m.KillerId != 0 {
		n += 1 + sovScene(uint64(m.KillerId))
	}
	l = len(m.KillerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.UserHpTotal != 0 {
		n += 1 + sovScene(uint64(m.UserHpTotal))
	}
	return n
}

func (m *SceneObjMpNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.Mp != 0 {
		n += 1 + sovScene(uint64(m.Mp))
	}
	if m.ChangeMp != 0 {
		n += 1 + sovScene(uint64(m.ChangeMp))
	}
	if m.TotalMp != 0 {
		n += 1 + sovScene(uint64(m.TotalMp))
	}
	return n
}

func (m *FightHurtRankReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightHurtRankAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Ranks) > 0 {
		for _, e := range m.Ranks {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if m.MyRank != nil {
		l = m.MyRank.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *FightRankUnit) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovScene(uint64(m.Rank))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	return n
}

func (m *GetBossOwnerChangReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BossOwnerChangNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *BuffChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if len(m.DelBuffInfos) > 0 {
		for _, e := range m.DelBuffInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffDelNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.DelBuffInfos) > 0 {
		for _, e := range m.DelBuffInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.SourceObjId != 0 {
		n += 1 + sovScene(uint64(m.SourceObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	if m.BuffId != 0 {
		n += 1 + sovScene(uint64(m.BuffId))
	}
	if m.TotalTime != 0 {
		n += 1 + sovScene(uint64(m.TotalTime))
	}
	if m.OwnerUserId != 0 {
		n += 1 + sovScene(uint64(m.OwnerUserId))
	}
	if m.SourceUserId != 0 {
		n += 1 + sovScene(uint64(m.SourceUserId))
	}
	return n
}

func (m *DelBuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	return n
}

func (m *BuffPropChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.PropId != 0 {
		n += 1 + sovScene(uint64(m.PropId))
	}
	if m.Total != 0 {
		n += 1 + sovScene(uint64(m.Total))
	}
	return n
}

func (m *BuffHpChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.BuffHpChangeInfos) > 0 {
		for _, e := range m.BuffHpChangeInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *BuffHpChangeInfo) Size() (n int) {
	var l int
	_ = l
	if m.OwnerObjId != 0 {
		n += 1 + sovScene(uint64(m.OwnerObjId))
	}
	if m.Idx != 0 {
		n += 1 + sovScene(uint64(m.Idx))
	}
	if m.Death != 0 {
		n += 1 + sovScene(uint64(m.Death))
	}
	if m.ChangeHp != 0 {
		n += 1 + sovScene(uint64(m.ChangeHp))
	}
	if m.TotalHp != 0 {
		n += 1 + sovScene(uint64(m.TotalHp))
	}
	if m.KillerId != 0 {
		n += 1 + sovScene(uint64(m.KillerId))
	}
	l = len(m.KillerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *MainCityEnterRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *MainCityMoveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.X != 0 {
		n += 1 + sovScene(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovScene(uint64(m.Y))
	}
	if m.Dir != 0 {
		n += 1 + sovScene(uint64(m.Dir))
	}
	return n
}

func (m *MainCityLeaveRpt) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	return n
}

func (m *MainCityUpdateRpt) Size() (n int) {
	var l int
	_ = l
	if m.Obj != nil {
		l = m.Obj.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *FightEnterOkReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightStartCountDownNtf) Size() (n int) {
	var l int
	_ = l
	if m.ServerTime != 0 {
		n += 1 + sovScene(uint64(m.ServerTime))
	}
	if m.CountDownTime != 0 {
		n += 1 + sovScene(uint64(m.CountDownTime))
	}
	return n
}

func (m *FightStartCountDownOkReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FightStartNtf) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CollectionStatusChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.UserObjId != 0 {
		n += 1 + sovScene(uint64(m.UserObjId))
	}
	if m.StartTime != 0 {
		n += 1 + sovScene(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	return n
}

func (m *FightTeamChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserTeamIndex) > 0 {
		for k, v := range m.UserTeamIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FightUserChangeToHelperNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	if m.TeamIndex != 0 {
		n += 1 + sovScene(uint64(m.TeamIndex))
	}
	return n
}

func (m *FightNpcEventReq) Size() (n int) {
	var l int
	_ = l
	if m.NpcId != 0 {
		n += 1 + sovScene(uint64(m.NpcId))
	}
	return n
}

func (m *ExpStageKillInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.KillMonsterNum != 0 {
		n += 1 + sovScene(uint64(m.KillMonsterNum))
	}
	if m.GetExp != 0 {
		n += 1 + sovScene(uint64(m.GetExp))
	}
	return n
}

func (m *PaodianTopUserReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PaodianTopUserNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovScene(uint64(e))
		}
		n += 1 + sovScene(uint64(l)) + l
	}
	return n
}

func (m *PaoDianUserNumNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserNums) > 0 {
		for k, v := range m.UserNums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovScene(uint64(k)) + 1 + sovScene(uint64(v))
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PaodianFightEnd) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovScene(uint64(m.StageId))
	}
	return n
}

func (m *GetShabakeScoresReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShabakeScoreRankNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, e := range m.UserScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if len(m.GuildScores) > 0 {
		for _, e := range m.GuildScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *ShabakeUserScore) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	if m.Rank != 0 {
		n += 1 + sovScene(uint64(m.Rank))
	}
	return n
}

func (m *ShabakeGuildScore) Size() (n int) {
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	if m.ServerId != 0 {
		n += 1 + sovScene(uint64(m.ServerId))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *ShabakeOccupiedNtf) Size() (n int) {
	var l int
	_ = l
	if m.IsOccupy {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovScene(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	if m.FightStatus != 0 {
		n += 1 + sovScene(uint64(m.FightStatus))
	}
	return n
}

func (m *GetShabakeCrossScoresReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ShabakeCrossScoreRankNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ServerScores) > 0 {
		for _, e := range m.ServerScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if len(m.GuildScores) > 0 {
		for _, e := range m.GuildScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *ShabakeCrossServerScore) Size() (n int) {
	var l int
	_ = l
	if m.ServerId != 0 {
		n += 1 + sovScene(uint64(m.ServerId))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	return n
}

func (m *ShabakeCrossOccupiedNtf) Size() (n int) {
	var l int
	_ = l
	if m.IsOccupy {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovScene(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovScene(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovScene(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovScene(uint64(m.EndTime))
	}
	if m.ServerId != 0 {
		n += 1 + sovScene(uint64(m.ServerId))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	return n
}

func (m *GuardPillarFightNtf) Size() (n int) {
	var l int
	_ = l
	if m.Rank != nil {
		l = m.Rank.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Wave != 0 {
		n += 1 + sovScene(uint64(m.Wave))
	}
	if m.NextTime != 0 {
		n += 1 + sovScene(uint64(m.NextTime))
	}
	if m.MonsterTotal != 0 {
		n += 1 + sovScene(uint64(m.MonsterTotal))
	}
	if m.Monsterless != 0 {
		n += 1 + sovScene(uint64(m.Monsterless))
	}
	if m.FightEndTime != 0 {
		n += 1 + sovScene(uint64(m.FightEndTime))
	}
	return n
}

func (m *MagicTowerBossInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.BossName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovScene(uint64(m.Layer))
	}
	if m.Status != 0 {
		n += 1 + sovScene(uint64(m.Status))
	}
	if m.RefreshTime != 0 {
		n += 1 + sovScene(uint64(m.RefreshTime))
	}
	if m.MonsterId != 0 {
		n += 1 + sovScene(uint64(m.MonsterId))
	}
	if m.OwnerUseId != 0 {
		n += 1 + sovScene(uint64(m.OwnerUseId))
	}
	l = len(m.OwnerName)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.MonsterObjId != 0 {
		n += 1 + sovScene(uint64(m.MonsterObjId))
	}
	return n
}

func (m *MagicTowerFightNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserScores) > 0 {
		for _, e := range m.UserScores {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	if len(m.BossInfos) > 0 {
		for _, e := range m.BossInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *FightUserScoreNtf) Size() (n int) {
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovScene(uint64(m.Score))
	}
	if m.ChangeScore != 0 {
		n += 1 + sovScene(uint64(m.ChangeScore))
	}
	if m.RankScore != 0 {
		n += 1 + sovScene(uint64(m.RankScore))
	}
	return n
}

func (m *GetFightBossInfosReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetFightBossInfosAck) Size() (n int) {
	var l int
	_ = l
	if len(m.BossInfos) > 0 {
		for _, e := range m.BossInfos {
			l = e.Size()
			n += 1 + l + sovScene(uint64(l))
		}
	}
	return n
}

func (m *FightBossInfoUnit) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.MonsterId != 0 {
		n += 1 + sovScene(uint64(m.MonsterId))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovScene(uint64(l))
	}
	if m.ReliveCD != 0 {
		n += 1 + sovScene(uint64(m.ReliveCD))
	}
	if m.Hp != 0 {
		n += 1 + sovScene(uint64(m.Hp))
	}
	return n
}

func (m *BossReliveNtf) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovScene(uint64(m.ObjId))
	}
	if m.ReliveCd != 0 {
		n += 1 + sovScene(uint64(m.ReliveCd))
	}
	return n
}

func sovScene(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozScene(x uint64) (n int) {
	return sovScene(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjType", wireType)
			}
			m.ObjType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpMax", wireType)
			}
			m.HpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HpMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffs = append(m.Buffs, &BuffInfo{})
			if err := m.Buffs[len(m.Buffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpMax", wireType)
			}
			m.MpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &SceneUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = &SceneMonster{}
			}
			if err := m.Monster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &SceneItem{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pet == nil {
				m.Pet = &ScenePet{}
			}
			if err := m.Pet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collection == nil {
				m.Collection = &SceneCollection{}
			}
			if err := m.Collection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &SceneFit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summon == nil {
				m.Summon = &SceneSummon{}
			}
			if err := m.Summon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &SceneBuff{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			m.Lvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElfLv", wireType)
			}
			m.ElfLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElfLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usersex", wireType)
			}
			m.Usersex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usersex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userjob", wireType)
			}
			m.Userjob = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userjob |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHpTotal", wireType)
			}
			m.UserHpTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserHpTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToHelpUserId", wireType)
			}
			m.ToHelpUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToHelpUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMonster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMonster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMonster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUseId", wireType)
			}
			m.OwnerUseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerUserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScenePet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScenePet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScenePet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionObjId", wireType)
			}
			m.CollectionObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneFit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneFit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneFit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitId", wireType)
			}
			m.FitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionId", wireType)
			}
			m.FashionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionLv", wireType)
			}
			m.FashionLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitLv", wireType)
			}
			m.FitLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderJob", wireType)
			}
			m.LeaderJob = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderJob |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderSex", wireType)
			}
			m.LeaderSex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderSex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneSummon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneSummon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneSummon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SummonId", wireType)
			}
			m.SummonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SummonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerProtectedTime", wireType)
			}
			m.OwnerProtectedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerProtectedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisappearTime", wireType)
			}
			m.DisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneBuff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneBuff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneBuff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneEnterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneEnterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneEnterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &SceneObj{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterType", wireType)
			}
			m.EnterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTower", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTower = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneEnterOverNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneEnterOverNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneEnterOverNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneLeaveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneLeaveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneLeaveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveType", wireType)
			}
			m.LeaveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTower", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTower = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneDieNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneDieNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneDieNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropItems = append(m.DropItems, &SceneObj{})
			if err := m.DropItems[len(m.DropItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneMoveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneMoveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneMoveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUserReliveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUserReliveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUserReliveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveType", wireType)
			}
			m.ReliveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUserUpdateNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUserUpdateNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUserUpdateNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjUser == nil {
				m.ObjUser = &SceneUser{}
			}
			if err := m.ObjUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneUserElfUpdateNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneUserElfUpdateNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneUserElfUpdateNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElfLv", wireType)
			}
			m.ElfLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElfLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevel", wireType)
			}
			m.SkillLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsElf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsElf = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackEffectNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackEffectNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackEffectNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hurts = append(m.Hurts, &HurtEffect{})
			if err := m.Hurts[len(m.Hurts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveToPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoveToPoint == nil {
				m.MoveToPoint = &Point{}
			}
			if err := m.MoveToPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLv", wireType)
			}
			m.SkillLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillStartT", wireType)
			}
			m.SkillStartT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillStartT |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillStopT", wireType)
			}
			m.SkillStopT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillStopT |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpNow", wireType)
			}
			m.MpNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpNow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsElf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsElf = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpNow", wireType)
			}
			m.HpNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HpNow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HurtEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HurtEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HurtEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangHp", wireType)
			}
			m.ChangHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeath = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDodge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDodge = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurt", wireType)
			}
			m.Hurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hurt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deathblow", wireType)
			}
			m.Deathblow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deathblow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutHurt", wireType)
			}
			m.CutHurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutHurt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveToPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoveToPoint == nil {
				m.MoveToPoint = &Point{}
			}
			if err := m.MoveToPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBlock", wireType)
			}
			m.UnBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnBlock |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reflex", wireType)
			}
			m.Reflex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reflex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReliveSelf = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWuDi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWuDi = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillHurt", wireType)
			}
			m.KillHurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillHurt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObjHpNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObjHpNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObjHpNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHp", wireType)
			}
			m.ChangeHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHp", wireType)
			}
			m.TotalHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerId", wireType)
			}
			m.KillerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHpTotal", wireType)
			}
			m.UserHpTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserHpTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneObjMpNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneObjMpNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneObjMpNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeMp", wireType)
			}
			m.ChangeMp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeMp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMp", wireType)
			}
			m.TotalMp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightHurtRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightHurtRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightHurtRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightHurtRankAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightHurtRankAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightHurtRankAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranks = append(m.Ranks, &FightRankUnit{})
			if err := m.Ranks[len(m.Ranks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MyRank == nil {
				m.MyRank = &FightRankUnit{}
			}
			if err := m.MyRank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightRankUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightRankUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightRankUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBossOwnerChangReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBossOwnerChangReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBossOwnerChangReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossOwnerChangNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossOwnerChangNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossOwnerChangNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &BuffInfo{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelBuffInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelBuffInfos = append(m.DelBuffInfos, &DelBuffInfo{})
			if err := m.DelBuffInfos[len(m.DelBuffInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffDelNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffDelNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffDelNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelBuffInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelBuffInfos = append(m.DelBuffInfos, &DelBuffInfo{})
			if err := m.DelBuffInfos[len(m.DelBuffInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceObjId", wireType)
			}
			m.SourceObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTime", wireType)
			}
			m.TotalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUserId", wireType)
			}
			m.OwnerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUserId", wireType)
			}
			m.SourceUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelBuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelBuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelBuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffPropChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffPropChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffPropChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffHpChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuffHpChangeInfos = append(m.BuffHpChangeInfos, &BuffHpChangeInfo{})
			if err := m.BuffHpChangeInfos[len(m.BuffHpChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffHpChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffHpChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffHpChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjId", wireType)
			}
			m.OwnerObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Death", wireType)
			}
			m.Death = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Death |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHp", wireType)
			}
			m.ChangeHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHp", wireType)
			}
			m.TotalHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerId", wireType)
			}
			m.KillerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityEnterRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityEnterRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityEnterRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityMoveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityMoveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityMoveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			m.Dir = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dir |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityLeaveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityLeaveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityLeaveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainCityUpdateRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainCityUpdateRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainCityUpdateRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obj == nil {
				m.Obj = &SceneObj{}
			}
			if err := m.Obj.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightEnterOkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightEnterOkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightEnterOkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartCountDownNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartCountDownNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartCountDownNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDownTime", wireType)
			}
			m.CountDownTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDownTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartCountDownOkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartCountDownOkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartCountDownOkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightStartNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightStartNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightStartNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionStatusChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionStatusChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionStatusChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObjId", wireType)
			}
			m.UserObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightTeamChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightTeamChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightTeamChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTeamIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserTeamIndex == nil {
				m.UserTeamIndex = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserTeamIndex[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightUserChangeToHelperNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightUserChangeToHelperNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightUserChangeToHelperNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamIndex", wireType)
			}
			m.TeamIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightNpcEventReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightNpcEventReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightNpcEventReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcId", wireType)
			}
			m.NpcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStageKillInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStageKillInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStageKillInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonsterNum", wireType)
			}
			m.KillMonsterNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillMonsterNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetExp", wireType)
			}
			m.GetExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianTopUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianTopUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianTopUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianTopUserNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianTopUserNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianTopUserNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScene
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaoDianUserNumNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaoDianUserNumNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaoDianUserNumNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserNums == nil {
				m.UserNums = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserNums[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianFightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianFightEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianFightEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShabakeScoresReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShabakeScoresReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShabakeScoresReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeScoreRankNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeScoreRankNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeScoreRankNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScores = append(m.UserScores, &ShabakeUserScore{})
			if err := m.UserScores[len(m.UserScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildScores = append(m.GuildScores, &ShabakeGuildScore{})
			if err := m.GuildScores[len(m.GuildScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeUserScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeUserScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeUserScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeGuildScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeGuildScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeGuildScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeOccupiedNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeOccupiedNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeOccupiedNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOccupy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOccupy = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightStatus", wireType)
			}
			m.FightStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShabakeCrossScoresReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShabakeCrossScoresReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShabakeCrossScoresReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeCrossScoreRankNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeCrossScoreRankNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeCrossScoreRankNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerScores = append(m.ServerScores, &ShabakeCrossServerScore{})
			if err := m.ServerScores[len(m.ServerScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildScores = append(m.GuildScores, &ShabakeGuildScore{})
			if err := m.GuildScores[len(m.GuildScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeCrossServerScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeCrossServerScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeCrossServerScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeCrossOccupiedNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeCrossOccupiedNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeCrossOccupiedNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOccupy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOccupy = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuardPillarFightNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuardPillarFightNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuardPillarFightNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rank == nil {
				m.Rank = &FightHurtRankAck{}
			}
			if err := m.Rank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wave", wireType)
			}
			m.Wave = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wave |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTime", wireType)
			}
			m.NextTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterTotal", wireType)
			}
			m.MonsterTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterTotal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monsterless", wireType)
			}
			m.Monsterless = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Monsterless |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightEndTime", wireType)
			}
			m.FightEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MagicTowerBossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MagicTowerBossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MagicTowerBossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BossName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTime", wireType)
			}
			m.RefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUseId", wireType)
			}
			m.OwnerUseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterObjId", wireType)
			}
			m.MonsterObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MagicTowerFightNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MagicTowerFightNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MagicTowerFightNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScores = append(m.UserScores, &ShabakeUserScore{})
			if err := m.UserScores[len(m.UserScores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BossInfos = append(m.BossInfos, &MagicTowerBossInfo{})
			if err := m.BossInfos[len(m.BossInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightUserScoreNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightUserScoreNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightUserScoreNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeScore", wireType)
			}
			m.ChangeScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFightBossInfosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFightBossInfosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFightBossInfosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFightBossInfosAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFightBossInfosAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFightBossInfosAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BossInfos = append(m.BossInfos, &FightBossInfoUnit{})
			if err := m.BossInfos[len(m.BossInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightBossInfoUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightBossInfoUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightBossInfoUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveCD", wireType)
			}
			m.ReliveCD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveCD |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossReliveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossReliveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossReliveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveCd", wireType)
			}
			m.ReliveCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScene(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScene
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthScene
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowScene
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipScene(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthScene = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScene   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("scene.proto", fileDescriptorScene) }

var fileDescriptorScene = []byte{
	// 2913 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x1a, 0x4d, 0x6f, 0x24, 0x57,
	0x91, 0x9e, 0x0f, 0x7b, 0xa6, 0xc6, 0x5e, 0xdb, 0xed, 0xdd, 0x4d, 0xc7, 0x59, 0x8c, 0xe9, 0x04,
	0xb2, 0x49, 0xc4, 0x1e, 0x76, 0x23, 0x81, 0xc8, 0x21, 0xec, 0xae, 0x9d, 0xb5, 0xc9, 0xfa, 0x43,
	0x6d, 0x5b, 0xb9, 0x81, 0x7a, 0x66, 0xde, 0xd8, 0x6d, 0xf7, 0x74, 0x77, 0xba, 0xdf, 0x8c, 0xed,
	0x03, 0x52, 0x24, 0x40, 0x9c, 0x41, 0x41, 0x42, 0x42, 0x9c, 0x11, 0xff, 0x81, 0x23, 0x48, 0x1c,
	0x38, 0x70, 0x04, 0x4e, 0x10, 0xfe, 0x03, 0x67, 0x54, 0xf5, 0x3e, 0xbb, 0xe7, 0xc3, 0xc9, 0x1e,
	0xb9, 0x75, 0x7d, 0xbc, 0x7a, 0xf5, 0xf5, 0xea, 0x55, 0xbd, 0x19, 0xe8, 0x14, 0x3d, 0x96, 0xb0,
	0x47, 0x59, 0x9e, 0xf2, 0xd4, 0xad, 0x65, 0xdd, 0x8d, 0xa5, 0x5e, 0x3a, 0x1c, 0xa6, 0x89, 0xc0,
	0xf8, 0x6f, 0x42, 0xf3, 0x28, 0x8d, 0x12, 0xee, 0x2e, 0x81, 0x73, 0xed, 0x39, 0x5b, 0xce, 0xc3,
	0x66, 0xe0, 0x5c, 0x23, 0x74, 0xe3, 0xd5, 0x04, 0x74, 0xe3, 0xff, 0xa9, 0x01, 0xad, 0x63, 0x14,
	0x73, 0xd8, 0xbd, 0x70, 0x3d, 0x58, 0x4c, 0xbb, 0x17, 0x27, 0x37, 0x19, 0x93, 0xec, 0x0a, 0x74,
	0xbf, 0x01, 0xcd, 0x0c, 0x65, 0xd1, 0xc2, 0xce, 0xe3, 0xf6, 0xa3, 0xac, 0xfb, 0x88, 0x84, 0x07,
	0x02, 0xef, 0xae, 0x42, 0xbd, 0x1f, 0xe5, 0x5e, 0x9d, 0x96, 0xe1, 0xa7, 0x7b, 0x17, 0x9a, 0x69,
	0xf7, 0x62, 0xaf, 0xef, 0x35, 0x08, 0x27, 0x00, 0xf7, 0x3e, 0x2c, 0x70, 0x16, 0x0e, 0xf7, 0xfa,
	0x5e, 0x93, 0xd0, 0x12, 0x72, 0xef, 0x40, 0xed, 0x3c, 0xf3, 0x16, 0xb7, 0x9c, 0x87, 0xf5, 0xa0,
	0x76, 0x9e, 0xe1, 0xea, 0xf3, 0x6c, 0x3f, 0xbc, 0xf6, 0x5a, 0x84, 0x12, 0x80, 0xeb, 0x43, 0xb3,
	0x3b, 0x1a, 0x0c, 0x0a, 0xaf, 0xbd, 0x55, 0x7f, 0xd8, 0x79, 0xbc, 0x84, 0x6a, 0x3c, 0x1b, 0x0d,
	0x06, 0x7b, 0xc9, 0x20, 0x0d, 0x04, 0x09, 0x25, 0x0d, 0x33, 0x0f, 0x84, 0xa4, 0x21, 0x49, 0x1a,
	0x92, 0xa4, 0x8e, 0x90, 0x44, 0x80, 0xbb, 0x01, 0xad, 0x82, 0xe5, 0x63, 0x96, 0xef, 0xf5, 0xbd,
	0x25, 0xd2, 0x44, 0xc3, 0xee, 0x37, 0xa1, 0x31, 0x2a, 0x58, 0xee, 0xdd, 0x23, 0x5b, 0x97, 0x71,
	0x13, 0x72, 0xd1, 0x69, 0xc1, 0xf2, 0x80, 0x48, 0xee, 0xbb, 0xb0, 0x38, 0x4c, 0x93, 0x82, 0xb3,
	0xdc, 0x7b, 0x8d, 0xb8, 0x56, 0x35, 0xd7, 0xbe, 0xc0, 0x07, 0x8a, 0x01, 0xc5, 0x45, 0x9c, 0x0d,
	0x3d, 0xaf, 0x22, 0x6e, 0x8f, 0xb3, 0x61, 0x40, 0x24, 0x77, 0x13, 0xea, 0x19, 0xe3, 0xde, 0xeb,
	0xc4, 0xb1, 0xa4, 0x39, 0x8e, 0x18, 0x0f, 0x90, 0xe0, 0x3e, 0x01, 0xe8, 0xa5, 0x71, 0xcc, 0x7a,
	0x3c, 0x4a, 0x13, 0x6f, 0x83, 0xd8, 0xd6, 0x35, 0xdb, 0x73, 0x4d, 0x0a, 0x2c, 0x36, 0x14, 0x3a,
	0x88, 0xb8, 0xf7, 0x46, 0x45, 0xe8, 0x47, 0x11, 0x0f, 0x90, 0xe0, 0xbe, 0x0d, 0x0b, 0xc5, 0x08,
	0xf3, 0xc5, 0x7b, 0x40, 0x2c, 0x2b, 0x9a, 0xe5, 0x98, 0xd0, 0x81, 0x24, 0xa3, 0x01, 0xe8, 0x5a,
	0xef, 0xeb, 0x15, 0x03, 0xd0, 0xf3, 0x01, 0x91, 0xfc, 0xbf, 0xd7, 0xa1, 0xad, 0x7d, 0x84, 0x41,
	0x46, 0x2f, 0xed, 0xf5, 0x65, 0x1a, 0x49, 0xc8, 0x75, 0xa1, 0x91, 0x84, 0x43, 0x46, 0x49, 0xd4,
	0x0e, 0xe8, 0xdb, 0xfd, 0x16, 0x2c, 0xf6, 0xa3, 0x22, 0x8b, 0xc3, 0x1b, 0x4a, 0x9e, 0xce, 0xe3,
	0x0e, 0xca, 0xdf, 0x16, 0xa8, 0x40, 0xd1, 0x30, 0xbf, 0xc6, 0x51, 0x26, 0x73, 0x09, 0x3f, 0x11,
	0x13, 0x8f, 0x63, 0x99, 0x46, 0xf8, 0x89, 0x98, 0x82, 0x5d, 0x7b, 0x0b, 0x02, 0x53, 0xb0, 0x6b,
	0x54, 0xa4, 0x97, 0x0e, 0xbb, 0x21, 0x97, 0x99, 0x25, 0x21, 0xc4, 0x87, 0xe3, 0x90, 0x87, 0x39,
	0xa5, 0x57, 0x3b, 0x90, 0x10, 0x4a, 0xb8, 0x48, 0xbb, 0x5e, 0x5b, 0x48, 0xb8, 0x48, 0xbb, 0xee,
	0x03, 0x68, 0x9f, 0xb3, 0x3c, 0xdd, 0x4b, 0xfa, 0xec, 0x9a, 0x92, 0xaa, 0x19, 0x18, 0x04, 0x1e,
	0x98, 0xb3, 0x51, 0x14, 0xf7, 0x75, 0x12, 0x29, 0x10, 0xd7, 0xd1, 0xe7, 0x01, 0xda, 0xbb, 0x4c,
	0x9b, 0x18, 0x04, 0xe6, 0x24, 0x8b, 0x07, 0x2f, 0xc7, 0xde, 0x1d, 0x71, 0x36, 0x08, 0xc0, 0x9c,
	0x44, 0x47, 0x91, 0x8b, 0x56, 0x68, 0x89, 0x86, 0x71, 0x27, 0xfc, 0x46, 0xfb, 0x56, 0xc5, 0x4e,
	0x12, 0x54, 0x14, 0xd4, 0x7b, 0xcd, 0x50, 0x50, 0xf7, 0x2d, 0xe8, 0xe0, 0xe7, 0x6e, 0x76, 0x92,
	0xf2, 0x30, 0xf6, 0x5c, 0x72, 0x81, 0x8d, 0x72, 0x7d, 0x58, 0xe2, 0xe9, 0x2e, 0x8b, 0xb3, 0x53,
	0x11, 0xae, 0x75, 0x12, 0x50, 0xc2, 0xf9, 0x03, 0x58, 0xb2, 0xf3, 0x1a, 0x7d, 0x14, 0xf5, 0x55,
	0x3d, 0xc1, 0x4f, 0x77, 0x13, 0x20, 0xbd, 0x4a, 0x58, 0x7e, 0x5a, 0xb0, 0xbd, 0xbe, 0x2c, 0x2d,
	0x16, 0xc6, 0x7d, 0x0b, 0x96, 0x15, 0x94, 0x93, 0x3f, 0xea, 0x64, 0x5c, 0x19, 0xe9, 0xbf, 0x2f,
	0x0b, 0xd1, 0x11, 0xe3, 0x33, 0x13, 0x48, 0xee, 0x5d, 0xd3, 0x7b, 0xfb, 0x3f, 0x77, 0x60, 0xa5,
	0x72, 0x08, 0xb0, 0x02, 0x44, 0x6a, 0x65, 0x2d, 0xea, 0xbb, 0x0f, 0x61, 0xc5, 0x1c, 0x8b, 0x43,
	0xaa, 0x49, 0x42, 0x42, 0x15, 0x8d, 0x96, 0x88, 0x2a, 0x70, 0x12, 0x49, 0x35, 0x9b, 0x81, 0x85,
	0x41, 0x5f, 0xb3, 0xa4, 0x4f, 0x44, 0x91, 0x89, 0x0a, 0xf4, 0x7f, 0x55, 0x93, 0xea, 0x7f, 0x14,
	0xcd, 0x56, 0xff, 0x2e, 0x34, 0x07, 0x11, 0xd7, 0xdb, 0x0b, 0x00, 0x53, 0x65, 0x10, 0x16, 0xe7,
	0x51, 0x9a, 0xec, 0xf5, 0xe5, 0x9e, 0x06, 0x61, 0x51, 0x5f, 0x8e, 0xe5, 0xa6, 0x06, 0xa1, 0x4f,
	0x54, 0xd3, 0x3a, 0x51, 0x62, 0x97, 0x97, 0x63, 0x79, 0x10, 0x04, 0x60, 0xa7, 0xea, 0xe2, 0x9c,
	0x54, 0x6d, 0x55, 0x53, 0xf5, 0x01, 0xb4, 0x63, 0x16, 0xf6, 0x59, 0xfe, 0x43, 0x7d, 0x30, 0x0c,
	0xc2, 0x50, 0x8f, 0xcd, 0xf1, 0xd0, 0x08, 0xff, 0x13, 0xe8, 0x58, 0xf5, 0x64, 0xa6, 0x5b, 0xb0,
	0x16, 0x13, 0x87, 0xf6, 0x8c, 0x86, 0xcd, 0x2d, 0x52, 0xb7, 0x6e, 0x11, 0xff, 0x0f, 0x8e, 0x2c,
	0x37, 0x58, 0x43, 0x51, 0x2e, 0x56, 0x51, 0xbd, 0x5a, 0x42, 0x68, 0x32, 0x7e, 0x1d, 0x8c, 0x86,
	0x72, 0xb5, 0x02, 0x49, 0x2a, 0x26, 0x9f, 0xbe, 0x9b, 0x10, 0x70, 0x1f, 0x81, 0x4b, 0x1f, 0x47,
	0x79, 0xca, 0x59, 0x8f, 0x33, 0x11, 0x68, 0x51, 0x60, 0xa6, 0x50, 0x30, 0xaf, 0xfb, 0x51, 0x11,
	0x66, 0x19, 0x0b, 0x45, 0xc2, 0x08, 0x87, 0x97, 0x91, 0xfe, 0x07, 0x52, 0x55, 0xac, 0x96, 0xa8,
	0x2a, 0xd6, 0x4b, 0xe3, 0x02, 0x01, 0x59, 0xae, 0xa9, 0xd9, 0xae, 0xf1, 0x7f, 0xea, 0xc0, 0x32,
	0xad, 0xde, 0x49, 0x38, 0xcb, 0x0f, 0xf8, 0x00, 0x8d, 0x2a, 0x78, 0x78, 0xc6, 0xb4, 0x08, 0x05,
	0xba, 0x5b, 0xd0, 0x48, 0xbb, 0x17, 0x85, 0x57, 0x33, 0x77, 0xa3, 0xba, 0xd9, 0x03, 0xa2, 0x60,
	0xb4, 0x18, 0xca, 0xa1, 0x1b, 0x5e, 0x66, 0x9a, 0x46, 0x90, 0xbb, 0x8a, 0x93, 0xf4, 0x4a, 0xba,
	0xa5, 0x15, 0x28, 0xd0, 0x5f, 0x87, 0x35, 0xa3, 0xc4, 0xe1, 0x98, 0x14, 0xf1, 0x7f, 0x2c, 0x35,
	0x7b, 0xc9, 0xc2, 0x31, 0x43, 0xcd, 0xee, 0xc3, 0x02, 0x45, 0xa7, 0xf0, 0x9c, 0xad, 0x3a, 0xda,
	0x20, 0x20, 0x99, 0x23, 0x63, 0x46, 0xbb, 0xd6, 0x74, 0x8e, 0x08, 0xc4, 0x9c, 0x5d, 0x0f, 0x65,
	0xf6, 0x6c, 0x47, 0x24, 0x5e, 0x67, 0x82, 0x63, 0xf7, 0x13, 0xef, 0x42, 0xbb, 0x9f, 0xa7, 0x19,
	0xe6, 0xc1, 0x74, 0xcb, 0x0d, 0xd9, 0x0f, 0x75, 0x25, 0x1b, 0xb3, 0x20, 0xe3, 0x33, 0x24, 0xde,
	0xda, 0xea, 0x6c, 0x40, 0x6b, 0x98, 0x4a, 0x73, 0x84, 0x13, 0x35, 0xec, 0x5f, 0x59, 0x5b, 0xcc,
	0x56, 0xfa, 0xd6, 0x2d, 0xf0, 0x08, 0xa7, 0x79, 0x4f, 0xc8, 0x6f, 0x05, 0x02, 0x28, 0x6d, 0xdc,
	0xa8, 0x6c, 0x7c, 0x02, 0xae, 0xe9, 0x51, 0x58, 0x1c, 0x89, 0xed, 0x37, 0xa1, 0x9e, 0x76, 0x2f,
	0x68, 0xf3, 0xaa, 0x5f, 0x90, 0x80, 0xf5, 0x2e, 0x27, 0x66, 0x2b, 0x36, 0x16, 0xc6, 0x3f, 0xb6,
	0xa4, 0x9e, 0x66, 0xfd, 0x90, 0xcf, 0x31, 0xea, 0x6d, 0x6a, 0x1e, 0x91, 0x53, 0x9a, 0x55, 0x69,
	0x9c, 0x14, 0xd5, 0xdf, 0x81, 0x7b, 0x1a, 0xbb, 0x13, 0x0f, 0x8c, 0xdc, 0x39, 0x65, 0x53, 0xdc,
	0x96, 0x35, 0xeb, 0xb6, 0xf4, 0xff, 0xe8, 0x40, 0xfb, 0x29, 0xe7, 0x61, 0xef, 0x12, 0x63, 0x89,
	0xc7, 0xe2, 0x32, 0x8a, 0x63, 0xeb, 0x58, 0x08, 0xd0, 0x4a, 0xcb, 0x5a, 0x29, 0x2d, 0x27, 0x3b,
	0x56, 0x1d, 0x96, 0xc6, 0x8c, 0xb0, 0xe0, 0xf5, 0x80, 0x52, 0x5f, 0xb2, 0x31, 0x53, 0x9d, 0x87,
	0x85, 0x31, 0x8e, 0x59, 0xb0, 0x1d, 0x73, 0x17, 0x9a, 0x51, 0xb1, 0x13, 0x0f, 0xa8, 0xee, 0xb6,
	0x02, 0x01, 0xf8, 0x7f, 0xae, 0xc3, 0x8a, 0x50, 0x7f, 0x67, 0x30, 0x60, 0x3d, 0xae, 0xce, 0xf6,
	0x74, 0x23, 0x36, 0x01, 0x42, 0x62, 0xb6, 0x6a, 0x84, 0x85, 0x79, 0x15, 0x63, 0xde, 0x82, 0xe6,
	0xf9, 0x28, 0xe7, 0x85, 0xd7, 0xa4, 0x53, 0x73, 0x07, 0x19, 0x76, 0x47, 0x39, 0x17, 0xea, 0x04,
	0x82, 0xe8, 0xbe, 0x07, 0x1d, 0xcc, 0xe5, 0x93, 0x94, 0xd6, 0x92, 0x61, 0x25, 0x61, 0x36, 0x55,
	0xeb, 0xff, 0x72, 0xac, 0xee, 0x18, 0x09, 0xa2, 0x7e, 0x2c, 0x17, 0xdd, 0x56, 0x33, 0xc0, 0x4f,
	0x6c, 0x4e, 0x88, 0x78, 0xcc, 0xc3, 0x9c, 0x9f, 0xd0, 0xcd, 0x52, 0x0f, 0x6c, 0x94, 0xf6, 0xf6,
	0x31, 0x4f, 0xb3, 0x13, 0xd9, 0xd0, 0x5b, 0x98, 0xca, 0x65, 0xdd, 0x91, 0x74, 0x73, 0x59, 0x53,
	0xe3, 0x7f, 0x90, 0x5e, 0x51, 0x6b, 0x46, 0x8d, 0xff, 0x41, 0x7a, 0x65, 0xa2, 0xb1, 0x6c, 0x45,
	0x03, 0x1b, 0x21, 0xe5, 0x4d, 0xba, 0x06, 0xef, 0xd0, 0x35, 0x58, 0xc2, 0x89, 0x91, 0x04, 0xe5,
	0xad, 0xa8, 0x91, 0xe4, 0x20, 0xbd, 0xf2, 0x7f, 0x5b, 0x07, 0x30, 0x6e, 0x9b, 0x71, 0x36, 0xc4,
	0x74, 0x53, 0xd3, 0xd3, 0x8d, 0x07, 0x8b, 0xbd, 0xf3, 0x30, 0x39, 0xdb, 0xcd, 0x28, 0x64, 0xf5,
	0x40, 0x81, 0xa2, 0x1c, 0x6e, 0xb3, 0x90, 0x9f, 0x9b, 0x72, 0x48, 0xa0, 0xa4, 0xa4, 0xfd, 0x33,
	0x71, 0x25, 0x09, 0x0a, 0x82, 0x58, 0x17, 0x30, 0x58, 0x74, 0x86, 0x45, 0xe6, 0x69, 0x18, 0x1b,
	0x04, 0xfc, 0x96, 0xfd, 0x2f, 0x7d, 0x63, 0x41, 0xee, 0xa3, 0xc8, 0x6e, 0x9c, 0x5e, 0xc9, 0xf9,
	0xca, 0x20, 0x48, 0xb7, 0x11, 0x47, 0x93, 0x64, 0x50, 0x14, 0x58, 0xcd, 0x05, 0xb8, 0x2d, 0x17,
	0x46, 0xc9, 0xb3, 0x38, 0xed, 0x5d, 0xca, 0xd0, 0x28, 0x10, 0x0f, 0x64, 0xce, 0x06, 0x31, 0xbb,
	0x96, 0x81, 0x91, 0x90, 0x29, 0x46, 0xc7, 0x4c, 0x87, 0xc7, 0xc2, 0xd0, 0x35, 0x5f, 0x7c, 0x32,
	0xda, 0x8e, 0x28, 0x3a, 0xad, 0x40, 0x42, 0x68, 0x3e, 0x26, 0x05, 0x69, 0x2c, 0x42, 0xa3, 0x61,
	0xff, 0xdf, 0xea, 0xfe, 0x3c, 0xec, 0x5e, 0xec, 0x66, 0xb3, 0x8b, 0x57, 0x35, 0x40, 0x1b, 0xd0,
	0xa2, 0x88, 0x30, 0x1d, 0x21, 0x0d, 0xa3, 0x65, 0x1c, 0xbb, 0xe7, 0x5d, 0x31, 0x8e, 0xd4, 0x03,
	0x05, 0x2a, 0x4d, 0xe8, 0x8c, 0x8a, 0xea, 0xa0, 0x61, 0xb4, 0x4e, 0x7c, 0x53, 0x7e, 0x2d, 0x50,
	0x7e, 0x59, 0x18, 0xab, 0xf8, 0x2d, 0x96, 0x8a, 0x5f, 0xa5, 0x89, 0x6f, 0x4d, 0x34, 0xf1, 0xfe,
	0xa5, 0x31, 0x71, 0x7f, 0xbe, 0x89, 0xfb, 0xda, 0xc4, 0x7d, 0xcb, 0xc4, 0xfd, 0x8a, 0x89, 0xfb,
	0xc6, 0xc4, 0xfd, 0xb2, 0x89, 0xfb, 0x99, 0xef, 0xc2, 0xea, 0x47, 0xd1, 0xd9, 0x39, 0x25, 0x44,
	0x10, 0x26, 0x97, 0x01, 0xfb, 0xd4, 0x1f, 0x54, 0x70, 0x4f, 0x7b, 0x97, 0xee, 0xdb, 0xd0, 0xcc,
	0xc3, 0xe4, 0x52, 0xf4, 0x02, 0x9d, 0xc7, 0x6b, 0x98, 0x25, 0xc4, 0x84, 0x0c, 0xa7, 0x49, 0xc4,
	0x03, 0x41, 0x77, 0xdf, 0x81, 0x85, 0xe1, 0x0d, 0x22, 0xe5, 0xad, 0x31, 0x85, 0x53, 0x32, 0x60,
	0xaf, 0xbf, 0x5c, 0xa2, 0x60, 0x76, 0xa3, 0x14, 0x69, 0x28, 0x7d, 0x4f, 0x1d, 0x32, 0xef, 0x42,
	0xb3, 0xe8, 0xa5, 0x39, 0x93, 0x86, 0x0a, 0xc0, 0x14, 0x10, 0x0a, 0x49, 0x43, 0x84, 0xc4, 0x60,
	0xac, 0x90, 0x34, 0x4b, 0x4d, 0xd9, 0x7d, 0xb8, 0xfb, 0x82, 0xf1, 0x67, 0x69, 0x51, 0x1c, 0x62,
	0x53, 0xf8, 0x1c, 0xbd, 0x86, 0x7e, 0xf8, 0x09, 0xac, 0x95, 0x91, 0xb3, 0x83, 0xa1, 0x46, 0x26,
	0x7b, 0x1a, 0xb1, 0x30, 0xd6, 0xd6, 0xf5, 0x6a, 0xab, 0x3c, 0x2a, 0x4a, 0x0a, 0x6b, 0xd8, 0x1f,
	0xc0, 0x32, 0xf6, 0x98, 0xb4, 0x33, 0xdd, 0xa7, 0x5b, 0x72, 0x6e, 0xb7, 0xae, 0x7f, 0xfd, 0x58,
	0x42, 0x14, 0xf7, 0x09, 0x2c, 0xf5, 0x59, 0xac, 0x90, 0xaa, 0x81, 0xa2, 0x87, 0x80, 0x6d, 0x83,
	0x0f, 0x4a, 0x4c, 0xfe, 0x53, 0x00, 0x04, 0xb6, 0x59, 0x8c, 0x9b, 0x54, 0x45, 0x38, 0x5f, 0x46,
	0xc4, 0x3f, 0x1d, 0x68, 0x29, 0xa8, 0xe2, 0x0b, 0x67, 0xc2, 0x17, 0x78, 0x53, 0xa4, 0xa3, 0xbc,
	0xc7, 0x6c, 0x67, 0xd9, 0x28, 0x35, 0x16, 0xd6, 0xcd, 0x48, 0x6a, 0xfa, 0xec, 0x46, 0xa9, 0xcf,
	0x7e, 0x00, 0x6d, 0xca, 0x64, 0xdd, 0xd9, 0xd7, 0x03, 0x83, 0xc0, 0x9d, 0xf4, 0x4c, 0xaa, 0x6f,
	0x71, 0x1b, 0x85, 0xf7, 0x84, 0xd8, 0xf8, 0xd4, 0x3e, 0xab, 0x25, 0x9c, 0xff, 0x21, 0x74, 0x2c,
	0xcb, 0x6f, 0x35, 0x6f, 0x72, 0xa6, 0xfd, 0x04, 0xd6, 0x70, 0xf5, 0x51, 0x9e, 0x66, 0x26, 0x98,
	0xd3, 0xf3, 0xe8, 0x3e, 0x2c, 0x64, 0xd8, 0xdf, 0xea, 0xb9, 0x41, 0x40, 0xc8, 0x4d, 0x66, 0xa9,
	0x84, 0x27, 0xc0, 0x3f, 0x85, 0x15, 0x14, 0xbc, 0x6b, 0x89, 0x7d, 0x06, 0x6b, 0x5d, 0x0b, 0x65,
	0xc7, 0xf0, 0xae, 0x4a, 0x18, 0x9b, 0x18, 0x4c, 0xb2, 0xfb, 0x7f, 0x75, 0x60, 0xb5, 0xca, 0xf7,
	0xd5, 0xcd, 0x46, 0x9d, 0xe9, 0x16, 0x52, 0xa3, 0x1e, 0x01, 0xa5, 0x4a, 0xdc, 0x98, 0x5d, 0x89,
	0x9b, 0xb3, 0x2b, 0xf1, 0xc2, 0xdc, 0x4a, 0xbc, 0x58, 0xad, 0xc4, 0xfe, 0x63, 0x58, 0xdd, 0x0f,
	0xa3, 0xe4, 0x79, 0xc4, 0x6f, 0x68, 0xe0, 0xc1, 0xf6, 0xf2, 0x96, 0x46, 0x1a, 0x3d, 0xab, 0xd6,
	0xcc, 0x9f, 0x2e, 0xe8, 0x2d, 0xb6, 0x56, 0x7a, 0x8b, 0xad, 0xcb, 0xb7, 0x58, 0xd5, 0xc4, 0x35,
	0x75, 0x13, 0xe7, 0x3f, 0x34, 0xaa, 0xd0, 0x98, 0x35, 0x53, 0xae, 0xff, 0x04, 0xd6, 0x14, 0xa7,
	0x68, 0xa8, 0xbf, 0x8c, 0xd6, 0x6b, 0xb0, 0x42, 0xf5, 0x54, 0xcc, 0x75, 0x54, 0xcb, 0x7f, 0x04,
	0xf7, 0x09, 0x45, 0x3d, 0xd8, 0xf3, 0x74, 0x94, 0xf0, 0xed, 0xf4, 0x2a, 0x11, 0xb3, 0x84, 0xdd,
	0x6e, 0x39, 0x13, 0x6f, 0x23, 0x6f, 0xc1, 0x72, 0x4f, 0xf1, 0x13, 0x8b, 0xb0, 0xb2, 0x8c, 0xf4,
	0x37, 0xc0, 0x9b, 0x22, 0x5f, 0xec, 0xbd, 0x22, 0xcb, 0x3b, 0xd1, 0x70, 0xc4, 0xfc, 0x85, 0x03,
	0xaf, 0x9b, 0x77, 0x9d, 0x63, 0x1e, 0xf2, 0x51, 0x71, 0xdb, 0x89, 0x78, 0x00, 0x6d, 0xac, 0x88,
	0x76, 0xad, 0x30, 0x08, 0xa4, 0x16, 0xd4, 0x5d, 0xaa, 0xf7, 0x9d, 0x7a, 0x60, 0x10, 0xd5, 0xe7,
	0x9d, 0xba, 0x79, 0xde, 0xf9, 0xbd, 0x03, 0x2e, 0xe9, 0x76, 0xc2, 0xc2, 0xa1, 0x51, 0xe1, 0x10,
	0x96, 0x51, 0x36, 0x22, 0xc5, 0x0b, 0xa1, 0x38, 0x39, 0xef, 0xe8, 0x3b, 0xac, 0xc4, 0xfe, 0xe8,
	0xd4, 0xe6, 0xdd, 0x49, 0x78, 0x7e, 0x13, 0x94, 0xd7, 0x6f, 0xfc, 0x00, 0xdc, 0x49, 0x26, 0x4c,
	0x8c, 0x4b, 0x76, 0xa3, 0x9e, 0xdc, 0x2e, 0xd9, 0x0d, 0xda, 0x3e, 0x0e, 0xe3, 0x91, 0x72, 0xb2,
	0x00, 0xbe, 0x5f, 0xfb, 0x9e, 0xe3, 0x07, 0xb0, 0x41, 0x3b, 0xa3, 0x18, 0xb1, 0xf3, 0x09, 0xbd,
	0xe6, 0x89, 0xd7, 0x83, 0x59, 0x23, 0x16, 0xd6, 0x45, 0x6d, 0x84, 0xf4, 0x9a, 0x46, 0x60, 0x1a,
	0x92, 0xcc, 0x83, 0xac, 0xb7, 0x33, 0x66, 0x09, 0x0f, 0xd8, 0xa7, 0xa8, 0x41, 0x92, 0xf5, 0x8c,
	0xf7, 0x09, 0xf0, 0x4f, 0x61, 0x7d, 0xe7, 0x3a, 0x3b, 0xe6, 0xe1, 0x19, 0xfb, 0x18, 0x27, 0x97,
	0x64, 0x90, 0xe2, 0xb6, 0xdf, 0x86, 0x3b, 0x78, 0xc0, 0xe4, 0x13, 0xe2, 0xc1, 0x68, 0x28, 0x57,
	0x55, 0xb0, 0xa8, 0xde, 0x19, 0xe3, 0x3b, 0xd7, 0x99, 0x2a, 0x67, 0x02, 0xf2, 0xd7, 0x61, 0xed,
	0x28, 0x4c, 0xfb, 0x51, 0x98, 0x9c, 0xa4, 0x99, 0x18, 0x71, 0x3f, 0xf5, 0xbf, 0x53, 0x45, 0xca,
	0x11, 0x4a, 0x98, 0xa4, 0x5e, 0x21, 0x14, 0xe8, 0xff, 0xd2, 0x21, 0xfe, 0xed, 0x28, 0x4c, 0x88,
	0x79, 0x34, 0x44, 0xfe, 0x0f, 0xe5, 0x85, 0x3a, 0x1a, 0xaa, 0xb2, 0xf7, 0x26, 0x35, 0xb4, 0x55,
	0xc6, 0x47, 0xf2, 0xb3, 0x10, 0x61, 0xd3, 0x8b, 0x36, 0x3e, 0x80, 0xe5, 0x12, 0xe9, 0x2b, 0x05,
	0xeb, 0x3d, 0x58, 0x91, 0x26, 0xc8, 0x73, 0xd8, 0x9f, 0xfd, 0xbe, 0xe3, 0xdf, 0x83, 0xf5, 0x17,
	0x8c, 0x1f, 0x9f, 0x87, 0xdd, 0xf0, 0x92, 0x1d, 0x63, 0x07, 0x53, 0xa0, 0x1b, 0x7e, 0xe6, 0xc0,
	0xba, 0x8d, 0xc4, 0xe6, 0x08, 0x2d, 0x7b, 0x1f, 0x00, 0x95, 0x14, 0x8c, 0x76, 0x49, 0x97, 0xcc,
	0xa7, 0x8a, 0x18, 0x58, 0x7c, 0xee, 0x77, 0xa1, 0x43, 0x6f, 0x7f, 0x72, 0x99, 0x68, 0x08, 0xee,
	0x59, 0xcb, 0x5e, 0x68, 0x6a, 0x60, 0x73, 0xfa, 0x19, 0xac, 0x56, 0x05, 0xcf, 0x7b, 0xf0, 0xd3,
	0x5d, 0x4c, 0xad, 0xdc, 0xc5, 0x94, 0x5b, 0xb5, 0xa6, 0x6a, 0xd5, 0x54, 0xa3, 0xd7, 0x30, 0x8d,
	0x9e, 0xff, 0x3b, 0x07, 0xd6, 0x26, 0x94, 0xb2, 0xdf, 0x39, 0x9d, 0x39, 0xef, 0x9c, 0xb5, 0x29,
	0x4f, 0xf2, 0x53, 0xf6, 0xb5, 0x7f, 0x26, 0x6a, 0x54, 0x7e, 0x26, 0x2a, 0xb7, 0x8f, 0xcd, 0x6a,
	0xfb, 0xe8, 0xff, 0xd7, 0x01, 0x57, 0xea, 0x77, 0xd8, 0xeb, 0x8d, 0xb2, 0x88, 0xf5, 0x31, 0x2e,
	0x1b, 0xd0, 0x8a, 0x0a, 0x42, 0x88, 0x24, 0x69, 0x05, 0x1a, 0x9e, 0xf5, 0x0c, 0x58, 0x72, 0x58,
	0xbd, 0xe2, 0x30, 0xcb, 0xe0, 0xc6, 0x1c, 0x83, 0x9b, 0x53, 0x1e, 0x76, 0x4d, 0x29, 0x14, 0x77,
	0xe4, 0xf4, 0x52, 0xb8, 0x58, 0x7a, 0xe9, 0xc6, 0x26, 0x69, 0x20, 0xab, 0x34, 0x1f, 0x15, 0x72,
	0xa4, 0xb7, 0x51, 0x58, 0xe3, 0x4d, 0xa2, 0x3e, 0xcf, 0xd3, 0xa2, 0x30, 0xd9, 0xfa, 0xb9, 0x03,
	0xde, 0x04, 0x45, 0xa5, 0xec, 0x87, 0xb0, 0x24, 0xfc, 0x57, 0x4a, 0xda, 0x37, 0xac, 0xec, 0x13,
	0x6b, 0x0c, 0x4f, 0x50, 0x5a, 0xf0, 0xea, 0xd9, 0x7b, 0x09, 0xaf, 0xcd, 0xd8, 0xa1, 0x94, 0x02,
	0xce, 0xdc, 0x14, 0xa8, 0x4d, 0x4c, 0x10, 0x53, 0x93, 0xca, 0xff, 0x75, 0xad, 0xbc, 0xdb, 0xff,
	0x53, 0x76, 0xd8, 0xde, 0x6a, 0xcd, 0xf5, 0x56, 0x7b, 0xe2, 0xc0, 0xfc, 0xc3, 0x81, 0xf5, 0x17,
	0xa3, 0x30, 0xef, 0x1f, 0x45, 0x71, 0x1c, 0xe6, 0xe2, 0xca, 0xe1, 0x03, 0xf7, 0xa1, 0x35, 0xe5,
	0xc9, 0x1a, 0x56, 0x9d, 0x37, 0xcd, 0xec, 0x77, 0x15, 0x8e, 0x55, 0xa1, 0xa5, 0x6f, 0xd4, 0x28,
	0x61, 0xd7, 0xdc, 0xfa, 0x45, 0x47, 0xc3, 0xd8, 0xce, 0xcb, 0x5f, 0x69, 0xc5, 0x74, 0x2d, 0x5c,
	0x54, 0xc2, 0x61, 0xbe, 0x4b, 0x38, 0x66, 0x45, 0x21, 0xbb, 0x33, 0x1b, 0x85, 0x52, 0x06, 0xb2,
	0x7c, 0x5b, 0xee, 0x2a, 0xe1, 0xfc, 0xcf, 0x6a, 0xe0, 0xee, 0x87, 0x67, 0x51, 0x8f, 0xde, 0xb6,
	0x71, 0x4c, 0xa4, 0x2e, 0x79, 0x03, 0x5a, 0xdd, 0xb4, 0x28, 0xc8, 0x21, 0x8e, 0x08, 0x9d, 0x82,
	0x31, 0x79, 0xe2, 0xf0, 0x46, 0x3e, 0xa7, 0x36, 0x03, 0x01, 0x60, 0x12, 0x14, 0xe2, 0xe4, 0xc9,
	0xc9, 0x50, 0x40, 0xa8, 0x66, 0xce, 0x06, 0x39, 0x2b, 0xce, 0xad, 0x9f, 0xa7, 0x6c, 0x14, 0x86,
	0x54, 0x6a, 0xad, 0x27, 0x5a, 0x83, 0xa8, 0xfc, 0x88, 0xb7, 0x30, 0xf1, 0x23, 0xde, 0x03, 0x68,
	0x13, 0x64, 0x35, 0xcd, 0x06, 0x61, 0x39, 0x52, 0x34, 0x5e, 0xad, 0x92, 0x23, 0x09, 0xe7, 0x7f,
	0xe6, 0xd8, 0x2e, 0xd0, 0xd1, 0x7d, 0xb5, 0x7b, 0xea, 0x7d, 0x68, 0x77, 0xa5, 0x13, 0xd5, 0x39,
	0xbf, 0x8f, 0x8b, 0x26, 0x7d, 0x1c, 0x18, 0x46, 0x3f, 0x82, 0x35, 0xdd, 0x1c, 0x91, 0x20, 0xd9,
	0x47, 0x8a, 0x43, 0xea, 0xd8, 0x95, 0x7f, 0x0b, 0x3a, 0x62, 0xce, 0x20, 0x3e, 0x35, 0x75, 0x5a,
	0x28, 0xf4, 0x08, 0x26, 0xdd, 0xb1, 0x75, 0xc0, 0x0d, 0x42, 0x3e, 0x12, 0xd0, 0x6e, 0x4a, 0x13,
	0x2a, 0x80, 0x1f, 0x4f, 0xc1, 0x3f, 0xed, 0x5d, 0xba, 0x4f, 0x6c, 0x83, 0x1c, 0x53, 0xb8, 0x4a,
	0x9c, 0xf4, 0x1c, 0x62, 0xd9, 0xf3, 0xb9, 0x23, 0x0d, 0xb2, 0x19, 0x66, 0x37, 0xc6, 0x26, 0xfc,
	0xb5, 0x6a, 0xf8, 0xf5, 0x73, 0x71, 0x7d, 0xf6, 0xaf, 0x1e, 0xe2, 0x2d, 0xee, 0xf9, 0xb6, 0xba,
	0x09, 0x15, 0x2c, 0x5f, 0xcf, 0x9a, 0xea, 0xf5, 0xcc, 0x7f, 0x0a, 0xcb, 0xa8, 0x90, 0xf9, 0x1d,
	0x62, 0xba, 0x46, 0x46, 0xa4, 0xfe, 0xdd, 0x4f, 0xc1, 0xcf, 0x56, 0xff, 0xf2, 0xc5, 0xa6, 0xf3,
	0xb7, 0x2f, 0x36, 0x9d, 0x7f, 0x7d, 0xb1, 0xe9, 0xfc, 0xe6, 0x3f, 0x9b, 0x5f, 0xeb, 0x2e, 0xd0,
	0xbf, 0x5a, 0x9e, 0xfc, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xee, 0x21, 0xaf, 0xf6, 0x22, 0x00,
	0x00,
}
