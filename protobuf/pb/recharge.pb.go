// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: recharge.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 服务器通知客户端充值到账了。
type RechargFulfilledNtf struct {
	Ingot        int32 `protobuf:"varint,1,opt,name=ingot,proto3" json:"ingot,omitempty"`
	PayMoney     int32 `protobuf:"varint,2,opt,name=payMoney,proto3" json:"payMoney,omitempty"`
	Vip          int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip,omitempty"`
	VipExp       int32 `protobuf:"varint,4,opt,name=vipExp,proto3" json:"vipExp,omitempty"`
	RechargedAll int32 `protobuf:"varint,5,opt,name=rechargedAll,proto3" json:"rechargedAll,omitempty"`
	RechargeId   int32 `protobuf:"varint,6,opt,name=rechargeId,proto3" json:"rechargeId,omitempty"`
}

func (m *RechargFulfilledNtf) Reset()                    { *m = RechargFulfilledNtf{} }
func (m *RechargFulfilledNtf) String() string            { return proto.CompactTextString(m) }
func (*RechargFulfilledNtf) ProtoMessage()               {}
func (*RechargFulfilledNtf) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{0} }

func (m *RechargFulfilledNtf) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *RechargFulfilledNtf) GetPayMoney() int32 {
	if m != nil {
		return m.PayMoney
	}
	return 0
}

func (m *RechargFulfilledNtf) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *RechargFulfilledNtf) GetVipExp() int32 {
	if m != nil {
		return m.VipExp
	}
	return 0
}

func (m *RechargFulfilledNtf) GetRechargedAll() int32 {
	if m != nil {
		return m.RechargedAll
	}
	return 0
}

func (m *RechargFulfilledNtf) GetRechargeId() int32 {
	if m != nil {
		return m.RechargeId
	}
	return 0
}

// 申请充值
type RechargeApplyPayReq struct {
	PayNum     int32 `protobuf:"varint,1,opt,name=payNum,proto3" json:"payNum,omitempty"`
	RechargeId int32 `protobuf:"varint,2,opt,name=rechargeId,proto3" json:"rechargeId,omitempty"`
}

func (m *RechargeApplyPayReq) Reset()                    { *m = RechargeApplyPayReq{} }
func (m *RechargeApplyPayReq) String() string            { return proto.CompactTextString(m) }
func (*RechargeApplyPayReq) ProtoMessage()               {}
func (*RechargeApplyPayReq) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{1} }

func (m *RechargeApplyPayReq) GetPayNum() int32 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *RechargeApplyPayReq) GetRechargeId() int32 {
	if m != nil {
		return m.RechargeId
	}
	return 0
}

// 形成充值订单
type RechargeApplyPayAck struct {
	Result     bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	PayData    string `protobuf:"bytes,2,opt,name=payData,proto3" json:"payData,omitempty"`
	RechargeId int32  `protobuf:"varint,3,opt,name=rechargeId,proto3" json:"rechargeId,omitempty"`
	IsPayToken bool   `protobuf:"varint,4,opt,name=isPayToken,proto3" json:"isPayToken,omitempty"`
}

func (m *RechargeApplyPayAck) Reset()                    { *m = RechargeApplyPayAck{} }
func (m *RechargeApplyPayAck) String() string            { return proto.CompactTextString(m) }
func (*RechargeApplyPayAck) ProtoMessage()               {}
func (*RechargeApplyPayAck) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{2} }

func (m *RechargeApplyPayAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *RechargeApplyPayAck) GetPayData() string {
	if m != nil {
		return m.PayData
	}
	return ""
}

func (m *RechargeApplyPayAck) GetRechargeId() int32 {
	if m != nil {
		return m.RechargeId
	}
	return 0
}

func (m *RechargeApplyPayAck) GetIsPayToken() bool {
	if m != nil {
		return m.IsPayToken
	}
	return false
}

// 用钱付款购买
type MoneyPayReq struct {
	PayType int32 `protobuf:"varint,1,opt,name=payType,proto3" json:"payType,omitempty"`
	PayNum  int32 `protobuf:"varint,2,opt,name=payNum,proto3" json:"payNum,omitempty"`
	TypeId  int32 `protobuf:"varint,3,opt,name=typeId,proto3" json:"typeId,omitempty"`
}

func (m *MoneyPayReq) Reset()                    { *m = MoneyPayReq{} }
func (m *MoneyPayReq) String() string            { return proto.CompactTextString(m) }
func (*MoneyPayReq) ProtoMessage()               {}
func (*MoneyPayReq) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{3} }

func (m *MoneyPayReq) GetPayType() int32 {
	if m != nil {
		return m.PayType
	}
	return 0
}

func (m *MoneyPayReq) GetPayNum() int32 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *MoneyPayReq) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

type MoneyPayAck struct {
	Result     bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	PayData    string `protobuf:"bytes,2,opt,name=payData,proto3" json:"payData,omitempty"`
	PayType    int32  `protobuf:"varint,3,opt,name=payType,proto3" json:"payType,omitempty"`
	PayNum     int32  `protobuf:"varint,4,opt,name=payNum,proto3" json:"payNum,omitempty"`
	TypeId     int32  `protobuf:"varint,5,opt,name=typeId,proto3" json:"typeId,omitempty"`
	IsPayToken bool   `protobuf:"varint,6,opt,name=isPayToken,proto3" json:"isPayToken,omitempty"`
}

func (m *MoneyPayAck) Reset()                    { *m = MoneyPayAck{} }
func (m *MoneyPayAck) String() string            { return proto.CompactTextString(m) }
func (*MoneyPayAck) ProtoMessage()               {}
func (*MoneyPayAck) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{4} }

func (m *MoneyPayAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *MoneyPayAck) GetPayData() string {
	if m != nil {
		return m.PayData
	}
	return ""
}

func (m *MoneyPayAck) GetPayType() int32 {
	if m != nil {
		return m.PayType
	}
	return 0
}

func (m *MoneyPayAck) GetPayNum() int32 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *MoneyPayAck) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *MoneyPayAck) GetIsPayToken() bool {
	if m != nil {
		return m.IsPayToken
	}
	return false
}

// 充值双倍重置
type RechargeResetNtf struct {
	Recharge []int32 `protobuf:"varint,1,rep,packed,name=recharge" json:"recharge,omitempty"`
}

func (m *RechargeResetNtf) Reset()                    { *m = RechargeResetNtf{} }
func (m *RechargeResetNtf) String() string            { return proto.CompactTextString(m) }
func (*RechargeResetNtf) ProtoMessage()               {}
func (*RechargeResetNtf) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{5} }

func (m *RechargeResetNtf) GetRecharge() []int32 {
	if m != nil {
		return m.Recharge
	}
	return nil
}

// 连续充值进入下个周期
type ContRechargeCycleNtf struct {
	Cycle int32 `protobuf:"varint,1,opt,name=cycle,proto3" json:"cycle,omitempty"`
}

func (m *ContRechargeCycleNtf) Reset()                    { *m = ContRechargeCycleNtf{} }
func (m *ContRechargeCycleNtf) String() string            { return proto.CompactTextString(m) }
func (*ContRechargeCycleNtf) ProtoMessage()               {}
func (*ContRechargeCycleNtf) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{6} }

func (m *ContRechargeCycleNtf) GetCycle() int32 {
	if m != nil {
		return m.Cycle
	}
	return 0
}

// 连续充值推送
type ContRechargeNtf struct {
	Recharge map[int32]int32 `protobuf:"bytes,1,rep,name=recharge" json:"recharge,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ContRechargeNtf) Reset()                    { *m = ContRechargeNtf{} }
func (m *ContRechargeNtf) String() string            { return proto.CompactTextString(m) }
func (*ContRechargeNtf) ProtoMessage()               {}
func (*ContRechargeNtf) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{7} }

func (m *ContRechargeNtf) GetRecharge() map[int32]int32 {
	if m != nil {
		return m.Recharge
	}
	return nil
}

// 连续充值领取奖励
type ContRechargeReceiveReq struct {
	ContRechargeId int32 `protobuf:"varint,1,opt,name=contRechargeId,proto3" json:"contRechargeId,omitempty"`
}

func (m *ContRechargeReceiveReq) Reset()                    { *m = ContRechargeReceiveReq{} }
func (m *ContRechargeReceiveReq) String() string            { return proto.CompactTextString(m) }
func (*ContRechargeReceiveReq) ProtoMessage()               {}
func (*ContRechargeReceiveReq) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{8} }

func (m *ContRechargeReceiveReq) GetContRechargeId() int32 {
	if m != nil {
		return m.ContRechargeId
	}
	return 0
}

type ContRechargeReceiveAck struct {
	ContRechargeId int32           `protobuf:"varint,1,opt,name=contRechargeId,proto3" json:"contRechargeId,omitempty"`
	Goods          *GoodsChangeNtf `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
}

func (m *ContRechargeReceiveAck) Reset()                    { *m = ContRechargeReceiveAck{} }
func (m *ContRechargeReceiveAck) String() string            { return proto.CompactTextString(m) }
func (*ContRechargeReceiveAck) ProtoMessage()               {}
func (*ContRechargeReceiveAck) Descriptor() ([]byte, []int) { return fileDescriptorRecharge, []int{9} }

func (m *ContRechargeReceiveAck) GetContRechargeId() int32 {
	if m != nil {
		return m.ContRechargeId
	}
	return 0
}

func (m *ContRechargeReceiveAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func init() {
	proto.RegisterType((*RechargFulfilledNtf)(nil), "pb.RechargFulfilledNtf")
	proto.RegisterType((*RechargeApplyPayReq)(nil), "pb.RechargeApplyPayReq")
	proto.RegisterType((*RechargeApplyPayAck)(nil), "pb.RechargeApplyPayAck")
	proto.RegisterType((*MoneyPayReq)(nil), "pb.MoneyPayReq")
	proto.RegisterType((*MoneyPayAck)(nil), "pb.MoneyPayAck")
	proto.RegisterType((*RechargeResetNtf)(nil), "pb.RechargeResetNtf")
	proto.RegisterType((*ContRechargeCycleNtf)(nil), "pb.ContRechargeCycleNtf")
	proto.RegisterType((*ContRechargeNtf)(nil), "pb.ContRechargeNtf")
	proto.RegisterType((*ContRechargeReceiveReq)(nil), "pb.ContRechargeReceiveReq")
	proto.RegisterType((*ContRechargeReceiveAck)(nil), "pb.ContRechargeReceiveAck")
}
func (m *RechargFulfilledNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargFulfilledNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ingot != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.Ingot))
	}
	if m.PayMoney != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayMoney))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.Vip))
	}
	if m.VipExp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.VipExp))
	}
	if m.RechargedAll != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.RechargedAll))
	}
	if m.RechargeId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.RechargeId))
	}
	return i, nil
}

func (m *RechargeApplyPayReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeApplyPayReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PayNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayNum))
	}
	if m.RechargeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.RechargeId))
	}
	return i, nil
}

func (m *RechargeApplyPayAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeApplyPayAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PayData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(len(m.PayData)))
		i += copy(dAtA[i:], m.PayData)
	}
	if m.RechargeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.RechargeId))
	}
	if m.IsPayToken {
		dAtA[i] = 0x20
		i++
		if m.IsPayToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MoneyPayReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyPayReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PayType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayType))
	}
	if m.PayNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayNum))
	}
	if m.TypeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.TypeId))
	}
	return i, nil
}

func (m *MoneyPayAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyPayAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PayData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(len(m.PayData)))
		i += copy(dAtA[i:], m.PayData)
	}
	if m.PayType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayType))
	}
	if m.PayNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.PayNum))
	}
	if m.TypeId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.TypeId))
	}
	if m.IsPayToken {
		dAtA[i] = 0x30
		i++
		if m.IsPayToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RechargeResetNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeResetNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Recharge) > 0 {
		dAtA2 := make([]byte, len(m.Recharge)*10)
		var j1 int
		for _, num1 := range m.Recharge {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *ContRechargeCycleNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContRechargeCycleNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cycle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.Cycle))
	}
	return i, nil
}

func (m *ContRechargeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContRechargeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Recharge) > 0 {
		for k, _ := range m.Recharge {
			dAtA[i] = 0xa
			i++
			v := m.Recharge[k]
			mapSize := 1 + sovRecharge(uint64(k)) + 1 + sovRecharge(uint64(v))
			i = encodeVarintRecharge(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRecharge(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintRecharge(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ContRechargeReceiveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContRechargeReceiveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContRechargeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.ContRechargeId))
	}
	return i, nil
}

func (m *ContRechargeReceiveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContRechargeReceiveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContRechargeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.ContRechargeId))
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecharge(dAtA, i, uint64(m.Goods.Size()))
		n3, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func encodeVarintRecharge(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RechargFulfilledNtf) Size() (n int) {
	var l int
	_ = l
	if m.Ingot != 0 {
		n += 1 + sovRecharge(uint64(m.Ingot))
	}
	if m.PayMoney != 0 {
		n += 1 + sovRecharge(uint64(m.PayMoney))
	}
	if m.Vip != 0 {
		n += 1 + sovRecharge(uint64(m.Vip))
	}
	if m.VipExp != 0 {
		n += 1 + sovRecharge(uint64(m.VipExp))
	}
	if m.RechargedAll != 0 {
		n += 1 + sovRecharge(uint64(m.RechargedAll))
	}
	if m.RechargeId != 0 {
		n += 1 + sovRecharge(uint64(m.RechargeId))
	}
	return n
}

func (m *RechargeApplyPayReq) Size() (n int) {
	var l int
	_ = l
	if m.PayNum != 0 {
		n += 1 + sovRecharge(uint64(m.PayNum))
	}
	if m.RechargeId != 0 {
		n += 1 + sovRecharge(uint64(m.RechargeId))
	}
	return n
}

func (m *RechargeApplyPayAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.PayData)
	if l > 0 {
		n += 1 + l + sovRecharge(uint64(l))
	}
	if m.RechargeId != 0 {
		n += 1 + sovRecharge(uint64(m.RechargeId))
	}
	if m.IsPayToken {
		n += 2
	}
	return n
}

func (m *MoneyPayReq) Size() (n int) {
	var l int
	_ = l
	if m.PayType != 0 {
		n += 1 + sovRecharge(uint64(m.PayType))
	}
	if m.PayNum != 0 {
		n += 1 + sovRecharge(uint64(m.PayNum))
	}
	if m.TypeId != 0 {
		n += 1 + sovRecharge(uint64(m.TypeId))
	}
	return n
}

func (m *MoneyPayAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.PayData)
	if l > 0 {
		n += 1 + l + sovRecharge(uint64(l))
	}
	if m.PayType != 0 {
		n += 1 + sovRecharge(uint64(m.PayType))
	}
	if m.PayNum != 0 {
		n += 1 + sovRecharge(uint64(m.PayNum))
	}
	if m.TypeId != 0 {
		n += 1 + sovRecharge(uint64(m.TypeId))
	}
	if m.IsPayToken {
		n += 2
	}
	return n
}

func (m *RechargeResetNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Recharge) > 0 {
		l = 0
		for _, e := range m.Recharge {
			l += sovRecharge(uint64(e))
		}
		n += 1 + sovRecharge(uint64(l)) + l
	}
	return n
}

func (m *ContRechargeCycleNtf) Size() (n int) {
	var l int
	_ = l
	if m.Cycle != 0 {
		n += 1 + sovRecharge(uint64(m.Cycle))
	}
	return n
}

func (m *ContRechargeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Recharge) > 0 {
		for k, v := range m.Recharge {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRecharge(uint64(k)) + 1 + sovRecharge(uint64(v))
			n += mapEntrySize + 1 + sovRecharge(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContRechargeReceiveReq) Size() (n int) {
	var l int
	_ = l
	if m.ContRechargeId != 0 {
		n += 1 + sovRecharge(uint64(m.ContRechargeId))
	}
	return n
}

func (m *ContRechargeReceiveAck) Size() (n int) {
	var l int
	_ = l
	if m.ContRechargeId != 0 {
		n += 1 + sovRecharge(uint64(m.ContRechargeId))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovRecharge(uint64(l))
	}
	return n
}

func sovRecharge(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRecharge(x uint64) (n int) {
	return sovRecharge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RechargFulfilledNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargFulfilledNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargFulfilledNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayMoney", wireType)
			}
			m.PayMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayMoney |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipExp", wireType)
			}
			m.VipExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargedAll", wireType)
			}
			m.RechargedAll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargedAll |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeId", wireType)
			}
			m.RechargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeApplyPayReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeApplyPayReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeApplyPayReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeId", wireType)
			}
			m.RechargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeApplyPayAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeApplyPayAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeApplyPayAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecharge
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeId", wireType)
			}
			m.RechargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayToken = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyPayReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyPayReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyPayReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			m.PayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyPayAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyPayAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyPayAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecharge
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			m.PayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPayToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPayToken = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeResetNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeResetNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeResetNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecharge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Recharge = append(m.Recharge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecharge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecharge
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecharge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Recharge = append(m.Recharge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Recharge", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContRechargeCycleNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContRechargeCycleNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContRechargeCycleNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycle", wireType)
			}
			m.Cycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cycle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContRechargeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContRechargeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContRechargeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecharge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recharge == nil {
				m.Recharge = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecharge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecharge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecharge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRecharge(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRecharge
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Recharge[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContRechargeReceiveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContRechargeReceiveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContRechargeReceiveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContRechargeId", wireType)
			}
			m.ContRechargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContRechargeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContRechargeReceiveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContRechargeReceiveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContRechargeReceiveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContRechargeId", wireType)
			}
			m.ContRechargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContRechargeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecharge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecharge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecharge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecharge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecharge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecharge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRecharge
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRecharge
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRecharge(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRecharge = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecharge   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("recharge.proto", fileDescriptorRecharge) }

var fileDescriptorRecharge = []byte{
	// 505 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6e, 0xd3, 0x40,
	0x14, 0x66, 0xec, 0xda, 0x84, 0x97, 0x52, 0xa2, 0xa1, 0x8a, 0xac, 0x2c, 0xac, 0xe2, 0x05, 0xea,
	0x02, 0x79, 0x51, 0x36, 0x08, 0x84, 0x44, 0x08, 0x05, 0x75, 0xd1, 0xaa, 0xb2, 0x2a, 0xb1, 0x9e,
	0xd8, 0xd3, 0xd4, 0x64, 0xe2, 0x19, 0x1c, 0x27, 0x62, 0x4e, 0xc0, 0x8a, 0x3d, 0x57, 0xe0, 0x00,
	0xdc, 0x81, 0x25, 0x47, 0x40, 0xe1, 0x22, 0x68, 0xc6, 0x33, 0x8d, 0xe3, 0x10, 0x09, 0xb1, 0x9b,
	0xef, 0x7b, 0x2f, 0xdf, 0xfb, 0xde, 0x4f, 0x0c, 0x07, 0x25, 0x4d, 0x6f, 0x48, 0x39, 0xa1, 0xb1,
	0x28, 0x79, 0xc5, 0xb1, 0x23, 0xc6, 0x83, 0xfd, 0x94, 0xcf, 0x66, 0xbc, 0xa8, 0x99, 0xe8, 0x3b,
	0x82, 0x87, 0x49, 0x9d, 0xf4, 0x76, 0xc1, 0xae, 0x73, 0xc6, 0x68, 0x76, 0x51, 0x5d, 0xe3, 0x43,
	0xf0, 0xf2, 0x62, 0xc2, 0xab, 0x00, 0x1d, 0xa1, 0x63, 0x2f, 0xa9, 0x01, 0x1e, 0x40, 0x47, 0x10,
	0x79, 0xce, 0x0b, 0x2a, 0x03, 0x47, 0x07, 0x6e, 0x31, 0xee, 0x81, 0xbb, 0xcc, 0x45, 0xe0, 0x6a,
	0x5a, 0x3d, 0x71, 0x1f, 0xfc, 0x65, 0x2e, 0x4e, 0x3f, 0x89, 0x60, 0x4f, 0x93, 0x06, 0xe1, 0x08,
	0xf6, 0xad, 0xaf, 0x6c, 0xc8, 0x58, 0xe0, 0xe9, 0xe8, 0x06, 0x87, 0x43, 0x00, 0x8b, 0xcf, 0xb2,
	0xc0, 0xd7, 0x19, 0x0d, 0x26, 0x3a, 0xbf, 0xb5, 0x4d, 0x87, 0x42, 0x30, 0x79, 0x49, 0x64, 0x42,
	0x3f, 0xaa, 0x92, 0x82, 0xc8, 0x8b, 0xc5, 0xcc, 0xf8, 0x36, 0xa8, 0x25, 0xe7, 0x6c, 0xc9, 0x7d,
	0x46, 0xdb, 0x7a, 0xc3, 0x74, 0xaa, 0xf4, 0x4a, 0x3a, 0x5f, 0xb0, 0x7a, 0x0e, 0x9d, 0xc4, 0x20,
	0x1c, 0xc0, 0x5d, 0x41, 0xe4, 0x1b, 0x52, 0x11, 0x2d, 0x76, 0x2f, 0xb1, 0xb0, 0x55, 0xc9, 0x6d,
	0x57, 0x52, 0xf1, 0x7c, 0x7e, 0x49, 0xe4, 0x15, 0x9f, 0xd2, 0x42, 0x0f, 0xa6, 0x93, 0x34, 0x98,
	0xe8, 0x3d, 0x74, 0xf5, 0x3c, 0x4d, 0x43, 0x75, 0xa1, 0x2b, 0x29, 0xa8, 0xe9, 0xc8, 0xc2, 0x46,
	0xab, 0xce, 0x46, 0xab, 0x7d, 0xf0, 0x2b, 0x29, 0xd6, 0xc5, 0x0d, 0x8a, 0xbe, 0xa1, 0xb5, 0xf2,
	0xff, 0xb5, 0xd6, 0xf0, 0xe2, 0xee, 0xf2, 0xb2, 0xb7, 0xc3, 0x8b, 0xd7, 0xf4, 0xd2, 0x1a, 0x82,
	0xbf, 0x35, 0x84, 0x18, 0x7a, 0x76, 0x1b, 0x09, 0x9d, 0xd3, 0x4a, 0x5d, 0xe4, 0x00, 0x3a, 0x76,
	0x8c, 0x01, 0x3a, 0x72, 0xd5, 0xed, 0x59, 0x1c, 0x3d, 0x81, 0xc3, 0x11, 0x2f, 0x2a, 0xfb, 0x9b,
	0x91, 0x4c, 0x19, 0x35, 0x57, 0x9c, 0xaa, 0xb7, 0xbd, 0x62, 0x0d, 0xa2, 0x2f, 0x08, 0x1e, 0x34,
	0xd3, 0x55, 0xe6, 0xcb, 0x96, 0x7a, 0xf7, 0xe4, 0x51, 0x2c, 0xc6, 0x71, 0x2b, 0x2d, 0xb6, 0xef,
	0xd3, 0xa2, 0x2a, 0xe5, 0xda, 0xc0, 0xe0, 0x05, 0xdc, 0xdf, 0x08, 0xa9, 0x7f, 0xc3, 0x94, 0x4a,
	0x53, 0x57, 0x3d, 0x95, 0x97, 0x25, 0x61, 0x0b, 0x6a, 0xd6, 0x55, 0x83, 0xe7, 0xce, 0x33, 0x14,
	0xbd, 0x82, 0x7e, 0xb3, 0x4e, 0x42, 0x53, 0x9a, 0x2f, 0xa9, 0xda, 0xfe, 0x63, 0x38, 0x48, 0x1b,
	0x91, 0xb3, 0xcc, 0x08, 0xb6, 0xd8, 0xe8, 0xc3, 0x5f, 0x15, 0xd4, 0x96, 0xff, 0x51, 0x01, 0x1f,
	0x83, 0x37, 0xe1, 0x3c, 0x9b, 0x6b, 0x77, 0xdd, 0x13, 0xac, 0x9a, 0x7f, 0xa7, 0x88, 0xd1, 0x0d,
	0x29, 0x74, 0xef, 0x49, 0x9d, 0xf0, 0xba, 0xf7, 0x63, 0x15, 0xa2, 0x9f, 0xab, 0x10, 0xfd, 0x5a,
	0x85, 0xe8, 0xeb, 0xef, 0xf0, 0xce, 0xd8, 0xd7, 0x9f, 0x92, 0xa7, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x2d, 0x7f, 0x9a, 0x9b, 0x6e, 0x04, 0x00, 0x00,
}
