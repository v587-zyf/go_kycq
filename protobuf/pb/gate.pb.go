// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gate.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ReportGtNoReq struct {
	GateNo int32 `protobuf:"varint,1,opt,name=gateNo,proto3" json:"gateNo,omitempty"`
	GsNo   int32 `protobuf:"varint,2,opt,name=gsNo,proto3" json:"gsNo,omitempty"`
}

func (m *ReportGtNoReq) Reset()                    { *m = ReportGtNoReq{} }
func (m *ReportGtNoReq) String() string            { return proto.CompactTextString(m) }
func (*ReportGtNoReq) ProtoMessage()               {}
func (*ReportGtNoReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{0} }

func (m *ReportGtNoReq) GetGateNo() int32 {
	if m != nil {
		return m.GateNo
	}
	return 0
}

func (m *ReportGtNoReq) GetGsNo() int32 {
	if m != nil {
		return m.GsNo
	}
	return 0
}

// 看gs身上是否需要验证gate的编号
type ReportGtNoAck struct {
	Result   int32  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	GateNo   int32  `protobuf:"varint,2,opt,name=gateNo,proto3" json:"gateNo,omitempty"`
	GateAddr string `protobuf:"bytes,3,opt,name=gateAddr,proto3" json:"gateAddr,omitempty"`
	GsNo     int32  `protobuf:"varint,4,opt,name=gsNo,proto3" json:"gsNo,omitempty"`
}

func (m *ReportGtNoAck) Reset()                    { *m = ReportGtNoAck{} }
func (m *ReportGtNoAck) String() string            { return proto.CompactTextString(m) }
func (*ReportGtNoAck) ProtoMessage()               {}
func (*ReportGtNoAck) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{1} }

func (m *ReportGtNoAck) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *ReportGtNoAck) GetGateNo() int32 {
	if m != nil {
		return m.GateNo
	}
	return 0
}

func (m *ReportGtNoAck) GetGateAddr() string {
	if m != nil {
		return m.GateAddr
	}
	return ""
}

func (m *ReportGtNoAck) GetGsNo() int32 {
	if m != nil {
		return m.GsNo
	}
	return 0
}

type GsBroadCastNtf struct {
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *GsBroadCastNtf) Reset()                    { *m = GsBroadCastNtf{} }
func (m *GsBroadCastNtf) String() string            { return proto.CompactTextString(m) }
func (*GsBroadCastNtf) ProtoMessage()               {}
func (*GsBroadCastNtf) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{2} }

func (m *GsBroadCastNtf) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

type GsMsgNtf struct {
	Indexes []int32 `protobuf:"varint,1,rep,packed,name=indexes" json:"indexes,omitempty"`
	Msg     []byte  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *GsMsgNtf) Reset()                    { *m = GsMsgNtf{} }
func (m *GsMsgNtf) String() string            { return proto.CompactTextString(m) }
func (*GsMsgNtf) ProtoMessage()               {}
func (*GsMsgNtf) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{3} }

func (m *GsMsgNtf) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *GsMsgNtf) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

type ReConnectReq struct {
	Token  string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	OpenId string `protobuf:"bytes,2,opt,name=openId,proto3" json:"openId,omitempty"`
	Magic  int32  `protobuf:"varint,3,opt,name=magic,proto3" json:"magic,omitempty"`
}

func (m *ReConnectReq) Reset()                    { *m = ReConnectReq{} }
func (m *ReConnectReq) String() string            { return proto.CompactTextString(m) }
func (*ReConnectReq) ProtoMessage()               {}
func (*ReConnectReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{4} }

func (m *ReConnectReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ReConnectReq) GetOpenId() string {
	if m != nil {
		return m.OpenId
	}
	return ""
}

func (m *ReConnectReq) GetMagic() int32 {
	if m != nil {
		return m.Magic
	}
	return 0
}

type ReConnectAck struct {
	Fail           int32          `protobuf:"varint,1,opt,name=fail,proto3" json:"fail,omitempty"`
	User           *UserLoginInfo `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	ReConnectToken string         `protobuf:"bytes,99,opt,name=reConnectToken,proto3" json:"reConnectToken,omitempty"`
}

func (m *ReConnectAck) Reset()                    { *m = ReConnectAck{} }
func (m *ReConnectAck) String() string            { return proto.CompactTextString(m) }
func (*ReConnectAck) ProtoMessage()               {}
func (*ReConnectAck) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{5} }

func (m *ReConnectAck) GetFail() int32 {
	if m != nil {
		return m.Fail
	}
	return 0
}

func (m *ReConnectAck) GetUser() *UserLoginInfo {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ReConnectAck) GetReConnectToken() string {
	if m != nil {
		return m.ReConnectToken
	}
	return ""
}

// 22 Logout       -------------主动断开 或 时钟超时
type LogoutReq struct {
	Reason int32 `protobuf:"varint,1,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *LogoutReq) Reset()                    { *m = LogoutReq{} }
func (m *LogoutReq) String() string            { return proto.CompactTextString(m) }
func (*LogoutReq) ProtoMessage()               {}
func (*LogoutReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{6} }

func (m *LogoutReq) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type LogoutAck struct {
	Result int32 `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *LogoutAck) Reset()                    { *m = LogoutAck{} }
func (m *LogoutAck) String() string            { return proto.CompactTextString(m) }
func (*LogoutAck) ProtoMessage()               {}
func (*LogoutAck) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{7} }

func (m *LogoutAck) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 通知gs下线    1:gate---> gs  2:gate<--- gs
type OfflineReq struct {
	Src    int32 `protobuf:"varint,1,opt,name=src,proto3" json:"src,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	CNo    int32 `protobuf:"varint,3,opt,name=CNo,proto3" json:"CNo,omitempty"`
	Reason int32 `protobuf:"varint,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *OfflineReq) Reset()                    { *m = OfflineReq{} }
func (m *OfflineReq) String() string            { return proto.CompactTextString(m) }
func (*OfflineReq) ProtoMessage()               {}
func (*OfflineReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{8} }

func (m *OfflineReq) GetSrc() int32 {
	if m != nil {
		return m.Src
	}
	return 0
}

func (m *OfflineReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *OfflineReq) GetCNo() int32 {
	if m != nil {
		return m.CNo
	}
	return 0
}

func (m *OfflineReq) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type ChatReq struct {
	Typ   int32  `protobuf:"varint,1,opt,name=typ,proto3" json:"typ,omitempty"`
	DesId int32  `protobuf:"varint,2,opt,name=desId,proto3" json:"desId,omitempty"`
	PNo   int32  `protobuf:"varint,3,opt,name=pNo,proto3" json:"pNo,omitempty"`
	Msg   string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ChatReq) Reset()                    { *m = ChatReq{} }
func (m *ChatReq) String() string            { return proto.CompactTextString(m) }
func (*ChatReq) ProtoMessage()               {}
func (*ChatReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{9} }

func (m *ChatReq) GetTyp() int32 {
	if m != nil {
		return m.Typ
	}
	return 0
}

func (m *ChatReq) GetDesId() int32 {
	if m != nil {
		return m.DesId
	}
	return 0
}

func (m *ChatReq) GetPNo() int32 {
	if m != nil {
		return m.PNo
	}
	return 0
}

func (m *ChatReq) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ChatRsp struct {
	Typ   int32  `protobuf:"varint,1,opt,name=typ,proto3" json:"typ,omitempty"`
	SrcId int32  `protobuf:"varint,2,opt,name=srcId,proto3" json:"srcId,omitempty"`
	Msg   string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ChatRsp) Reset()                    { *m = ChatRsp{} }
func (m *ChatRsp) String() string            { return proto.CompactTextString(m) }
func (*ChatRsp) ProtoMessage()               {}
func (*ChatRsp) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{10} }

func (m *ChatRsp) GetTyp() int32 {
	if m != nil {
		return m.Typ
	}
	return 0
}

func (m *ChatRsp) GetSrcId() int32 {
	if m != nil {
		return m.SrcId
	}
	return 0
}

func (m *ChatRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type OnlineNumReq struct {
	GateNo int32 `protobuf:"varint,1,opt,name=gateNo,proto3" json:"gateNo,omitempty"`
}

func (m *OnlineNumReq) Reset()                    { *m = OnlineNumReq{} }
func (m *OnlineNumReq) String() string            { return proto.CompactTextString(m) }
func (*OnlineNumReq) ProtoMessage()               {}
func (*OnlineNumReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{11} }

func (m *OnlineNumReq) GetGateNo() int32 {
	if m != nil {
		return m.GateNo
	}
	return 0
}

type OnlineNumAck struct {
	GsNo    int32 `protobuf:"varint,1,opt,name=gsNo,proto3" json:"gsNo,omitempty"`
	Onlines int32 `protobuf:"varint,2,opt,name=onlines,proto3" json:"onlines,omitempty"`
}

func (m *OnlineNumAck) Reset()                    { *m = OnlineNumAck{} }
func (m *OnlineNumAck) String() string            { return proto.CompactTextString(m) }
func (*OnlineNumAck) ProtoMessage()               {}
func (*OnlineNumAck) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{12} }

func (m *OnlineNumAck) GetGsNo() int32 {
	if m != nil {
		return m.GsNo
	}
	return 0
}

func (m *OnlineNumAck) GetOnlines() int32 {
	if m != nil {
		return m.Onlines
	}
	return 0
}

type MsgNtf struct {
	Typ   int32  `protobuf:"varint,1,opt,name=typ,proto3" json:"typ,omitempty"`
	SrcId int32  `protobuf:"varint,2,opt,name=srcId,proto3" json:"srcId,omitempty"`
	Msg   string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *MsgNtf) Reset()                    { *m = MsgNtf{} }
func (m *MsgNtf) String() string            { return proto.CompactTextString(m) }
func (*MsgNtf) ProtoMessage()               {}
func (*MsgNtf) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{13} }

func (m *MsgNtf) GetTyp() int32 {
	if m != nil {
		return m.Typ
	}
	return 0
}

func (m *MsgNtf) GetSrcId() int32 {
	if m != nil {
		return m.SrcId
	}
	return 0
}

func (m *MsgNtf) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// gs通知gate准备跳gs
type PreJumpGsReq struct {
	CNo    int32 `protobuf:"varint,1,opt,name=cNo,proto3" json:"cNo,omitempty"`
	PNo    int32 `protobuf:"varint,2,opt,name=pNo,proto3" json:"pNo,omitempty"`
	UserId int32 `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *PreJumpGsReq) Reset()                    { *m = PreJumpGsReq{} }
func (m *PreJumpGsReq) String() string            { return proto.CompactTextString(m) }
func (*PreJumpGsReq) ProtoMessage()               {}
func (*PreJumpGsReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{14} }

func (m *PreJumpGsReq) GetCNo() int32 {
	if m != nil {
		return m.CNo
	}
	return 0
}

func (m *PreJumpGsReq) GetPNo() int32 {
	if m != nil {
		return m.PNo
	}
	return 0
}

func (m *PreJumpGsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// gs通知gate进行跳gs
type DoJumpGsReq struct {
	CNo     int32  `protobuf:"varint,1,opt,name=cNo,proto3" json:"cNo,omitempty"`
	PNo     int32  `protobuf:"varint,2,opt,name=pNo,proto3" json:"pNo,omitempty"`
	DesGsNo int32  `protobuf:"varint,3,opt,name=desGsNo,proto3" json:"desGsNo,omitempty"`
	Reason  int32  `protobuf:"varint,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Args    []byte `protobuf:"bytes,5,opt,name=args,proto3" json:"args,omitempty"`
	UserId  int32  `protobuf:"varint,6,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *DoJumpGsReq) Reset()                    { *m = DoJumpGsReq{} }
func (m *DoJumpGsReq) String() string            { return proto.CompactTextString(m) }
func (*DoJumpGsReq) ProtoMessage()               {}
func (*DoJumpGsReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{15} }

func (m *DoJumpGsReq) GetCNo() int32 {
	if m != nil {
		return m.CNo
	}
	return 0
}

func (m *DoJumpGsReq) GetPNo() int32 {
	if m != nil {
		return m.PNo
	}
	return 0
}

func (m *DoJumpGsReq) GetDesGsNo() int32 {
	if m != nil {
		return m.DesGsNo
	}
	return 0
}

func (m *DoJumpGsReq) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *DoJumpGsReq) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *DoJumpGsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// gate通知gs，玩家跳gs进入
type JumpGsReq struct {
	CNo    int32 `protobuf:"varint,1,opt,name=cNo,proto3" json:"cNo,omitempty"`
	PNo    int32 `protobuf:"varint,2,opt,name=pNo,proto3" json:"pNo,omitempty"`
	Reason int32 `protobuf:"varint,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Arg1   int32 `protobuf:"varint,4,opt,name=arg1,proto3" json:"arg1,omitempty"`
	UserId int32 `protobuf:"varint,6,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *JumpGsReq) Reset()                    { *m = JumpGsReq{} }
func (m *JumpGsReq) String() string            { return proto.CompactTextString(m) }
func (*JumpGsReq) ProtoMessage()               {}
func (*JumpGsReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{16} }

func (m *JumpGsReq) GetCNo() int32 {
	if m != nil {
		return m.CNo
	}
	return 0
}

func (m *JumpGsReq) GetPNo() int32 {
	if m != nil {
		return m.PNo
	}
	return 0
}

func (m *JumpGsReq) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *JumpGsReq) GetArg1() int32 {
	if m != nil {
		return m.Arg1
	}
	return 0
}

func (m *JumpGsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type BenchMarkReq struct {
	Magic  int64 `protobuf:"varint,1,opt,name=magic,proto3" json:"magic,omitempty"`
	Magic2 int64 `protobuf:"varint,2,opt,name=magic2,proto3" json:"magic2,omitempty"`
	Magic3 int64 `protobuf:"varint,3,opt,name=magic3,proto3" json:"magic3,omitempty"`
	Magic4 int64 `protobuf:"varint,4,opt,name=magic4,proto3" json:"magic4,omitempty"`
}

func (m *BenchMarkReq) Reset()                    { *m = BenchMarkReq{} }
func (m *BenchMarkReq) String() string            { return proto.CompactTextString(m) }
func (*BenchMarkReq) ProtoMessage()               {}
func (*BenchMarkReq) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{17} }

func (m *BenchMarkReq) GetMagic() int64 {
	if m != nil {
		return m.Magic
	}
	return 0
}

func (m *BenchMarkReq) GetMagic2() int64 {
	if m != nil {
		return m.Magic2
	}
	return 0
}

func (m *BenchMarkReq) GetMagic3() int64 {
	if m != nil {
		return m.Magic3
	}
	return 0
}

func (m *BenchMarkReq) GetMagic4() int64 {
	if m != nil {
		return m.Magic4
	}
	return 0
}

type BenchMarkAck struct {
	Magic    int64 `protobuf:"varint,1,opt,name=magic,proto3" json:"magic,omitempty"`
	Magic2   int64 `protobuf:"varint,2,opt,name=magic2,proto3" json:"magic2,omitempty"`
	Magic3   int64 `protobuf:"varint,3,opt,name=magic3,proto3" json:"magic3,omitempty"`
	Magic4   int64 `protobuf:"varint,4,opt,name=magic4,proto3" json:"magic4,omitempty"`
	Magic100 int64 `protobuf:"varint,100,opt,name=magic100,proto3" json:"magic100,omitempty"`
}

func (m *BenchMarkAck) Reset()                    { *m = BenchMarkAck{} }
func (m *BenchMarkAck) String() string            { return proto.CompactTextString(m) }
func (*BenchMarkAck) ProtoMessage()               {}
func (*BenchMarkAck) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{18} }

func (m *BenchMarkAck) GetMagic() int64 {
	if m != nil {
		return m.Magic
	}
	return 0
}

func (m *BenchMarkAck) GetMagic2() int64 {
	if m != nil {
		return m.Magic2
	}
	return 0
}

func (m *BenchMarkAck) GetMagic3() int64 {
	if m != nil {
		return m.Magic3
	}
	return 0
}

func (m *BenchMarkAck) GetMagic4() int64 {
	if m != nil {
		return m.Magic4
	}
	return 0
}

func (m *BenchMarkAck) GetMagic100() int64 {
	if m != nil {
		return m.Magic100
	}
	return 0
}

type KeepAliveRpt struct {
	Mark int32 `protobuf:"varint,1,opt,name=mark,proto3" json:"mark,omitempty"`
}

func (m *KeepAliveRpt) Reset()                    { *m = KeepAliveRpt{} }
func (m *KeepAliveRpt) String() string            { return proto.CompactTextString(m) }
func (*KeepAliveRpt) ProtoMessage()               {}
func (*KeepAliveRpt) Descriptor() ([]byte, []int) { return fileDescriptorGate, []int{19} }

func (m *KeepAliveRpt) GetMark() int32 {
	if m != nil {
		return m.Mark
	}
	return 0
}

func init() {
	proto.RegisterType((*ReportGtNoReq)(nil), "pb.ReportGtNoReq")
	proto.RegisterType((*ReportGtNoAck)(nil), "pb.ReportGtNoAck")
	proto.RegisterType((*GsBroadCastNtf)(nil), "pb.GsBroadCastNtf")
	proto.RegisterType((*GsMsgNtf)(nil), "pb.GsMsgNtf")
	proto.RegisterType((*ReConnectReq)(nil), "pb.ReConnectReq")
	proto.RegisterType((*ReConnectAck)(nil), "pb.ReConnectAck")
	proto.RegisterType((*LogoutReq)(nil), "pb.LogoutReq")
	proto.RegisterType((*LogoutAck)(nil), "pb.LogoutAck")
	proto.RegisterType((*OfflineReq)(nil), "pb.OfflineReq")
	proto.RegisterType((*ChatReq)(nil), "pb.ChatReq")
	proto.RegisterType((*ChatRsp)(nil), "pb.ChatRsp")
	proto.RegisterType((*OnlineNumReq)(nil), "pb.OnlineNumReq")
	proto.RegisterType((*OnlineNumAck)(nil), "pb.OnlineNumAck")
	proto.RegisterType((*MsgNtf)(nil), "pb.MsgNtf")
	proto.RegisterType((*PreJumpGsReq)(nil), "pb.PreJumpGsReq")
	proto.RegisterType((*DoJumpGsReq)(nil), "pb.DoJumpGsReq")
	proto.RegisterType((*JumpGsReq)(nil), "pb.JumpGsReq")
	proto.RegisterType((*BenchMarkReq)(nil), "pb.BenchMarkReq")
	proto.RegisterType((*BenchMarkAck)(nil), "pb.BenchMarkAck")
	proto.RegisterType((*KeepAliveRpt)(nil), "pb.KeepAliveRpt")
}
func (m *ReportGtNoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportGtNoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GateNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GateNo))
	}
	if m.GsNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GsNo))
	}
	return i, nil
}

func (m *ReportGtNoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportGtNoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Result))
	}
	if m.GateNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GateNo))
	}
	if len(m.GateAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.GateAddr)))
		i += copy(dAtA[i:], m.GateAddr)
	}
	if m.GsNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GsNo))
	}
	return i, nil
}

func (m *GsBroadCastNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsBroadCastNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *GsMsgNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsMsgNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		dAtA2 := make([]byte, len(m.Indexes)*10)
		var j1 int
		for _, num1 := range m.Indexes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintGate(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *ReConnectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReConnectReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.OpenId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.OpenId)))
		i += copy(dAtA[i:], m.OpenId)
	}
	if m.Magic != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic))
	}
	return i, nil
}

func (m *ReConnectAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReConnectAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fail != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Fail))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.User.Size()))
		n3, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.ReConnectToken) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.ReConnectToken)))
		i += copy(dAtA[i:], m.ReConnectToken)
	}
	return i, nil
}

func (m *LogoutReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *LogoutAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *OfflineReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Src != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Src))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.UserId))
	}
	if m.CNo != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.CNo))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *ChatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Typ))
	}
	if m.DesId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.DesId))
	}
	if m.PNo != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.PNo))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *ChatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Typ))
	}
	if m.SrcId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.SrcId))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *OnlineNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnlineNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GateNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GateNo))
	}
	return i, nil
}

func (m *OnlineNumAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnlineNumAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GsNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.GsNo))
	}
	if m.Onlines != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Onlines))
	}
	return i, nil
}

func (m *MsgNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Typ))
	}
	if m.SrcId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.SrcId))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *PreJumpGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreJumpGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.CNo))
	}
	if m.PNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.PNo))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *DoJumpGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoJumpGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.CNo))
	}
	if m.PNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.PNo))
	}
	if m.DesGsNo != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.DesGsNo))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Reason))
	}
	if len(m.Args) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGate(dAtA, i, uint64(len(m.Args)))
		i += copy(dAtA[i:], m.Args)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *JumpGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JumpGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.CNo))
	}
	if m.PNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.PNo))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Reason))
	}
	if m.Arg1 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Arg1))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *BenchMarkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchMarkReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Magic != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic))
	}
	if m.Magic2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic2))
	}
	if m.Magic3 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic3))
	}
	if m.Magic4 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic4))
	}
	return i, nil
}

func (m *BenchMarkAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchMarkAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Magic != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic))
	}
	if m.Magic2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic2))
	}
	if m.Magic3 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic3))
	}
	if m.Magic4 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic4))
	}
	if m.Magic100 != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Magic100))
	}
	return i, nil
}

func (m *KeepAliveRpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAliveRpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mark != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGate(dAtA, i, uint64(m.Mark))
	}
	return i, nil
}

func encodeVarintGate(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReportGtNoReq) Size() (n int) {
	var l int
	_ = l
	if m.GateNo != 0 {
		n += 1 + sovGate(uint64(m.GateNo))
	}
	if m.GsNo != 0 {
		n += 1 + sovGate(uint64(m.GsNo))
	}
	return n
}

func (m *ReportGtNoAck) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGate(uint64(m.Result))
	}
	if m.GateNo != 0 {
		n += 1 + sovGate(uint64(m.GateNo))
	}
	l = len(m.GateAddr)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	if m.GsNo != 0 {
		n += 1 + sovGate(uint64(m.GsNo))
	}
	return n
}

func (m *GsBroadCastNtf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	return n
}

func (m *GsMsgNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		l = 0
		for _, e := range m.Indexes {
			l += sovGate(uint64(e))
		}
		n += 1 + sovGate(uint64(l)) + l
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	return n
}

func (m *ReConnectReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	l = len(m.OpenId)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	if m.Magic != 0 {
		n += 1 + sovGate(uint64(m.Magic))
	}
	return n
}

func (m *ReConnectAck) Size() (n int) {
	var l int
	_ = l
	if m.Fail != 0 {
		n += 1 + sovGate(uint64(m.Fail))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGate(uint64(l))
	}
	l = len(m.ReConnectToken)
	if l > 0 {
		n += 2 + l + sovGate(uint64(l))
	}
	return n
}

func (m *LogoutReq) Size() (n int) {
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovGate(uint64(m.Reason))
	}
	return n
}

func (m *LogoutAck) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGate(uint64(m.Result))
	}
	return n
}

func (m *OfflineReq) Size() (n int) {
	var l int
	_ = l
	if m.Src != 0 {
		n += 1 + sovGate(uint64(m.Src))
	}
	if m.UserId != 0 {
		n += 1 + sovGate(uint64(m.UserId))
	}
	if m.CNo != 0 {
		n += 1 + sovGate(uint64(m.CNo))
	}
	if m.Reason != 0 {
		n += 1 + sovGate(uint64(m.Reason))
	}
	return n
}

func (m *ChatReq) Size() (n int) {
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovGate(uint64(m.Typ))
	}
	if m.DesId != 0 {
		n += 1 + sovGate(uint64(m.DesId))
	}
	if m.PNo != 0 {
		n += 1 + sovGate(uint64(m.PNo))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	return n
}

func (m *ChatRsp) Size() (n int) {
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovGate(uint64(m.Typ))
	}
	if m.SrcId != 0 {
		n += 1 + sovGate(uint64(m.SrcId))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	return n
}

func (m *OnlineNumReq) Size() (n int) {
	var l int
	_ = l
	if m.GateNo != 0 {
		n += 1 + sovGate(uint64(m.GateNo))
	}
	return n
}

func (m *OnlineNumAck) Size() (n int) {
	var l int
	_ = l
	if m.GsNo != 0 {
		n += 1 + sovGate(uint64(m.GsNo))
	}
	if m.Onlines != 0 {
		n += 1 + sovGate(uint64(m.Onlines))
	}
	return n
}

func (m *MsgNtf) Size() (n int) {
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovGate(uint64(m.Typ))
	}
	if m.SrcId != 0 {
		n += 1 + sovGate(uint64(m.SrcId))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	return n
}

func (m *PreJumpGsReq) Size() (n int) {
	var l int
	_ = l
	if m.CNo != 0 {
		n += 1 + sovGate(uint64(m.CNo))
	}
	if m.PNo != 0 {
		n += 1 + sovGate(uint64(m.PNo))
	}
	if m.UserId != 0 {
		n += 1 + sovGate(uint64(m.UserId))
	}
	return n
}

func (m *DoJumpGsReq) Size() (n int) {
	var l int
	_ = l
	if m.CNo != 0 {
		n += 1 + sovGate(uint64(m.CNo))
	}
	if m.PNo != 0 {
		n += 1 + sovGate(uint64(m.PNo))
	}
	if m.DesGsNo != 0 {
		n += 1 + sovGate(uint64(m.DesGsNo))
	}
	if m.Reason != 0 {
		n += 1 + sovGate(uint64(m.Reason))
	}
	l = len(m.Args)
	if l > 0 {
		n += 1 + l + sovGate(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovGate(uint64(m.UserId))
	}
	return n
}

func (m *JumpGsReq) Size() (n int) {
	var l int
	_ = l
	if m.CNo != 0 {
		n += 1 + sovGate(uint64(m.CNo))
	}
	if m.PNo != 0 {
		n += 1 + sovGate(uint64(m.PNo))
	}
	if m.Reason != 0 {
		n += 1 + sovGate(uint64(m.Reason))
	}
	if m.Arg1 != 0 {
		n += 1 + sovGate(uint64(m.Arg1))
	}
	if m.UserId != 0 {
		n += 1 + sovGate(uint64(m.UserId))
	}
	return n
}

func (m *BenchMarkReq) Size() (n int) {
	var l int
	_ = l
	if m.Magic != 0 {
		n += 1 + sovGate(uint64(m.Magic))
	}
	if m.Magic2 != 0 {
		n += 1 + sovGate(uint64(m.Magic2))
	}
	if m.Magic3 != 0 {
		n += 1 + sovGate(uint64(m.Magic3))
	}
	if m.Magic4 != 0 {
		n += 1 + sovGate(uint64(m.Magic4))
	}
	return n
}

func (m *BenchMarkAck) Size() (n int) {
	var l int
	_ = l
	if m.Magic != 0 {
		n += 1 + sovGate(uint64(m.Magic))
	}
	if m.Magic2 != 0 {
		n += 1 + sovGate(uint64(m.Magic2))
	}
	if m.Magic3 != 0 {
		n += 1 + sovGate(uint64(m.Magic3))
	}
	if m.Magic4 != 0 {
		n += 1 + sovGate(uint64(m.Magic4))
	}
	if m.Magic100 != 0 {
		n += 2 + sovGate(uint64(m.Magic100))
	}
	return n
}

func (m *KeepAliveRpt) Size() (n int) {
	var l int
	_ = l
	if m.Mark != 0 {
		n += 1 + sovGate(uint64(m.Mark))
	}
	return n
}

func sovGate(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGate(x uint64) (n int) {
	return sovGate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReportGtNoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportGtNoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportGtNoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateNo", wireType)
			}
			m.GateNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GsNo", wireType)
			}
			m.GsNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GsNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportGtNoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportGtNoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportGtNoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateNo", wireType)
			}
			m.GateNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GateAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GsNo", wireType)
			}
			m.GsNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GsNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsBroadCastNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsBroadCastNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsBroadCastNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsMsgNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsMsgNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsMsgNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGate
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indexes = append(m.Indexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGate
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGate
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGate
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indexes = append(m.Indexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReConnectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReConnectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReConnectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			m.Magic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReConnectAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReConnectAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReConnectAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fail", wireType)
			}
			m.Fail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fail |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserLoginInfo{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReConnectToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReConnectToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNo", wireType)
			}
			m.CNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesId", wireType)
			}
			m.DesId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PNo", wireType)
			}
			m.PNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcId", wireType)
			}
			m.SrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnlineNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateNo", wireType)
			}
			m.GateNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnlineNumAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineNumAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineNumAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GsNo", wireType)
			}
			m.GsNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GsNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Onlines", wireType)
			}
			m.Onlines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Onlines |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcId", wireType)
			}
			m.SrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreJumpGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreJumpGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreJumpGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNo", wireType)
			}
			m.CNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PNo", wireType)
			}
			m.PNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoJumpGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoJumpGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoJumpGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNo", wireType)
			}
			m.CNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PNo", wireType)
			}
			m.PNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesGsNo", wireType)
			}
			m.DesGsNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesGsNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGate
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JumpGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JumpGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JumpGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNo", wireType)
			}
			m.CNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PNo", wireType)
			}
			m.PNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PNo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg1", wireType)
			}
			m.Arg1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arg1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchMarkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchMarkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchMarkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			m.Magic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic2", wireType)
			}
			m.Magic2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic2 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic3", wireType)
			}
			m.Magic3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic3 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic4", wireType)
			}
			m.Magic4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic4 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchMarkAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchMarkAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchMarkAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			m.Magic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic2", wireType)
			}
			m.Magic2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic2 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic3", wireType)
			}
			m.Magic3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic3 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic4", wireType)
			}
			m.Magic4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic4 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic100", wireType)
			}
			m.Magic100 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic100 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeepAliveRpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAliveRpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAliveRpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			m.Mark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mark |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGate
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGate
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGate(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGate = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGate   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gate.proto", fileDescriptorGate) }

var fileDescriptorGate = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0x92, 0x36, 0x53, 0x53, 0x15, 0x0b, 0x21, 0xab, 0x87, 0xa8, 0x5a, 0x44, 0xd5,
	0x53, 0xd5, 0x3f, 0x71, 0x81, 0x4b, 0x13, 0xa4, 0xa8, 0xa5, 0x75, 0xd1, 0x8a, 0xde, 0x71, 0xed,
	0x8d, 0x1b, 0x25, 0xf6, 0x6e, 0x77, 0x37, 0x88, 0xbe, 0x01, 0x37, 0xae, 0x3c, 0x12, 0x47, 0x1e,
	0x01, 0x95, 0x17, 0x41, 0xb3, 0xd9, 0xb5, 0x5d, 0xd4, 0x56, 0x2a, 0x12, 0xb7, 0xf9, 0xc6, 0x33,
	0xdf, 0xcc, 0x7e, 0x33, 0xbb, 0x06, 0xc8, 0x13, 0xcd, 0xb6, 0x85, 0xe4, 0x9a, 0x87, 0x2d, 0x71,
	0xb1, 0x1e, 0xa4, 0xbc, 0x28, 0x78, 0xb9, 0xf0, 0x90, 0x37, 0xf0, 0x94, 0x32, 0xc1, 0xa5, 0x1e,
	0xe9, 0x98, 0x53, 0x76, 0x15, 0xbe, 0x80, 0x2e, 0x26, 0xc4, 0x3c, 0xf2, 0x36, 0xbc, 0xad, 0x0e,
	0xb5, 0x28, 0x0c, 0xa1, 0x9d, 0xab, 0x98, 0x47, 0x2d, 0xe3, 0x35, 0x36, 0xe1, 0xcd, 0xe4, 0xc3,
	0x74, 0x8a, 0xc9, 0x92, 0xa9, 0xf9, 0x4c, 0xbb, 0xe4, 0x05, 0x6a, 0x90, 0xb6, 0x6e, 0x91, 0xae,
	0xc3, 0x32, 0x5a, 0x87, 0x59, 0x26, 0x23, 0x7f, 0xc3, 0xdb, 0xea, 0xd1, 0x0a, 0x57, 0x05, 0xdb,
	0x8d, 0x82, 0x04, 0x56, 0x47, 0x6a, 0x20, 0x79, 0x92, 0x0d, 0x13, 0xa5, 0x63, 0x3d, 0x0e, 0xd7,
	0xc0, 0x2f, 0x54, 0x6e, 0xca, 0x05, 0x14, 0x4d, 0xf2, 0x1a, 0x96, 0x47, 0xea, 0x54, 0xe5, 0xf8,
	0x35, 0x82, 0xa5, 0x49, 0x99, 0xb1, 0x2f, 0x4c, 0x45, 0xde, 0x86, 0xbf, 0xd5, 0xa1, 0x0e, 0xba,
	0xbc, 0x56, 0x9d, 0x47, 0x21, 0xa0, 0x6c, 0xc8, 0xcb, 0x92, 0xa5, 0x1a, 0x85, 0x78, 0x0e, 0x1d,
	0xcd, 0xa7, 0xac, 0x34, 0xdc, 0x3d, 0xba, 0x00, 0x78, 0x12, 0x2e, 0x58, 0x79, 0x94, 0x99, 0xd4,
	0x1e, 0xb5, 0x08, 0xa3, 0x8b, 0x24, 0x9f, 0xa4, 0xe6, 0x18, 0x1d, 0xba, 0x00, 0xe4, 0xaa, 0xc1,
	0x89, 0xfa, 0x84, 0xd0, 0x1e, 0x27, 0x93, 0x99, 0x55, 0xc7, 0xd8, 0xe1, 0x2b, 0x68, 0xcf, 0x15,
	0x93, 0x86, 0x6f, 0x65, 0xef, 0xd9, 0xb6, 0xb8, 0xd8, 0x3e, 0x57, 0x4c, 0x9e, 0xf0, 0x7c, 0x52,
	0x1e, 0x95, 0x63, 0x4e, 0xcd, 0xe7, 0x70, 0x13, 0x56, 0xa5, 0xa3, 0xfa, 0x68, 0xfa, 0x4a, 0x4d,
	0x03, 0x7f, 0x79, 0xc9, 0x4b, 0xe8, 0x9d, 0xf0, 0x9c, 0xcf, 0xb5, 0x1d, 0xa6, 0x64, 0x89, 0xe2,
	0x65, 0x3d, 0x0f, 0x44, 0x75, 0xd0, 0x03, 0x43, 0x23, 0x9f, 0x00, 0xce, 0xc6, 0xe3, 0xd9, 0xa4,
	0x64, 0x48, 0xb5, 0x06, 0xbe, 0x92, 0xa9, 0x0d, 0x41, 0x13, 0xf3, 0xb0, 0x33, 0x2b, 0x45, 0x87,
	0x5a, 0x84, 0x91, 0xc3, 0x98, 0x5b, 0x21, 0xd0, 0x6c, 0xb4, 0xd1, 0xbe, 0xd5, 0xc6, 0x39, 0x2c,
	0x0d, 0x2f, 0x13, 0x6d, 0xe9, 0xf5, 0xb5, 0x70, 0xf4, 0xfa, 0x5a, 0xa0, 0xa2, 0x19, 0x53, 0x15,
	0xfb, 0x02, 0x60, 0x9c, 0xa8, 0xc9, 0x45, 0xcc, 0xdd, 0x24, 0xdb, 0x46, 0x0d, 0x33, 0xc9, 0xa1,
	0xa5, 0x55, 0xe2, 0x6e, 0x5a, 0x25, 0xd3, 0x9a, 0xd6, 0x00, 0x47, 0xe2, 0xd7, 0x24, 0x9b, 0x10,
	0x9c, 0x95, 0x78, 0xf8, 0x78, 0x5e, 0x3c, 0x70, 0x2f, 0xc8, 0xdb, 0x46, 0x9c, 0x1d, 0xb1, 0x59,
	0x5b, 0xaf, 0x5e, 0x5b, 0x5c, 0x43, 0x6e, 0x62, 0x94, 0xad, 0xea, 0x20, 0x19, 0x40, 0xd7, 0xae,
	0xea, 0xbf, 0x77, 0x7a, 0x0c, 0xc1, 0x07, 0xc9, 0x8e, 0xe7, 0x85, 0x18, 0x29, 0x2b, 0x65, 0x5a,
	0x35, 0x80, 0xa6, 0x13, 0xad, 0x55, 0x8b, 0x56, 0xcf, 0xce, 0x6f, 0xce, 0x8e, 0x7c, 0xf3, 0x60,
	0xe5, 0x1d, 0x7f, 0x1c, 0x57, 0x04, 0x4b, 0x19, 0x53, 0x23, 0x55, 0x8d, 0xc5, 0xc1, 0xfb, 0xe6,
	0x8e, 0x1a, 0x25, 0x32, 0x57, 0x51, 0xc7, 0xdc, 0x3e, 0x63, 0x37, 0x3a, 0xea, 0xde, 0xea, 0x48,
	0x41, 0xef, 0xd1, 0x47, 0xb3, 0x45, 0xfd, 0x3b, 0x8a, 0xee, 0xba, 0xf7, 0x04, 0xed, 0x7b, 0x8b,
	0xce, 0x20, 0x18, 0xb0, 0x32, 0xbd, 0x3c, 0x4d, 0xe4, 0xd4, 0xbe, 0x05, 0x8b, 0xdb, 0x8d, 0x95,
	0x7d, 0x7b, 0xbb, 0x31, 0xdb, 0x18, 0x7b, 0xa6, 0xbc, 0x4f, 0x2d, 0xaa, 0xfc, 0xfb, 0xa6, 0x03,
	0xe7, 0xdf, 0xaf, 0xfc, 0x07, 0xa6, 0x07, 0xe7, 0x3f, 0x20, 0x5f, 0xbd, 0x46, 0x39, 0xdc, 0xa1,
	0xff, 0x5a, 0x0e, 0x1f, 0x5d, 0x63, 0xed, 0xee, 0xec, 0x44, 0x99, 0xf9, 0x52, 0x61, 0x42, 0x20,
	0x78, 0xcf, 0x98, 0x38, 0x9c, 0x4d, 0x3e, 0x33, 0x2a, 0x34, 0x8a, 0x56, 0x24, 0x72, 0xea, 0xb6,
	0x19, 0xed, 0xc1, 0xda, 0x8f, 0x9b, 0xbe, 0xf7, 0xf3, 0xa6, 0xef, 0xfd, 0xba, 0xe9, 0x7b, 0xdf,
	0x7f, 0xf7, 0x9f, 0x5c, 0x74, 0xcd, 0xbf, 0x64, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5a,
	0xb4, 0x13, 0xbc, 0x6b, 0x06, 0x00, 0x00,
}
