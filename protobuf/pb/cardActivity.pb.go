// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cardActivity.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 申请抽卡
type CardActivityApplyGetReq struct {
	Times int32 `protobuf:"varint,1,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *CardActivityApplyGetReq) Reset()         { *m = CardActivityApplyGetReq{} }
func (m *CardActivityApplyGetReq) String() string { return proto.CompactTextString(m) }
func (*CardActivityApplyGetReq) ProtoMessage()    {}
func (*CardActivityApplyGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptorCardActivity, []int{0}
}

func (m *CardActivityApplyGetReq) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

// 抽卡结果
type CardActivityApplyGetAck struct {
	Cards          []int32         `protobuf:"varint,1,rep,packed,name=cards" json:"cards,omitempty"`
	CardTime       int32           `protobuf:"varint,2,opt,name=cardTime,proto3" json:"cardTime,omitempty"`
	Goods          *GoodsChangeNtf `protobuf:"bytes,3,opt,name=goods" json:"goods,omitempty"`
	Type           int32           `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	MyDrawInfo     []*CardInfoUnit `protobuf:"bytes,5,rep,name=myDrawInfo" json:"myDrawInfo,omitempty"`
	ServerDrawInfo []*CardInfoUnit `protobuf:"bytes,6,rep,name=serverDrawInfo" json:"serverDrawInfo,omitempty"`
	Integral       int32           `protobuf:"varint,7,opt,name=integral,proto3" json:"integral,omitempty"`
}

func (m *CardActivityApplyGetAck) Reset()         { *m = CardActivityApplyGetAck{} }
func (m *CardActivityApplyGetAck) String() string { return proto.CompactTextString(m) }
func (*CardActivityApplyGetAck) ProtoMessage()    {}
func (*CardActivityApplyGetAck) Descriptor() ([]byte, []int) {
	return fileDescriptorCardActivity, []int{1}
}

func (m *CardActivityApplyGetAck) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *CardActivityApplyGetAck) GetCardTime() int32 {
	if m != nil {
		return m.CardTime
	}
	return 0
}

func (m *CardActivityApplyGetAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *CardActivityApplyGetAck) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CardActivityApplyGetAck) GetMyDrawInfo() []*CardInfoUnit {
	if m != nil {
		return m.MyDrawInfo
	}
	return nil
}

func (m *CardActivityApplyGetAck) GetServerDrawInfo() []*CardInfoUnit {
	if m != nil {
		return m.ServerDrawInfo
	}
	return nil
}

func (m *CardActivityApplyGetAck) GetIntegral() int32 {
	if m != nil {
		return m.Integral
	}
	return 0
}

// 抽卡信息
type CardActivityInfosReq struct {
}

func (m *CardActivityInfosReq) Reset()                    { *m = CardActivityInfosReq{} }
func (m *CardActivityInfosReq) String() string            { return proto.CompactTextString(m) }
func (*CardActivityInfosReq) ProtoMessage()               {}
func (*CardActivityInfosReq) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{2} }

// 抽卡信息
type CardActivityInfosAck struct {
	Integral           int32           `protobuf:"varint,1,opt,name=integral,proto3" json:"integral,omitempty"`
	TotalDrawCardTimes int32           `protobuf:"varint,2,opt,name=totalDrawCardTimes,proto3" json:"totalDrawCardTimes,omitempty"`
	MyDrawInfo         []*CardInfoUnit `protobuf:"bytes,3,rep,name=myDrawInfo" json:"myDrawInfo,omitempty"`
	ServerDrawInfo     []*CardInfoUnit `protobuf:"bytes,4,rep,name=serverDrawInfo" json:"serverDrawInfo,omitempty"`
	HaveGetIndex       []int32         `protobuf:"varint,5,rep,packed,name=haveGetIndex" json:"haveGetIndex,omitempty"`
	NowSeason          int32           `protobuf:"varint,6,opt,name=nowSeason,proto3" json:"nowSeason,omitempty"`
	MergeMark          int32           `protobuf:"varint,7,opt,name=mergeMark,proto3" json:"mergeMark,omitempty"`
}

func (m *CardActivityInfosAck) Reset()                    { *m = CardActivityInfosAck{} }
func (m *CardActivityInfosAck) String() string            { return proto.CompactTextString(m) }
func (*CardActivityInfosAck) ProtoMessage()               {}
func (*CardActivityInfosAck) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{3} }

func (m *CardActivityInfosAck) GetIntegral() int32 {
	if m != nil {
		return m.Integral
	}
	return 0
}

func (m *CardActivityInfosAck) GetTotalDrawCardTimes() int32 {
	if m != nil {
		return m.TotalDrawCardTimes
	}
	return 0
}

func (m *CardActivityInfosAck) GetMyDrawInfo() []*CardInfoUnit {
	if m != nil {
		return m.MyDrawInfo
	}
	return nil
}

func (m *CardActivityInfosAck) GetServerDrawInfo() []*CardInfoUnit {
	if m != nil {
		return m.ServerDrawInfo
	}
	return nil
}

func (m *CardActivityInfosAck) GetHaveGetIndex() []int32 {
	if m != nil {
		return m.HaveGetIndex
	}
	return nil
}

func (m *CardActivityInfosAck) GetNowSeason() int32 {
	if m != nil {
		return m.NowSeason
	}
	return 0
}

func (m *CardActivityInfosAck) GetMergeMark() int32 {
	if m != nil {
		return m.MergeMark
	}
	return 0
}

// 返回键抽卡信息
type CardInfoUnit struct {
	ItemId   int32  `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count    int32  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Time     int32  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	UserName string `protobuf:"bytes,4,opt,name=userName,proto3" json:"userName,omitempty"`
	Type     int32  `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *CardInfoUnit) Reset()                    { *m = CardInfoUnit{} }
func (m *CardInfoUnit) String() string            { return proto.CompactTextString(m) }
func (*CardInfoUnit) ProtoMessage()               {}
func (*CardInfoUnit) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{4} }

func (m *CardInfoUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CardInfoUnit) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CardInfoUnit) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CardInfoUnit) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *CardInfoUnit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type CardInfoNtf struct {
	ItemId   int32  `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Time     int32  `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	UserName string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
}

func (m *CardInfoNtf) Reset()                    { *m = CardInfoNtf{} }
func (m *CardInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*CardInfoNtf) ProtoMessage()               {}
func (*CardInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{5} }

func (m *CardInfoNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CardInfoNtf) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CardInfoNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

// 积分商城
type GetIntegralAwardReq struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Times int32 `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *GetIntegralAwardReq) Reset()                    { *m = GetIntegralAwardReq{} }
func (m *GetIntegralAwardReq) String() string            { return proto.CompactTextString(m) }
func (*GetIntegralAwardReq) ProtoMessage()               {}
func (*GetIntegralAwardReq) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{6} }

func (m *GetIntegralAwardReq) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetIntegralAwardReq) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

type GetIntegralAwardAck struct {
	HaveGetIndex []int32         `protobuf:"varint,1,rep,packed,name=haveGetIndex" json:"haveGetIndex,omitempty"`
	Integral     int32           `protobuf:"varint,2,opt,name=integral,proto3" json:"integral,omitempty"`
	Goods        *GoodsChangeNtf `protobuf:"bytes,3,opt,name=goods" json:"goods,omitempty"`
}

func (m *GetIntegralAwardAck) Reset()                    { *m = GetIntegralAwardAck{} }
func (m *GetIntegralAwardAck) String() string            { return proto.CompactTextString(m) }
func (*GetIntegralAwardAck) ProtoMessage()               {}
func (*GetIntegralAwardAck) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{7} }

func (m *GetIntegralAwardAck) GetHaveGetIndex() []int32 {
	if m != nil {
		return m.HaveGetIndex
	}
	return nil
}

func (m *GetIntegralAwardAck) GetIntegral() int32 {
	if m != nil {
		return m.Integral
	}
	return 0
}

func (m *GetIntegralAwardAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

type CardCloseNtf struct {
	IsClose bool `protobuf:"varint,1,opt,name=isClose,proto3" json:"isClose,omitempty"`
}

func (m *CardCloseNtf) Reset()                    { *m = CardCloseNtf{} }
func (m *CardCloseNtf) String() string            { return proto.CompactTextString(m) }
func (*CardCloseNtf) ProtoMessage()               {}
func (*CardCloseNtf) Descriptor() ([]byte, []int) { return fileDescriptorCardActivity, []int{8} }

func (m *CardCloseNtf) GetIsClose() bool {
	if m != nil {
		return m.IsClose
	}
	return false
}

func init() {
	proto.RegisterType((*CardActivityApplyGetReq)(nil), "pb.CardActivityApplyGetReq")
	proto.RegisterType((*CardActivityApplyGetAck)(nil), "pb.CardActivityApplyGetAck")
	proto.RegisterType((*CardActivityInfosReq)(nil), "pb.CardActivityInfosReq")
	proto.RegisterType((*CardActivityInfosAck)(nil), "pb.CardActivityInfosAck")
	proto.RegisterType((*CardInfoUnit)(nil), "pb.CardInfoUnit")
	proto.RegisterType((*CardInfoNtf)(nil), "pb.CardInfoNtf")
	proto.RegisterType((*GetIntegralAwardReq)(nil), "pb.GetIntegralAwardReq")
	proto.RegisterType((*GetIntegralAwardAck)(nil), "pb.GetIntegralAwardAck")
	proto.RegisterType((*CardCloseNtf)(nil), "pb.CardCloseNtf")
}
func (m *CardActivityApplyGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardActivityApplyGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Times != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *CardActivityApplyGetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardActivityApplyGetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		dAtA2 := make([]byte, len(m.Cards)*10)
		var j1 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.CardTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.CardTime))
	}
	if m.Goods != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Goods.Size()))
		n3, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Type))
	}
	if len(m.MyDrawInfo) > 0 {
		for _, msg := range m.MyDrawInfo {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCardActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerDrawInfo) > 0 {
		for _, msg := range m.ServerDrawInfo {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCardActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Integral != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Integral))
	}
	return i, nil
}

func (m *CardActivityInfosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardActivityInfosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CardActivityInfosAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardActivityInfosAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Integral != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Integral))
	}
	if m.TotalDrawCardTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.TotalDrawCardTimes))
	}
	if len(m.MyDrawInfo) > 0 {
		for _, msg := range m.MyDrawInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCardActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerDrawInfo) > 0 {
		for _, msg := range m.ServerDrawInfo {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCardActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HaveGetIndex) > 0 {
		dAtA5 := make([]byte, len(m.HaveGetIndex)*10)
		var j4 int
		for _, num1 := range m.HaveGetIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.NowSeason != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.NowSeason))
	}
	if m.MergeMark != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.MergeMark))
	}
	return i, nil
}

func (m *CardInfoUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardInfoUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Count))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Time))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *CardInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.ItemId))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Time))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	return i, nil
}

func (m *GetIntegralAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIntegralAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Index))
	}
	if m.Times != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *GetIntegralAwardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIntegralAwardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HaveGetIndex) > 0 {
		dAtA7 := make([]byte, len(m.HaveGetIndex)*10)
		var j6 int
		for _, num1 := range m.HaveGetIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.Integral != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Integral))
	}
	if m.Goods != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCardActivity(dAtA, i, uint64(m.Goods.Size()))
		n8, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CardCloseNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardCloseNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsClose {
		dAtA[i] = 0x8
		i++
		if m.IsClose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintCardActivity(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CardActivityApplyGetReq) Size() (n int) {
	var l int
	_ = l
	if m.Times != 0 {
		n += 1 + sovCardActivity(uint64(m.Times))
	}
	return n
}

func (m *CardActivityApplyGetAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovCardActivity(uint64(e))
		}
		n += 1 + sovCardActivity(uint64(l)) + l
	}
	if m.CardTime != 0 {
		n += 1 + sovCardActivity(uint64(m.CardTime))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovCardActivity(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCardActivity(uint64(m.Type))
	}
	if len(m.MyDrawInfo) > 0 {
		for _, e := range m.MyDrawInfo {
			l = e.Size()
			n += 1 + l + sovCardActivity(uint64(l))
		}
	}
	if len(m.ServerDrawInfo) > 0 {
		for _, e := range m.ServerDrawInfo {
			l = e.Size()
			n += 1 + l + sovCardActivity(uint64(l))
		}
	}
	if m.Integral != 0 {
		n += 1 + sovCardActivity(uint64(m.Integral))
	}
	return n
}

func (m *CardActivityInfosReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CardActivityInfosAck) Size() (n int) {
	var l int
	_ = l
	if m.Integral != 0 {
		n += 1 + sovCardActivity(uint64(m.Integral))
	}
	if m.TotalDrawCardTimes != 0 {
		n += 1 + sovCardActivity(uint64(m.TotalDrawCardTimes))
	}
	if len(m.MyDrawInfo) > 0 {
		for _, e := range m.MyDrawInfo {
			l = e.Size()
			n += 1 + l + sovCardActivity(uint64(l))
		}
	}
	if len(m.ServerDrawInfo) > 0 {
		for _, e := range m.ServerDrawInfo {
			l = e.Size()
			n += 1 + l + sovCardActivity(uint64(l))
		}
	}
	if len(m.HaveGetIndex) > 0 {
		l = 0
		for _, e := range m.HaveGetIndex {
			l += sovCardActivity(uint64(e))
		}
		n += 1 + sovCardActivity(uint64(l)) + l
	}
	if m.NowSeason != 0 {
		n += 1 + sovCardActivity(uint64(m.NowSeason))
	}
	if m.MergeMark != 0 {
		n += 1 + sovCardActivity(uint64(m.MergeMark))
	}
	return n
}

func (m *CardInfoUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCardActivity(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovCardActivity(uint64(m.Count))
	}
	if m.Time != 0 {
		n += 1 + sovCardActivity(uint64(m.Time))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCardActivity(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCardActivity(uint64(m.Type))
	}
	return n
}

func (m *CardInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCardActivity(uint64(m.ItemId))
	}
	if m.Time != 0 {
		n += 1 + sovCardActivity(uint64(m.Time))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCardActivity(uint64(l))
	}
	return n
}

func (m *GetIntegralAwardReq) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCardActivity(uint64(m.Index))
	}
	if m.Times != 0 {
		n += 1 + sovCardActivity(uint64(m.Times))
	}
	return n
}

func (m *GetIntegralAwardAck) Size() (n int) {
	var l int
	_ = l
	if len(m.HaveGetIndex) > 0 {
		l = 0
		for _, e := range m.HaveGetIndex {
			l += sovCardActivity(uint64(e))
		}
		n += 1 + sovCardActivity(uint64(l)) + l
	}
	if m.Integral != 0 {
		n += 1 + sovCardActivity(uint64(m.Integral))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovCardActivity(uint64(l))
	}
	return n
}

func (m *CardCloseNtf) Size() (n int) {
	var l int
	_ = l
	if m.IsClose {
		n += 2
	}
	return n
}

func sovCardActivity(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCardActivity(x uint64) (n int) {
	return sovCardActivity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CardActivityApplyGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardActivityApplyGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardActivityApplyGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardActivityApplyGetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardActivityApplyGetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardActivityApplyGetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCardActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCardActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardTime", wireType)
			}
			m.CardTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyDrawInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyDrawInfo = append(m.MyDrawInfo, &CardInfoUnit{})
			if err := m.MyDrawInfo[len(m.MyDrawInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDrawInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerDrawInfo = append(m.ServerDrawInfo, &CardInfoUnit{})
			if err := m.ServerDrawInfo[len(m.ServerDrawInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integral", wireType)
			}
			m.Integral = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Integral |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardActivityInfosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardActivityInfosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardActivityInfosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardActivityInfosAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardActivityInfosAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardActivityInfosAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integral", wireType)
			}
			m.Integral = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Integral |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDrawCardTimes", wireType)
			}
			m.TotalDrawCardTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDrawCardTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyDrawInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyDrawInfo = append(m.MyDrawInfo, &CardInfoUnit{})
			if err := m.MyDrawInfo[len(m.MyDrawInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDrawInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerDrawInfo = append(m.ServerDrawInfo, &CardInfoUnit{})
			if err := m.ServerDrawInfo[len(m.ServerDrawInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HaveGetIndex = append(m.HaveGetIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCardActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCardActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HaveGetIndex = append(m.HaveGetIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetIndex", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowSeason", wireType)
			}
			m.NowSeason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowSeason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeMark", wireType)
			}
			m.MergeMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergeMark |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardInfoUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardInfoUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardInfoUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIntegralAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIntegralAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIntegralAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIntegralAwardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIntegralAwardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIntegralAwardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HaveGetIndex = append(m.HaveGetIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCardActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCardActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HaveGetIndex = append(m.HaveGetIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetIndex", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integral", wireType)
			}
			m.Integral = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Integral |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCardActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardCloseNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardCloseNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardCloseNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClose = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCardActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCardActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCardActivity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCardActivity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCardActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCardActivity
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCardActivity
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCardActivity(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCardActivity = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCardActivity   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cardActivity.proto", fileDescriptorCardActivity) }

var fileDescriptorCardActivity = []byte{
	// 512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6e, 0xda, 0x40,
	0x14, 0xae, 0x6d, 0x4c, 0xc8, 0x03, 0x55, 0xd1, 0x34, 0x4a, 0x2d, 0x54, 0x21, 0xe4, 0x95, 0x57,
	0xb4, 0x4a, 0x37, 0xdd, 0xba, 0x54, 0x42, 0x2c, 0xca, 0xc2, 0x6d, 0x0e, 0x30, 0xe0, 0x07, 0xb1,
	0x82, 0x3d, 0xce, 0x78, 0x02, 0x65, 0xd5, 0x5e, 0xa1, 0xbb, 0x9e, 0xa2, 0xe7, 0xe8, 0xb2, 0x47,
	0xa8, 0xe8, 0x45, 0xaa, 0x37, 0x1e, 0xc0, 0x50, 0x90, 0xa2, 0xec, 0xfc, 0x7d, 0xf3, 0xfe, 0xe6,
	0x9b, 0xef, 0x19, 0xd8, 0x84, 0xcb, 0x38, 0x9c, 0xa8, 0x64, 0x91, 0xa8, 0x55, 0x2f, 0x97, 0x42,
	0x09, 0x66, 0xe7, 0xe3, 0x76, 0x6b, 0x22, 0xd2, 0x54, 0x64, 0x25, 0xe3, 0xbf, 0x86, 0x97, 0xfd,
	0x4a, 0x5c, 0x98, 0xe7, 0xf3, 0xd5, 0x00, 0x55, 0x84, 0xf7, 0xec, 0x12, 0x5c, 0x95, 0xa4, 0x58,
	0x78, 0x56, 0xd7, 0x0a, 0xdc, 0xa8, 0x04, 0xfe, 0x77, 0xfb, 0x78, 0x46, 0x38, 0xb9, 0xa3, 0x0c,
	0x6a, 0x4a, 0x19, 0x0e, 0x65, 0x68, 0xc0, 0xda, 0xd0, 0xa0, 0x8f, 0xcf, 0x49, 0x8a, 0x9e, 0xad,
	0x4b, 0x6d, 0x31, 0x0b, 0xc0, 0x9d, 0x09, 0x11, 0x17, 0x9e, 0xd3, 0xb5, 0x82, 0xe6, 0x35, 0xeb,
	0xe5, 0xe3, 0xde, 0x80, 0x88, 0xfe, 0x2d, 0xcf, 0x66, 0x38, 0x52, 0xd3, 0xa8, 0x0c, 0x60, 0x0c,
	0x6a, 0x6a, 0x95, 0xa3, 0x57, 0xd3, 0x15, 0xf4, 0x37, 0x7b, 0x03, 0x90, 0xae, 0x3e, 0x48, 0xbe,
	0x1c, 0x66, 0x53, 0xe1, 0xb9, 0x5d, 0x27, 0x68, 0x5e, 0x5f, 0x50, 0x09, 0x1a, 0x90, 0xb8, 0x9b,
	0x2c, 0x51, 0x51, 0x25, 0x86, 0xbd, 0x83, 0xe7, 0x05, 0xca, 0x05, 0xca, 0x6d, 0x56, 0xfd, 0x44,
	0xd6, 0x41, 0x1c, 0xdd, 0x22, 0xc9, 0x14, 0xce, 0x24, 0x9f, 0x7b, 0x67, 0xe5, 0x2d, 0x36, 0xd8,
	0xbf, 0x82, 0xcb, 0xaa, 0x24, 0x14, 0x5f, 0x44, 0x78, 0xef, 0xff, 0xb4, 0x8f, 0x1c, 0x90, 0x50,
	0xd5, 0x62, 0xd6, 0x7e, 0x31, 0xd6, 0x03, 0xa6, 0x84, 0xe2, 0x73, 0xea, 0xdc, 0x37, 0x3a, 0x15,
	0x46, 0xb8, 0x23, 0x27, 0x07, 0x22, 0x38, 0x4f, 0x12, 0xa1, 0xf6, 0x48, 0x11, 0x7c, 0x68, 0xdd,
	0xf2, 0x05, 0x0e, 0x50, 0x0d, 0xb3, 0x18, 0xbf, 0x68, 0xc9, 0xdd, 0x68, 0x8f, 0x63, 0xaf, 0xe0,
	0x3c, 0x13, 0xcb, 0x4f, 0xc8, 0x0b, 0x91, 0x79, 0x75, 0x3d, 0xf6, 0x8e, 0xa0, 0xd3, 0x14, 0xe5,
	0x0c, 0x3f, 0x72, 0x79, 0x67, 0x74, 0xdc, 0x11, 0xfe, 0x37, 0x0b, 0x5a, 0xd5, 0x01, 0xd8, 0x15,
	0xd4, 0x13, 0x85, 0xe9, 0x30, 0x36, 0x32, 0x19, 0xa4, 0x9d, 0x26, 0x1e, 0x32, 0x65, 0x74, 0x29,
	0x81, 0xf6, 0x08, 0xb9, 0xcc, 0x31, 0x1e, 0x21, 0x87, 0xb5, 0xa1, 0xf1, 0x50, 0xa0, 0x1c, 0xf1,
	0xb4, 0xf4, 0xce, 0x79, 0xb4, 0xc5, 0x5b, 0x4f, 0xb9, 0x3b, 0x4f, 0xf9, 0x37, 0xd0, 0xdc, 0x4c,
	0x30, 0x52, 0xd3, 0x93, 0x03, 0x6c, 0x5a, 0xd9, 0x27, 0x5a, 0x39, 0xfb, 0xad, 0xfc, 0x10, 0x5e,
	0x68, 0x85, 0xca, 0x47, 0x0e, 0x97, 0x5c, 0xc6, 0x66, 0xc7, 0x12, 0xad, 0xa4, 0xd9, 0x31, 0x0d,
	0x76, 0x9b, 0x67, 0x57, 0x37, 0xef, 0xeb, 0xff, 0x25, 0xc8, 0x4b, 0x87, 0x6f, 0x62, 0x1d, 0x79,
	0x93, 0xaa, 0xdf, 0xec, 0x03, 0xbf, 0x3d, 0x7a, 0x05, 0xfd, 0xa0, 0x7c, 0x9c, 0xfe, 0x5c, 0x14,
	0x44, 0x33, 0x0f, 0xce, 0x92, 0x42, 0x23, 0x3d, 0x7e, 0x23, 0xda, 0xc0, 0xf7, 0x17, 0xbf, 0xd6,
	0x1d, 0xeb, 0xf7, 0xba, 0x63, 0xfd, 0x59, 0x77, 0xac, 0x1f, 0x7f, 0x3b, 0xcf, 0xc6, 0x75, 0xfd,
	0xbb, 0x79, 0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x16, 0xd3, 0x80, 0xfb, 0x96, 0x04, 0x00, 0x00,
}
