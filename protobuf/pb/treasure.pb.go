// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: treasure.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 设置弹框状态
type SetTreasurePopUpStateReq struct {
	State int32 `protobuf:"varint,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *SetTreasurePopUpStateReq) Reset()                    { *m = SetTreasurePopUpStateReq{} }
func (m *SetTreasurePopUpStateReq) String() string            { return proto.CompactTextString(m) }
func (*SetTreasurePopUpStateReq) ProtoMessage()               {}
func (*SetTreasurePopUpStateReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{0} }

func (m *SetTreasurePopUpStateReq) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type SetTreasurePopUpStateAck struct {
	State int32 `protobuf:"varint,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *SetTreasurePopUpStateAck) Reset()                    { *m = SetTreasurePopUpStateAck{} }
func (m *SetTreasurePopUpStateAck) String() string            { return proto.CompactTextString(m) }
func (*SetTreasurePopUpStateAck) ProtoMessage()               {}
func (*SetTreasurePopUpStateAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{1} }

func (m *SetTreasurePopUpStateAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

// 选择奖励
type ChooseTreasureAwardReq struct {
	Type         int32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Index        []int32 `protobuf:"varint,2,rep,packed,name=index" json:"index,omitempty"`
	IsReplace    int32   `protobuf:"varint,3,opt,name=isReplace,proto3" json:"isReplace,omitempty"`
	ReplaceIndex int32   `protobuf:"varint,4,opt,name=replaceIndex,proto3" json:"replaceIndex,omitempty"`
}

func (m *ChooseTreasureAwardReq) Reset()                    { *m = ChooseTreasureAwardReq{} }
func (m *ChooseTreasureAwardReq) String() string            { return proto.CompactTextString(m) }
func (*ChooseTreasureAwardReq) ProtoMessage()               {}
func (*ChooseTreasureAwardReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{2} }

func (m *ChooseTreasureAwardReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ChooseTreasureAwardReq) GetIndex() []int32 {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *ChooseTreasureAwardReq) GetIsReplace() int32 {
	if m != nil {
		return m.IsReplace
	}
	return 0
}

func (m *ChooseTreasureAwardReq) GetReplaceIndex() int32 {
	if m != nil {
		return m.ReplaceIndex
	}
	return 0
}

type ChooseTreasureAwardAck struct {
	Type         int32                 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Index        []int32               `protobuf:"varint,2,rep,packed,name=index" json:"index,omitempty"`
	ItemId       []int32               `protobuf:"varint,3,rep,packed,name=itemId" json:"itemId,omitempty"`
	ChoosItems   map[int32]*ChooseInfo `protobuf:"bytes,4,rep,name=choosItems" json:"choosItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	HaveGetItems map[int32]*ChooseInfo `protobuf:"bytes,5,rep,name=haveGetItems" json:"haveGetItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	IsReplace    int32                 `protobuf:"varint,6,opt,name=isReplace,proto3" json:"isReplace,omitempty"`
	ReplaceIndex int32                 `protobuf:"varint,7,opt,name=replaceIndex,proto3" json:"replaceIndex,omitempty"`
}

func (m *ChooseTreasureAwardAck) Reset()                    { *m = ChooseTreasureAwardAck{} }
func (m *ChooseTreasureAwardAck) String() string            { return proto.CompactTextString(m) }
func (*ChooseTreasureAwardAck) ProtoMessage()               {}
func (*ChooseTreasureAwardAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{3} }

func (m *ChooseTreasureAwardAck) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ChooseTreasureAwardAck) GetIndex() []int32 {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *ChooseTreasureAwardAck) GetItemId() []int32 {
	if m != nil {
		return m.ItemId
	}
	return nil
}

func (m *ChooseTreasureAwardAck) GetChoosItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.ChoosItems
	}
	return nil
}

func (m *ChooseTreasureAwardAck) GetHaveGetItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.HaveGetItems
	}
	return nil
}

func (m *ChooseTreasureAwardAck) GetIsReplace() int32 {
	if m != nil {
		return m.IsReplace
	}
	return 0
}

func (m *ChooseTreasureAwardAck) GetReplaceIndex() int32 {
	if m != nil {
		return m.ReplaceIndex
	}
	return 0
}

type ChooseInfo struct {
	Items []int32 `protobuf:"varint,1,rep,packed,name=items" json:"items,omitempty"`
}

func (m *ChooseInfo) Reset()                    { *m = ChooseInfo{} }
func (m *ChooseInfo) String() string            { return proto.CompactTextString(m) }
func (*ChooseInfo) ProtoMessage()               {}
func (*ChooseInfo) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{4} }

func (m *ChooseInfo) GetItems() []int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

// 购买寻龙令
type BuyTreasureItemReq struct {
}

func (m *BuyTreasureItemReq) Reset()                    { *m = BuyTreasureItemReq{} }
func (m *BuyTreasureItemReq) String() string            { return proto.CompactTextString(m) }
func (*BuyTreasureItemReq) ProtoMessage()               {}
func (*BuyTreasureItemReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{5} }

type BuyTreasureItemAck struct {
	HaveBuyTimes map[int32]int32 `protobuf:"bytes,1,rep,name=haveBuyTimes" json:"haveBuyTimes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Goods        *GoodsChangeNtf `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
}

func (m *BuyTreasureItemAck) Reset()                    { *m = BuyTreasureItemAck{} }
func (m *BuyTreasureItemAck) String() string            { return proto.CompactTextString(m) }
func (*BuyTreasureItemAck) ProtoMessage()               {}
func (*BuyTreasureItemAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{6} }

func (m *BuyTreasureItemAck) GetHaveBuyTimes() map[int32]int32 {
	if m != nil {
		return m.HaveBuyTimes
	}
	return nil
}

func (m *BuyTreasureItemAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 申请转盘
type TreasureApplyGetReq struct {
}

func (m *TreasureApplyGetReq) Reset()                    { *m = TreasureApplyGetReq{} }
func (m *TreasureApplyGetReq) String() string            { return proto.CompactTextString(m) }
func (*TreasureApplyGetReq) ProtoMessage()               {}
func (*TreasureApplyGetReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{7} }

type TreasureApplyGetAck struct {
	Items              []int32               `protobuf:"varint,1,rep,packed,name=items" json:"items,omitempty"`
	TreasureTimes      int32                 `protobuf:"varint,2,opt,name=treasureTimes,proto3" json:"treasureTimes,omitempty"`
	Goods              *GoodsChangeNtf       `protobuf:"bytes,3,opt,name=goods" json:"goods,omitempty"`
	ChoosItems         map[int32]*ChooseInfo `protobuf:"bytes,4,rep,name=choosItems" json:"choosItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	HaveGetItems       map[int32]*ChooseInfo `protobuf:"bytes,5,rep,name=haveGetItems" json:"haveGetItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MyTreasureInfo     []*TreasureInfoUnit   `protobuf:"bytes,6,rep,name=myTreasureInfo" json:"myTreasureInfo,omitempty"`
	ServerTreasureInfo []*TreasureInfoUnit   `protobuf:"bytes,7,rep,name=serverTreasureInfo" json:"serverTreasureInfo,omitempty"`
	RandomType         int32                 `protobuf:"varint,8,opt,name=randomType,proto3" json:"randomType,omitempty"`
}

func (m *TreasureApplyGetAck) Reset()                    { *m = TreasureApplyGetAck{} }
func (m *TreasureApplyGetAck) String() string            { return proto.CompactTextString(m) }
func (*TreasureApplyGetAck) ProtoMessage()               {}
func (*TreasureApplyGetAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{8} }

func (m *TreasureApplyGetAck) GetItems() []int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *TreasureApplyGetAck) GetTreasureTimes() int32 {
	if m != nil {
		return m.TreasureTimes
	}
	return 0
}

func (m *TreasureApplyGetAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *TreasureApplyGetAck) GetChoosItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.ChoosItems
	}
	return nil
}

func (m *TreasureApplyGetAck) GetHaveGetItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.HaveGetItems
	}
	return nil
}

func (m *TreasureApplyGetAck) GetMyTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.MyTreasureInfo
	}
	return nil
}

func (m *TreasureApplyGetAck) GetServerTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.ServerTreasureInfo
	}
	return nil
}

func (m *TreasureApplyGetAck) GetRandomType() int32 {
	if m != nil {
		return m.RandomType
	}
	return 0
}

// 转盘信息
type TreasureInfosReq struct {
}

func (m *TreasureInfosReq) Reset()                    { *m = TreasureInfosReq{} }
func (m *TreasureInfosReq) String() string            { return proto.CompactTextString(m) }
func (*TreasureInfosReq) ProtoMessage()               {}
func (*TreasureInfosReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{9} }

type TreasureInfosAck struct {
	TreasureTimes      int32                 `protobuf:"varint,1,opt,name=treasureTimes,proto3" json:"treasureTimes,omitempty"`
	MyTreasureInfo     []*TreasureInfoUnit   `protobuf:"bytes,2,rep,name=myTreasureInfo" json:"myTreasureInfo,omitempty"`
	ServerTreasureInfo []*TreasureInfoUnit   `protobuf:"bytes,3,rep,name=serverTreasureInfo" json:"serverTreasureInfo,omitempty"`
	HaveGetRoundId     []int32               `protobuf:"varint,4,rep,packed,name=haveGetRoundId" json:"haveGetRoundId,omitempty"`
	HaveBuyTimes       map[int32]int32       `protobuf:"bytes,5,rep,name=HaveBuyTimes" json:"HaveBuyTimes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ChoosItems         map[int32]*ChooseInfo `protobuf:"bytes,6,rep,name=choosItems" json:"choosItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	HaveGetItems       map[int32]*ChooseInfo `protobuf:"bytes,7,rep,name=haveGetItems" json:"haveGetItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Season             int32                 `protobuf:"varint,8,opt,name=season,proto3" json:"season,omitempty"`
	PopUpState         int32                 `protobuf:"varint,9,opt,name=popUpState,proto3" json:"popUpState,omitempty"`
	MergeMark          int32                 `protobuf:"varint,10,opt,name=mergeMark,proto3" json:"mergeMark,omitempty"`
}

func (m *TreasureInfosAck) Reset()                    { *m = TreasureInfosAck{} }
func (m *TreasureInfosAck) String() string            { return proto.CompactTextString(m) }
func (*TreasureInfosAck) ProtoMessage()               {}
func (*TreasureInfosAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{10} }

func (m *TreasureInfosAck) GetTreasureTimes() int32 {
	if m != nil {
		return m.TreasureTimes
	}
	return 0
}

func (m *TreasureInfosAck) GetMyTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.MyTreasureInfo
	}
	return nil
}

func (m *TreasureInfosAck) GetServerTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.ServerTreasureInfo
	}
	return nil
}

func (m *TreasureInfosAck) GetHaveGetRoundId() []int32 {
	if m != nil {
		return m.HaveGetRoundId
	}
	return nil
}

func (m *TreasureInfosAck) GetHaveBuyTimes() map[int32]int32 {
	if m != nil {
		return m.HaveBuyTimes
	}
	return nil
}

func (m *TreasureInfosAck) GetChoosItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.ChoosItems
	}
	return nil
}

func (m *TreasureInfosAck) GetHaveGetItems() map[int32]*ChooseInfo {
	if m != nil {
		return m.HaveGetItems
	}
	return nil
}

func (m *TreasureInfosAck) GetSeason() int32 {
	if m != nil {
		return m.Season
	}
	return 0
}

func (m *TreasureInfosAck) GetPopUpState() int32 {
	if m != nil {
		return m.PopUpState
	}
	return 0
}

func (m *TreasureInfosAck) GetMergeMark() int32 {
	if m != nil {
		return m.MergeMark
	}
	return 0
}

// 返回键抽卡信息
type TreasureInfoUnit struct {
	ItemId   int32  `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count    int32  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Time     int32  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	UserName string `protobuf:"bytes,4,opt,name=userName,proto3" json:"userName,omitempty"`
	Type     int32  `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TreasureInfoUnit) Reset()                    { *m = TreasureInfoUnit{} }
func (m *TreasureInfoUnit) String() string            { return proto.CompactTextString(m) }
func (*TreasureInfoUnit) ProtoMessage()               {}
func (*TreasureInfoUnit) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{11} }

func (m *TreasureInfoUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *TreasureInfoUnit) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TreasureInfoUnit) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TreasureInfoUnit) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *TreasureInfoUnit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type TreasureInfoNtf struct {
	ItemId   int32  `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Time     int32  `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	UserName string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
}

func (m *TreasureInfoNtf) Reset()                    { *m = TreasureInfoNtf{} }
func (m *TreasureInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*TreasureInfoNtf) ProtoMessage()               {}
func (*TreasureInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{12} }

func (m *TreasureInfoNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *TreasureInfoNtf) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TreasureInfoNtf) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

// 领取每轮福利
type GetTreasureIntegralAwardReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetTreasureIntegralAwardReq) Reset()         { *m = GetTreasureIntegralAwardReq{} }
func (m *GetTreasureIntegralAwardReq) String() string { return proto.CompactTextString(m) }
func (*GetTreasureIntegralAwardReq) ProtoMessage()    {}
func (*GetTreasureIntegralAwardReq) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasure, []int{13}
}

func (m *GetTreasureIntegralAwardReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type GetTreasureIntegralAwardAck struct {
	HaveGetIndex  []int32 `protobuf:"varint,1,rep,packed,name=haveGetIndex" json:"haveGetIndex,omitempty"`
	TreasureTimes int32   `protobuf:"varint,2,opt,name=treasureTimes,proto3" json:"treasureTimes,omitempty"`
}

func (m *GetTreasureIntegralAwardAck) Reset()         { *m = GetTreasureIntegralAwardAck{} }
func (m *GetTreasureIntegralAwardAck) String() string { return proto.CompactTextString(m) }
func (*GetTreasureIntegralAwardAck) ProtoMessage()    {}
func (*GetTreasureIntegralAwardAck) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasure, []int{14}
}

func (m *GetTreasureIntegralAwardAck) GetHaveGetIndex() []int32 {
	if m != nil {
		return m.HaveGetIndex
	}
	return nil
}

func (m *GetTreasureIntegralAwardAck) GetTreasureTimes() int32 {
	if m != nil {
		return m.TreasureTimes
	}
	return 0
}

// 抽卡信息
type TreasureDrawInfoReq struct {
}

func (m *TreasureDrawInfoReq) Reset()                    { *m = TreasureDrawInfoReq{} }
func (m *TreasureDrawInfoReq) String() string            { return proto.CompactTextString(m) }
func (*TreasureDrawInfoReq) ProtoMessage()               {}
func (*TreasureDrawInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{15} }

type TreasureDrawInfoAck struct {
	MyTreasureInfo     []*TreasureInfoUnit `protobuf:"bytes,1,rep,name=myTreasureInfo" json:"myTreasureInfo,omitempty"`
	ServerTreasureInfo []*TreasureInfoUnit `protobuf:"bytes,2,rep,name=serverTreasureInfo" json:"serverTreasureInfo,omitempty"`
}

func (m *TreasureDrawInfoAck) Reset()                    { *m = TreasureDrawInfoAck{} }
func (m *TreasureDrawInfoAck) String() string            { return proto.CompactTextString(m) }
func (*TreasureDrawInfoAck) ProtoMessage()               {}
func (*TreasureDrawInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{16} }

func (m *TreasureDrawInfoAck) GetMyTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.MyTreasureInfo
	}
	return nil
}

func (m *TreasureDrawInfoAck) GetServerTreasureInfo() []*TreasureInfoUnit {
	if m != nil {
		return m.ServerTreasureInfo
	}
	return nil
}

type TreasureCloseNtf struct {
	IsClose bool `protobuf:"varint,1,opt,name=isClose,proto3" json:"isClose,omitempty"`
}

func (m *TreasureCloseNtf) Reset()                    { *m = TreasureCloseNtf{} }
func (m *TreasureCloseNtf) String() string            { return proto.CompactTextString(m) }
func (*TreasureCloseNtf) ProtoMessage()               {}
func (*TreasureCloseNtf) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{17} }

func (m *TreasureCloseNtf) GetIsClose() bool {
	if m != nil {
		return m.IsClose
	}
	return false
}

func init() {
	proto.RegisterType((*SetTreasurePopUpStateReq)(nil), "pb.SetTreasurePopUpStateReq")
	proto.RegisterType((*SetTreasurePopUpStateAck)(nil), "pb.SetTreasurePopUpStateAck")
	proto.RegisterType((*ChooseTreasureAwardReq)(nil), "pb.ChooseTreasureAwardReq")
	proto.RegisterType((*ChooseTreasureAwardAck)(nil), "pb.ChooseTreasureAwardAck")
	proto.RegisterType((*ChooseInfo)(nil), "pb.ChooseInfo")
	proto.RegisterType((*BuyTreasureItemReq)(nil), "pb.BuyTreasureItemReq")
	proto.RegisterType((*BuyTreasureItemAck)(nil), "pb.BuyTreasureItemAck")
	proto.RegisterType((*TreasureApplyGetReq)(nil), "pb.TreasureApplyGetReq")
	proto.RegisterType((*TreasureApplyGetAck)(nil), "pb.TreasureApplyGetAck")
	proto.RegisterType((*TreasureInfosReq)(nil), "pb.TreasureInfosReq")
	proto.RegisterType((*TreasureInfosAck)(nil), "pb.TreasureInfosAck")
	proto.RegisterType((*TreasureInfoUnit)(nil), "pb.TreasureInfoUnit")
	proto.RegisterType((*TreasureInfoNtf)(nil), "pb.TreasureInfoNtf")
	proto.RegisterType((*GetTreasureIntegralAwardReq)(nil), "pb.GetTreasureIntegralAwardReq")
	proto.RegisterType((*GetTreasureIntegralAwardAck)(nil), "pb.GetTreasureIntegralAwardAck")
	proto.RegisterType((*TreasureDrawInfoReq)(nil), "pb.TreasureDrawInfoReq")
	proto.RegisterType((*TreasureDrawInfoAck)(nil), "pb.TreasureDrawInfoAck")
	proto.RegisterType((*TreasureCloseNtf)(nil), "pb.TreasureCloseNtf")
}
func (m *SetTreasurePopUpStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTreasurePopUpStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *SetTreasurePopUpStateAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTreasurePopUpStateAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *ChooseTreasureAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChooseTreasureAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Type))
	}
	if len(m.Index) > 0 {
		dAtA2 := make([]byte, len(m.Index)*10)
		var j1 int
		for _, num1 := range m.Index {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.IsReplace != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.IsReplace))
	}
	if m.ReplaceIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ReplaceIndex))
	}
	return i, nil
}

func (m *ChooseTreasureAwardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChooseTreasureAwardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Type))
	}
	if len(m.Index) > 0 {
		dAtA4 := make([]byte, len(m.Index)*10)
		var j3 int
		for _, num1 := range m.Index {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.ItemId) > 0 {
		dAtA6 := make([]byte, len(m.ItemId)*10)
		var j5 int
		for _, num1 := range m.ItemId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.ChoosItems) > 0 {
		for k, _ := range m.ChoosItems {
			dAtA[i] = 0x22
			i++
			v := m.ChoosItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, _ := range m.HaveGetItems {
			dAtA[i] = 0x2a
			i++
			v := m.HaveGetItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if m.IsReplace != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.IsReplace))
	}
	if m.ReplaceIndex != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ReplaceIndex))
	}
	return i, nil
}

func (m *ChooseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChooseInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		dAtA10 := make([]byte, len(m.Items)*10)
		var j9 int
		for _, num1 := range m.Items {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *BuyTreasureItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyTreasureItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BuyTreasureItemAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyTreasureItemAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HaveBuyTimes) > 0 {
		for k, _ := range m.HaveBuyTimes {
			dAtA[i] = 0xa
			i++
			v := m.HaveBuyTimes[k]
			mapSize := 1 + sovTreasure(uint64(k)) + 1 + sovTreasure(uint64(v))
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(v))
		}
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Goods.Size()))
		n11, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *TreasureApplyGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureApplyGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TreasureApplyGetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureApplyGetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		dAtA13 := make([]byte, len(m.Items)*10)
		var j12 int
		for _, num1 := range m.Items {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.TreasureTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureTimes))
	}
	if m.Goods != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Goods.Size()))
		n14, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.ChoosItems) > 0 {
		for k, _ := range m.ChoosItems {
			dAtA[i] = 0x22
			i++
			v := m.ChoosItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, _ := range m.HaveGetItems {
			dAtA[i] = 0x2a
			i++
			v := m.HaveGetItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	if len(m.MyTreasureInfo) > 0 {
		for _, msg := range m.MyTreasureInfo {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, msg := range m.ServerTreasureInfo {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RandomType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.RandomType))
	}
	return i, nil
}

func (m *TreasureInfosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureInfosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TreasureInfosAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureInfosAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureTimes))
	}
	if len(m.MyTreasureInfo) > 0 {
		for _, msg := range m.MyTreasureInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, msg := range m.ServerTreasureInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HaveGetRoundId) > 0 {
		dAtA18 := make([]byte, len(m.HaveGetRoundId)*10)
		var j17 int
		for _, num1 := range m.HaveGetRoundId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.HaveBuyTimes) > 0 {
		for k, _ := range m.HaveBuyTimes {
			dAtA[i] = 0x2a
			i++
			v := m.HaveBuyTimes[k]
			mapSize := 1 + sovTreasure(uint64(k)) + 1 + sovTreasure(uint64(v))
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(v))
		}
	}
	if len(m.ChoosItems) > 0 {
		for k, _ := range m.ChoosItems {
			dAtA[i] = 0x32
			i++
			v := m.ChoosItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, _ := range m.HaveGetItems {
			dAtA[i] = 0x3a
			i++
			v := m.HaveGetItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTreasure(uint64(msgSize))
			}
			mapSize := 1 + sovTreasure(uint64(k)) + msgSize
			i = encodeVarintTreasure(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTreasure(dAtA, i, uint64(v.Size()))
				n20, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n20
			}
		}
	}
	if m.Season != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Season))
	}
	if m.PopUpState != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.PopUpState))
	}
	if m.MergeMark != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.MergeMark))
	}
	return i, nil
}

func (m *TreasureInfoUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureInfoUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Count))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Time))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *TreasureInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ItemId))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Time))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	return i, nil
}

func (m *GetTreasureIntegralAwardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasureIntegralAwardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GetTreasureIntegralAwardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasureIntegralAwardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HaveGetIndex) > 0 {
		dAtA22 := make([]byte, len(m.HaveGetIndex)*10)
		var j21 int
		for _, num1 := range m.HaveGetIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if m.TreasureTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureTimes))
	}
	return i, nil
}

func (m *TreasureDrawInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureDrawInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TreasureDrawInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureDrawInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MyTreasureInfo) > 0 {
		for _, msg := range m.MyTreasureInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, msg := range m.ServerTreasureInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TreasureCloseNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureCloseNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsClose {
		dAtA[i] = 0x8
		i++
		if m.IsClose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintTreasure(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SetTreasurePopUpStateReq) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTreasure(uint64(m.State))
	}
	return n
}

func (m *SetTreasurePopUpStateAck) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTreasure(uint64(m.State))
	}
	return n
}

func (m *ChooseTreasureAwardReq) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTreasure(uint64(m.Type))
	}
	if len(m.Index) > 0 {
		l = 0
		for _, e := range m.Index {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if m.IsReplace != 0 {
		n += 1 + sovTreasure(uint64(m.IsReplace))
	}
	if m.ReplaceIndex != 0 {
		n += 1 + sovTreasure(uint64(m.ReplaceIndex))
	}
	return n
}

func (m *ChooseTreasureAwardAck) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTreasure(uint64(m.Type))
	}
	if len(m.Index) > 0 {
		l = 0
		for _, e := range m.Index {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if len(m.ItemId) > 0 {
		l = 0
		for _, e := range m.ItemId {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if len(m.ChoosItems) > 0 {
		for k, v := range m.ChoosItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, v := range m.HaveGetItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if m.IsReplace != 0 {
		n += 1 + sovTreasure(uint64(m.IsReplace))
	}
	if m.ReplaceIndex != 0 {
		n += 1 + sovTreasure(uint64(m.ReplaceIndex))
	}
	return n
}

func (m *ChooseInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		l = 0
		for _, e := range m.Items {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	return n
}

func (m *BuyTreasureItemReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BuyTreasureItemAck) Size() (n int) {
	var l int
	_ = l
	if len(m.HaveBuyTimes) > 0 {
		for k, v := range m.HaveBuyTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasure(uint64(k)) + 1 + sovTreasure(uint64(v))
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovTreasure(uint64(l))
	}
	return n
}

func (m *TreasureApplyGetReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TreasureApplyGetAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		l = 0
		for _, e := range m.Items {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if m.TreasureTimes != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureTimes))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovTreasure(uint64(l))
	}
	if len(m.ChoosItems) > 0 {
		for k, v := range m.ChoosItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, v := range m.HaveGetItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if len(m.MyTreasureInfo) > 0 {
		for _, e := range m.MyTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, e := range m.ServerTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if m.RandomType != 0 {
		n += 1 + sovTreasure(uint64(m.RandomType))
	}
	return n
}

func (m *TreasureInfosReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TreasureInfosAck) Size() (n int) {
	var l int
	_ = l
	if m.TreasureTimes != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureTimes))
	}
	if len(m.MyTreasureInfo) > 0 {
		for _, e := range m.MyTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, e := range m.ServerTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.HaveGetRoundId) > 0 {
		l = 0
		for _, e := range m.HaveGetRoundId {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if len(m.HaveBuyTimes) > 0 {
		for k, v := range m.HaveBuyTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasure(uint64(k)) + 1 + sovTreasure(uint64(v))
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if len(m.ChoosItems) > 0 {
		for k, v := range m.ChoosItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if len(m.HaveGetItems) > 0 {
		for k, v := range m.HaveGetItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTreasure(uint64(l))
			}
			mapEntrySize := 1 + sovTreasure(uint64(k)) + l
			n += mapEntrySize + 1 + sovTreasure(uint64(mapEntrySize))
		}
	}
	if m.Season != 0 {
		n += 1 + sovTreasure(uint64(m.Season))
	}
	if m.PopUpState != 0 {
		n += 1 + sovTreasure(uint64(m.PopUpState))
	}
	if m.MergeMark != 0 {
		n += 1 + sovTreasure(uint64(m.MergeMark))
	}
	return n
}

func (m *TreasureInfoUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovTreasure(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovTreasure(uint64(m.Count))
	}
	if m.Time != 0 {
		n += 1 + sovTreasure(uint64(m.Time))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTreasure(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTreasure(uint64(m.Type))
	}
	return n
}

func (m *TreasureInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovTreasure(uint64(m.ItemId))
	}
	if m.Time != 0 {
		n += 1 + sovTreasure(uint64(m.Time))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTreasure(uint64(l))
	}
	return n
}

func (m *GetTreasureIntegralAwardReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTreasure(uint64(m.Id))
	}
	return n
}

func (m *GetTreasureIntegralAwardAck) Size() (n int) {
	var l int
	_ = l
	if len(m.HaveGetIndex) > 0 {
		l = 0
		for _, e := range m.HaveGetIndex {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if m.TreasureTimes != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureTimes))
	}
	return n
}

func (m *TreasureDrawInfoReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TreasureDrawInfoAck) Size() (n int) {
	var l int
	_ = l
	if len(m.MyTreasureInfo) > 0 {
		for _, e := range m.MyTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.ServerTreasureInfo) > 0 {
		for _, e := range m.ServerTreasureInfo {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	return n
}

func (m *TreasureCloseNtf) Size() (n int) {
	var l int
	_ = l
	if m.IsClose {
		n += 2
	}
	return n
}

func sovTreasure(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTreasure(x uint64) (n int) {
	return sovTreasure(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SetTreasurePopUpStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTreasurePopUpStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTreasurePopUpStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTreasurePopUpStateAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTreasurePopUpStateAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTreasurePopUpStateAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChooseTreasureAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChooseTreasureAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChooseTreasureAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Index = append(m.Index, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Index = append(m.Index, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplace", wireType)
			}
			m.IsReplace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReplace |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceIndex", wireType)
			}
			m.ReplaceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChooseTreasureAwardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChooseTreasureAwardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChooseTreasureAwardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Index = append(m.Index, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Index = append(m.Index, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ItemId = append(m.ItemId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ItemId = append(m.ItemId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChoosItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChoosItems == nil {
				m.ChoosItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChoosItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HaveGetItems == nil {
				m.HaveGetItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HaveGetItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplace", wireType)
			}
			m.IsReplace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReplace |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceIndex", wireType)
			}
			m.ReplaceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChooseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChooseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChooseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Items = append(m.Items, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Items = append(m.Items, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyTreasureItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyTreasureItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyTreasureItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyTreasureItemAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyTreasureItemAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyTreasureItemAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveBuyTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HaveBuyTimes == nil {
				m.HaveBuyTimes = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HaveBuyTimes[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureApplyGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureApplyGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureApplyGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureApplyGetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureApplyGetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureApplyGetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Items = append(m.Items, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Items = append(m.Items, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureTimes", wireType)
			}
			m.TreasureTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChoosItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChoosItems == nil {
				m.ChoosItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChoosItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HaveGetItems == nil {
				m.HaveGetItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HaveGetItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyTreasureInfo = append(m.MyTreasureInfo, &TreasureInfoUnit{})
			if err := m.MyTreasureInfo[len(m.MyTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerTreasureInfo = append(m.ServerTreasureInfo, &TreasureInfoUnit{})
			if err := m.ServerTreasureInfo[len(m.ServerTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomType", wireType)
			}
			m.RandomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureInfosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureInfosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureInfosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureInfosAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureInfosAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureInfosAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureTimes", wireType)
			}
			m.TreasureTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyTreasureInfo = append(m.MyTreasureInfo, &TreasureInfoUnit{})
			if err := m.MyTreasureInfo[len(m.MyTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerTreasureInfo = append(m.ServerTreasureInfo, &TreasureInfoUnit{})
			if err := m.ServerTreasureInfo[len(m.ServerTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HaveGetRoundId = append(m.HaveGetRoundId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HaveGetRoundId = append(m.HaveGetRoundId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetRoundId", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveBuyTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HaveBuyTimes == nil {
				m.HaveBuyTimes = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HaveBuyTimes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChoosItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChoosItems == nil {
				m.ChoosItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChoosItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HaveGetItems == nil {
				m.HaveGetItems = make(map[int32]*ChooseInfo)
			}
			var mapkey int32
			var mapvalue *ChooseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTreasure
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChooseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasure(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasure
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HaveGetItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			m.Season = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Season |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopUpState", wireType)
			}
			m.PopUpState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopUpState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeMark", wireType)
			}
			m.MergeMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergeMark |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureInfoUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureInfoUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureInfoUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasureIntegralAwardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasureIntegralAwardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasureIntegralAwardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasureIntegralAwardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasureIntegralAwardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasureIntegralAwardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HaveGetIndex = append(m.HaveGetIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HaveGetIndex = append(m.HaveGetIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveGetIndex", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureTimes", wireType)
			}
			m.TreasureTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureDrawInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureDrawInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureDrawInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureDrawInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureDrawInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureDrawInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyTreasureInfo = append(m.MyTreasureInfo, &TreasureInfoUnit{})
			if err := m.MyTreasureInfo[len(m.MyTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerTreasureInfo = append(m.ServerTreasureInfo, &TreasureInfoUnit{})
			if err := m.ServerTreasureInfo[len(m.ServerTreasureInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureCloseNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureCloseNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureCloseNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClose = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTreasure(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTreasure
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTreasure(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTreasure = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTreasure   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("treasure.proto", fileDescriptorTreasure) }

var fileDescriptorTreasure = []byte{
	// 865 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4f, 0x4f, 0xdb, 0x48,
	0x14, 0x5f, 0xdb, 0x71, 0x02, 0x8f, 0x6c, 0x60, 0x67, 0xb3, 0xc8, 0xca, 0xae, 0xa2, 0xc8, 0x42,
	0x6c, 0x5a, 0x51, 0x54, 0xd1, 0x4b, 0x55, 0x55, 0xaa, 0xf8, 0x53, 0xa5, 0x41, 0x85, 0x22, 0x03,
	0x87, 0x1e, 0x4d, 0x3c, 0x09, 0x16, 0xb1, 0xc7, 0xd8, 0x13, 0x68, 0xee, 0x7c, 0x88, 0xf6, 0x1b,
	0xf5, 0x52, 0xa9, 0xb7, 0x4a, 0x3d, 0x55, 0xf4, 0x53, 0xf4, 0x56, 0xcd, 0x8c, 0x1d, 0xdb, 0xb1,
	0x93, 0x80, 0x72, 0xe1, 0xe6, 0xf9, 0xf9, 0xcd, 0xef, 0xbd, 0x79, 0xef, 0xf7, 0x66, 0x1e, 0x54,
	0xa8, 0x8f, 0xcd, 0x60, 0xe0, 0xe3, 0x4d, 0xcf, 0x27, 0x94, 0x20, 0xd9, 0x3b, 0xab, 0x95, 0x3b,
	0xc4, 0x71, 0x88, 0x2b, 0x10, 0xfd, 0x29, 0x68, 0xc7, 0x98, 0x9e, 0x84, 0x66, 0x47, 0xc4, 0x3b,
	0xf5, 0x8e, 0xa9, 0x49, 0xb1, 0x81, 0x2f, 0x51, 0x15, 0xd4, 0x80, 0x7d, 0x6b, 0x52, 0x43, 0x6a,
	0xaa, 0x86, 0x58, 0x4c, 0xdc, 0xb1, 0xdd, 0xb9, 0x98, 0xb0, 0xe3, 0x46, 0x82, 0xd5, 0xdd, 0x73,
	0x42, 0x02, 0x1c, 0xed, 0xda, 0xbe, 0x36, 0x7d, 0x8b, 0xb9, 0x40, 0x50, 0xa0, 0x43, 0x2f, 0xb2,
	0xe7, 0xdf, 0x8c, 0xc4, 0x76, 0x2d, 0xfc, 0x41, 0x93, 0x1b, 0x0a, 0x23, 0xe1, 0x0b, 0xf4, 0x1f,
	0x2c, 0xda, 0x81, 0x81, 0xbd, 0xbe, 0xd9, 0xc1, 0x9a, 0xc2, 0xcd, 0x63, 0x00, 0xe9, 0x50, 0xf6,
	0xc5, 0x67, 0x9b, 0x6f, 0x2d, 0x70, 0x83, 0x14, 0xa6, 0x7f, 0x57, 0x72, 0xc3, 0x60, 0x71, 0xdf,
	0x3d, 0x8c, 0x55, 0x28, 0xda, 0x14, 0x3b, 0x6d, 0x4b, 0x53, 0x38, 0x1c, 0xae, 0xd0, 0x3e, 0x40,
	0x87, 0x71, 0xb7, 0x29, 0x76, 0x02, 0xad, 0xd0, 0x50, 0x9a, 0x4b, 0x5b, 0x8f, 0x37, 0xbd, 0xb3,
	0xcd, 0x7c, 0x8f, 0x02, 0xe6, 0xc6, 0xaf, 0x5d, 0xea, 0x0f, 0x8d, 0xc4, 0x6e, 0x74, 0x04, 0xe5,
	0x73, 0xf3, 0x0a, 0xb7, 0x30, 0x15, 0x6c, 0x2a, 0x67, 0xdb, 0x98, 0xc2, 0xf6, 0x26, 0x61, 0x2e,
	0xf8, 0x52, 0x0c, 0xe9, 0xe4, 0x15, 0x67, 0x25, 0xaf, 0x94, 0x4d, 0x5e, 0xed, 0x00, 0x96, 0xc7,
	0x42, 0x46, 0x2b, 0xa0, 0x5c, 0xe0, 0x61, 0x98, 0x33, 0xf6, 0x89, 0xd6, 0x40, 0xbd, 0x32, 0xfb,
	0x03, 0xac, 0xc9, 0x0d, 0xa9, 0xb9, 0xb4, 0x55, 0x89, 0x23, 0x6e, 0xbb, 0x5d, 0x62, 0x88, 0x9f,
	0x2f, 0xe4, 0xe7, 0x52, 0xed, 0x1d, 0xfc, 0x95, 0x89, 0x79, 0x1e, 0x42, 0x5d, 0x07, 0x88, 0x7f,
	0xf0, 0xda, 0xf1, 0xd4, 0x49, 0x61, 0xed, 0xd8, 0x42, 0xaf, 0x02, 0xda, 0x19, 0x0c, 0xa3, 0xe4,
	0x31, 0xc7, 0x06, 0xbe, 0xd4, 0xbf, 0x48, 0x19, 0x98, 0x49, 0xe2, 0xad, 0x28, 0x02, 0xfb, 0x63,
	0x3b, 0x58, 0x30, 0x2d, 0x6d, 0x35, 0x59, 0x04, 0x59, 0x6b, 0x5e, 0x80, 0xc8, 0x34, 0x51, 0x80,
	0x08, 0x42, 0x4d, 0x50, 0x7b, 0x84, 0x58, 0x41, 0x78, 0x10, 0xc4, 0x68, 0x5a, 0x0c, 0xd8, 0x3d,
	0x37, 0xdd, 0x1e, 0x3e, 0xa4, 0x5d, 0x43, 0x18, 0xd4, 0x5e, 0x89, 0xcc, 0xa4, 0xc8, 0x72, 0x32,
	0x53, 0x4d, 0x66, 0x46, 0x4d, 0x66, 0xe2, 0x1f, 0xf8, 0x7b, 0xa4, 0x0f, 0xcf, 0xeb, 0x0f, 0x5b,
	0x98, 0xb2, 0x63, 0x7e, 0x2b, 0x64, 0xf1, 0xb0, 0x65, 0xb3, 0xa9, 0x42, 0x6b, 0xf0, 0x67, 0x74,
	0x75, 0x88, 0xe3, 0x0b, 0x37, 0x69, 0x30, 0x3e, 0x95, 0x32, 0xe3, 0x54, 0xa8, 0x95, 0xd3, 0x1e,
	0xff, 0x33, 0xf3, 0x9c, 0x90, 0xa6, 0xf6, 0xc6, 0x41, 0x6e, 0x6f, 0x3c, 0x9a, 0x44, 0x35, 0xab,
	0x31, 0x5e, 0x42, 0xc5, 0x89, 0x8b, 0xe9, 0x76, 0x89, 0x56, 0xe4, 0x84, 0xd5, 0x24, 0x21, 0xc3,
	0x4f, 0x5d, 0x9b, 0x1a, 0x63, 0xb6, 0x68, 0x0f, 0x50, 0x80, 0xfd, 0x2b, 0xec, 0xa7, 0x18, 0x4a,
	0x53, 0x18, 0x72, 0xec, 0x51, 0x1d, 0xc0, 0x37, 0x5d, 0x8b, 0x38, 0x27, 0xec, 0x0a, 0x5a, 0xe0,
	0x89, 0x4e, 0x20, 0x0f, 0xbe, 0xf5, 0x10, 0xac, 0x24, 0xcf, 0x13, 0x30, 0xb5, 0xfd, 0x52, 0xc7,
	0x40, 0x26, 0xb5, 0x8c, 0xa8, 0xa4, 0x3c, 0x51, 0x65, 0x4b, 0x22, 0xcf, 0x5d, 0x12, 0xe5, 0x9e,
	0x25, 0x59, 0x87, 0x4a, 0x28, 0x13, 0x83, 0x0c, 0x5c, 0xab, 0x6d, 0x71, 0xc9, 0xaa, 0xc6, 0x18,
	0x8a, 0xf6, 0xa1, 0x9c, 0x6c, 0xd6, 0x50, 0x8d, 0xeb, 0xe3, 0x7e, 0x82, 0x09, 0x57, 0x44, 0x12,
	0x42, 0x7b, 0xa9, 0x16, 0x11, 0x32, 0x5c, 0xcb, 0x65, 0x9a, 0xd6, 0x1f, 0xfb, 0x63, 0xfd, 0x51,
	0x9a, 0x11, 0xd1, 0xb4, 0xe6, 0x58, 0x85, 0x62, 0x80, 0xcd, 0x80, 0xb8, 0xa1, 0x28, 0xc3, 0x15,
	0x13, 0xac, 0x37, 0x7a, 0xf6, 0xb5, 0x45, 0x21, 0xd8, 0x18, 0x61, 0xaf, 0x8d, 0x83, 0xfd, 0x1e,
	0x3e, 0x30, 0xfd, 0x0b, 0x0d, 0xc4, 0x6b, 0x33, 0x02, 0xe6, 0xbe, 0xe0, 0x1e, 0x7c, 0x3f, 0xdc,
	0x48, 0x69, 0xed, 0x33, 0x95, 0x25, 0xe6, 0x06, 0xc1, 0x19, 0xcd, 0x0d, 0x55, 0x50, 0x3b, 0x64,
	0xe0, 0xd2, 0xe8, 0x98, 0x7c, 0xc1, 0xe7, 0x11, 0xdb, 0x89, 0xe6, 0x1c, 0xfe, 0x8d, 0x6a, 0xb0,
	0x30, 0x08, 0xb0, 0x7f, 0x68, 0x3a, 0x98, 0x8f, 0x37, 0x8b, 0xc6, 0x68, 0x3d, 0x9a, 0x5f, 0xd4,
	0x78, 0x7e, 0xd1, 0xdf, 0xc3, 0x72, 0x32, 0x8a, 0x43, 0xda, 0x9d, 0x18, 0x44, 0xe4, 0x4e, 0x9e,
	0xe0, 0x4e, 0x49, 0xbb, 0xd3, 0x9f, 0xc0, 0xbf, 0xad, 0x78, 0x04, 0x6c, 0xbb, 0x14, 0xf7, 0x7c,
	0xb3, 0x3f, 0x1a, 0xea, 0x2a, 0x20, 0xdb, 0x91, 0x0b, 0xd9, 0xb6, 0xf4, 0xde, 0x64, 0x73, 0x76,
	0x2d, 0xe8, 0xb1, 0x64, 0xf9, 0xf8, 0x21, 0x1e, 0xa2, 0x14, 0x76, 0xb7, 0xf7, 0x28, 0xf9, 0xf4,
	0xed, 0xf9, 0xe6, 0x35, 0x2f, 0x0c, 0xbe, 0xd4, 0x3f, 0x49, 0x59, 0x9c, 0x39, 0xce, 0xde, 0x34,
	0xd2, 0xdc, 0x37, 0x8d, 0x7c, 0xbf, 0x9b, 0x46, 0xdf, 0x88, 0xb5, 0xb2, 0xdb, 0x27, 0x01, 0x7b,
	0x33, 0x91, 0x06, 0x25, 0x3b, 0xe0, 0x2b, 0x9e, 0xc4, 0x05, 0x23, 0x5a, 0xee, 0xac, 0x7c, 0xbe,
	0xad, 0x4b, 0x5f, 0x6f, 0xeb, 0xd2, 0x8f, 0xdb, 0xba, 0xf4, 0xf1, 0x67, 0xfd, 0x8f, 0xb3, 0x22,
	0x1f, 0xe3, 0x9f, 0xfd, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x04, 0x07, 0xde, 0x62, 0xea, 0x0b, 0x00,
	0x00,
}
