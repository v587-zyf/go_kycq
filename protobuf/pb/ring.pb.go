// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ring.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 特戒穿戴
type RingWearReq struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	BagPos    int32 `protobuf:"varint,3,opt,name=bagPos,proto3" json:"bagPos,omitempty"`
}

func (m *RingWearReq) Reset()                    { *m = RingWearReq{} }
func (m *RingWearReq) String() string            { return proto.CompactTextString(m) }
func (*RingWearReq) ProtoMessage()               {}
func (*RingWearReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{0} }

func (m *RingWearReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingWearReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingWearReq) GetBagPos() int32 {
	if m != nil {
		return m.BagPos
	}
	return 0
}

type RingWearAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingWearAck) Reset()                    { *m = RingWearAck{} }
func (m *RingWearAck) String() string            { return proto.CompactTextString(m) }
func (*RingWearAck) ProtoMessage()               {}
func (*RingWearAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{1} }

func (m *RingWearAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingWearAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingWearAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

// 特戒卸掉
type RingRemoveReq struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
}

func (m *RingRemoveReq) Reset()                    { *m = RingRemoveReq{} }
func (m *RingRemoveReq) String() string            { return proto.CompactTextString(m) }
func (*RingRemoveReq) ProtoMessage()               {}
func (*RingRemoveReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{2} }

func (m *RingRemoveReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingRemoveReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

type RingRemoveAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingRemoveAck) Reset()                    { *m = RingRemoveAck{} }
func (m *RingRemoveAck) String() string            { return proto.CompactTextString(m) }
func (*RingRemoveAck) ProtoMessage()               {}
func (*RingRemoveAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{3} }

func (m *RingRemoveAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingRemoveAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingRemoveAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

// 特戒强化(ringStrengthen表)
type RingStrengthenReq struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
}

func (m *RingStrengthenReq) Reset()                    { *m = RingStrengthenReq{} }
func (m *RingStrengthenReq) String() string            { return proto.CompactTextString(m) }
func (*RingStrengthenReq) ProtoMessage()               {}
func (*RingStrengthenReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{4} }

func (m *RingStrengthenReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingStrengthenReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

type RingStrengthenAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingStrengthenAck) Reset()                    { *m = RingStrengthenAck{} }
func (m *RingStrengthenAck) String() string            { return proto.CompactTextString(m) }
func (*RingStrengthenAck) ProtoMessage()               {}
func (*RingStrengthenAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{5} }

func (m *RingStrengthenAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingStrengthenAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingStrengthenAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

// 特戒强化(ringPhantom表)
type RingPhantomReq struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
}

func (m *RingPhantomReq) Reset()                    { *m = RingPhantomReq{} }
func (m *RingPhantomReq) String() string            { return proto.CompactTextString(m) }
func (*RingPhantomReq) ProtoMessage()               {}
func (*RingPhantomReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{6} }

func (m *RingPhantomReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingPhantomReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

type RingPhantomAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingPhantomAck) Reset()                    { *m = RingPhantomAck{} }
func (m *RingPhantomAck) String() string            { return proto.CompactTextString(m) }
func (*RingPhantomAck) ProtoMessage()               {}
func (*RingPhantomAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{7} }

func (m *RingPhantomAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingPhantomAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingPhantomAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

// 技能升级
type RingSkillUpReq struct {
	HeroIndex  int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos    int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	PhantomPos int32 `protobuf:"varint,3,opt,name=phantomPos,proto3" json:"phantomPos,omitempty"`
	SkillId    int32 `protobuf:"varint,4,opt,name=skillId,proto3" json:"skillId,omitempty"`
}

func (m *RingSkillUpReq) Reset()                    { *m = RingSkillUpReq{} }
func (m *RingSkillUpReq) String() string            { return proto.CompactTextString(m) }
func (*RingSkillUpReq) ProtoMessage()               {}
func (*RingSkillUpReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{8} }

func (m *RingSkillUpReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingSkillUpReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingSkillUpReq) GetPhantomPos() int32 {
	if m != nil {
		return m.PhantomPos
	}
	return 0
}

func (m *RingSkillUpReq) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

type RingSkillUpAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingSkillUpAck) Reset()                    { *m = RingSkillUpAck{} }
func (m *RingSkillUpAck) String() string            { return proto.CompactTextString(m) }
func (*RingSkillUpAck) ProtoMessage()               {}
func (*RingSkillUpAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{9} }

func (m *RingSkillUpAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingSkillUpAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingSkillUpAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

// 融合
type RingFuseReq struct {
	Id      int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BagPos1 int32 `protobuf:"varint,2,opt,name=bagPos1,proto3" json:"bagPos1,omitempty"`
	BagPos2 int32 `protobuf:"varint,3,opt,name=bagPos2,proto3" json:"bagPos2,omitempty"`
}

func (m *RingFuseReq) Reset()                    { *m = RingFuseReq{} }
func (m *RingFuseReq) String() string            { return proto.CompactTextString(m) }
func (*RingFuseReq) ProtoMessage()               {}
func (*RingFuseReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{10} }

func (m *RingFuseReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RingFuseReq) GetBagPos1() int32 {
	if m != nil {
		return m.BagPos1
	}
	return 0
}

func (m *RingFuseReq) GetBagPos2() int32 {
	if m != nil {
		return m.BagPos2
	}
	return 0
}

type RingFuseAck struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RingFuseAck) Reset()                    { *m = RingFuseAck{} }
func (m *RingFuseAck) String() string            { return proto.CompactTextString(m) }
func (*RingFuseAck) ProtoMessage()               {}
func (*RingFuseAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{11} }

func (m *RingFuseAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 重置技能点
type RingSkillResetReq struct {
	HeroIndex  int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos    int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	PhantomPos int32 `protobuf:"varint,3,opt,name=phantomPos,proto3" json:"phantomPos,omitempty"`
}

func (m *RingSkillResetReq) Reset()                    { *m = RingSkillResetReq{} }
func (m *RingSkillResetReq) String() string            { return proto.CompactTextString(m) }
func (*RingSkillResetReq) ProtoMessage()               {}
func (*RingSkillResetReq) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{12} }

func (m *RingSkillResetReq) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingSkillResetReq) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingSkillResetReq) GetPhantomPos() int32 {
	if m != nil {
		return m.PhantomPos
	}
	return 0
}

type RingSkillResetAck struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	RingPos   int32 `protobuf:"varint,2,opt,name=ringPos,proto3" json:"ringPos,omitempty"`
	Ring      *Ring `protobuf:"bytes,3,opt,name=ring" json:"ring,omitempty"`
}

func (m *RingSkillResetAck) Reset()                    { *m = RingSkillResetAck{} }
func (m *RingSkillResetAck) String() string            { return proto.CompactTextString(m) }
func (*RingSkillResetAck) ProtoMessage()               {}
func (*RingSkillResetAck) Descriptor() ([]byte, []int) { return fileDescriptorRing, []int{13} }

func (m *RingSkillResetAck) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *RingSkillResetAck) GetRingPos() int32 {
	if m != nil {
		return m.RingPos
	}
	return 0
}

func (m *RingSkillResetAck) GetRing() *Ring {
	if m != nil {
		return m.Ring
	}
	return nil
}

func init() {
	proto.RegisterType((*RingWearReq)(nil), "pb.RingWearReq")
	proto.RegisterType((*RingWearAck)(nil), "pb.RingWearAck")
	proto.RegisterType((*RingRemoveReq)(nil), "pb.RingRemoveReq")
	proto.RegisterType((*RingRemoveAck)(nil), "pb.RingRemoveAck")
	proto.RegisterType((*RingStrengthenReq)(nil), "pb.RingStrengthenReq")
	proto.RegisterType((*RingStrengthenAck)(nil), "pb.RingStrengthenAck")
	proto.RegisterType((*RingPhantomReq)(nil), "pb.RingPhantomReq")
	proto.RegisterType((*RingPhantomAck)(nil), "pb.RingPhantomAck")
	proto.RegisterType((*RingSkillUpReq)(nil), "pb.RingSkillUpReq")
	proto.RegisterType((*RingSkillUpAck)(nil), "pb.RingSkillUpAck")
	proto.RegisterType((*RingFuseReq)(nil), "pb.RingFuseReq")
	proto.RegisterType((*RingFuseAck)(nil), "pb.RingFuseAck")
	proto.RegisterType((*RingSkillResetReq)(nil), "pb.RingSkillResetReq")
	proto.RegisterType((*RingSkillResetAck)(nil), "pb.RingSkillResetAck")
}
func (m *RingWearReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingWearReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.BagPos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.BagPos))
	}
	return i, nil
}

func (m *RingWearAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingWearAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n1, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *RingRemoveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingRemoveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	return i, nil
}

func (m *RingRemoveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingRemoveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n2, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *RingStrengthenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingStrengthenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	return i, nil
}

func (m *RingStrengthenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingStrengthenAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n3, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *RingPhantomReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingPhantomReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	return i, nil
}

func (m *RingPhantomAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingPhantomAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n4, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *RingSkillUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingSkillUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.PhantomPos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.PhantomPos))
	}
	if m.SkillId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.SkillId))
	}
	return i, nil
}

func (m *RingSkillUpAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingSkillUpAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n5, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *RingFuseReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingFuseReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Id))
	}
	if m.BagPos1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.BagPos1))
	}
	if m.BagPos2 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.BagPos2))
	}
	return i, nil
}

func (m *RingFuseAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingFuseAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *RingSkillResetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingSkillResetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.PhantomPos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.PhantomPos))
	}
	return i, nil
}

func (m *RingSkillResetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingSkillResetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.RingPos))
	}
	if m.Ring != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRing(dAtA, i, uint64(m.Ring.Size()))
		n6, err := m.Ring.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func encodeVarintRing(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RingWearReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.BagPos != 0 {
		n += 1 + sovRing(uint64(m.BagPos))
	}
	return n
}

func (m *RingWearAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func (m *RingRemoveReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	return n
}

func (m *RingRemoveAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func (m *RingStrengthenReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	return n
}

func (m *RingStrengthenAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func (m *RingPhantomReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	return n
}

func (m *RingPhantomAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func (m *RingSkillUpReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.PhantomPos != 0 {
		n += 1 + sovRing(uint64(m.PhantomPos))
	}
	if m.SkillId != 0 {
		n += 1 + sovRing(uint64(m.SkillId))
	}
	return n
}

func (m *RingSkillUpAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func (m *RingFuseReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRing(uint64(m.Id))
	}
	if m.BagPos1 != 0 {
		n += 1 + sovRing(uint64(m.BagPos1))
	}
	if m.BagPos2 != 0 {
		n += 1 + sovRing(uint64(m.BagPos2))
	}
	return n
}

func (m *RingFuseAck) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRing(uint64(m.Id))
	}
	return n
}

func (m *RingSkillResetReq) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.PhantomPos != 0 {
		n += 1 + sovRing(uint64(m.PhantomPos))
	}
	return n
}

func (m *RingSkillResetAck) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovRing(uint64(m.HeroIndex))
	}
	if m.RingPos != 0 {
		n += 1 + sovRing(uint64(m.RingPos))
	}
	if m.Ring != nil {
		l = m.Ring.Size()
		n += 1 + l + sovRing(uint64(l))
	}
	return n
}

func sovRing(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRing(x uint64) (n int) {
	return sovRing(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RingWearReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingWearReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingWearReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagPos", wireType)
			}
			m.BagPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingWearAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingWearAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingWearAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingRemoveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingRemoveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingRemoveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingRemoveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingRemoveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingRemoveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingStrengthenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingStrengthenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingStrengthenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingStrengthenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingStrengthenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingStrengthenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingPhantomReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingPhantomReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingPhantomReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingPhantomAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingPhantomAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingPhantomAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingSkillUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingSkillUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingSkillUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhantomPos", wireType)
			}
			m.PhantomPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhantomPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingSkillUpAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingSkillUpAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingSkillUpAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingFuseReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingFuseReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingFuseReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagPos1", wireType)
			}
			m.BagPos1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagPos1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagPos2", wireType)
			}
			m.BagPos2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagPos2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingFuseAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingFuseAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingFuseAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingSkillResetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingSkillResetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingSkillResetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhantomPos", wireType)
			}
			m.PhantomPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhantomPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingSkillResetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingSkillResetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingSkillResetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingPos", wireType)
			}
			m.RingPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ring == nil {
				m.Ring = &Ring{}
			}
			if err := m.Ring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRing(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRing(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRing
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRing
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRing
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRing(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRing = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRing   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ring.proto", fileDescriptorRing) }

var fileDescriptorRing = []byte{
	// 342 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0xbd, 0x4e, 0xfb, 0x30,
	0x14, 0xc5, 0xff, 0xce, 0xbf, 0x14, 0xb8, 0x85, 0x0a, 0x32, 0xa0, 0x08, 0x95, 0x08, 0x79, 0x62,
	0xaa, 0x44, 0x79, 0x02, 0x18, 0x80, 0x8a, 0xa5, 0xa4, 0x42, 0x4c, 0x0c, 0xf9, 0x30, 0x89, 0x95,
	0xc6, 0x0e, 0x49, 0x40, 0xcc, 0x3c, 0x05, 0x8f, 0xc4, 0xc8, 0x23, 0xa0, 0xf0, 0x22, 0xc8, 0x1f,
	0x69, 0x4a, 0x47, 0x22, 0x6f, 0x39, 0xf7, 0xca, 0x3f, 0x9f, 0x63, 0xdd, 0x1b, 0x80, 0x82, 0xb2,
	0x78, 0x9c, 0x17, 0xbc, 0xe2, 0xb6, 0x95, 0x07, 0x87, 0x3b, 0x21, 0xcf, 0x32, 0xce, 0x54, 0x05,
	0x3f, 0xc0, 0xc0, 0xa3, 0x2c, 0xbe, 0x27, 0x7e, 0xe1, 0x91, 0x27, 0x7b, 0x04, 0xdb, 0x09, 0x29,
	0xf8, 0x94, 0x45, 0xe4, 0xd5, 0x41, 0xc7, 0xe8, 0x64, 0xc3, 0x6b, 0x0b, 0xb6, 0x03, 0x9b, 0x02,
	0x36, 0xe3, 0xa5, 0x63, 0xc9, 0x5e, 0x23, 0xed, 0x03, 0xe8, 0x07, 0xbe, 0x6c, 0xfc, 0x97, 0x0d,
	0xad, 0x70, 0xd8, 0xe2, 0xcf, 0xc3, 0xf4, 0xcf, 0xf8, 0x11, 0xf4, 0xc4, 0xa7, 0x84, 0x0f, 0x26,
	0x5b, 0xe3, 0x3c, 0x18, 0x0b, 0xac, 0x27, 0xab, 0xf8, 0x0a, 0x76, 0xa5, 0x22, 0x19, 0x7f, 0x21,
	0x1d, 0x52, 0x60, 0xb2, 0x0a, 0x32, 0xe7, 0xf7, 0x06, 0xf6, 0x85, 0x9a, 0x57, 0x05, 0x61, 0x71,
	0x95, 0x10, 0xd6, 0xc5, 0x33, 0x5d, 0x87, 0x99, 0xf3, 0x7d, 0x0d, 0x43, 0xa1, 0x66, 0x89, 0xcf,
	0x2a, 0x9e, 0x75, 0x31, 0xfd, 0xf8, 0x8b, 0x64, 0xce, 0xf1, 0x1b, 0x52, 0x17, 0xcd, 0x53, 0xba,
	0x58, 0xdc, 0xe5, 0x5d, 0x26, 0xdc, 0x05, 0xc8, 0x95, 0xdd, 0x76, 0xca, 0x57, 0x2a, 0xe2, 0x64,
	0x29, 0x6e, 0x99, 0x46, 0x4e, 0x4f, 0x9d, 0xd4, 0xb2, 0x09, 0xab, 0x3d, 0x98, 0x0b, 0x7b, 0xab,
	0x76, 0xed, 0xf2, 0xb9, 0x94, 0x4b, 0x30, 0x04, 0x8b, 0x46, 0x9a, 0x6e, 0xd1, 0x48, 0x60, 0xd5,
	0x52, 0x9e, 0x36, 0x58, 0x2d, 0xdb, 0xce, 0x44, 0xe7, 0x6a, 0x24, 0x3e, 0x6a, 0x91, 0xc2, 0xf7,
	0x1a, 0x12, 0xa7, 0x7a, 0xf6, 0x44, 0x32, 0x8f, 0x94, 0xa4, 0x32, 0xf8, 0xc0, 0xcb, 0x41, 0x5f,
	0x5e, 0x66, 0xec, 0x25, 0x2f, 0xf6, 0x3e, 0x6a, 0x17, 0x7d, 0xd6, 0x2e, 0xfa, 0xaa, 0x5d, 0xf4,
	0xfe, 0xed, 0xfe, 0x0b, 0xfa, 0xf2, 0x6f, 0x79, 0xf6, 0x13, 0x00, 0x00, 0xff, 0xff, 0x13, 0xc0,
	0xce, 0x75, 0x4d, 0x05, 0x00, 0x00,
}
