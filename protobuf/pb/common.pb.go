// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ErrorAck struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ErrorAck) Reset()                    { *m = ErrorAck{} }
func (m *ErrorAck) String() string            { return proto.CompactTextString(m) }
func (*ErrorAck) ProtoMessage()               {}
func (*ErrorAck) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *ErrorAck) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrorAck) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type UserLoginInfo struct {
	Userid                         int32                          `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	NickName                       string                         `protobuf:"bytes,2,opt,name=nickName,proto3" json:"nickName,omitempty"`
	Avatar                         string                         `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	VipLevel                       int32                          `protobuf:"varint,4,opt,name=vipLevel,proto3" json:"vipLevel,omitempty"`
	VipScore                       int32                          `protobuf:"varint,5,opt,name=vipScore,proto3" json:"vipScore,omitempty"`
	Level                          int32                          `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	Exp                            int32                          `protobuf:"varint,7,opt,name=exp,proto3" json:"exp,omitempty"`
	Gold                           int64                          `protobuf:"varint,8,opt,name=gold,proto3" json:"gold,omitempty"`
	Ingot                          int32                          `protobuf:"varint,9,opt,name=ingot,proto3" json:"ingot,omitempty"`
	CreateTime                     int32                          `protobuf:"varint,10,opt,name=createTime,proto3" json:"createTime,omitempty"`
	StageId                        int32                          `protobuf:"varint,11,opt,name=stageId,proto3" json:"stageId,omitempty"`
	StageWave                      int32                          `protobuf:"varint,12,opt,name=stageWave,proto3" json:"stageWave,omitempty"`
	Combat                         int64                          `protobuf:"varint,14,opt,name=combat,proto3" json:"combat,omitempty"`
	Heros                          []*HeroInfo                    `protobuf:"bytes,15,rep,name=heros" json:"heros,omitempty"`
	Rein                           *Rein                          `protobuf:"bytes,16,opt,name=rein" json:"rein,omitempty"`
	ReinCost                       []*ReinCost                    `protobuf:"bytes,17,rep,name=reinCost" json:"reinCost,omitempty"`
	Fabao                          []*Fabao                       `protobuf:"bytes,18,rep,name=fabao" json:"fabao,omitempty"`
	FieldBossInfo                  *FieldBossInfo                 `protobuf:"bytes,19,opt,name=fieldBossInfo" json:"fieldBossInfo,omitempty"`
	WorldBossInfo                  *WorldBossInfoNtf              `protobuf:"bytes,20,opt,name=worldBossInfo" json:"worldBossInfo,omitempty"`
	ArenaFightNum                  int32                          `protobuf:"varint,21,opt,name=ArenaFightNum,proto3" json:"ArenaFightNum,omitempty"`
	FightModel                     int32                          `protobuf:"varint,22,opt,name=fightModel,proto3" json:"fightModel,omitempty"`
	Task                           *TaskInfoNtf                   `protobuf:"bytes,23,opt,name=task" json:"task,omitempty"`
	ShopInfo                       map[int32]*ShopInfo            `protobuf:"bytes,24,rep,name=shopInfo" json:"shopInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ChuanqiBi                      int32                          `protobuf:"varint,25,opt,name=chuanqiBi,proto3" json:"chuanqiBi,omitempty"`
	MaterialStage                  map[int32]*MaterialStage       `protobuf:"bytes,26,rep,name=materialStage" json:"materialStage,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Panaceas                       map[int32]*PanaceaInfo         `protobuf:"bytes,27,rep,name=panaceas" json:"panaceas,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	SignInfo                       *SignInfo                      `protobuf:"bytes,28,opt,name=signInfo" json:"signInfo,omitempty"`
	DayStateInfo                   *DayStateInfo                  `protobuf:"bytes,29,opt,name=dayStateInfo" json:"dayStateInfo,omitempty"`
	Official                       int32                          `protobuf:"varint,30,opt,name=official,proto3" json:"official,omitempty"`
	Holy                           []*Holy                        `protobuf:"bytes,31,rep,name=holy" json:"holy,omitempty"`
	Atlases                        []*Atlas                       `protobuf:"bytes,32,rep,name=atlases" json:"atlases,omitempty"`
	AtlasGathers                   []*AtlasGather                 `protobuf:"bytes,33,rep,name=atlasGathers" json:"atlasGathers,omitempty"`
	MiningWorkTime                 int64                          `protobuf:"varint,34,opt,name=miningWorkTime,proto3" json:"miningWorkTime,omitempty"`
	Miner                          int32                          `protobuf:"varint,35,opt,name=miner,proto3" json:"miner,omitempty"`
	ExpStage                       *ExpStage                      `protobuf:"bytes,36,opt,name=expStage" json:"expStage,omitempty"`
	Pets                           map[int32]*PetInfo             `protobuf:"bytes,37,rep,name=pets" json:"pets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Juexues                        []*Juexue                      `protobuf:"bytes,38,rep,name=juexues" json:"juexues,omitempty"`
	UserWear                       *UserWear                      `protobuf:"bytes,39,opt,name=userWear" json:"userWear,omitempty"`
	IsHaveGetDailyCompetitveReward int32                          `protobuf:"varint,40,opt,name=isHaveGetDailyCompetitveReward,proto3" json:"isHaveGetDailyCompetitveReward,omitempty"`
	Honour                         int64                          `protobuf:"varint,41,opt,name=honour,proto3" json:"honour,omitempty"`
	DarkPalaceInfo                 *DarkPalaceInfo                `protobuf:"bytes,42,opt,name=darkPalaceInfo" json:"darkPalaceInfo,omitempty"`
	PersonBoss                     map[int32]int32                `protobuf:"bytes,43,rep,name=personBoss" json:"personBoss,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipBoss                        map[int32]int32                `protobuf:"bytes,44,rep,name=vipBoss" json:"vipBoss,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipGift                        []int32                        `protobuf:"varint,45,rep,packed,name=vipGift" json:"vipGift,omitempty"`
	Fit                            *Fit                           `protobuf:"bytes,46,opt,name=fit" json:"fit,omitempty"`
	RechargeAll                    int32                          `protobuf:"varint,47,opt,name=rechargeAll,proto3" json:"rechargeAll,omitempty"`
	AccumulativeAllGetIds          []int32                        `protobuf:"varint,48,rep,packed,name=accumulativeAllGetIds" json:"accumulativeAllGetIds,omitempty"`
	MonthCard                      map[int32]*MonthCardUnit       `protobuf:"bytes,49,rep,name=monthCard" json:"monthCard,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	FirstRecharge                  *FirstRecharge                 `protobuf:"bytes,50,opt,name=firstRecharge" json:"firstRecharge,omitempty"`
	SpendRebates                   *SpendRebates                  `protobuf:"bytes,51,opt,name=spendRebates" json:"spendRebates,omitempty"`
	DailyPack                      map[int32]int32                `protobuf:"bytes,52,rep,name=dailyPack" json:"dailyPack,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GrowFund                       *GrowFund                      `protobuf:"bytes,53,opt,name=growFund" json:"growFund,omitempty"`
	WarOrder                       *WarOrder                      `protobuf:"bytes,54,opt,name=warOrder" json:"warOrder,omitempty"`
	RedPacketGetNum                int32                          `protobuf:"varint,55,opt,name=redPacketGetNum,proto3" json:"redPacketGetNum,omitempty"`
	Elf                            *Elf                           `protobuf:"bytes,56,opt,name=elf" json:"elf,omitempty"`
	CutTreasureLv                  int32                          `protobuf:"varint,57,opt,name=cutTreasureLv,proto3" json:"cutTreasureLv,omitempty"`
	FitHolyEquip                   *FitHolyEquip                  `protobuf:"bytes,58,opt,name=fitHolyEquip" json:"fitHolyEquip,omitempty"`
	Recharge                       []int32                        `protobuf:"varint,59,rep,packed,name=recharge" json:"recharge,omitempty"`
	ShaBakeIsEnd                   int32                          `protobuf:"varint,60,opt,name=shaBakeIsEnd,proto3" json:"shaBakeIsEnd,omitempty"`
	CrossShabakeIsEnd              int32                          `protobuf:"varint,61,opt,name=crossShabakeIsEnd,proto3" json:"crossShabakeIsEnd,omitempty"`
	IsFriendApply                  bool                           `protobuf:"varint,62,opt,name=isFriendApply,proto3" json:"isFriendApply,omitempty"`
	BindingIngot                   int32                          `protobuf:"varint,63,opt,name=bindingIngot,proto3" json:"bindingIngot,omitempty"`
	HookupTime                     int32                          `protobuf:"varint,64,opt,name=hookupTime,proto3" json:"hookupTime,omitempty"`
	HookupBag                      []*ItemUnit                    `protobuf:"bytes,65,rep,name=hookupBag" json:"hookupBag,omitempty"`
	ContRecharge                   *ContRecharge                  `protobuf:"bytes,66,opt,name=contRecharge" json:"contRecharge,omitempty"`
	OpenGift                       map[int32]int32                `protobuf:"bytes,67,rep,name=openGift" json:"openGift,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CrossChallengeIsApply          int32                          `protobuf:"varint,68,opt,name=crossChallengeIsApply,proto3" json:"crossChallengeIsApply,omitempty"`
	AnnouncementInfos              []*AnnouncementInfo            `protobuf:"bytes,69,rep,name=AnnouncementInfos" json:"AnnouncementInfos,omitempty"`
	VipCustomer                    bool                           `protobuf:"varint,70,opt,name=vipCustomer,proto3" json:"vipCustomer,omitempty"`
	ChatBanTime                    int32                          `protobuf:"varint,71,opt,name=chatBanTime,proto3" json:"chatBanTime,omitempty"`
	HaveUseRecharge                int32                          `protobuf:"varint,72,opt,name=haveUseRecharge,proto3" json:"haveUseRecharge,omitempty"`
	GoldIngot                      int32                          `protobuf:"varint,73,opt,name=goldIngot,proto3" json:"goldIngot,omitempty"`
	AncientBossInfo                *AncientBossInfo               `protobuf:"bytes,74,opt,name=ancientBossInfo" json:"ancientBossInfo,omitempty"`
	TitleList                      []*Title                       `protobuf:"bytes,75,rep,name=titleList" json:"titleList,omitempty"`
	MiJiInfos                      []*MiJiInfo                    `protobuf:"bytes,76,rep,name=miJiInfos" json:"miJiInfos,omitempty"`
	AncientTreasureInfo            map[int32]*AncientTreasureInfo `protobuf:"bytes,77,rep,name=ancientTreasureInfo" json:"ancientTreasureInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	PetAppendage                   map[int32]int32                `protobuf:"bytes,78,rep,name=petAppendage" json:"petAppendage,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	HellBossInfo                   *HellBossInfo                  `protobuf:"bytes,79,opt,name=hellBossInfo" json:"hellBossInfo,omitempty"`
	RedPacketNum                   int32                          `protobuf:"varint,80,opt,name=redPacketNum,proto3" json:"redPacketNum,omitempty"`
	DaBaoEquip                     map[int32]int32                `protobuf:"bytes,81,rep,name=daBaoEquip" json:"daBaoEquip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DaBaoMysteryEnergy             int32                          `protobuf:"varint,82,opt,name=daBaoMysteryEnergy,proto3" json:"daBaoMysteryEnergy,omitempty"`
	AppletsEnergy                  int32                          `protobuf:"varint,83,opt,name=appletsEnergy,proto3" json:"appletsEnergy,omitempty"`
	AppletsResumeTime              int32                          `protobuf:"varint,84,opt,name=appletsResumeTime,proto3" json:"appletsResumeTime,omitempty"`
	AppletsInfos                   map[int32]*AppletsInfo         `protobuf:"bytes,85,rep,name=appletsInfos" json:"appletsInfos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Label                          *Label                         `protobuf:"bytes,86,opt,name=label" json:"label,omitempty"`
	Subscribe                      []int32                        `protobuf:"varint,87,rep,packed,name=subscribe" json:"subscribe,omitempty"`
	Privilege                      []int32                        `protobuf:"varint,88,rep,packed,name=privilege" json:"privilege,omitempty"`
	UseRedPacketNum                int32                          `protobuf:"varint,89,opt,name=useRedPacketNum,proto3" json:"useRedPacketNum,omitempty"`
	DailyRecharge                  int32                          `protobuf:"varint,90,opt,name=dailyRecharge,proto3" json:"dailyRecharge,omitempty"`
}

func (m *UserLoginInfo) Reset()                    { *m = UserLoginInfo{} }
func (m *UserLoginInfo) String() string            { return proto.CompactTextString(m) }
func (*UserLoginInfo) ProtoMessage()               {}
func (*UserLoginInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *UserLoginInfo) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *UserLoginInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *UserLoginInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *UserLoginInfo) GetVipLevel() int32 {
	if m != nil {
		return m.VipLevel
	}
	return 0
}

func (m *UserLoginInfo) GetVipScore() int32 {
	if m != nil {
		return m.VipScore
	}
	return 0
}

func (m *UserLoginInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UserLoginInfo) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *UserLoginInfo) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *UserLoginInfo) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *UserLoginInfo) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *UserLoginInfo) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *UserLoginInfo) GetStageWave() int32 {
	if m != nil {
		return m.StageWave
	}
	return 0
}

func (m *UserLoginInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *UserLoginInfo) GetHeros() []*HeroInfo {
	if m != nil {
		return m.Heros
	}
	return nil
}

func (m *UserLoginInfo) GetRein() *Rein {
	if m != nil {
		return m.Rein
	}
	return nil
}

func (m *UserLoginInfo) GetReinCost() []*ReinCost {
	if m != nil {
		return m.ReinCost
	}
	return nil
}

func (m *UserLoginInfo) GetFabao() []*Fabao {
	if m != nil {
		return m.Fabao
	}
	return nil
}

func (m *UserLoginInfo) GetFieldBossInfo() *FieldBossInfo {
	if m != nil {
		return m.FieldBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetWorldBossInfo() *WorldBossInfoNtf {
	if m != nil {
		return m.WorldBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetArenaFightNum() int32 {
	if m != nil {
		return m.ArenaFightNum
	}
	return 0
}

func (m *UserLoginInfo) GetFightModel() int32 {
	if m != nil {
		return m.FightModel
	}
	return 0
}

func (m *UserLoginInfo) GetTask() *TaskInfoNtf {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *UserLoginInfo) GetShopInfo() map[int32]*ShopInfo {
	if m != nil {
		return m.ShopInfo
	}
	return nil
}

func (m *UserLoginInfo) GetChuanqiBi() int32 {
	if m != nil {
		return m.ChuanqiBi
	}
	return 0
}

func (m *UserLoginInfo) GetMaterialStage() map[int32]*MaterialStage {
	if m != nil {
		return m.MaterialStage
	}
	return nil
}

func (m *UserLoginInfo) GetPanaceas() map[int32]*PanaceaInfo {
	if m != nil {
		return m.Panaceas
	}
	return nil
}

func (m *UserLoginInfo) GetSignInfo() *SignInfo {
	if m != nil {
		return m.SignInfo
	}
	return nil
}

func (m *UserLoginInfo) GetDayStateInfo() *DayStateInfo {
	if m != nil {
		return m.DayStateInfo
	}
	return nil
}

func (m *UserLoginInfo) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *UserLoginInfo) GetHoly() []*Holy {
	if m != nil {
		return m.Holy
	}
	return nil
}

func (m *UserLoginInfo) GetAtlases() []*Atlas {
	if m != nil {
		return m.Atlases
	}
	return nil
}

func (m *UserLoginInfo) GetAtlasGathers() []*AtlasGather {
	if m != nil {
		return m.AtlasGathers
	}
	return nil
}

func (m *UserLoginInfo) GetMiningWorkTime() int64 {
	if m != nil {
		return m.MiningWorkTime
	}
	return 0
}

func (m *UserLoginInfo) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *UserLoginInfo) GetExpStage() *ExpStage {
	if m != nil {
		return m.ExpStage
	}
	return nil
}

func (m *UserLoginInfo) GetPets() map[int32]*PetInfo {
	if m != nil {
		return m.Pets
	}
	return nil
}

func (m *UserLoginInfo) GetJuexues() []*Juexue {
	if m != nil {
		return m.Juexues
	}
	return nil
}

func (m *UserLoginInfo) GetUserWear() *UserWear {
	if m != nil {
		return m.UserWear
	}
	return nil
}

func (m *UserLoginInfo) GetIsHaveGetDailyCompetitveReward() int32 {
	if m != nil {
		return m.IsHaveGetDailyCompetitveReward
	}
	return 0
}

func (m *UserLoginInfo) GetHonour() int64 {
	if m != nil {
		return m.Honour
	}
	return 0
}

func (m *UserLoginInfo) GetDarkPalaceInfo() *DarkPalaceInfo {
	if m != nil {
		return m.DarkPalaceInfo
	}
	return nil
}

func (m *UserLoginInfo) GetPersonBoss() map[int32]int32 {
	if m != nil {
		return m.PersonBoss
	}
	return nil
}

func (m *UserLoginInfo) GetVipBoss() map[int32]int32 {
	if m != nil {
		return m.VipBoss
	}
	return nil
}

func (m *UserLoginInfo) GetVipGift() []int32 {
	if m != nil {
		return m.VipGift
	}
	return nil
}

func (m *UserLoginInfo) GetFit() *Fit {
	if m != nil {
		return m.Fit
	}
	return nil
}

func (m *UserLoginInfo) GetRechargeAll() int32 {
	if m != nil {
		return m.RechargeAll
	}
	return 0
}

func (m *UserLoginInfo) GetAccumulativeAllGetIds() []int32 {
	if m != nil {
		return m.AccumulativeAllGetIds
	}
	return nil
}

func (m *UserLoginInfo) GetMonthCard() map[int32]*MonthCardUnit {
	if m != nil {
		return m.MonthCard
	}
	return nil
}

func (m *UserLoginInfo) GetFirstRecharge() *FirstRecharge {
	if m != nil {
		return m.FirstRecharge
	}
	return nil
}

func (m *UserLoginInfo) GetSpendRebates() *SpendRebates {
	if m != nil {
		return m.SpendRebates
	}
	return nil
}

func (m *UserLoginInfo) GetDailyPack() map[int32]int32 {
	if m != nil {
		return m.DailyPack
	}
	return nil
}

func (m *UserLoginInfo) GetGrowFund() *GrowFund {
	if m != nil {
		return m.GrowFund
	}
	return nil
}

func (m *UserLoginInfo) GetWarOrder() *WarOrder {
	if m != nil {
		return m.WarOrder
	}
	return nil
}

func (m *UserLoginInfo) GetRedPacketGetNum() int32 {
	if m != nil {
		return m.RedPacketGetNum
	}
	return 0
}

func (m *UserLoginInfo) GetElf() *Elf {
	if m != nil {
		return m.Elf
	}
	return nil
}

func (m *UserLoginInfo) GetCutTreasureLv() int32 {
	if m != nil {
		return m.CutTreasureLv
	}
	return 0
}

func (m *UserLoginInfo) GetFitHolyEquip() *FitHolyEquip {
	if m != nil {
		return m.FitHolyEquip
	}
	return nil
}

func (m *UserLoginInfo) GetRecharge() []int32 {
	if m != nil {
		return m.Recharge
	}
	return nil
}

func (m *UserLoginInfo) GetShaBakeIsEnd() int32 {
	if m != nil {
		return m.ShaBakeIsEnd
	}
	return 0
}

func (m *UserLoginInfo) GetCrossShabakeIsEnd() int32 {
	if m != nil {
		return m.CrossShabakeIsEnd
	}
	return 0
}

func (m *UserLoginInfo) GetIsFriendApply() bool {
	if m != nil {
		return m.IsFriendApply
	}
	return false
}

func (m *UserLoginInfo) GetBindingIngot() int32 {
	if m != nil {
		return m.BindingIngot
	}
	return 0
}

func (m *UserLoginInfo) GetHookupTime() int32 {
	if m != nil {
		return m.HookupTime
	}
	return 0
}

func (m *UserLoginInfo) GetHookupBag() []*ItemUnit {
	if m != nil {
		return m.HookupBag
	}
	return nil
}

func (m *UserLoginInfo) GetContRecharge() *ContRecharge {
	if m != nil {
		return m.ContRecharge
	}
	return nil
}

func (m *UserLoginInfo) GetOpenGift() map[int32]int32 {
	if m != nil {
		return m.OpenGift
	}
	return nil
}

func (m *UserLoginInfo) GetCrossChallengeIsApply() int32 {
	if m != nil {
		return m.CrossChallengeIsApply
	}
	return 0
}

func (m *UserLoginInfo) GetAnnouncementInfos() []*AnnouncementInfo {
	if m != nil {
		return m.AnnouncementInfos
	}
	return nil
}

func (m *UserLoginInfo) GetVipCustomer() bool {
	if m != nil {
		return m.VipCustomer
	}
	return false
}

func (m *UserLoginInfo) GetChatBanTime() int32 {
	if m != nil {
		return m.ChatBanTime
	}
	return 0
}

func (m *UserLoginInfo) GetHaveUseRecharge() int32 {
	if m != nil {
		return m.HaveUseRecharge
	}
	return 0
}

func (m *UserLoginInfo) GetGoldIngot() int32 {
	if m != nil {
		return m.GoldIngot
	}
	return 0
}

func (m *UserLoginInfo) GetAncientBossInfo() *AncientBossInfo {
	if m != nil {
		return m.AncientBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetTitleList() []*Title {
	if m != nil {
		return m.TitleList
	}
	return nil
}

func (m *UserLoginInfo) GetMiJiInfos() []*MiJiInfo {
	if m != nil {
		return m.MiJiInfos
	}
	return nil
}

func (m *UserLoginInfo) GetAncientTreasureInfo() map[int32]*AncientTreasureInfo {
	if m != nil {
		return m.AncientTreasureInfo
	}
	return nil
}

func (m *UserLoginInfo) GetPetAppendage() map[int32]int32 {
	if m != nil {
		return m.PetAppendage
	}
	return nil
}

func (m *UserLoginInfo) GetHellBossInfo() *HellBossInfo {
	if m != nil {
		return m.HellBossInfo
	}
	return nil
}

func (m *UserLoginInfo) GetRedPacketNum() int32 {
	if m != nil {
		return m.RedPacketNum
	}
	return 0
}

func (m *UserLoginInfo) GetDaBaoEquip() map[int32]int32 {
	if m != nil {
		return m.DaBaoEquip
	}
	return nil
}

func (m *UserLoginInfo) GetDaBaoMysteryEnergy() int32 {
	if m != nil {
		return m.DaBaoMysteryEnergy
	}
	return 0
}

func (m *UserLoginInfo) GetAppletsEnergy() int32 {
	if m != nil {
		return m.AppletsEnergy
	}
	return 0
}

func (m *UserLoginInfo) GetAppletsResumeTime() int32 {
	if m != nil {
		return m.AppletsResumeTime
	}
	return 0
}

func (m *UserLoginInfo) GetAppletsInfos() map[int32]*AppletsInfo {
	if m != nil {
		return m.AppletsInfos
	}
	return nil
}

func (m *UserLoginInfo) GetLabel() *Label {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *UserLoginInfo) GetSubscribe() []int32 {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

func (m *UserLoginInfo) GetPrivilege() []int32 {
	if m != nil {
		return m.Privilege
	}
	return nil
}

func (m *UserLoginInfo) GetUseRedPacketNum() int32 {
	if m != nil {
		return m.UseRedPacketNum
	}
	return 0
}

func (m *UserLoginInfo) GetDailyRecharge() int32 {
	if m != nil {
		return m.DailyRecharge
	}
	return 0
}

type AppletsInfo struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *AppletsInfo) Reset()                    { *m = AppletsInfo{} }
func (m *AppletsInfo) String() string            { return proto.CompactTextString(m) }
func (*AppletsInfo) ProtoMessage()               {}
func (*AppletsInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *AppletsInfo) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

type AncientTreasureInfo struct {
	ZhuLinLv int32 `protobuf:"varint,1,opt,name=zhuLinLv,proto3" json:"zhuLinLv,omitempty"`
	StarLv   int32 `protobuf:"varint,2,opt,name=starLv,proto3" json:"starLv,omitempty"`
	JueXinLv int32 `protobuf:"varint,3,opt,name=jueXinLv,proto3" json:"jueXinLv,omitempty"`
	Types    int32 `protobuf:"varint,4,opt,name=types,proto3" json:"types,omitempty"`
}

func (m *AncientTreasureInfo) Reset()                    { *m = AncientTreasureInfo{} }
func (m *AncientTreasureInfo) String() string            { return proto.CompactTextString(m) }
func (*AncientTreasureInfo) ProtoMessage()               {}
func (*AncientTreasureInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *AncientTreasureInfo) GetZhuLinLv() int32 {
	if m != nil {
		return m.ZhuLinLv
	}
	return 0
}

func (m *AncientTreasureInfo) GetStarLv() int32 {
	if m != nil {
		return m.StarLv
	}
	return 0
}

func (m *AncientTreasureInfo) GetJueXinLv() int32 {
	if m != nil {
		return m.JueXinLv
	}
	return 0
}

func (m *AncientTreasureInfo) GetTypes() int32 {
	if m != nil {
		return m.Types
	}
	return 0
}

type MiJiInfo struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lv int32 `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
}

func (m *MiJiInfo) Reset()                    { *m = MiJiInfo{} }
func (m *MiJiInfo) String() string            { return proto.CompactTextString(m) }
func (*MiJiInfo) ProtoMessage()               {}
func (*MiJiInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *MiJiInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MiJiInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

type AnnouncementInfo struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Title        string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Announcement string `protobuf:"bytes,3,opt,name=announcement,proto3" json:"announcement,omitempty"`
}

func (m *AnnouncementInfo) Reset()                    { *m = AnnouncementInfo{} }
func (m *AnnouncementInfo) String() string            { return proto.CompactTextString(m) }
func (*AnnouncementInfo) ProtoMessage()               {}
func (*AnnouncementInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

func (m *AnnouncementInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AnnouncementInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AnnouncementInfo) GetAnnouncement() string {
	if m != nil {
		return m.Announcement
	}
	return ""
}

type HeroInfo struct {
	Index              int32                       `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Job                int32                       `protobuf:"varint,2,opt,name=job,proto3" json:"job,omitempty"`
	Sex                int32                       `protobuf:"varint,3,opt,name=sex,proto3" json:"sex,omitempty"`
	Equips             map[int32]*EquipUnit        `protobuf:"bytes,4,rep,name=equips" json:"equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	EquipGrids         []*EquipGrid                `protobuf:"bytes,5,rep,name=equipGrids" json:"equipGrids,omitempty"`
	HeroProp           *HeroProp                   `protobuf:"bytes,6,opt,name=heroProp" json:"heroProp,omitempty"`
	Wing               []*Wing                     `protobuf:"bytes,7,rep,name=wing" json:"wing,omitempty"`
	Zodiacs            map[int32]*SpecialEquipUnit `protobuf:"bytes,8,rep,name=zodiacs" json:"zodiacs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Kingarms           map[int32]*SpecialEquipUnit `protobuf:"bytes,9,rep,name=kingarms" json:"kingarms,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Dictates           []*DictateInfo              `protobuf:"bytes,10,rep,name=dictates" json:"dictates,omitempty"`
	WingSpecial        []*WingSpecialNtf           `protobuf:"bytes,11,rep,name=wingSpecial" json:"wingSpecial,omitempty"`
	Jewels             map[int32]*JewelInfo        `protobuf:"bytes,12,rep,name=jewels" json:"jewels,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Name               string                      `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	InsideInfo         *InsideInfo                 `protobuf:"bytes,14,opt,name=insideInfo" json:"insideInfo,omitempty"`
	Fashions           map[int32]*Fashion          `protobuf:"bytes,15,rep,name=Fashions" json:"Fashions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Wears              *Wears                      `protobuf:"bytes,16,opt,name=wears" json:"wears,omitempty"`
	Rings              map[int32]*Ring             `protobuf:"bytes,17,rep,name=rings" json:"rings,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Skills             []*SkillUnit                `protobuf:"bytes,18,rep,name=skills" json:"skills,omitempty"`
	SkillBag           map[int32]int32             `protobuf:"bytes,19,rep,name=skillBag" json:"skillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	UniqueSkills       []*SkillUnit                `protobuf:"bytes,20,rep,name=uniqueSkills" json:"uniqueSkills,omitempty"`
	UniqueSkillBag     map[int32]int32             `protobuf:"bytes,21,rep,name=uniqueSkillBag" json:"uniqueSkillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GodEquips          map[int32]*GodEquip         `protobuf:"bytes,22,rep,name=godEquips" json:"godEquips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Area               map[int32]int32             `protobuf:"bytes,23,rep,name=area" json:"area,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EquipClears        map[int32]*EquipClearArr    `protobuf:"bytes,24,rep,name=equipClears" json:"equipClears,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ExpLvl             int32                       `protobuf:"varint,25,opt,name=expLvl,proto3" json:"expLvl,omitempty"`
	DragonEquip        map[int32]int32             `protobuf:"bytes,26,rep,name=dragonEquip" json:"dragonEquip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MagicCircle        map[int32]int32             `protobuf:"bytes,27,rep,name=MagicCircle" json:"MagicCircle,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Talents            *TalentInfo                 `protobuf:"bytes,28,opt,name=talents" json:"talents,omitempty"`
	ChuanShiEquip      map[int32]int32             `protobuf:"bytes,29,rep,name=chuanShiEquip" json:"chuanShiEquip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AncientSkill       *AncientSkill               `protobuf:"bytes,30,opt,name=ancientSkill" json:"ancientSkill,omitempty"`
	ChuanShiStrengthen map[int32]int32             `protobuf:"bytes,31,rep,name=chuanShiStrengthen" json:"chuanShiStrengthen,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroInfo) Reset()                    { *m = HeroInfo{} }
func (m *HeroInfo) String() string            { return proto.CompactTextString(m) }
func (*HeroInfo) ProtoMessage()               {}
func (*HeroInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

func (m *HeroInfo) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *HeroInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *HeroInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *HeroInfo) GetEquips() map[int32]*EquipUnit {
	if m != nil {
		return m.Equips
	}
	return nil
}

func (m *HeroInfo) GetEquipGrids() []*EquipGrid {
	if m != nil {
		return m.EquipGrids
	}
	return nil
}

func (m *HeroInfo) GetHeroProp() *HeroProp {
	if m != nil {
		return m.HeroProp
	}
	return nil
}

func (m *HeroInfo) GetWing() []*Wing {
	if m != nil {
		return m.Wing
	}
	return nil
}

func (m *HeroInfo) GetZodiacs() map[int32]*SpecialEquipUnit {
	if m != nil {
		return m.Zodiacs
	}
	return nil
}

func (m *HeroInfo) GetKingarms() map[int32]*SpecialEquipUnit {
	if m != nil {
		return m.Kingarms
	}
	return nil
}

func (m *HeroInfo) GetDictates() []*DictateInfo {
	if m != nil {
		return m.Dictates
	}
	return nil
}

func (m *HeroInfo) GetWingSpecial() []*WingSpecialNtf {
	if m != nil {
		return m.WingSpecial
	}
	return nil
}

func (m *HeroInfo) GetJewels() map[int32]*JewelInfo {
	if m != nil {
		return m.Jewels
	}
	return nil
}

func (m *HeroInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeroInfo) GetInsideInfo() *InsideInfo {
	if m != nil {
		return m.InsideInfo
	}
	return nil
}

func (m *HeroInfo) GetFashions() map[int32]*Fashion {
	if m != nil {
		return m.Fashions
	}
	return nil
}

func (m *HeroInfo) GetWears() *Wears {
	if m != nil {
		return m.Wears
	}
	return nil
}

func (m *HeroInfo) GetRings() map[int32]*Ring {
	if m != nil {
		return m.Rings
	}
	return nil
}

func (m *HeroInfo) GetSkills() []*SkillUnit {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *HeroInfo) GetSkillBag() map[int32]int32 {
	if m != nil {
		return m.SkillBag
	}
	return nil
}

func (m *HeroInfo) GetUniqueSkills() []*SkillUnit {
	if m != nil {
		return m.UniqueSkills
	}
	return nil
}

func (m *HeroInfo) GetUniqueSkillBag() map[int32]int32 {
	if m != nil {
		return m.UniqueSkillBag
	}
	return nil
}

func (m *HeroInfo) GetGodEquips() map[int32]*GodEquip {
	if m != nil {
		return m.GodEquips
	}
	return nil
}

func (m *HeroInfo) GetArea() map[int32]int32 {
	if m != nil {
		return m.Area
	}
	return nil
}

func (m *HeroInfo) GetEquipClears() map[int32]*EquipClearArr {
	if m != nil {
		return m.EquipClears
	}
	return nil
}

func (m *HeroInfo) GetExpLvl() int32 {
	if m != nil {
		return m.ExpLvl
	}
	return 0
}

func (m *HeroInfo) GetDragonEquip() map[int32]int32 {
	if m != nil {
		return m.DragonEquip
	}
	return nil
}

func (m *HeroInfo) GetMagicCircle() map[int32]int32 {
	if m != nil {
		return m.MagicCircle
	}
	return nil
}

func (m *HeroInfo) GetTalents() *TalentInfo {
	if m != nil {
		return m.Talents
	}
	return nil
}

func (m *HeroInfo) GetChuanShiEquip() map[int32]int32 {
	if m != nil {
		return m.ChuanShiEquip
	}
	return nil
}

func (m *HeroInfo) GetAncientSkill() *AncientSkill {
	if m != nil {
		return m.AncientSkill
	}
	return nil
}

func (m *HeroInfo) GetChuanShiStrengthen() map[int32]int32 {
	if m != nil {
		return m.ChuanShiStrengthen
	}
	return nil
}

type UserWear struct {
	Petid        int32 `protobuf:"varint,1,opt,name=petid,proto3" json:"petid,omitempty"`
	FitFashionId int32 `protobuf:"varint,2,opt,name=fitFashionId,proto3" json:"fitFashionId,omitempty"`
}

func (m *UserWear) Reset()                    { *m = UserWear{} }
func (m *UserWear) String() string            { return proto.CompactTextString(m) }
func (*UserWear) ProtoMessage()               {}
func (*UserWear) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

func (m *UserWear) GetPetid() int32 {
	if m != nil {
		return m.Petid
	}
	return 0
}

func (m *UserWear) GetFitFashionId() int32 {
	if m != nil {
		return m.FitFashionId
	}
	return 0
}

type Wears struct {
	FashionWeaponId int32   `protobuf:"varint,1,opt,name=FashionWeaponId,proto3" json:"FashionWeaponId,omitempty"`
	FashionClothId  int32   `protobuf:"varint,2,opt,name=FashionClothId,proto3" json:"FashionClothId,omitempty"`
	AtlasWear       []int32 `protobuf:"varint,3,rep,packed,name=atlasWear" json:"atlasWear,omitempty"`
	WingId          int32   `protobuf:"varint,4,opt,name=wingId,proto3" json:"wingId,omitempty"`
	MagicCircleLvId int32   `protobuf:"varint,5,opt,name=magicCircleLvId,proto3" json:"magicCircleLvId,omitempty"`
	TitleId         int32   `protobuf:"varint,6,opt,name=titleId,proto3" json:"titleId,omitempty"`
}

func (m *Wears) Reset()                    { *m = Wears{} }
func (m *Wears) String() string            { return proto.CompactTextString(m) }
func (*Wears) ProtoMessage()               {}
func (*Wears) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{8} }

func (m *Wears) GetFashionWeaponId() int32 {
	if m != nil {
		return m.FashionWeaponId
	}
	return 0
}

func (m *Wears) GetFashionClothId() int32 {
	if m != nil {
		return m.FashionClothId
	}
	return 0
}

func (m *Wears) GetAtlasWear() []int32 {
	if m != nil {
		return m.AtlasWear
	}
	return nil
}

func (m *Wears) GetWingId() int32 {
	if m != nil {
		return m.WingId
	}
	return 0
}

func (m *Wears) GetMagicCircleLvId() int32 {
	if m != nil {
		return m.MagicCircleLvId
	}
	return 0
}

func (m *Wears) GetTitleId() int32 {
	if m != nil {
		return m.TitleId
	}
	return 0
}

// 简短的用户信息，用于聊天，走马灯等 消息。
type BriefUserInfo struct {
	Id       int32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sex      int32              `protobuf:"varint,3,opt,name=sex,proto3" json:"sex,omitempty"`
	Lvl      int32              `protobuf:"varint,4,opt,name=lvl,proto3" json:"lvl,omitempty"`
	Vip      int32              `protobuf:"varint,5,opt,name=vip,proto3" json:"vip,omitempty"`
	Combat   int64              `protobuf:"varint,6,opt,name=combat,proto3" json:"combat,omitempty"`
	Avatar   string             `protobuf:"bytes,7,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Job      int32              `protobuf:"varint,8,opt,name=job,proto3" json:"job,omitempty"`
	MaxLv    int32              `protobuf:"varint,9,opt,name=maxLv,proto3" json:"maxLv,omitempty"`
	ServerId int32              `protobuf:"varint,10,opt,name=serverId,proto3" json:"serverId,omitempty"`
	Display  map[int32]*Display `protobuf:"bytes,11,rep,name=display" json:"display,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BriefUserInfo) Reset()                    { *m = BriefUserInfo{} }
func (m *BriefUserInfo) String() string            { return proto.CompactTextString(m) }
func (*BriefUserInfo) ProtoMessage()               {}
func (*BriefUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{9} }

func (m *BriefUserInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BriefUserInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BriefUserInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *BriefUserInfo) GetLvl() int32 {
	if m != nil {
		return m.Lvl
	}
	return 0
}

func (m *BriefUserInfo) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *BriefUserInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *BriefUserInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *BriefUserInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *BriefUserInfo) GetMaxLv() int32 {
	if m != nil {
		return m.MaxLv
	}
	return 0
}

func (m *BriefUserInfo) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *BriefUserInfo) GetDisplay() map[int32]*Display {
	if m != nil {
		return m.Display
	}
	return nil
}

type BriefUserInfoWithDisplay struct {
	UserInfo *BriefUserInfo `protobuf:"bytes,1,opt,name=userInfo" json:"userInfo,omitempty"`
	Display  *DisplayNtf    `protobuf:"bytes,14,opt,name=display" json:"display,omitempty"`
}

func (m *BriefUserInfoWithDisplay) Reset()                    { *m = BriefUserInfoWithDisplay{} }
func (m *BriefUserInfoWithDisplay) String() string            { return proto.CompactTextString(m) }
func (*BriefUserInfoWithDisplay) ProtoMessage()               {}
func (*BriefUserInfoWithDisplay) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{10} }

func (m *BriefUserInfoWithDisplay) GetUserInfo() *BriefUserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *BriefUserInfoWithDisplay) GetDisplay() *DisplayNtf {
	if m != nil {
		return m.Display
	}
	return nil
}

// 顶级数据变化
type TopDataChangeNtf struct {
	ChangeInfos []*TopDataChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32            `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TopDataChangeNtf) Reset()                    { *m = TopDataChangeNtf{} }
func (m *TopDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*TopDataChangeNtf) ProtoMessage()               {}
func (*TopDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{11} }

func (m *TopDataChangeNtf) GetChangeInfos() []*TopDataChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *TopDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 顶级数据变化
type TopDataChange struct {
	Id     int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Change int64 `protobuf:"varint,2,opt,name=change,proto3" json:"change,omitempty"`
	NowNum int64 `protobuf:"varint,3,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
}

func (m *TopDataChange) Reset()                    { *m = TopDataChange{} }
func (m *TopDataChange) String() string            { return proto.CompactTextString(m) }
func (*TopDataChange) ProtoMessage()               {}
func (*TopDataChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{12} }

func (m *TopDataChange) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TopDataChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *TopDataChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

// 背包道具变化
type BagDataChangeNtf struct {
	ChangeInfos []*ItemChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *BagDataChangeNtf) Reset()                    { *m = BagDataChangeNtf{} }
func (m *BagDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BagDataChangeNtf) ProtoMessage()               {}
func (*BagDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{13} }

func (m *BagDataChangeNtf) GetChangeInfos() []*ItemChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *BagDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 背包道具变化
type ItemChange struct {
	Position  int32      `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	ItemId    int32      `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Change    int64      `protobuf:"varint,3,opt,name=change,proto3" json:"change,omitempty"`
	NowNum    int64      `protobuf:"varint,4,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
	GetSource *GetSource `protobuf:"bytes,5,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *ItemChange) Reset()                    { *m = ItemChange{} }
func (m *ItemChange) String() string            { return proto.CompactTextString(m) }
func (*ItemChange) ProtoMessage()               {}
func (*ItemChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{14} }

func (m *ItemChange) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *ItemChange) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *ItemChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

func (m *ItemChange) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

// 背包装备变化
type BagEquipDataChangeNtf struct {
	ChangeInfos []*EquipChange `protobuf:"bytes,1,rep,name=changeInfos" json:"changeInfos,omitempty"`
	Type        int32          `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *BagEquipDataChangeNtf) Reset()                    { *m = BagEquipDataChangeNtf{} }
func (m *BagEquipDataChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*BagEquipDataChangeNtf) ProtoMessage()               {}
func (*BagEquipDataChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{15} }

func (m *BagEquipDataChangeNtf) GetChangeInfos() []*EquipChange {
	if m != nil {
		return m.ChangeInfos
	}
	return nil
}

func (m *BagEquipDataChangeNtf) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 背包道具变化
type EquipChange struct {
	Position  int32      `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	ItemId    int32      `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Change    int64      `protobuf:"varint,3,opt,name=change,proto3" json:"change,omitempty"`
	NowNum    int64      `protobuf:"varint,4,opt,name=nowNum,proto3" json:"nowNum,omitempty"`
	Equip     *EquipUnit `protobuf:"bytes,5,opt,name=equip" json:"equip,omitempty"`
	GetSource *GetSource `protobuf:"bytes,6,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *EquipChange) Reset()                    { *m = EquipChange{} }
func (m *EquipChange) String() string            { return proto.CompactTextString(m) }
func (*EquipChange) ProtoMessage()               {}
func (*EquipChange) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{16} }

func (m *EquipChange) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *EquipChange) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *EquipChange) GetChange() int64 {
	if m != nil {
		return m.Change
	}
	return 0
}

func (m *EquipChange) GetNowNum() int64 {
	if m != nil {
		return m.NowNum
	}
	return 0
}

func (m *EquipChange) GetEquip() *EquipUnit {
	if m != nil {
		return m.Equip
	}
	return nil
}

func (m *EquipChange) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type Item struct {
	ItemId    int32      `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count     int64      `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Position  int32      `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty"`
	Equip     *EquipUnit `protobuf:"bytes,4,opt,name=equip" json:"equip,omitempty"`
	GetSource *GetSource `protobuf:"bytes,5,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{17} }

func (m *Item) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *Item) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Item) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Item) GetEquip() *EquipUnit {
	if m != nil {
		return m.Equip
	}
	return nil
}

func (m *Item) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type GoodsChangeNtf struct {
	Items []*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *GoodsChangeNtf) Reset()                    { *m = GoodsChangeNtf{} }
func (m *GoodsChangeNtf) String() string            { return proto.CompactTextString(m) }
func (*GoodsChangeNtf) ProtoMessage()               {}
func (*GoodsChangeNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{18} }

func (m *GoodsChangeNtf) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

type ItemUnit struct {
	ItemId int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count  int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ItemUnit) Reset()                    { *m = ItemUnit{} }
func (m *ItemUnit) String() string            { return proto.CompactTextString(m) }
func (*ItemUnit) ProtoMessage()               {}
func (*ItemUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{19} }

func (m *ItemUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *ItemUnit) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EquipUnit struct {
	ItemId     int32            `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	RandProps  []*EquipRandProp `protobuf:"bytes,2,rep,name=randProps" json:"randProps,omitempty"`
	Lock       bool             `protobuf:"varint,3,opt,name=lock,proto3" json:"lock,omitempty"`
	EquipIndex int32            `protobuf:"varint,4,opt,name=equipIndex,proto3" json:"equipIndex,omitempty"`
	Lucky      int32            `protobuf:"varint,5,opt,name=lucky,proto3" json:"lucky,omitempty"`
}

func (m *EquipUnit) Reset()                    { *m = EquipUnit{} }
func (m *EquipUnit) String() string            { return proto.CompactTextString(m) }
func (*EquipUnit) ProtoMessage()               {}
func (*EquipUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{20} }

func (m *EquipUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *EquipUnit) GetRandProps() []*EquipRandProp {
	if m != nil {
		return m.RandProps
	}
	return nil
}

func (m *EquipUnit) GetLock() bool {
	if m != nil {
		return m.Lock
	}
	return false
}

func (m *EquipUnit) GetEquipIndex() int32 {
	if m != nil {
		return m.EquipIndex
	}
	return 0
}

func (m *EquipUnit) GetLucky() int32 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

type EquipRandProp struct {
	PropId int32 `protobuf:"varint,1,opt,name=propId,proto3" json:"propId,omitempty"`
	Color  int32 `protobuf:"varint,2,opt,name=color,proto3" json:"color,omitempty"`
	Value  int32 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EquipRandProp) Reset()                    { *m = EquipRandProp{} }
func (m *EquipRandProp) String() string            { return proto.CompactTextString(m) }
func (*EquipRandProp) ProtoMessage()               {}
func (*EquipRandProp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{21} }

func (m *EquipRandProp) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *EquipRandProp) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *EquipRandProp) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type EquipClearArr struct {
	EquipClearInfo []*EquipClearInfo `protobuf:"bytes,1,rep,name=equipClearInfo" json:"equipClearInfo,omitempty"`
}

func (m *EquipClearArr) Reset()                    { *m = EquipClearArr{} }
func (m *EquipClearArr) String() string            { return proto.CompactTextString(m) }
func (*EquipClearArr) ProtoMessage()               {}
func (*EquipClearArr) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{22} }

func (m *EquipClearArr) GetEquipClearInfo() []*EquipClearInfo {
	if m != nil {
		return m.EquipClearInfo
	}
	return nil
}

type EquipClearInfo struct {
	Grade  int32 `protobuf:"varint,1,opt,name=grade,proto3" json:"grade,omitempty"`
	Color  int32 `protobuf:"varint,2,opt,name=color,proto3" json:"color,omitempty"`
	PropId int32 `protobuf:"varint,3,opt,name=propId,proto3" json:"propId,omitempty"`
	Value  int32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EquipClearInfo) Reset()                    { *m = EquipClearInfo{} }
func (m *EquipClearInfo) String() string            { return proto.CompactTextString(m) }
func (*EquipClearInfo) ProtoMessage()               {}
func (*EquipClearInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{23} }

func (m *EquipClearInfo) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *EquipClearInfo) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *EquipClearInfo) GetPropId() int32 {
	if m != nil {
		return m.PropId
	}
	return 0
}

func (m *EquipClearInfo) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type HeroProp struct {
	Props         map[int32]int64 `protobuf:"bytes,1,rep,name=props" json:"props,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ModulesCombat map[int32]int64 `protobuf:"bytes,2,rep,name=modulesCombat" json:"modulesCombat,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroProp) Reset()                    { *m = HeroProp{} }
func (m *HeroProp) String() string            { return proto.CompactTextString(m) }
func (*HeroProp) ProtoMessage()               {}
func (*HeroProp) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{24} }

func (m *HeroProp) GetProps() map[int32]int64 {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *HeroProp) GetModulesCombat() map[int32]int64 {
	if m != nil {
		return m.ModulesCombat
	}
	return nil
}

type TaskInfoNtf struct {
	TaskId      int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Process     int32 `protobuf:"varint,2,opt,name=process,proto3" json:"process,omitempty"`
	MarkProcess int32 `protobuf:"varint,3,opt,name=markProcess,proto3" json:"markProcess,omitempty"`
}

func (m *TaskInfoNtf) Reset()                    { *m = TaskInfoNtf{} }
func (m *TaskInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*TaskInfoNtf) ProtoMessage()               {}
func (*TaskInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{25} }

func (m *TaskInfoNtf) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskInfoNtf) GetProcess() int32 {
	if m != nil {
		return m.Process
	}
	return 0
}

func (m *TaskInfoNtf) GetMarkProcess() int32 {
	if m != nil {
		return m.MarkProcess
	}
	return 0
}

type DisplayNtf struct {
	Display map[int32]*Display `protobuf:"bytes,1,rep,name=display" json:"display,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DisplayNtf) Reset()                    { *m = DisplayNtf{} }
func (m *DisplayNtf) String() string            { return proto.CompactTextString(m) }
func (*DisplayNtf) ProtoMessage()               {}
func (*DisplayNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{26} }

func (m *DisplayNtf) GetDisplay() map[int32]*Display {
	if m != nil {
		return m.Display
	}
	return nil
}

type EventNtf struct {
	Id       int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts       int32    `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Args     []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	SourceId int32    `protobuf:"varint,4,opt,name=sourceId,proto3" json:"sourceId,omitempty"`
}

func (m *EventNtf) Reset()                    { *m = EventNtf{} }
func (m *EventNtf) String() string            { return proto.CompactTextString(m) }
func (*EventNtf) ProtoMessage()               {}
func (*EventNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{27} }

func (m *EventNtf) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventNtf) GetTs() int32 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *EventNtf) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *EventNtf) GetSourceId() int32 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

type DailyConditionNtf struct {
	DailyConditions map[int32]int32 `protobuf:"bytes,1,rep,name=dailyConditions" json:"dailyConditions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *DailyConditionNtf) Reset()                    { *m = DailyConditionNtf{} }
func (m *DailyConditionNtf) String() string            { return proto.CompactTextString(m) }
func (*DailyConditionNtf) ProtoMessage()               {}
func (*DailyConditionNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{28} }

func (m *DailyConditionNtf) GetDailyConditions() map[int32]int32 {
	if m != nil {
		return m.DailyConditions
	}
	return nil
}

type PropInfo struct {
	Key   int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PropInfo) Reset()                    { *m = PropInfo{} }
func (m *PropInfo) String() string            { return proto.CompactTextString(m) }
func (*PropInfo) ProtoMessage()               {}
func (*PropInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{29} }

func (m *PropInfo) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *PropInfo) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type EquipGrid struct {
	Pos      int32 `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	Strength int32 `protobuf:"varint,2,opt,name=strength,proto3" json:"strength,omitempty"`
}

func (m *EquipGrid) Reset()                    { *m = EquipGrid{} }
func (m *EquipGrid) String() string            { return proto.CompactTextString(m) }
func (*EquipGrid) ProtoMessage()               {}
func (*EquipGrid) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{30} }

func (m *EquipGrid) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *EquipGrid) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

type Fabao struct {
	Id     int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level  int32   `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Exp    int32   `protobuf:"varint,3,opt,name=exp,proto3" json:"exp,omitempty"`
	Skills []int32 `protobuf:"varint,4,rep,packed,name=skills" json:"skills,omitempty"`
}

func (m *Fabao) Reset()                    { *m = Fabao{} }
func (m *Fabao) String() string            { return proto.CompactTextString(m) }
func (*Fabao) ProtoMessage()               {}
func (*Fabao) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{31} }

func (m *Fabao) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Fabao) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Fabao) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *Fabao) GetSkills() []int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

type GodEquip struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Blood int32 `protobuf:"varint,3,opt,name=blood,proto3" json:"blood,omitempty"`
}

func (m *GodEquip) Reset()                    { *m = GodEquip{} }
func (m *GodEquip) String() string            { return proto.CompactTextString(m) }
func (*GodEquip) ProtoMessage()               {}
func (*GodEquip) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{32} }

func (m *GodEquip) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GodEquip) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GodEquip) GetBlood() int32 {
	if m != nil {
		return m.Blood
	}
	return 0
}

type Juexue struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *Juexue) Reset()                    { *m = Juexue{} }
func (m *Juexue) String() string            { return proto.CompactTextString(m) }
func (*Juexue) ProtoMessage()               {}
func (*Juexue) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{33} }

func (m *Juexue) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Juexue) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Fashion struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *Fashion) Reset()                    { *m = Fashion{} }
func (m *Fashion) String() string            { return proto.CompactTextString(m) }
func (*Fashion) ProtoMessage()               {}
func (*Fashion) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{34} }

func (m *Fashion) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Fashion) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Wing struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Exp int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *Wing) Reset()                    { *m = Wing{} }
func (m *Wing) String() string            { return proto.CompactTextString(m) }
func (*Wing) ProtoMessage()               {}
func (*Wing) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{35} }

func (m *Wing) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Wing) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type WingSpecialNtf struct {
	SpecialType int32 `protobuf:"varint,1,opt,name=specialType,proto3" json:"specialType,omitempty"`
	Level       int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *WingSpecialNtf) Reset()                    { *m = WingSpecialNtf{} }
func (m *WingSpecialNtf) String() string            { return proto.CompactTextString(m) }
func (*WingSpecialNtf) ProtoMessage()               {}
func (*WingSpecialNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{36} }

func (m *WingSpecialNtf) GetSpecialType() int32 {
	if m != nil {
		return m.SpecialType
	}
	return 0
}

func (m *WingSpecialNtf) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type Rein struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Exp int64 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *Rein) Reset()                    { *m = Rein{} }
func (m *Rein) String() string            { return proto.CompactTextString(m) }
func (*Rein) ProtoMessage()               {}
func (*Rein) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{37} }

func (m *Rein) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Rein) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type ReinCost struct {
	Id  int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num int32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *ReinCost) Reset()                    { *m = ReinCost{} }
func (m *ReinCost) String() string            { return proto.CompactTextString(m) }
func (*ReinCost) ProtoMessage()               {}
func (*ReinCost) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{38} }

func (m *ReinCost) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReinCost) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type Atlas struct {
	Id       int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Star     int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
	IsActive bool  `protobuf:"varint,3,opt,name=isActive,proto3" json:"isActive,omitempty"`
}

func (m *Atlas) Reset()                    { *m = Atlas{} }
func (m *Atlas) String() string            { return proto.CompactTextString(m) }
func (*Atlas) ProtoMessage()               {}
func (*Atlas) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{39} }

func (m *Atlas) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Atlas) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *Atlas) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type AtlasGather struct {
	Id       int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Star     int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
	IsActive bool  `protobuf:"varint,3,opt,name=isActive,proto3" json:"isActive,omitempty"`
}

func (m *AtlasGather) Reset()                    { *m = AtlasGather{} }
func (m *AtlasGather) String() string            { return proto.CompactTextString(m) }
func (*AtlasGather) ProtoMessage()               {}
func (*AtlasGather) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{40} }

func (m *AtlasGather) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AtlasGather) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *AtlasGather) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type Preference struct {
	Key   int32  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Preference) Reset()                    { *m = Preference{} }
func (m *Preference) String() string            { return proto.CompactTextString(m) }
func (*Preference) ProtoMessage()               {}
func (*Preference) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{41} }

func (m *Preference) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Preference) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type WorldBossInfoNtf struct {
	Id          int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PrepareTime int32 `protobuf:"varint,2,opt,name=prepareTime,proto3" json:"prepareTime,omitempty"`
	OpenTime    int32 `protobuf:"varint,3,opt,name=openTime,proto3" json:"openTime,omitempty"`
	CloseTime   int32 `protobuf:"varint,4,opt,name=closeTime,proto3" json:"closeTime,omitempty"`
}

func (m *WorldBossInfoNtf) Reset()                    { *m = WorldBossInfoNtf{} }
func (m *WorldBossInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldBossInfoNtf) ProtoMessage()               {}
func (*WorldBossInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{42} }

func (m *WorldBossInfoNtf) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WorldBossInfoNtf) GetPrepareTime() int32 {
	if m != nil {
		return m.PrepareTime
	}
	return 0
}

func (m *WorldBossInfoNtf) GetOpenTime() int32 {
	if m != nil {
		return m.OpenTime
	}
	return 0
}

func (m *WorldBossInfoNtf) GetCloseTime() int32 {
	if m != nil {
		return m.CloseTime
	}
	return 0
}

type VipBoss struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	DareNum int32 `protobuf:"varint,2,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
}

func (m *VipBoss) Reset()                    { *m = VipBoss{} }
func (m *VipBoss) String() string            { return proto.CompactTextString(m) }
func (*VipBoss) ProtoMessage()               {}
func (*VipBoss) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{43} }

func (m *VipBoss) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *VipBoss) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

type ExpStage struct {
	DareNum   int32           `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum    int32           `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	ExpStages map[int32]int64 `protobuf:"bytes,3,rep,name=expStages" json:"expStages,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Appraise  map[int32]int32 `protobuf:"bytes,4,rep,name=appraise" json:"appraise,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Layer     int32           `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *ExpStage) Reset()                    { *m = ExpStage{} }
func (m *ExpStage) String() string            { return proto.CompactTextString(m) }
func (*ExpStage) ProtoMessage()               {}
func (*ExpStage) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{44} }

func (m *ExpStage) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *ExpStage) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *ExpStage) GetExpStages() map[int32]int64 {
	if m != nil {
		return m.ExpStages
	}
	return nil
}

func (m *ExpStage) GetAppraise() map[int32]int32 {
	if m != nil {
		return m.Appraise
	}
	return nil
}

func (m *ExpStage) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type MaterialStage struct {
	DareNum   int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum    int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	NowLayer  int32 `protobuf:"varint,3,opt,name=nowLayer,proto3" json:"nowLayer,omitempty"`
	LastLayer int32 `protobuf:"varint,4,opt,name=lastLayer,proto3" json:"lastLayer,omitempty"`
}

func (m *MaterialStage) Reset()                    { *m = MaterialStage{} }
func (m *MaterialStage) String() string            { return proto.CompactTextString(m) }
func (*MaterialStage) ProtoMessage()               {}
func (*MaterialStage) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{45} }

func (m *MaterialStage) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *MaterialStage) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *MaterialStage) GetNowLayer() int32 {
	if m != nil {
		return m.NowLayer
	}
	return 0
}

func (m *MaterialStage) GetLastLayer() int32 {
	if m != nil {
		return m.LastLayer
	}
	return 0
}

type Display struct {
	ClothItemId     int32 `protobuf:"varint,1,opt,name=clothItemId,proto3" json:"clothItemId,omitempty"`
	ClothType       int32 `protobuf:"varint,2,opt,name=clothType,proto3" json:"clothType,omitempty"`
	WeaponItemId    int32 `protobuf:"varint,3,opt,name=weaponItemId,proto3" json:"weaponItemId,omitempty"`
	WeaponType      int32 `protobuf:"varint,4,opt,name=weaponType,proto3" json:"weaponType,omitempty"`
	WingId          int32 `protobuf:"varint,5,opt,name=wingId,proto3" json:"wingId,omitempty"`
	MagicCircleLvId int32 `protobuf:"varint,6,opt,name=magicCircleLvId,proto3" json:"magicCircleLvId,omitempty"`
	TitleId         int32 `protobuf:"varint,7,opt,name=titleId,proto3" json:"titleId,omitempty"`
	LabelId         int32 `protobuf:"varint,8,opt,name=labelId,proto3" json:"labelId,omitempty"`
	LabelJob        int32 `protobuf:"varint,9,opt,name=labelJob,proto3" json:"labelJob,omitempty"`
}

func (m *Display) Reset()                    { *m = Display{} }
func (m *Display) String() string            { return proto.CompactTextString(m) }
func (*Display) ProtoMessage()               {}
func (*Display) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{46} }

func (m *Display) GetClothItemId() int32 {
	if m != nil {
		return m.ClothItemId
	}
	return 0
}

func (m *Display) GetClothType() int32 {
	if m != nil {
		return m.ClothType
	}
	return 0
}

func (m *Display) GetWeaponItemId() int32 {
	if m != nil {
		return m.WeaponItemId
	}
	return 0
}

func (m *Display) GetWeaponType() int32 {
	if m != nil {
		return m.WeaponType
	}
	return 0
}

func (m *Display) GetWingId() int32 {
	if m != nil {
		return m.WingId
	}
	return 0
}

func (m *Display) GetMagicCircleLvId() int32 {
	if m != nil {
		return m.MagicCircleLvId
	}
	return 0
}

func (m *Display) GetTitleId() int32 {
	if m != nil {
		return m.TitleId
	}
	return 0
}

func (m *Display) GetLabelId() int32 {
	if m != nil {
		return m.LabelId
	}
	return 0
}

func (m *Display) GetLabelJob() int32 {
	if m != nil {
		return m.LabelJob
	}
	return 0
}

type SpecialEquipUnit struct {
	ItemId    int32      `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	GetSource *GetSource `protobuf:"bytes,2,opt,name=getSource" json:"getSource,omitempty"`
}

func (m *SpecialEquipUnit) Reset()                    { *m = SpecialEquipUnit{} }
func (m *SpecialEquipUnit) String() string            { return proto.CompactTextString(m) }
func (*SpecialEquipUnit) ProtoMessage()               {}
func (*SpecialEquipUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{47} }

func (m *SpecialEquipUnit) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *SpecialEquipUnit) GetGetSource() *GetSource {
	if m != nil {
		return m.GetSource
	}
	return nil
}

type GetSource struct {
	Map       string `protobuf:"bytes,1,opt,name=map,proto3" json:"map,omitempty"`
	Monster   string `protobuf:"bytes,2,opt,name=monster,proto3" json:"monster,omitempty"`
	SkillUser string `protobuf:"bytes,3,opt,name=skillUser,proto3" json:"skillUser,omitempty"`
	SkillDate string `protobuf:"bytes,4,opt,name=skillDate,proto3" json:"skillDate,omitempty"`
}

func (m *GetSource) Reset()                    { *m = GetSource{} }
func (m *GetSource) String() string            { return proto.CompactTextString(m) }
func (*GetSource) ProtoMessage()               {}
func (*GetSource) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{48} }

func (m *GetSource) GetMap() string {
	if m != nil {
		return m.Map
	}
	return ""
}

func (m *GetSource) GetMonster() string {
	if m != nil {
		return m.Monster
	}
	return ""
}

func (m *GetSource) GetSkillUser() string {
	if m != nil {
		return m.SkillUser
	}
	return ""
}

func (m *GetSource) GetSkillDate() string {
	if m != nil {
		return m.SkillDate
	}
	return ""
}

type RankInfo struct {
	Rank     int32          `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	Score    int64          `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	UserInfo *BriefUserInfo `protobuf:"bytes,3,opt,name=userInfo" json:"userInfo,omitempty"`
	Display  *Display       `protobuf:"bytes,4,opt,name=display" json:"display,omitempty"`
}

func (m *RankInfo) Reset()                    { *m = RankInfo{} }
func (m *RankInfo) String() string            { return proto.CompactTextString(m) }
func (*RankInfo) ProtoMessage()               {}
func (*RankInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{49} }

func (m *RankInfo) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *RankInfo) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RankInfo) GetUserInfo() *BriefUserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *RankInfo) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

type SkillUnit struct {
	SkillId   int32 `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	Level     int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	StartTime int64 `protobuf:"varint,3,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,4,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *SkillUnit) Reset()                    { *m = SkillUnit{} }
func (m *SkillUnit) String() string            { return proto.CompactTextString(m) }
func (*SkillUnit) ProtoMessage()               {}
func (*SkillUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{50} }

func (m *SkillUnit) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *SkillUnit) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SkillUnit) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *SkillUnit) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type ShopInfo struct {
	ShopItem map[int32]int32 `protobuf:"bytes,1,rep,name=shopItem" json:"shopItem,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ShopInfo) Reset()                    { *m = ShopInfo{} }
func (m *ShopInfo) String() string            { return proto.CompactTextString(m) }
func (*ShopInfo) ProtoMessage()               {}
func (*ShopInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{51} }

func (m *ShopInfo) GetShopItem() map[int32]int32 {
	if m != nil {
		return m.ShopItem
	}
	return nil
}

type DictateInfo struct {
	Type  int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *DictateInfo) Reset()                    { *m = DictateInfo{} }
func (m *DictateInfo) String() string            { return proto.CompactTextString(m) }
func (*DictateInfo) ProtoMessage()               {}
func (*DictateInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{52} }

func (m *DictateInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DictateInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type PanaceaInfo struct {
	Numbers int32 `protobuf:"varint,1,opt,name=numbers,proto3" json:"numbers,omitempty"`
	Number  int32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *PanaceaInfo) Reset()                    { *m = PanaceaInfo{} }
func (m *PanaceaInfo) String() string            { return proto.CompactTextString(m) }
func (*PanaceaInfo) ProtoMessage()               {}
func (*PanaceaInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{53} }

func (m *PanaceaInfo) GetNumbers() int32 {
	if m != nil {
		return m.Numbers
	}
	return 0
}

func (m *PanaceaInfo) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

type JewelInfo struct {
	Left  int32 `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Right int32 `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
	Down  int32 `protobuf:"varint,3,opt,name=down,proto3" json:"down,omitempty"`
}

func (m *JewelInfo) Reset()                    { *m = JewelInfo{} }
func (m *JewelInfo) String() string            { return proto.CompactTextString(m) }
func (*JewelInfo) ProtoMessage()               {}
func (*JewelInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{54} }

func (m *JewelInfo) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *JewelInfo) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *JewelInfo) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 通用每日状态
type DayStateInfo struct {
	RankWorship      int32   `protobuf:"varint,1,opt,name=rankWorship,proto3" json:"rankWorship,omitempty"`
	MonthCardReceive []int32 `protobuf:"varint,2,rep,packed,name=monthCardReceive" json:"monthCardReceive,omitempty"`
}

func (m *DayStateInfo) Reset()                    { *m = DayStateInfo{} }
func (m *DayStateInfo) String() string            { return proto.CompactTextString(m) }
func (*DayStateInfo) ProtoMessage()               {}
func (*DayStateInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{55} }

func (m *DayStateInfo) GetRankWorship() int32 {
	if m != nil {
		return m.RankWorship
	}
	return 0
}

func (m *DayStateInfo) GetMonthCardReceive() []int32 {
	if m != nil {
		return m.MonthCardReceive
	}
	return nil
}

type SignInfo struct {
	SignCount     int32           `protobuf:"varint,1,opt,name=signCount,proto3" json:"signCount,omitempty"`
	SignDay       map[int32]int32 `protobuf:"bytes,2,rep,name=signDay" json:"signDay,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CumulativeDay map[int32]int32 `protobuf:"bytes,3,rep,name=cumulativeDay" json:"cumulativeDay,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *SignInfo) Reset()                    { *m = SignInfo{} }
func (m *SignInfo) String() string            { return proto.CompactTextString(m) }
func (*SignInfo) ProtoMessage()               {}
func (*SignInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{56} }

func (m *SignInfo) GetSignCount() int32 {
	if m != nil {
		return m.SignCount
	}
	return 0
}

func (m *SignInfo) GetSignDay() map[int32]int32 {
	if m != nil {
		return m.SignDay
	}
	return nil
}

func (m *SignInfo) GetCumulativeDay() map[int32]int32 {
	if m != nil {
		return m.CumulativeDay
	}
	return nil
}

type InsideInfo struct {
	Acupoint    map[int32]int32        `protobuf:"bytes,1,rep,name=acupoint" json:"acupoint,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	InsideSkill map[int32]*InsideSkill `protobuf:"bytes,2,rep,name=insideSkill" json:"insideSkill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InsideInfo) Reset()                    { *m = InsideInfo{} }
func (m *InsideInfo) String() string            { return proto.CompactTextString(m) }
func (*InsideInfo) ProtoMessage()               {}
func (*InsideInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{57} }

func (m *InsideInfo) GetAcupoint() map[int32]int32 {
	if m != nil {
		return m.Acupoint
	}
	return nil
}

func (m *InsideInfo) GetInsideSkill() map[int32]*InsideSkill {
	if m != nil {
		return m.InsideSkill
	}
	return nil
}

type InsideSkill struct {
	Level int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Exp   int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *InsideSkill) Reset()                    { *m = InsideSkill{} }
func (m *InsideSkill) String() string            { return proto.CompactTextString(m) }
func (*InsideSkill) ProtoMessage()               {}
func (*InsideSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{58} }

func (m *InsideSkill) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *InsideSkill) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type Holy struct {
	Id     int32           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level  int32           `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Exp    int32           `protobuf:"varint,3,opt,name=exp,proto3" json:"exp,omitempty"`
	Skills map[int32]int32 `protobuf:"bytes,4,rep,name=skills" json:"skills,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Holy) Reset()                    { *m = Holy{} }
func (m *Holy) String() string            { return proto.CompactTextString(m) }
func (*Holy) ProtoMessage()               {}
func (*Holy) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{59} }

func (m *Holy) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Holy) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Holy) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *Holy) GetSkills() map[int32]int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

type Ring struct {
	Rid        int32                  `protobuf:"varint,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Strengthen int32                  `protobuf:"varint,2,opt,name=strengthen,proto3" json:"strengthen,omitempty"`
	Pid        int32                  `protobuf:"varint,3,opt,name=pid,proto3" json:"pid,omitempty"`
	Talent     int32                  `protobuf:"varint,4,opt,name=talent,proto3" json:"talent,omitempty"`
	Phantom    map[int32]*RingPhantom `protobuf:"bytes,5,rep,name=phantom" json:"phantom,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Ring) Reset()                    { *m = Ring{} }
func (m *Ring) String() string            { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()               {}
func (*Ring) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{60} }

func (m *Ring) GetRid() int32 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *Ring) GetStrengthen() int32 {
	if m != nil {
		return m.Strengthen
	}
	return 0
}

func (m *Ring) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Ring) GetTalent() int32 {
	if m != nil {
		return m.Talent
	}
	return 0
}

func (m *Ring) GetPhantom() map[int32]*RingPhantom {
	if m != nil {
		return m.Phantom
	}
	return nil
}

type RingPhantom struct {
	Talent  int32           `protobuf:"varint,1,opt,name=talent,proto3" json:"talent,omitempty"`
	Phantom int32           `protobuf:"varint,2,opt,name=phantom,proto3" json:"phantom,omitempty"`
	Skill   map[int32]int32 `protobuf:"bytes,3,rep,name=skill" json:"skill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *RingPhantom) Reset()                    { *m = RingPhantom{} }
func (m *RingPhantom) String() string            { return proto.CompactTextString(m) }
func (*RingPhantom) ProtoMessage()               {}
func (*RingPhantom) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{61} }

func (m *RingPhantom) GetTalent() int32 {
	if m != nil {
		return m.Talent
	}
	return 0
}

func (m *RingPhantom) GetPhantom() int32 {
	if m != nil {
		return m.Phantom
	}
	return 0
}

func (m *RingPhantom) GetSkill() map[int32]int32 {
	if m != nil {
		return m.Skill
	}
	return nil
}

type PetInfo struct {
	Lv    int32   `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp   int32   `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Grade int32   `protobuf:"varint,3,opt,name=grade,proto3" json:"grade,omitempty"`
	Break int32   `protobuf:"varint,4,opt,name=break,proto3" json:"break,omitempty"`
	Skill []int32 `protobuf:"varint,5,rep,packed,name=skill" json:"skill,omitempty"`
}

func (m *PetInfo) Reset()                    { *m = PetInfo{} }
func (m *PetInfo) String() string            { return proto.CompactTextString(m) }
func (*PetInfo) ProtoMessage()               {}
func (*PetInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{62} }

func (m *PetInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PetInfo) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *PetInfo) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

func (m *PetInfo) GetBreak() int32 {
	if m != nil {
		return m.Break
	}
	return 0
}

func (m *PetInfo) GetSkill() []int32 {
	if m != nil {
		return m.Skill
	}
	return nil
}

type ResetNtf struct {
	Type       map[int32]int32 `protobuf:"bytes,1,rep,name=type" json:"type,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	NewDayTime int32           `protobuf:"varint,2,opt,name=newDayTime,proto3" json:"newDayTime,omitempty"`
}

func (m *ResetNtf) Reset()                    { *m = ResetNtf{} }
func (m *ResetNtf) String() string            { return proto.CompactTextString(m) }
func (*ResetNtf) ProtoMessage()               {}
func (*ResetNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{63} }

func (m *ResetNtf) GetType() map[int32]int32 {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ResetNtf) GetNewDayTime() int32 {
	if m != nil {
		return m.NewDayTime
	}
	return 0
}

type FieldFightRivalUserInfo struct {
	RivalUserId    int32 `protobuf:"varint,1,opt,name=rivalUserId,proto3" json:"rivalUserId,omitempty"`
	RivalDifficult int32 `protobuf:"varint,2,opt,name=rivalDifficult,proto3" json:"rivalDifficult,omitempty"`
}

func (m *FieldFightRivalUserInfo) Reset()                    { *m = FieldFightRivalUserInfo{} }
func (m *FieldFightRivalUserInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldFightRivalUserInfo) ProtoMessage()               {}
func (*FieldFightRivalUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{64} }

func (m *FieldFightRivalUserInfo) GetRivalUserId() int32 {
	if m != nil {
		return m.RivalUserId
	}
	return 0
}

func (m *FieldFightRivalUserInfo) GetRivalDifficult() int32 {
	if m != nil {
		return m.RivalDifficult
	}
	return 0
}

type DarkPalaceInfo struct {
	DareNum int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum  int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	HelpNum int32 `protobuf:"varint,3,opt,name=helpNum,proto3" json:"helpNum,omitempty"`
}

func (m *DarkPalaceInfo) Reset()                    { *m = DarkPalaceInfo{} }
func (m *DarkPalaceInfo) String() string            { return proto.CompactTextString(m) }
func (*DarkPalaceInfo) ProtoMessage()               {}
func (*DarkPalaceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{65} }

func (m *DarkPalaceInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *DarkPalaceInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *DarkPalaceInfo) GetHelpNum() int32 {
	if m != nil {
		return m.HelpNum
	}
	return 0
}

type HellBossInfo struct {
	DareNum int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum  int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	HelpNum int32 `protobuf:"varint,3,opt,name=helpNum,proto3" json:"helpNum,omitempty"`
}

func (m *HellBossInfo) Reset()                    { *m = HellBossInfo{} }
func (m *HellBossInfo) String() string            { return proto.CompactTextString(m) }
func (*HellBossInfo) ProtoMessage()               {}
func (*HellBossInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{66} }

func (m *HellBossInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *HellBossInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *HellBossInfo) GetHelpNum() int32 {
	if m != nil {
		return m.HelpNum
	}
	return 0
}

type FieldBossInfo struct {
	DareNum      int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum       int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	FirstReceive bool  `protobuf:"varint,3,opt,name=firstReceive,proto3" json:"firstReceive,omitempty"`
}

func (m *FieldBossInfo) Reset()                    { *m = FieldBossInfo{} }
func (m *FieldBossInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldBossInfo) ProtoMessage()               {}
func (*FieldBossInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{67} }

func (m *FieldBossInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *FieldBossInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *FieldBossInfo) GetFirstReceive() bool {
	if m != nil {
		return m.FirstReceive
	}
	return false
}

type AncientBossInfo struct {
	DareNum int32 `protobuf:"varint,1,opt,name=dareNum,proto3" json:"dareNum,omitempty"`
	BuyNum  int32 `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
}

func (m *AncientBossInfo) Reset()                    { *m = AncientBossInfo{} }
func (m *AncientBossInfo) String() string            { return proto.CompactTextString(m) }
func (*AncientBossInfo) ProtoMessage()               {}
func (*AncientBossInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{68} }

func (m *AncientBossInfo) GetDareNum() int32 {
	if m != nil {
		return m.DareNum
	}
	return 0
}

func (m *AncientBossInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

type TalentInfo struct {
	GetPoints     int32                 `protobuf:"varint,1,opt,name=getPoints,proto3" json:"getPoints,omitempty"`
	SurplusPoints int32                 `protobuf:"varint,2,opt,name=surplusPoints,proto3" json:"surplusPoints,omitempty"`
	Talents       map[int32]*TalentUnit `protobuf:"bytes,3,rep,name=talents" json:"talents,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TalentInfo) Reset()                    { *m = TalentInfo{} }
func (m *TalentInfo) String() string            { return proto.CompactTextString(m) }
func (*TalentInfo) ProtoMessage()               {}
func (*TalentInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{69} }

func (m *TalentInfo) GetGetPoints() int32 {
	if m != nil {
		return m.GetPoints
	}
	return 0
}

func (m *TalentInfo) GetSurplusPoints() int32 {
	if m != nil {
		return m.SurplusPoints
	}
	return 0
}

func (m *TalentInfo) GetTalents() map[int32]*TalentUnit {
	if m != nil {
		return m.Talents
	}
	return nil
}

type TalentUnit struct {
	UsePoints int32           `protobuf:"varint,1,opt,name=usePoints,proto3" json:"usePoints,omitempty"`
	Talents   map[int32]int32 `protobuf:"bytes,2,rep,name=talents" json:"talents,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TalentUnit) Reset()                    { *m = TalentUnit{} }
func (m *TalentUnit) String() string            { return proto.CompactTextString(m) }
func (*TalentUnit) ProtoMessage()               {}
func (*TalentUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{70} }

func (m *TalentUnit) GetUsePoints() int32 {
	if m != nil {
		return m.UsePoints
	}
	return 0
}

func (m *TalentUnit) GetTalents() map[int32]int32 {
	if m != nil {
		return m.Talents
	}
	return nil
}

type Fit struct {
	CdStart  int64               `protobuf:"varint,1,opt,name=cdStart,proto3" json:"cdStart,omitempty"`
	CdEnd    int64               `protobuf:"varint,2,opt,name=cdEnd,proto3" json:"cdEnd,omitempty"`
	Fashion  map[int32]int32     `protobuf:"bytes,3,rep,name=fashion" json:"fashion,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SkillBag map[int32]int32     `protobuf:"bytes,4,rep,name=skillBag" json:"skillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Lv       map[int32]int32     `protobuf:"bytes,5,rep,name=lv" json:"lv,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Skills   map[int32]*FitSkill `protobuf:"bytes,6,rep,name=skills" json:"skills,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Fit) Reset()                    { *m = Fit{} }
func (m *Fit) String() string            { return proto.CompactTextString(m) }
func (*Fit) ProtoMessage()               {}
func (*Fit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{71} }

func (m *Fit) GetCdStart() int64 {
	if m != nil {
		return m.CdStart
	}
	return 0
}

func (m *Fit) GetCdEnd() int64 {
	if m != nil {
		return m.CdEnd
	}
	return 0
}

func (m *Fit) GetFashion() map[int32]int32 {
	if m != nil {
		return m.Fashion
	}
	return nil
}

func (m *Fit) GetSkillBag() map[int32]int32 {
	if m != nil {
		return m.SkillBag
	}
	return nil
}

func (m *Fit) GetLv() map[int32]int32 {
	if m != nil {
		return m.Lv
	}
	return nil
}

func (m *Fit) GetSkills() map[int32]*FitSkill {
	if m != nil {
		return m.Skills
	}
	return nil
}

type FitSkill struct {
	Lv   int32 `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Star int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
}

func (m *FitSkill) Reset()                    { *m = FitSkill{} }
func (m *FitSkill) String() string            { return proto.CompactTextString(m) }
func (*FitSkill) ProtoMessage()               {}
func (*FitSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{72} }

func (m *FitSkill) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *FitSkill) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

type MonthCardUnit struct {
	StartTime int64 `protobuf:"varint,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	IsExpire  bool  `protobuf:"varint,3,opt,name=isExpire,proto3" json:"isExpire,omitempty"`
}

func (m *MonthCardUnit) Reset()                    { *m = MonthCardUnit{} }
func (m *MonthCardUnit) String() string            { return proto.CompactTextString(m) }
func (*MonthCardUnit) ProtoMessage()               {}
func (*MonthCardUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{73} }

func (m *MonthCardUnit) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MonthCardUnit) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MonthCardUnit) GetIsExpire() bool {
	if m != nil {
		return m.IsExpire
	}
	return false
}

type FirstRecharge struct {
	IsRecharge bool    `protobuf:"varint,1,opt,name=isRecharge,proto3" json:"isRecharge,omitempty"`
	Days       []int32 `protobuf:"varint,2,rep,packed,name=days" json:"days,omitempty"`
	OpenDay    int64   `protobuf:"varint,3,opt,name=openDay,proto3" json:"openDay,omitempty"`
}

func (m *FirstRecharge) Reset()                    { *m = FirstRecharge{} }
func (m *FirstRecharge) String() string            { return proto.CompactTextString(m) }
func (*FirstRecharge) ProtoMessage()               {}
func (*FirstRecharge) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{74} }

func (m *FirstRecharge) GetIsRecharge() bool {
	if m != nil {
		return m.IsRecharge
	}
	return false
}

func (m *FirstRecharge) GetDays() []int32 {
	if m != nil {
		return m.Days
	}
	return nil
}

func (m *FirstRecharge) GetOpenDay() int64 {
	if m != nil {
		return m.OpenDay
	}
	return 0
}

type SpendRebates struct {
	CountIngot int32   `protobuf:"varint,1,opt,name=countIngot,proto3" json:"countIngot,omitempty"`
	Ingot      int32   `protobuf:"varint,2,opt,name=ingot,proto3" json:"ingot,omitempty"`
	Reward     []int32 `protobuf:"varint,3,rep,packed,name=reward" json:"reward,omitempty"`
	Cycle      int32   `protobuf:"varint,4,opt,name=cycle,proto3" json:"cycle,omitempty"`
}

func (m *SpendRebates) Reset()                    { *m = SpendRebates{} }
func (m *SpendRebates) String() string            { return proto.CompactTextString(m) }
func (*SpendRebates) ProtoMessage()               {}
func (*SpendRebates) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{75} }

func (m *SpendRebates) GetCountIngot() int32 {
	if m != nil {
		return m.CountIngot
	}
	return 0
}

func (m *SpendRebates) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *SpendRebates) GetReward() []int32 {
	if m != nil {
		return m.Reward
	}
	return nil
}

func (m *SpendRebates) GetCycle() int32 {
	if m != nil {
		return m.Cycle
	}
	return 0
}

type GrowFund struct {
	IsBuy bool    `protobuf:"varint,1,opt,name=isBuy,proto3" json:"isBuy,omitempty"`
	Ids   []int32 `protobuf:"varint,2,rep,packed,name=ids" json:"ids,omitempty"`
}

func (m *GrowFund) Reset()                    { *m = GrowFund{} }
func (m *GrowFund) String() string            { return proto.CompactTextString(m) }
func (*GrowFund) ProtoMessage()               {}
func (*GrowFund) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{76} }

func (m *GrowFund) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *GrowFund) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

type WarOrderTaskUnit struct {
	One   int32           `protobuf:"varint,1,opt,name=one,proto3" json:"one,omitempty"`
	Two   map[int32]int32 `protobuf:"bytes,2,rep,name=two" json:"two,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Three map[int32]int32 `protobuf:"bytes,3,rep,name=three" json:"three,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *WarOrderTaskUnit) Reset()                    { *m = WarOrderTaskUnit{} }
func (m *WarOrderTaskUnit) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskUnit) ProtoMessage()               {}
func (*WarOrderTaskUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{77} }

func (m *WarOrderTaskUnit) GetOne() int32 {
	if m != nil {
		return m.One
	}
	return 0
}

func (m *WarOrderTaskUnit) GetTwo() map[int32]int32 {
	if m != nil {
		return m.Two
	}
	return nil
}

func (m *WarOrderTaskUnit) GetThree() map[int32]int32 {
	if m != nil {
		return m.Three
	}
	return nil
}

type WarOrderTaskInfo struct {
	Val    *WarOrderTaskUnit `protobuf:"bytes,1,opt,name=val" json:"val,omitempty"`
	Finish bool              `protobuf:"varint,2,opt,name=finish,proto3" json:"finish,omitempty"`
	Reward bool              `protobuf:"varint,3,opt,name=reward,proto3" json:"reward,omitempty"`
}

func (m *WarOrderTaskInfo) Reset()                    { *m = WarOrderTaskInfo{} }
func (m *WarOrderTaskInfo) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskInfo) ProtoMessage()               {}
func (*WarOrderTaskInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{78} }

func (m *WarOrderTaskInfo) GetVal() *WarOrderTaskUnit {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *WarOrderTaskInfo) GetFinish() bool {
	if m != nil {
		return m.Finish
	}
	return false
}

func (m *WarOrderTaskInfo) GetReward() bool {
	if m != nil {
		return m.Reward
	}
	return false
}

type WarOrderTask struct {
	Task map[int32]*WarOrderTaskInfo `protobuf:"bytes,1,rep,name=task" json:"task,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *WarOrderTask) Reset()                    { *m = WarOrderTask{} }
func (m *WarOrderTask) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTask) ProtoMessage()               {}
func (*WarOrderTask) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{79} }

func (m *WarOrderTask) GetTask() map[int32]*WarOrderTaskInfo {
	if m != nil {
		return m.Task
	}
	return nil
}

type WarOrderReward struct {
	Elite  bool `protobuf:"varint,1,opt,name=elite,proto3" json:"elite,omitempty"`
	Luxury bool `protobuf:"varint,2,opt,name=luxury,proto3" json:"luxury,omitempty"`
}

func (m *WarOrderReward) Reset()                    { *m = WarOrderReward{} }
func (m *WarOrderReward) String() string            { return proto.CompactTextString(m) }
func (*WarOrderReward) ProtoMessage()               {}
func (*WarOrderReward) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{80} }

func (m *WarOrderReward) GetElite() bool {
	if m != nil {
		return m.Elite
	}
	return false
}

func (m *WarOrderReward) GetLuxury() bool {
	if m != nil {
		return m.Luxury
	}
	return false
}

type WarOrder struct {
	Lv        int32                     `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp       int32                     `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Season    int32                     `protobuf:"varint,3,opt,name=season,proto3" json:"season,omitempty"`
	StartTime int64                     `protobuf:"varint,4,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64                     `protobuf:"varint,5,opt,name=endTime,proto3" json:"endTime,omitempty"`
	IsLuxury  bool                      `protobuf:"varint,6,opt,name=isLuxury,proto3" json:"isLuxury,omitempty"`
	Task      *WarOrderTask             `protobuf:"bytes,7,opt,name=task" json:"task,omitempty"`
	Exchange  map[int32]int32           `protobuf:"bytes,8,rep,name=exchange" json:"exchange,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	WeekTask  map[int32]*WarOrderTask   `protobuf:"bytes,9,rep,name=weekTask" json:"weekTask,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Reward    map[int32]*WarOrderReward `protobuf:"bytes,10,rep,name=reward" json:"reward,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *WarOrder) Reset()                    { *m = WarOrder{} }
func (m *WarOrder) String() string            { return proto.CompactTextString(m) }
func (*WarOrder) ProtoMessage()               {}
func (*WarOrder) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{81} }

func (m *WarOrder) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrder) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *WarOrder) GetSeason() int32 {
	if m != nil {
		return m.Season
	}
	return 0
}

func (m *WarOrder) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *WarOrder) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *WarOrder) GetIsLuxury() bool {
	if m != nil {
		return m.IsLuxury
	}
	return false
}

func (m *WarOrder) GetTask() *WarOrderTask {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *WarOrder) GetExchange() map[int32]int32 {
	if m != nil {
		return m.Exchange
	}
	return nil
}

func (m *WarOrder) GetWeekTask() map[int32]*WarOrderTask {
	if m != nil {
		return m.WeekTask
	}
	return nil
}

func (m *WarOrder) GetReward() map[int32]*WarOrderReward {
	if m != nil {
		return m.Reward
	}
	return nil
}

type Elf struct {
	Lv           int32           `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp          int32           `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Skills       map[int32]int32 `protobuf:"bytes,3,rep,name=skills" json:"skills,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SkillBag     map[int32]int32 `protobuf:"bytes,4,rep,name=skillBag" json:"skillBag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ReceiveLimit map[int32]int32 `protobuf:"bytes,5,rep,name=receiveLimit" json:"receiveLimit,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Elf) Reset()                    { *m = Elf{} }
func (m *Elf) String() string            { return proto.CompactTextString(m) }
func (*Elf) ProtoMessage()               {}
func (*Elf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{82} }

func (m *Elf) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *Elf) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *Elf) GetSkills() map[int32]int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *Elf) GetSkillBag() map[int32]int32 {
	if m != nil {
		return m.SkillBag
	}
	return nil
}

func (m *Elf) GetReceiveLimit() map[int32]int32 {
	if m != nil {
		return m.ReceiveLimit
	}
	return nil
}

type FriendUserInfo struct {
	UserId         int32                     `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Combat         int64                     `protobuf:"varint,2,opt,name=combat,proto3" json:"combat,omitempty"`
	FriendHeroInfo map[int32]*FriendHeroInfo `protobuf:"bytes,3,rep,name=friendHeroInfo" json:"friendHeroInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FriendUserInfo) Reset()                    { *m = FriendUserInfo{} }
func (m *FriendUserInfo) String() string            { return proto.CompactTextString(m) }
func (*FriendUserInfo) ProtoMessage()               {}
func (*FriendUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{83} }

func (m *FriendUserInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FriendUserInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *FriendUserInfo) GetFriendHeroInfo() map[int32]*FriendHeroInfo {
	if m != nil {
		return m.FriendHeroInfo
	}
	return nil
}

type FriendHeroInfo struct {
	Equips  map[int32]*EquipUnit `protobuf:"bytes,1,rep,name=equips" json:"equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Props   map[int32]int64      `protobuf:"bytes,2,rep,name=props" json:"props,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Job     int32                `protobuf:"varint,3,opt,name=job,proto3" json:"job,omitempty"`
	Sex     int32                `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Lv      int32                `protobuf:"varint,5,opt,name=lv,proto3" json:"lv,omitempty"`
	Display *Display             `protobuf:"bytes,6,opt,name=display" json:"display,omitempty"`
	Name    string               `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	Combat  int64                `protobuf:"varint,8,opt,name=combat,proto3" json:"combat,omitempty"`
}

func (m *FriendHeroInfo) Reset()                    { *m = FriendHeroInfo{} }
func (m *FriendHeroInfo) String() string            { return proto.CompactTextString(m) }
func (*FriendHeroInfo) ProtoMessage()               {}
func (*FriendHeroInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{84} }

func (m *FriendHeroInfo) GetEquips() map[int32]*EquipUnit {
	if m != nil {
		return m.Equips
	}
	return nil
}

func (m *FriendHeroInfo) GetProps() map[int32]int64 {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *FriendHeroInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *FriendHeroInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *FriendHeroInfo) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *FriendHeroInfo) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *FriendHeroInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FriendHeroInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

type FitHolyEquipUnit struct {
	Equip map[int32]int32 `protobuf:"bytes,1,rep,name=equip" json:"equip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FitHolyEquipUnit) Reset()                    { *m = FitHolyEquipUnit{} }
func (m *FitHolyEquipUnit) String() string            { return proto.CompactTextString(m) }
func (*FitHolyEquipUnit) ProtoMessage()               {}
func (*FitHolyEquipUnit) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{85} }

func (m *FitHolyEquipUnit) GetEquip() map[int32]int32 {
	if m != nil {
		return m.Equip
	}
	return nil
}

type FitHolyEquip struct {
	SuitId int32                       `protobuf:"varint,1,opt,name=suitId,proto3" json:"suitId,omitempty"`
	Equips map[int32]*FitHolyEquipUnit `protobuf:"bytes,2,rep,name=equips" json:"equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FitHolyEquip) Reset()                    { *m = FitHolyEquip{} }
func (m *FitHolyEquip) String() string            { return proto.CompactTextString(m) }
func (*FitHolyEquip) ProtoMessage()               {}
func (*FitHolyEquip) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{86} }

func (m *FitHolyEquip) GetSuitId() int32 {
	if m != nil {
		return m.SuitId
	}
	return 0
}

func (m *FitHolyEquip) GetEquips() map[int32]*FitHolyEquipUnit {
	if m != nil {
		return m.Equips
	}
	return nil
}

type ContRecharge struct {
	Cycle    int32           `protobuf:"varint,1,opt,name=cycle,proto3" json:"cycle,omitempty"`
	Recharge map[int32]int32 `protobuf:"bytes,2,rep,name=recharge" json:"recharge,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Receive  []int32         `protobuf:"varint,3,rep,packed,name=receive" json:"receive,omitempty"`
	TodayPay int32           `protobuf:"varint,4,opt,name=todayPay,proto3" json:"todayPay,omitempty"`
}

func (m *ContRecharge) Reset()                    { *m = ContRecharge{} }
func (m *ContRecharge) String() string            { return proto.CompactTextString(m) }
func (*ContRecharge) ProtoMessage()               {}
func (*ContRecharge) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{87} }

func (m *ContRecharge) GetCycle() int32 {
	if m != nil {
		return m.Cycle
	}
	return 0
}

func (m *ContRecharge) GetRecharge() map[int32]int32 {
	if m != nil {
		return m.Recharge
	}
	return nil
}

func (m *ContRecharge) GetReceive() []int32 {
	if m != nil {
		return m.Receive
	}
	return nil
}

func (m *ContRecharge) GetTodayPay() int32 {
	if m != nil {
		return m.TodayPay
	}
	return 0
}

type PaoMaDengInfo struct {
	Type       int32  `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	CycleTimes int32  `protobuf:"varint,2,opt,name=cycleTimes,proto3" json:"cycleTimes,omitempty"`
	Content    string `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PaoMaDengInfo) Reset()                    { *m = PaoMaDengInfo{} }
func (m *PaoMaDengInfo) String() string            { return proto.CompactTextString(m) }
func (*PaoMaDengInfo) ProtoMessage()               {}
func (*PaoMaDengInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{88} }

func (m *PaoMaDengInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *PaoMaDengInfo) GetCycleTimes() int32 {
	if m != nil {
		return m.CycleTimes
	}
	return 0
}

func (m *PaoMaDengInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PaoMaDengNtf struct {
	PaoMaDengInfos []*PaoMaDengInfo `protobuf:"bytes,1,rep,name=PaoMaDengInfos" json:"PaoMaDengInfos,omitempty"`
}

func (m *PaoMaDengNtf) Reset()                    { *m = PaoMaDengNtf{} }
func (m *PaoMaDengNtf) String() string            { return proto.CompactTextString(m) }
func (*PaoMaDengNtf) ProtoMessage()               {}
func (*PaoMaDengNtf) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{89} }

func (m *PaoMaDengNtf) GetPaoMaDengInfos() []*PaoMaDengInfo {
	if m != nil {
		return m.PaoMaDengInfos
	}
	return nil
}

type AncientSkill struct {
	SkillId int32 `protobuf:"varint,1,opt,name=skillId,proto3" json:"skillId,omitempty"`
	Level   int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	Grade   int32 `protobuf:"varint,3,opt,name=grade,proto3" json:"grade,omitempty"`
}

func (m *AncientSkill) Reset()                    { *m = AncientSkill{} }
func (m *AncientSkill) String() string            { return proto.CompactTextString(m) }
func (*AncientSkill) ProtoMessage()               {}
func (*AncientSkill) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{90} }

func (m *AncientSkill) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *AncientSkill) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *AncientSkill) GetGrade() int32 {
	if m != nil {
		return m.Grade
	}
	return 0
}

type Title struct {
	TitleId   int32 `protobuf:"varint,1,opt,name=titleId,proto3" json:"titleId,omitempty"`
	StartTime int64 `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,3,opt,name=endTime,proto3" json:"endTime,omitempty"`
	IsLook    bool  `protobuf:"varint,4,opt,name=isLook,proto3" json:"isLook,omitempty"`
}

func (m *Title) Reset()                    { *m = Title{} }
func (m *Title) String() string            { return proto.CompactTextString(m) }
func (*Title) ProtoMessage()               {}
func (*Title) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{91} }

func (m *Title) GetTitleId() int32 {
	if m != nil {
		return m.TitleId
	}
	return 0
}

func (m *Title) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Title) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *Title) GetIsLook() bool {
	if m != nil {
		return m.IsLook
	}
	return false
}

type BriefServerInfo struct {
	ServerId   int32  `protobuf:"varint,1,opt,name=serverId,proto3" json:"serverId,omitempty"`
	ServerName string `protobuf:"bytes,2,opt,name=serverName,proto3" json:"serverName,omitempty"`
	CrossFsId  int32  `protobuf:"varint,3,opt,name=crossFsId,proto3" json:"crossFsId,omitempty"`
}

func (m *BriefServerInfo) Reset()                    { *m = BriefServerInfo{} }
func (m *BriefServerInfo) String() string            { return proto.CompactTextString(m) }
func (*BriefServerInfo) ProtoMessage()               {}
func (*BriefServerInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{92} }

func (m *BriefServerInfo) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *BriefServerInfo) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *BriefServerInfo) GetCrossFsId() int32 {
	if m != nil {
		return m.CrossFsId
	}
	return 0
}

type Label struct {
	LabelId   int32 `protobuf:"varint,1,opt,name=labelId,proto3" json:"labelId,omitempty"`
	Job       int32 `protobuf:"varint,2,opt,name=job,proto3" json:"job,omitempty"`
	Transfer  int32 `protobuf:"varint,3,opt,name=transfer,proto3" json:"transfer,omitempty"`
	DayReward bool  `protobuf:"varint,4,opt,name=dayReward,proto3" json:"dayReward,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (m *Label) String() string            { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{93} }

func (m *Label) GetLabelId() int32 {
	if m != nil {
		return m.LabelId
	}
	return 0
}

func (m *Label) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *Label) GetTransfer() int32 {
	if m != nil {
		return m.Transfer
	}
	return 0
}

func (m *Label) GetDayReward() bool {
	if m != nil {
		return m.DayReward
	}
	return false
}

func init() {
	proto.RegisterType((*ErrorAck)(nil), "pb.ErrorAck")
	proto.RegisterType((*UserLoginInfo)(nil), "pb.UserLoginInfo")
	proto.RegisterType((*AppletsInfo)(nil), "pb.appletsInfo")
	proto.RegisterType((*AncientTreasureInfo)(nil), "pb.AncientTreasureInfo")
	proto.RegisterType((*MiJiInfo)(nil), "pb.MiJiInfo")
	proto.RegisterType((*AnnouncementInfo)(nil), "pb.AnnouncementInfo")
	proto.RegisterType((*HeroInfo)(nil), "pb.HeroInfo")
	proto.RegisterType((*UserWear)(nil), "pb.UserWear")
	proto.RegisterType((*Wears)(nil), "pb.Wears")
	proto.RegisterType((*BriefUserInfo)(nil), "pb.BriefUserInfo")
	proto.RegisterType((*BriefUserInfoWithDisplay)(nil), "pb.BriefUserInfoWithDisplay")
	proto.RegisterType((*TopDataChangeNtf)(nil), "pb.TopDataChangeNtf")
	proto.RegisterType((*TopDataChange)(nil), "pb.TopDataChange")
	proto.RegisterType((*BagDataChangeNtf)(nil), "pb.BagDataChangeNtf")
	proto.RegisterType((*ItemChange)(nil), "pb.ItemChange")
	proto.RegisterType((*BagEquipDataChangeNtf)(nil), "pb.BagEquipDataChangeNtf")
	proto.RegisterType((*EquipChange)(nil), "pb.EquipChange")
	proto.RegisterType((*Item)(nil), "pb.Item")
	proto.RegisterType((*GoodsChangeNtf)(nil), "pb.GoodsChangeNtf")
	proto.RegisterType((*ItemUnit)(nil), "pb.itemUnit")
	proto.RegisterType((*EquipUnit)(nil), "pb.EquipUnit")
	proto.RegisterType((*EquipRandProp)(nil), "pb.EquipRandProp")
	proto.RegisterType((*EquipClearArr)(nil), "pb.EquipClearArr")
	proto.RegisterType((*EquipClearInfo)(nil), "pb.EquipClearInfo")
	proto.RegisterType((*HeroProp)(nil), "pb.HeroProp")
	proto.RegisterType((*TaskInfoNtf)(nil), "pb.TaskInfoNtf")
	proto.RegisterType((*DisplayNtf)(nil), "pb.DisplayNtf")
	proto.RegisterType((*EventNtf)(nil), "pb.EventNtf")
	proto.RegisterType((*DailyConditionNtf)(nil), "pb.DailyConditionNtf")
	proto.RegisterType((*PropInfo)(nil), "pb.PropInfo")
	proto.RegisterType((*EquipGrid)(nil), "pb.EquipGrid")
	proto.RegisterType((*Fabao)(nil), "pb.Fabao")
	proto.RegisterType((*GodEquip)(nil), "pb.GodEquip")
	proto.RegisterType((*Juexue)(nil), "pb.Juexue")
	proto.RegisterType((*Fashion)(nil), "pb.Fashion")
	proto.RegisterType((*Wing)(nil), "pb.Wing")
	proto.RegisterType((*WingSpecialNtf)(nil), "pb.WingSpecialNtf")
	proto.RegisterType((*Rein)(nil), "pb.Rein")
	proto.RegisterType((*ReinCost)(nil), "pb.ReinCost")
	proto.RegisterType((*Atlas)(nil), "pb.Atlas")
	proto.RegisterType((*AtlasGather)(nil), "pb.AtlasGather")
	proto.RegisterType((*Preference)(nil), "pb.Preference")
	proto.RegisterType((*WorldBossInfoNtf)(nil), "pb.WorldBossInfoNtf")
	proto.RegisterType((*VipBoss)(nil), "pb.VipBoss")
	proto.RegisterType((*ExpStage)(nil), "pb.ExpStage")
	proto.RegisterType((*MaterialStage)(nil), "pb.MaterialStage")
	proto.RegisterType((*Display)(nil), "pb.Display")
	proto.RegisterType((*SpecialEquipUnit)(nil), "pb.SpecialEquipUnit")
	proto.RegisterType((*GetSource)(nil), "pb.GetSource")
	proto.RegisterType((*RankInfo)(nil), "pb.RankInfo")
	proto.RegisterType((*SkillUnit)(nil), "pb.SkillUnit")
	proto.RegisterType((*ShopInfo)(nil), "pb.ShopInfo")
	proto.RegisterType((*DictateInfo)(nil), "pb.DictateInfo")
	proto.RegisterType((*PanaceaInfo)(nil), "pb.PanaceaInfo")
	proto.RegisterType((*JewelInfo)(nil), "pb.JewelInfo")
	proto.RegisterType((*DayStateInfo)(nil), "pb.DayStateInfo")
	proto.RegisterType((*SignInfo)(nil), "pb.SignInfo")
	proto.RegisterType((*InsideInfo)(nil), "pb.InsideInfo")
	proto.RegisterType((*InsideSkill)(nil), "pb.InsideSkill")
	proto.RegisterType((*Holy)(nil), "pb.Holy")
	proto.RegisterType((*Ring)(nil), "pb.Ring")
	proto.RegisterType((*RingPhantom)(nil), "pb.RingPhantom")
	proto.RegisterType((*PetInfo)(nil), "pb.PetInfo")
	proto.RegisterType((*ResetNtf)(nil), "pb.ResetNtf")
	proto.RegisterType((*FieldFightRivalUserInfo)(nil), "pb.FieldFightRivalUserInfo")
	proto.RegisterType((*DarkPalaceInfo)(nil), "pb.DarkPalaceInfo")
	proto.RegisterType((*HellBossInfo)(nil), "pb.HellBossInfo")
	proto.RegisterType((*FieldBossInfo)(nil), "pb.FieldBossInfo")
	proto.RegisterType((*AncientBossInfo)(nil), "pb.AncientBossInfo")
	proto.RegisterType((*TalentInfo)(nil), "pb.TalentInfo")
	proto.RegisterType((*TalentUnit)(nil), "pb.TalentUnit")
	proto.RegisterType((*Fit)(nil), "pb.Fit")
	proto.RegisterType((*FitSkill)(nil), "pb.FitSkill")
	proto.RegisterType((*MonthCardUnit)(nil), "pb.MonthCardUnit")
	proto.RegisterType((*FirstRecharge)(nil), "pb.FirstRecharge")
	proto.RegisterType((*SpendRebates)(nil), "pb.SpendRebates")
	proto.RegisterType((*GrowFund)(nil), "pb.GrowFund")
	proto.RegisterType((*WarOrderTaskUnit)(nil), "pb.WarOrderTaskUnit")
	proto.RegisterType((*WarOrderTaskInfo)(nil), "pb.WarOrderTaskInfo")
	proto.RegisterType((*WarOrderTask)(nil), "pb.WarOrderTask")
	proto.RegisterType((*WarOrderReward)(nil), "pb.WarOrderReward")
	proto.RegisterType((*WarOrder)(nil), "pb.WarOrder")
	proto.RegisterType((*Elf)(nil), "pb.Elf")
	proto.RegisterType((*FriendUserInfo)(nil), "pb.FriendUserInfo")
	proto.RegisterType((*FriendHeroInfo)(nil), "pb.FriendHeroInfo")
	proto.RegisterType((*FitHolyEquipUnit)(nil), "pb.FitHolyEquipUnit")
	proto.RegisterType((*FitHolyEquip)(nil), "pb.FitHolyEquip")
	proto.RegisterType((*ContRecharge)(nil), "pb.ContRecharge")
	proto.RegisterType((*PaoMaDengInfo)(nil), "pb.PaoMaDengInfo")
	proto.RegisterType((*PaoMaDengNtf)(nil), "pb.PaoMaDengNtf")
	proto.RegisterType((*AncientSkill)(nil), "pb.AncientSkill")
	proto.RegisterType((*Title)(nil), "pb.Title")
	proto.RegisterType((*BriefServerInfo)(nil), "pb.BriefServerInfo")
	proto.RegisterType((*Label)(nil), "pb.Label")
}
func (m *ErrorAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *UserLoginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLoginInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Userid))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.VipLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VipLevel))
	}
	if m.VipScore != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VipScore))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Gold))
	}
	if m.Ingot != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ingot))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageId))
	}
	if m.StageWave != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageWave))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	if len(m.Heros) > 0 {
		for _, msg := range m.Heros {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Rein != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rein.Size()))
		n1, err := m.Rein.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ReinCost) > 0 {
		for _, msg := range m.ReinCost {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Fabao) > 0 {
		for _, msg := range m.Fabao {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FieldBossInfo != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FieldBossInfo.Size()))
		n2, err := m.FieldBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.WorldBossInfo != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WorldBossInfo.Size()))
		n3, err := m.WorldBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ArenaFightNum != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ArenaFightNum))
	}
	if m.FightModel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FightModel))
	}
	if m.Task != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Task.Size()))
		n4, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.ShopInfo) > 0 {
		for k, _ := range m.ShopInfo {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.ShopInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.ChuanqiBi != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChuanqiBi))
	}
	if len(m.MaterialStage) > 0 {
		for k, _ := range m.MaterialStage {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.MaterialStage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if len(m.Panaceas) > 0 {
		for k, _ := range m.Panaceas {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.Panaceas[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if m.SignInfo != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SignInfo.Size()))
		n8, err := m.SignInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DayStateInfo != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DayStateInfo.Size()))
		n9, err := m.DayStateInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Official != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Official))
	}
	if len(m.Holy) > 0 {
		for _, msg := range m.Holy {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Atlases) > 0 {
		for _, msg := range m.Atlases {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AtlasGathers) > 0 {
		for _, msg := range m.AtlasGathers {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MiningWorkTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MiningWorkTime))
	}
	if m.Miner != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Miner))
	}
	if m.ExpStage != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpStage.Size()))
		n10, err := m.ExpStage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Pets) > 0 {
		for k, _ := range m.Pets {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.Pets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if len(m.Juexues) > 0 {
		for _, msg := range m.Juexues {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UserWear != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserWear.Size()))
		n12, err := m.UserWear.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.IsHaveGetDailyCompetitveReward != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsHaveGetDailyCompetitveReward))
	}
	if m.Honour != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Honour))
	}
	if m.DarkPalaceInfo != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DarkPalaceInfo.Size()))
		n13, err := m.DarkPalaceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.PersonBoss) > 0 {
		for k, _ := range m.PersonBoss {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			v := m.PersonBoss[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.VipBoss) > 0 {
		for k, _ := range m.VipBoss {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x2
			i++
			v := m.VipBoss[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.VipGift) > 0 {
		dAtA15 := make([]byte, len(m.VipGift)*10)
		var j14 int
		for _, num1 := range m.VipGift {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.Fit != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Fit.Size()))
		n16, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.RechargeAll != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RechargeAll))
	}
	if len(m.AccumulativeAllGetIds) > 0 {
		dAtA18 := make([]byte, len(m.AccumulativeAllGetIds)*10)
		var j17 int
		for _, num1 := range m.AccumulativeAllGetIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.MonthCard) > 0 {
		for k, _ := range m.MonthCard {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x3
			i++
			v := m.MonthCard[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	if m.FirstRecharge != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FirstRecharge.Size()))
		n20, err := m.FirstRecharge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.SpendRebates != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SpendRebates.Size()))
		n21, err := m.SpendRebates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.DailyPack) > 0 {
		for k, _ := range m.DailyPack {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3
			i++
			v := m.DailyPack[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.GrowFund != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GrowFund.Size()))
		n22, err := m.GrowFund.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.WarOrder != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WarOrder.Size()))
		n23, err := m.WarOrder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RedPacketGetNum != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RedPacketGetNum))
	}
	if m.Elf != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Elf.Size()))
		n24, err := m.Elf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.CutTreasureLv != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CutTreasureLv))
	}
	if m.FitHolyEquip != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FitHolyEquip.Size()))
		n25, err := m.FitHolyEquip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.Recharge) > 0 {
		dAtA27 := make([]byte, len(m.Recharge)*10)
		var j26 int
		for _, num1 := range m.Recharge {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if m.ShaBakeIsEnd != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ShaBakeIsEnd))
	}
	if m.CrossShabakeIsEnd != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CrossShabakeIsEnd))
	}
	if m.IsFriendApply {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		if m.IsFriendApply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BindingIngot != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BindingIngot))
	}
	if m.HookupTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HookupTime))
	}
	if len(m.HookupBag) > 0 {
		for _, msg := range m.HookupBag {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ContRecharge != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ContRecharge.Size()))
		n28, err := m.ContRecharge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.OpenGift) > 0 {
		for k, _ := range m.OpenGift {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x4
			i++
			v := m.OpenGift[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.CrossChallengeIsApply != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CrossChallengeIsApply))
	}
	if len(m.AnnouncementInfos) > 0 {
		for _, msg := range m.AnnouncementInfos {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VipCustomer {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x4
		i++
		if m.VipCustomer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChatBanTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ChatBanTime))
	}
	if m.HaveUseRecharge != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HaveUseRecharge))
	}
	if m.GoldIngot != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GoldIngot))
	}
	if m.AncientBossInfo != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.AncientBossInfo.Size()))
		n29, err := m.AncientBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.TitleList) > 0 {
		for _, msg := range m.TitleList {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MiJiInfos) > 0 {
		for _, msg := range m.MiJiInfos {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AncientTreasureInfo) > 0 {
		for k, _ := range m.AncientTreasureInfo {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x4
			i++
			v := m.AncientTreasureInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n30, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n30
			}
		}
	}
	if len(m.PetAppendage) > 0 {
		for k, _ := range m.PetAppendage {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x4
			i++
			v := m.PetAppendage[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.HellBossInfo != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HellBossInfo.Size()))
		n31, err := m.HellBossInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.RedPacketNum != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RedPacketNum))
	}
	if len(m.DaBaoEquip) > 0 {
		for k, _ := range m.DaBaoEquip {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x5
			i++
			v := m.DaBaoEquip[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.DaBaoMysteryEnergy != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DaBaoMysteryEnergy))
	}
	if m.AppletsEnergy != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.AppletsEnergy))
	}
	if m.AppletsResumeTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.AppletsResumeTime))
	}
	if len(m.AppletsInfos) > 0 {
		for k, _ := range m.AppletsInfos {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x5
			i++
			v := m.AppletsInfos[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n32, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n32
			}
		}
	}
	if m.Label != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Label.Size()))
		n33, err := m.Label.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Subscribe) > 0 {
		dAtA35 := make([]byte, len(m.Subscribe)*10)
		var j34 int
		for _, num1 := range m.Subscribe {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	if len(m.Privilege) > 0 {
		dAtA37 := make([]byte, len(m.Privilege)*10)
		var j36 int
		for _, num1 := range m.Privilege {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	if m.UseRedPacketNum != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UseRedPacketNum))
	}
	if m.DailyRecharge != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DailyRecharge))
	}
	return i, nil
}

func (m *AppletsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppletsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *AncientTreasureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasureInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ZhuLinLv))
	}
	if m.StarLv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StarLv))
	}
	if m.JueXinLv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.JueXinLv))
	}
	if m.Types != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Types))
	}
	return i, nil
}

func (m *MiJiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiJiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	return i, nil
}

func (m *AnnouncementInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnouncementInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Announcement) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Announcement)))
		i += copy(dAtA[i:], m.Announcement)
	}
	return i, nil
}

func (m *HeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Index))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if len(m.Equips) > 0 {
		for k, _ := range m.Equips {
			dAtA[i] = 0x22
			i++
			v := m.Equips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n38, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n38
			}
		}
	}
	if len(m.EquipGrids) > 0 {
		for _, msg := range m.EquipGrids {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HeroProp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HeroProp.Size()))
		n39, err := m.HeroProp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Wing) > 0 {
		for _, msg := range m.Wing {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Zodiacs) > 0 {
		for k, _ := range m.Zodiacs {
			dAtA[i] = 0x42
			i++
			v := m.Zodiacs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n40, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n40
			}
		}
	}
	if len(m.Kingarms) > 0 {
		for k, _ := range m.Kingarms {
			dAtA[i] = 0x4a
			i++
			v := m.Kingarms[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n41, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n41
			}
		}
	}
	if len(m.Dictates) > 0 {
		for _, msg := range m.Dictates {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WingSpecial) > 0 {
		for _, msg := range m.WingSpecial {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Jewels) > 0 {
		for k, _ := range m.Jewels {
			dAtA[i] = 0x62
			i++
			v := m.Jewels[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n42, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n42
			}
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.InsideInfo != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.InsideInfo.Size()))
		n43, err := m.InsideInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Fashions) > 0 {
		for k, _ := range m.Fashions {
			dAtA[i] = 0x7a
			i++
			v := m.Fashions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n44, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n44
			}
		}
	}
	if m.Wears != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Wears.Size()))
		n45, err := m.Wears.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Rings) > 0 {
		for k, _ := range m.Rings {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Rings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n46, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n46
			}
		}
	}
	if len(m.Skills) > 0 {
		for _, msg := range m.Skills {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SkillBag) > 0 {
		for k, _ := range m.SkillBag {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.SkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.UniqueSkills) > 0 {
		for _, msg := range m.UniqueSkills {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UniqueSkillBag) > 0 {
		for k, _ := range m.UniqueSkillBag {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.UniqueSkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.GodEquips) > 0 {
		for k, _ := range m.GodEquips {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.GodEquips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n47, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n47
			}
		}
	}
	if len(m.Area) > 0 {
		for k, _ := range m.Area {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.Area[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.EquipClears) > 0 {
		for k, _ := range m.EquipClears {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.EquipClears[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n48, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n48
			}
		}
	}
	if m.ExpLvl != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpLvl))
	}
	if len(m.DragonEquip) > 0 {
		for k, _ := range m.DragonEquip {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.DragonEquip[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.MagicCircle) > 0 {
		for k, _ := range m.MagicCircle {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.MagicCircle[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.Talents != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talents.Size()))
		n49, err := m.Talents.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.ChuanShiEquip) > 0 {
		for k, _ := range m.ChuanShiEquip {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x1
			i++
			v := m.ChuanShiEquip[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.AncientSkill != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.AncientSkill.Size()))
		n50, err := m.AncientSkill.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.ChuanShiStrengthen) > 0 {
		for k, _ := range m.ChuanShiStrengthen {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.ChuanShiStrengthen[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *UserWear) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserWear) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Petid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Petid))
	}
	if m.FitFashionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FitFashionId))
	}
	return i, nil
}

func (m *Wears) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wears) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FashionWeaponId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionWeaponId))
	}
	if m.FashionClothId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.FashionClothId))
	}
	if len(m.AtlasWear) > 0 {
		dAtA52 := make([]byte, len(m.AtlasWear)*10)
		var j51 int
		for _, num1 := range m.AtlasWear {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j51))
		i += copy(dAtA[i:], dAtA52[:j51])
	}
	if m.WingId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MagicCircleLvId))
	}
	if m.TitleId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TitleId))
	}
	return i, nil
}

func (m *BriefUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BriefUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if m.Lvl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lvl))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Vip))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Job != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.MaxLv != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxLv))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ServerId))
	}
	if len(m.Display) > 0 {
		for k, _ := range m.Display {
			dAtA[i] = 0x5a
			i++
			v := m.Display[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n53, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n53
			}
		}
	}
	return i, nil
}

func (m *BriefUserInfoWithDisplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BriefUserInfoWithDisplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserInfo.Size()))
		n54, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Display != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Display.Size()))
		n55, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *TopDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *TopDataChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopDataChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Change != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	return i, nil
}

func (m *BagDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ItemChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Change != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	if m.GetSource != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n56, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}

func (m *BagEquipDataChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagEquipDataChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, msg := range m.ChangeInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *EquipChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Change != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Change))
	}
	if m.NowNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowNum))
	}
	if m.Equip != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Equip.Size()))
		n57, err := m.Equip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.GetSource != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n58, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Count))
	}
	if m.Position != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Position))
	}
	if m.Equip != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Equip.Size()))
		n59, err := m.Equip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.GetSource != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n60, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}

func (m *GoodsChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ItemUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *EquipUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if len(m.RandProps) > 0 {
		for _, msg := range m.RandProps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lock {
		dAtA[i] = 0x18
		i++
		if m.Lock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EquipIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EquipIndex))
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lucky))
	}
	return i, nil
}

func (m *EquipRandProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipRandProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PropId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PropId))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Color))
	}
	if m.Value != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *EquipClearArr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipClearArr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EquipClearInfo) > 0 {
		for _, msg := range m.EquipClearInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EquipClearInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipClearInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Grade != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Color))
	}
	if m.PropId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PropId))
	}
	if m.Value != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *HeroProp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroProp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0xa
			i++
			v := m.Props[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.ModulesCombat) > 0 {
		for k, _ := range m.ModulesCombat {
			dAtA[i] = 0x12
			i++
			v := m.ModulesCombat[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TaskInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TaskId))
	}
	if m.Process != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Process))
	}
	if m.MarkProcess != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MarkProcess))
	}
	return i, nil
}

func (m *DisplayNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisplayNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Display) > 0 {
		for k, _ := range m.Display {
			dAtA[i] = 0xa
			i++
			v := m.Display[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n61, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n61
			}
		}
	}
	return i, nil
}

func (m *EventNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ts))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SourceId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SourceId))
	}
	return i, nil
}

func (m *DailyConditionNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyConditionNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DailyConditions) > 0 {
		for k, _ := range m.DailyConditions {
			dAtA[i] = 0xa
			i++
			v := m.DailyConditions[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PropInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Key))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *EquipGrid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipGrid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pos))
	}
	if m.Strength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Strength))
	}
	return i, nil
}

func (m *Fabao) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fabao) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		dAtA63 := make([]byte, len(m.Skills)*10)
		var j62 int
		for _, num1 := range m.Skills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j62))
		i += copy(dAtA[i:], dAtA63[:j62])
	}
	return i, nil
}

func (m *GodEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GodEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Blood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Blood))
	}
	return i, nil
}

func (m *Juexue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Juexue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Fashion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fashion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Wing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WingSpecialNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WingSpecialNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpecialType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SpecialType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *Rein) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rein) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *ReinCost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReinCost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *Atlas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Atlas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	if m.IsActive {
		dAtA[i] = 0x18
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AtlasGather) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtlasGather) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	if m.IsActive {
		dAtA[i] = 0x18
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Preference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Preference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Key))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *WorldBossInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldBossInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.PrepareTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrepareTime))
	}
	if m.OpenTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenTime))
	}
	if m.CloseTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CloseTime))
	}
	return i, nil
}

func (m *VipBoss) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipBoss) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StageId))
	}
	if m.DareNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	return i, nil
}

func (m *ExpStage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if len(m.ExpStages) > 0 {
		for k, _ := range m.ExpStages {
			dAtA[i] = 0x1a
			i++
			v := m.ExpStages[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Appraise) > 0 {
		for k, _ := range m.Appraise {
			dAtA[i] = 0x22
			i++
			v := m.Appraise[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.Layer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Layer))
	}
	return i, nil
}

func (m *MaterialStage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterialStage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if m.NowLayer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NowLayer))
	}
	if m.LastLayer != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.LastLayer))
	}
	return i, nil
}

func (m *Display) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Display) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClothItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MagicCircleLvId))
	}
	if m.TitleId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TitleId))
	}
	if m.LabelId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.LabelId))
	}
	if m.LabelJob != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.LabelJob))
	}
	return i, nil
}

func (m *SpecialEquipUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialEquipUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ItemId))
	}
	if m.GetSource != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetSource.Size()))
		n64, err := m.GetSource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}

func (m *GetSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Map)))
		i += copy(dAtA[i:], m.Map)
	}
	if len(m.Monster) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Monster)))
		i += copy(dAtA[i:], m.Monster)
	}
	if len(m.SkillUser) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SkillUser)))
		i += copy(dAtA[i:], m.SkillUser)
	}
	if len(m.SkillDate) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SkillDate)))
		i += copy(dAtA[i:], m.SkillDate)
	}
	return i, nil
}

func (m *RankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rank))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Score))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserInfo.Size()))
		n65, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Display != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Display.Size()))
		n66, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}

func (m *SkillUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SkillId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *ShopInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShopItem) > 0 {
		for k, _ := range m.ShopItem {
			dAtA[i] = 0xa
			i++
			v := m.ShopItem[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DictateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DictateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *PanaceaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PanaceaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Numbers != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Numbers))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *JewelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JewelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Left))
	}
	if m.Right != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Right))
	}
	if m.Down != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Down))
	}
	return i, nil
}

func (m *DayStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DayStateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RankWorship != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RankWorship))
	}
	if len(m.MonthCardReceive) > 0 {
		dAtA68 := make([]byte, len(m.MonthCardReceive)*10)
		var j67 int
		for _, num1 := range m.MonthCardReceive {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j67))
		i += copy(dAtA[i:], dAtA68[:j67])
	}
	return i, nil
}

func (m *SignInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SignCount))
	}
	if len(m.SignDay) > 0 {
		for k, _ := range m.SignDay {
			dAtA[i] = 0x12
			i++
			v := m.SignDay[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.CumulativeDay) > 0 {
		for k, _ := range m.CumulativeDay {
			dAtA[i] = 0x1a
			i++
			v := m.CumulativeDay[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *InsideInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsideInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Acupoint) > 0 {
		for k, _ := range m.Acupoint {
			dAtA[i] = 0xa
			i++
			v := m.Acupoint[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.InsideSkill) > 0 {
		for k, _ := range m.InsideSkill {
			dAtA[i] = 0x12
			i++
			v := m.InsideSkill[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n69, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n69
			}
		}
	}
	return i, nil
}

func (m *InsideSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsideSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *Holy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Holy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, _ := range m.Skills {
			dAtA[i] = 0x22
			i++
			v := m.Skills[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Ring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ring) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Rid))
	}
	if m.Strengthen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Strengthen))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Pid))
	}
	if m.Talent != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talent))
	}
	if len(m.Phantom) > 0 {
		for k, _ := range m.Phantom {
			dAtA[i] = 0x2a
			i++
			v := m.Phantom[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n70, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n70
			}
		}
	}
	return i, nil
}

func (m *RingPhantom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RingPhantom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Talent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Talent))
	}
	if m.Phantom != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Phantom))
	}
	if len(m.Skill) > 0 {
		for k, _ := range m.Skill {
			dAtA[i] = 0x1a
			i++
			v := m.Skill[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if m.Grade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	if m.Break != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Break))
	}
	if len(m.Skill) > 0 {
		dAtA72 := make([]byte, len(m.Skill)*10)
		var j71 int
		for _, num1 := range m.Skill {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j71))
		i += copy(dAtA[i:], dAtA72[:j71])
	}
	return i, nil
}

func (m *ResetNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		for k, _ := range m.Type {
			dAtA[i] = 0xa
			i++
			v := m.Type[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.NewDayTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.NewDayTime))
	}
	return i, nil
}

func (m *FieldFightRivalUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldFightRivalUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RivalUserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RivalUserId))
	}
	if m.RivalDifficult != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.RivalDifficult))
	}
	return i, nil
}

func (m *DarkPalaceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DarkPalaceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HelpNum))
	}
	return i, nil
}

func (m *HellBossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HellBossInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.HelpNum))
	}
	return i, nil
}

func (m *FieldBossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldBossInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	if m.FirstReceive {
		dAtA[i] = 0x18
		i++
		if m.FirstReceive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AncientBossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientBossInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DareNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.BuyNum))
	}
	return i, nil
}

func (m *TalentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GetPoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.GetPoints))
	}
	if m.SurplusPoints != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SurplusPoints))
	}
	if len(m.Talents) > 0 {
		for k, _ := range m.Talents {
			dAtA[i] = 0x1a
			i++
			v := m.Talents[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n73, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n73
			}
		}
	}
	return i, nil
}

func (m *TalentUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalentUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UsePoints != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UsePoints))
	}
	if len(m.Talents) > 0 {
		for k, _ := range m.Talents {
			dAtA[i] = 0x12
			i++
			v := m.Talents[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Fit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CdStart != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CdStart))
	}
	if m.CdEnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CdEnd))
	}
	if len(m.Fashion) > 0 {
		for k, _ := range m.Fashion {
			dAtA[i] = 0x1a
			i++
			v := m.Fashion[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, _ := range m.SkillBag {
			dAtA[i] = 0x22
			i++
			v := m.SkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Lv) > 0 {
		for k, _ := range m.Lv {
			dAtA[i] = 0x2a
			i++
			v := m.Lv[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Skills) > 0 {
		for k, _ := range m.Skills {
			dAtA[i] = 0x32
			i++
			v := m.Skills[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n74, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n74
			}
		}
	}
	return i, nil
}

func (m *FitSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FitSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *MonthCardUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonthCardUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	if m.IsExpire {
		dAtA[i] = 0x18
		i++
		if m.IsExpire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FirstRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsRecharge {
		dAtA[i] = 0x8
		i++
		if m.IsRecharge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Days) > 0 {
		dAtA76 := make([]byte, len(m.Days)*10)
		var j75 int
		for _, num1 := range m.Days {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA76[j75] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j75++
			}
			dAtA76[j75] = uint8(num)
			j75++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j75))
		i += copy(dAtA[i:], dAtA76[:j75])
	}
	if m.OpenDay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenDay))
	}
	return i, nil
}

func (m *SpendRebates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendRebates) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CountIngot != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CountIngot))
	}
	if m.Ingot != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Ingot))
	}
	if len(m.Reward) > 0 {
		dAtA78 := make([]byte, len(m.Reward)*10)
		var j77 int
		for _, num1 := range m.Reward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA78[j77] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j77++
			}
			dAtA78[j77] = uint8(num)
			j77++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j77))
		i += copy(dAtA[i:], dAtA78[:j77])
	}
	if m.Cycle != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Cycle))
	}
	return i, nil
}

func (m *GrowFund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GrowFund) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsBuy {
		dAtA[i] = 0x8
		i++
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ids) > 0 {
		dAtA80 := make([]byte, len(m.Ids)*10)
		var j79 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j79))
		i += copy(dAtA[i:], dAtA80[:j79])
	}
	return i, nil
}

func (m *WarOrderTaskUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.One != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.One))
	}
	if len(m.Two) > 0 {
		for k, _ := range m.Two {
			dAtA[i] = 0x12
			i++
			v := m.Two[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Three) > 0 {
		for k, _ := range m.Three {
			dAtA[i] = 0x1a
			i++
			v := m.Three[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *WarOrderTaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Val != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Val.Size()))
		n81, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.Finish {
		dAtA[i] = 0x10
		i++
		if m.Finish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reward {
		dAtA[i] = 0x18
		i++
		if m.Reward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrderTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTask) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		for k, _ := range m.Task {
			dAtA[i] = 0xa
			i++
			v := m.Task[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n82, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n82
			}
		}
	}
	return i, nil
}

func (m *WarOrderReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Elite {
		dAtA[i] = 0x8
		i++
		if m.Elite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Luxury {
		dAtA[i] = 0x10
		i++
		if m.Luxury {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if m.Season != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Season))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	if m.IsLuxury {
		dAtA[i] = 0x30
		i++
		if m.IsLuxury {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Task != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Task.Size()))
		n83, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if len(m.Exchange) > 0 {
		for k, _ := range m.Exchange {
			dAtA[i] = 0x42
			i++
			v := m.Exchange[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.WeekTask) > 0 {
		for k, _ := range m.WeekTask {
			dAtA[i] = 0x4a
			i++
			v := m.WeekTask[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n84, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n84
			}
		}
	}
	if len(m.Reward) > 0 {
		for k, _ := range m.Reward {
			dAtA[i] = 0x52
			i++
			v := m.Reward[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n85, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n85
			}
		}
	}
	return i, nil
}

func (m *Elf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Elf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, _ := range m.Skills {
			dAtA[i] = 0x1a
			i++
			v := m.Skills[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, _ := range m.SkillBag {
			dAtA[i] = 0x22
			i++
			v := m.SkillBag[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.ReceiveLimit) > 0 {
		for k, _ := range m.ReceiveLimit {
			dAtA[i] = 0x2a
			i++
			v := m.ReceiveLimit[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *FriendUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UserId))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	if len(m.FriendHeroInfo) > 0 {
		for k, _ := range m.FriendHeroInfo {
			dAtA[i] = 0x1a
			i++
			v := m.FriendHeroInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n86, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n86
			}
		}
	}
	return i, nil
}

func (m *FriendHeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendHeroInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Equips) > 0 {
		for k, _ := range m.Equips {
			dAtA[i] = 0xa
			i++
			v := m.Equips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n87, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n87
			}
		}
	}
	if len(m.Props) > 0 {
		for k, _ := range m.Props {
			dAtA[i] = 0x12
			i++
			v := m.Props[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if m.Job != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Sex))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Lv))
	}
	if m.Display != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Display.Size()))
		n88, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Combat != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Combat))
	}
	return i, nil
}

func (m *FitHolyEquipUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FitHolyEquipUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Equip) > 0 {
		for k, _ := range m.Equip {
			dAtA[i] = 0xa
			i++
			v := m.Equip[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *FitHolyEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FitHolyEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SuitId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SuitId))
	}
	if len(m.Equips) > 0 {
		for k, _ := range m.Equips {
			dAtA[i] = 0x12
			i++
			v := m.Equips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + sovCommon(uint64(k)) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n89, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n89
			}
		}
	}
	return i, nil
}

func (m *ContRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cycle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Cycle))
	}
	if len(m.Recharge) > 0 {
		for k, _ := range m.Recharge {
			dAtA[i] = 0x12
			i++
			v := m.Recharge[k]
			mapSize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCommon(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCommon(dAtA, i, uint64(v))
		}
	}
	if len(m.Receive) > 0 {
		dAtA91 := make([]byte, len(m.Receive)*10)
		var j90 int
		for _, num1 := range m.Receive {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA91[j90] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j90++
			}
			dAtA91[j90] = uint8(num)
			j90++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(j90))
		i += copy(dAtA[i:], dAtA91[:j90])
	}
	if m.TodayPay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TodayPay))
	}
	return i, nil
}

func (m *PaoMaDengInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaoMaDengInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if m.CycleTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CycleTimes))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *PaoMaDengNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaoMaDengNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PaoMaDengInfos) > 0 {
		for _, msg := range m.PaoMaDengInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AncientSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientSkill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SkillId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Level))
	}
	if m.Grade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Grade))
	}
	return i, nil
}

func (m *Title) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Title) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TitleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TitleId))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndTime))
	}
	if m.IsLook {
		dAtA[i] = 0x20
		i++
		if m.IsLook {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BriefServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BriefServerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ServerId))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.CrossFsId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CrossFsId))
	}
	return i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LabelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.LabelId))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Job))
	}
	if m.Transfer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Transfer))
	}
	if m.DayReward {
		dAtA[i] = 0x20
		i++
		if m.DayReward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ErrorAck) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCommon(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *UserLoginInfo) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovCommon(uint64(m.Userid))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.VipLevel != 0 {
		n += 1 + sovCommon(uint64(m.VipLevel))
	}
	if m.VipScore != 0 {
		n += 1 + sovCommon(uint64(m.VipScore))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if m.Gold != 0 {
		n += 1 + sovCommon(uint64(m.Gold))
	}
	if m.Ingot != 0 {
		n += 1 + sovCommon(uint64(m.Ingot))
	}
	if m.CreateTime != 0 {
		n += 1 + sovCommon(uint64(m.CreateTime))
	}
	if m.StageId != 0 {
		n += 1 + sovCommon(uint64(m.StageId))
	}
	if m.StageWave != 0 {
		n += 1 + sovCommon(uint64(m.StageWave))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	if len(m.Heros) > 0 {
		for _, e := range m.Heros {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Rein != nil {
		l = m.Rein.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ReinCost) > 0 {
		for _, e := range m.ReinCost {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Fabao) > 0 {
		for _, e := range m.Fabao {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.FieldBossInfo != nil {
		l = m.FieldBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.WorldBossInfo != nil {
		l = m.WorldBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.ArenaFightNum != 0 {
		n += 2 + sovCommon(uint64(m.ArenaFightNum))
	}
	if m.FightModel != 0 {
		n += 2 + sovCommon(uint64(m.FightModel))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ShopInfo) > 0 {
		for k, v := range m.ShopInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.ChuanqiBi != 0 {
		n += 2 + sovCommon(uint64(m.ChuanqiBi))
	}
	if len(m.MaterialStage) > 0 {
		for k, v := range m.MaterialStage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Panaceas) > 0 {
		for k, v := range m.Panaceas {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.SignInfo != nil {
		l = m.SignInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.DayStateInfo != nil {
		l = m.DayStateInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.Official != 0 {
		n += 2 + sovCommon(uint64(m.Official))
	}
	if len(m.Holy) > 0 {
		for _, e := range m.Holy {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Atlases) > 0 {
		for _, e := range m.Atlases {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.AtlasGathers) > 0 {
		for _, e := range m.AtlasGathers {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.MiningWorkTime != 0 {
		n += 2 + sovCommon(uint64(m.MiningWorkTime))
	}
	if m.Miner != 0 {
		n += 2 + sovCommon(uint64(m.Miner))
	}
	if m.ExpStage != nil {
		l = m.ExpStage.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Pets) > 0 {
		for k, v := range m.Pets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Juexues) > 0 {
		for _, e := range m.Juexues {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.UserWear != nil {
		l = m.UserWear.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.IsHaveGetDailyCompetitveReward != 0 {
		n += 2 + sovCommon(uint64(m.IsHaveGetDailyCompetitveReward))
	}
	if m.Honour != 0 {
		n += 2 + sovCommon(uint64(m.Honour))
	}
	if m.DarkPalaceInfo != nil {
		l = m.DarkPalaceInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.PersonBoss) > 0 {
		for k, v := range m.PersonBoss {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.VipBoss) > 0 {
		for k, v := range m.VipBoss {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.VipGift) > 0 {
		l = 0
		for _, e := range m.VipGift {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.RechargeAll != 0 {
		n += 2 + sovCommon(uint64(m.RechargeAll))
	}
	if len(m.AccumulativeAllGetIds) > 0 {
		l = 0
		for _, e := range m.AccumulativeAllGetIds {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if len(m.MonthCard) > 0 {
		for k, v := range m.MonthCard {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.FirstRecharge != nil {
		l = m.FirstRecharge.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.SpendRebates != nil {
		l = m.SpendRebates.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.DailyPack) > 0 {
		for k, v := range m.DailyPack {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.GrowFund != nil {
		l = m.GrowFund.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.WarOrder != nil {
		l = m.WarOrder.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.RedPacketGetNum != 0 {
		n += 2 + sovCommon(uint64(m.RedPacketGetNum))
	}
	if m.Elf != nil {
		l = m.Elf.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.CutTreasureLv != 0 {
		n += 2 + sovCommon(uint64(m.CutTreasureLv))
	}
	if m.FitHolyEquip != nil {
		l = m.FitHolyEquip.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Recharge) > 0 {
		l = 0
		for _, e := range m.Recharge {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if m.ShaBakeIsEnd != 0 {
		n += 2 + sovCommon(uint64(m.ShaBakeIsEnd))
	}
	if m.CrossShabakeIsEnd != 0 {
		n += 2 + sovCommon(uint64(m.CrossShabakeIsEnd))
	}
	if m.IsFriendApply {
		n += 3
	}
	if m.BindingIngot != 0 {
		n += 2 + sovCommon(uint64(m.BindingIngot))
	}
	if m.HookupTime != 0 {
		n += 2 + sovCommon(uint64(m.HookupTime))
	}
	if len(m.HookupBag) > 0 {
		for _, e := range m.HookupBag {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.ContRecharge != nil {
		l = m.ContRecharge.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.OpenGift) > 0 {
		for k, v := range m.OpenGift {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.CrossChallengeIsApply != 0 {
		n += 2 + sovCommon(uint64(m.CrossChallengeIsApply))
	}
	if len(m.AnnouncementInfos) > 0 {
		for _, e := range m.AnnouncementInfos {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if m.VipCustomer {
		n += 3
	}
	if m.ChatBanTime != 0 {
		n += 2 + sovCommon(uint64(m.ChatBanTime))
	}
	if m.HaveUseRecharge != 0 {
		n += 2 + sovCommon(uint64(m.HaveUseRecharge))
	}
	if m.GoldIngot != 0 {
		n += 2 + sovCommon(uint64(m.GoldIngot))
	}
	if m.AncientBossInfo != nil {
		l = m.AncientBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.TitleList) > 0 {
		for _, e := range m.TitleList {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.MiJiInfos) > 0 {
		for _, e := range m.MiJiInfos {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.AncientTreasureInfo) > 0 {
		for k, v := range m.AncientTreasureInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.PetAppendage) > 0 {
		for k, v := range m.PetAppendage {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.HellBossInfo != nil {
		l = m.HellBossInfo.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.RedPacketNum != 0 {
		n += 2 + sovCommon(uint64(m.RedPacketNum))
	}
	if len(m.DaBaoEquip) > 0 {
		for k, v := range m.DaBaoEquip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.DaBaoMysteryEnergy != 0 {
		n += 2 + sovCommon(uint64(m.DaBaoMysteryEnergy))
	}
	if m.AppletsEnergy != 0 {
		n += 2 + sovCommon(uint64(m.AppletsEnergy))
	}
	if m.AppletsResumeTime != 0 {
		n += 2 + sovCommon(uint64(m.AppletsResumeTime))
	}
	if len(m.AppletsInfos) > 0 {
		for k, v := range m.AppletsInfos {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Label != nil {
		l = m.Label.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Subscribe) > 0 {
		l = 0
		for _, e := range m.Subscribe {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if len(m.Privilege) > 0 {
		l = 0
		for _, e := range m.Privilege {
			l += sovCommon(uint64(e))
		}
		n += 2 + sovCommon(uint64(l)) + l
	}
	if m.UseRedPacketNum != 0 {
		n += 2 + sovCommon(uint64(m.UseRedPacketNum))
	}
	if m.DailyRecharge != 0 {
		n += 2 + sovCommon(uint64(m.DailyRecharge))
	}
	return n
}

func (m *AppletsInfo) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovCommon(uint64(m.StageId))
	}
	return n
}

func (m *AncientTreasureInfo) Size() (n int) {
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		n += 1 + sovCommon(uint64(m.ZhuLinLv))
	}
	if m.StarLv != 0 {
		n += 1 + sovCommon(uint64(m.StarLv))
	}
	if m.JueXinLv != 0 {
		n += 1 + sovCommon(uint64(m.JueXinLv))
	}
	if m.Types != 0 {
		n += 1 + sovCommon(uint64(m.Types))
	}
	return n
}

func (m *MiJiInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	return n
}

func (m *AnnouncementInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Announcement)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *HeroInfo) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCommon(uint64(m.Index))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.EquipGrids) > 0 {
		for _, e := range m.EquipGrids {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.HeroProp != nil {
		l = m.HeroProp.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Wing) > 0 {
		for _, e := range m.Wing {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Zodiacs) > 0 {
		for k, v := range m.Zodiacs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Kingarms) > 0 {
		for k, v := range m.Kingarms {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Dictates) > 0 {
		for _, e := range m.Dictates {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.WingSpecial) > 0 {
		for _, e := range m.WingSpecial {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.Jewels) > 0 {
		for k, v := range m.Jewels {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.InsideInfo != nil {
		l = m.InsideInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Fashions) > 0 {
		for k, v := range m.Fashions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Wears != nil {
		l = m.Wears.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.Rings) > 0 {
		for k, v := range m.Rings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Skills) > 0 {
		for _, e := range m.Skills {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, v := range m.SkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.UniqueSkills) > 0 {
		for _, e := range m.UniqueSkills {
			l = e.Size()
			n += 2 + l + sovCommon(uint64(l))
		}
	}
	if len(m.UniqueSkillBag) > 0 {
		for k, v := range m.UniqueSkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.GodEquips) > 0 {
		for k, v := range m.GodEquips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Area) > 0 {
		for k, v := range m.Area {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.EquipClears) > 0 {
		for k, v := range m.EquipClears {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.ExpLvl != 0 {
		n += 2 + sovCommon(uint64(m.ExpLvl))
	}
	if len(m.DragonEquip) > 0 {
		for k, v := range m.DragonEquip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.MagicCircle) > 0 {
		for k, v := range m.MagicCircle {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Talents != nil {
		l = m.Talents.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ChuanShiEquip) > 0 {
		for k, v := range m.ChuanShiEquip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.AncientSkill != nil {
		l = m.AncientSkill.Size()
		n += 2 + l + sovCommon(uint64(l))
	}
	if len(m.ChuanShiStrengthen) > 0 {
		for k, v := range m.ChuanShiStrengthen {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 2 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UserWear) Size() (n int) {
	var l int
	_ = l
	if m.Petid != 0 {
		n += 1 + sovCommon(uint64(m.Petid))
	}
	if m.FitFashionId != 0 {
		n += 1 + sovCommon(uint64(m.FitFashionId))
	}
	return n
}

func (m *Wears) Size() (n int) {
	var l int
	_ = l
	if m.FashionWeaponId != 0 {
		n += 1 + sovCommon(uint64(m.FashionWeaponId))
	}
	if m.FashionClothId != 0 {
		n += 1 + sovCommon(uint64(m.FashionClothId))
	}
	if len(m.AtlasWear) > 0 {
		l = 0
		for _, e := range m.AtlasWear {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.WingId != 0 {
		n += 1 + sovCommon(uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		n += 1 + sovCommon(uint64(m.MagicCircleLvId))
	}
	if m.TitleId != 0 {
		n += 1 + sovCommon(uint64(m.TitleId))
	}
	return n
}

func (m *BriefUserInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if m.Lvl != 0 {
		n += 1 + sovCommon(uint64(m.Lvl))
	}
	if m.Vip != 0 {
		n += 1 + sovCommon(uint64(m.Vip))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.MaxLv != 0 {
		n += 1 + sovCommon(uint64(m.MaxLv))
	}
	if m.ServerId != 0 {
		n += 1 + sovCommon(uint64(m.ServerId))
	}
	if len(m.Display) > 0 {
		for k, v := range m.Display {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BriefUserInfoWithDisplay) Size() (n int) {
	var l int
	_ = l
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *TopDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *TopDataChange) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	return n
}

func (m *BagDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *ItemChange) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *BagEquipDataChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeInfos) > 0 {
		for _, e := range m.ChangeInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	return n
}

func (m *EquipChange) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Change != 0 {
		n += 1 + sovCommon(uint64(m.Change))
	}
	if m.NowNum != 0 {
		n += 1 + sovCommon(uint64(m.NowNum))
	}
	if m.Equip != nil {
		l = m.Equip.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovCommon(uint64(m.Count))
	}
	if m.Position != 0 {
		n += 1 + sovCommon(uint64(m.Position))
	}
	if m.Equip != nil {
		l = m.Equip.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GoodsChangeNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ItemUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.Count != 0 {
		n += 1 + sovCommon(uint64(m.Count))
	}
	return n
}

func (m *EquipUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if len(m.RandProps) > 0 {
		for _, e := range m.RandProps {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Lock {
		n += 2
	}
	if m.EquipIndex != 0 {
		n += 1 + sovCommon(uint64(m.EquipIndex))
	}
	if m.Lucky != 0 {
		n += 1 + sovCommon(uint64(m.Lucky))
	}
	return n
}

func (m *EquipRandProp) Size() (n int) {
	var l int
	_ = l
	if m.PropId != 0 {
		n += 1 + sovCommon(uint64(m.PropId))
	}
	if m.Color != 0 {
		n += 1 + sovCommon(uint64(m.Color))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *EquipClearArr) Size() (n int) {
	var l int
	_ = l
	if len(m.EquipClearInfo) > 0 {
		for _, e := range m.EquipClearInfo {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *EquipClearInfo) Size() (n int) {
	var l int
	_ = l
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Color != 0 {
		n += 1 + sovCommon(uint64(m.Color))
	}
	if m.PropId != 0 {
		n += 1 + sovCommon(uint64(m.PropId))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *HeroProp) Size() (n int) {
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.ModulesCombat) > 0 {
		for k, v := range m.ModulesCombat {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TaskInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovCommon(uint64(m.TaskId))
	}
	if m.Process != 0 {
		n += 1 + sovCommon(uint64(m.Process))
	}
	if m.MarkProcess != 0 {
		n += 1 + sovCommon(uint64(m.MarkProcess))
	}
	return n
}

func (m *DisplayNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Display) > 0 {
		for k, v := range m.Display {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventNtf) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Ts != 0 {
		n += 1 + sovCommon(uint64(m.Ts))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.SourceId != 0 {
		n += 1 + sovCommon(uint64(m.SourceId))
	}
	return n
}

func (m *DailyConditionNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.DailyConditions) > 0 {
		for k, v := range m.DailyConditions {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PropInfo) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovCommon(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovCommon(uint64(m.Value))
	}
	return n
}

func (m *EquipGrid) Size() (n int) {
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovCommon(uint64(m.Pos))
	}
	if m.Strength != 0 {
		n += 1 + sovCommon(uint64(m.Strength))
	}
	return n
}

func (m *Fabao) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		l = 0
		for _, e := range m.Skills {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *GodEquip) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Blood != 0 {
		n += 1 + sovCommon(uint64(m.Blood))
	}
	return n
}

func (m *Juexue) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Fashion) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Wing) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *WingSpecialNtf) Size() (n int) {
	var l int
	_ = l
	if m.SpecialType != 0 {
		n += 1 + sovCommon(uint64(m.SpecialType))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *Rein) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *ReinCost) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovCommon(uint64(m.Num))
	}
	return n
}

func (m *Atlas) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *AtlasGather) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *Preference) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovCommon(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *WorldBossInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.PrepareTime != 0 {
		n += 1 + sovCommon(uint64(m.PrepareTime))
	}
	if m.OpenTime != 0 {
		n += 1 + sovCommon(uint64(m.OpenTime))
	}
	if m.CloseTime != 0 {
		n += 1 + sovCommon(uint64(m.CloseTime))
	}
	return n
}

func (m *VipBoss) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovCommon(uint64(m.StageId))
	}
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	return n
}

func (m *ExpStage) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if len(m.ExpStages) > 0 {
		for k, v := range m.ExpStages {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Appraise) > 0 {
		for k, v := range m.Appraise {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Layer != 0 {
		n += 1 + sovCommon(uint64(m.Layer))
	}
	return n
}

func (m *MaterialStage) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if m.NowLayer != 0 {
		n += 1 + sovCommon(uint64(m.NowLayer))
	}
	if m.LastLayer != 0 {
		n += 1 + sovCommon(uint64(m.LastLayer))
	}
	return n
}

func (m *Display) Size() (n int) {
	var l int
	_ = l
	if m.ClothItemId != 0 {
		n += 1 + sovCommon(uint64(m.ClothItemId))
	}
	if m.ClothType != 0 {
		n += 1 + sovCommon(uint64(m.ClothType))
	}
	if m.WeaponItemId != 0 {
		n += 1 + sovCommon(uint64(m.WeaponItemId))
	}
	if m.WeaponType != 0 {
		n += 1 + sovCommon(uint64(m.WeaponType))
	}
	if m.WingId != 0 {
		n += 1 + sovCommon(uint64(m.WingId))
	}
	if m.MagicCircleLvId != 0 {
		n += 1 + sovCommon(uint64(m.MagicCircleLvId))
	}
	if m.TitleId != 0 {
		n += 1 + sovCommon(uint64(m.TitleId))
	}
	if m.LabelId != 0 {
		n += 1 + sovCommon(uint64(m.LabelId))
	}
	if m.LabelJob != 0 {
		n += 1 + sovCommon(uint64(m.LabelJob))
	}
	return n
}

func (m *SpecialEquipUnit) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCommon(uint64(m.ItemId))
	}
	if m.GetSource != nil {
		l = m.GetSource.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *GetSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Map)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Monster)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SkillUser)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.SkillDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *RankInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovCommon(uint64(m.Rank))
	}
	if m.Score != 0 {
		n += 1 + sovCommon(uint64(m.Score))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SkillUnit) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovCommon(uint64(m.SkillId))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	return n
}

func (m *ShopInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ShopItem) > 0 {
		for k, v := range m.ShopItem {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DictateInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	return n
}

func (m *PanaceaInfo) Size() (n int) {
	var l int
	_ = l
	if m.Numbers != 0 {
		n += 1 + sovCommon(uint64(m.Numbers))
	}
	if m.Number != 0 {
		n += 1 + sovCommon(uint64(m.Number))
	}
	return n
}

func (m *JewelInfo) Size() (n int) {
	var l int
	_ = l
	if m.Left != 0 {
		n += 1 + sovCommon(uint64(m.Left))
	}
	if m.Right != 0 {
		n += 1 + sovCommon(uint64(m.Right))
	}
	if m.Down != 0 {
		n += 1 + sovCommon(uint64(m.Down))
	}
	return n
}

func (m *DayStateInfo) Size() (n int) {
	var l int
	_ = l
	if m.RankWorship != 0 {
		n += 1 + sovCommon(uint64(m.RankWorship))
	}
	if len(m.MonthCardReceive) > 0 {
		l = 0
		for _, e := range m.MonthCardReceive {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *SignInfo) Size() (n int) {
	var l int
	_ = l
	if m.SignCount != 0 {
		n += 1 + sovCommon(uint64(m.SignCount))
	}
	if len(m.SignDay) > 0 {
		for k, v := range m.SignDay {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.CumulativeDay) > 0 {
		for k, v := range m.CumulativeDay {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InsideInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Acupoint) > 0 {
		for k, v := range m.Acupoint {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.InsideSkill) > 0 {
		for k, v := range m.InsideSkill {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InsideSkill) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	return n
}

func (m *Holy) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, v := range m.Skills {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Ring) Size() (n int) {
	var l int
	_ = l
	if m.Rid != 0 {
		n += 1 + sovCommon(uint64(m.Rid))
	}
	if m.Strengthen != 0 {
		n += 1 + sovCommon(uint64(m.Strengthen))
	}
	if m.Pid != 0 {
		n += 1 + sovCommon(uint64(m.Pid))
	}
	if m.Talent != 0 {
		n += 1 + sovCommon(uint64(m.Talent))
	}
	if len(m.Phantom) > 0 {
		for k, v := range m.Phantom {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RingPhantom) Size() (n int) {
	var l int
	_ = l
	if m.Talent != 0 {
		n += 1 + sovCommon(uint64(m.Talent))
	}
	if m.Phantom != 0 {
		n += 1 + sovCommon(uint64(m.Phantom))
	}
	if len(m.Skill) > 0 {
		for k, v := range m.Skill {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PetInfo) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	if m.Break != 0 {
		n += 1 + sovCommon(uint64(m.Break))
	}
	if len(m.Skill) > 0 {
		l = 0
		for _, e := range m.Skill {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *ResetNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Type) > 0 {
		for k, v := range m.Type {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.NewDayTime != 0 {
		n += 1 + sovCommon(uint64(m.NewDayTime))
	}
	return n
}

func (m *FieldFightRivalUserInfo) Size() (n int) {
	var l int
	_ = l
	if m.RivalUserId != 0 {
		n += 1 + sovCommon(uint64(m.RivalUserId))
	}
	if m.RivalDifficult != 0 {
		n += 1 + sovCommon(uint64(m.RivalDifficult))
	}
	return n
}

func (m *DarkPalaceInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		n += 1 + sovCommon(uint64(m.HelpNum))
	}
	return n
}

func (m *HellBossInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if m.HelpNum != 0 {
		n += 1 + sovCommon(uint64(m.HelpNum))
	}
	return n
}

func (m *FieldBossInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	if m.FirstReceive {
		n += 2
	}
	return n
}

func (m *AncientBossInfo) Size() (n int) {
	var l int
	_ = l
	if m.DareNum != 0 {
		n += 1 + sovCommon(uint64(m.DareNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCommon(uint64(m.BuyNum))
	}
	return n
}

func (m *TalentInfo) Size() (n int) {
	var l int
	_ = l
	if m.GetPoints != 0 {
		n += 1 + sovCommon(uint64(m.GetPoints))
	}
	if m.SurplusPoints != 0 {
		n += 1 + sovCommon(uint64(m.SurplusPoints))
	}
	if len(m.Talents) > 0 {
		for k, v := range m.Talents {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TalentUnit) Size() (n int) {
	var l int
	_ = l
	if m.UsePoints != 0 {
		n += 1 + sovCommon(uint64(m.UsePoints))
	}
	if len(m.Talents) > 0 {
		for k, v := range m.Talents {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Fit) Size() (n int) {
	var l int
	_ = l
	if m.CdStart != 0 {
		n += 1 + sovCommon(uint64(m.CdStart))
	}
	if m.CdEnd != 0 {
		n += 1 + sovCommon(uint64(m.CdEnd))
	}
	if len(m.Fashion) > 0 {
		for k, v := range m.Fashion {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, v := range m.SkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Lv) > 0 {
		for k, v := range m.Lv {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Skills) > 0 {
		for k, v := range m.Skills {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FitSkill) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Star != 0 {
		n += 1 + sovCommon(uint64(m.Star))
	}
	return n
}

func (m *MonthCardUnit) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	if m.IsExpire {
		n += 2
	}
	return n
}

func (m *FirstRecharge) Size() (n int) {
	var l int
	_ = l
	if m.IsRecharge {
		n += 2
	}
	if len(m.Days) > 0 {
		l = 0
		for _, e := range m.Days {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.OpenDay != 0 {
		n += 1 + sovCommon(uint64(m.OpenDay))
	}
	return n
}

func (m *SpendRebates) Size() (n int) {
	var l int
	_ = l
	if m.CountIngot != 0 {
		n += 1 + sovCommon(uint64(m.CountIngot))
	}
	if m.Ingot != 0 {
		n += 1 + sovCommon(uint64(m.Ingot))
	}
	if len(m.Reward) > 0 {
		l = 0
		for _, e := range m.Reward {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.Cycle != 0 {
		n += 1 + sovCommon(uint64(m.Cycle))
	}
	return n
}

func (m *GrowFund) Size() (n int) {
	var l int
	_ = l
	if m.IsBuy {
		n += 2
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	return n
}

func (m *WarOrderTaskUnit) Size() (n int) {
	var l int
	_ = l
	if m.One != 0 {
		n += 1 + sovCommon(uint64(m.One))
	}
	if len(m.Two) > 0 {
		for k, v := range m.Two {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Three) > 0 {
		for k, v := range m.Three {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *WarOrderTaskInfo) Size() (n int) {
	var l int
	_ = l
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Finish {
		n += 2
	}
	if m.Reward {
		n += 2
	}
	return n
}

func (m *WarOrderTask) Size() (n int) {
	var l int
	_ = l
	if len(m.Task) > 0 {
		for k, v := range m.Task {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *WarOrderReward) Size() (n int) {
	var l int
	_ = l
	if m.Elite {
		n += 2
	}
	if m.Luxury {
		n += 2
	}
	return n
}

func (m *WarOrder) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if m.Season != 0 {
		n += 1 + sovCommon(uint64(m.Season))
	}
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	if m.IsLuxury {
		n += 2
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Exchange) > 0 {
		for k, v := range m.Exchange {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.WeekTask) > 0 {
		for k, v := range m.WeekTask {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Reward) > 0 {
		for k, v := range m.Reward {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Elf) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovCommon(uint64(m.Exp))
	}
	if len(m.Skills) > 0 {
		for k, v := range m.Skills {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.SkillBag) > 0 {
		for k, v := range m.SkillBag {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.ReceiveLimit) > 0 {
		for k, v := range m.ReceiveLimit {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FriendUserInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCommon(uint64(m.UserId))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	if len(m.FriendHeroInfo) > 0 {
		for k, v := range m.FriendHeroInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FriendHeroInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.Sex != 0 {
		n += 1 + sovCommon(uint64(m.Sex))
	}
	if m.Lv != 0 {
		n += 1 + sovCommon(uint64(m.Lv))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Combat != 0 {
		n += 1 + sovCommon(uint64(m.Combat))
	}
	return n
}

func (m *FitHolyEquipUnit) Size() (n int) {
	var l int
	_ = l
	if len(m.Equip) > 0 {
		for k, v := range m.Equip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FitHolyEquip) Size() (n int) {
	var l int
	_ = l
	if m.SuitId != 0 {
		n += 1 + sovCommon(uint64(m.SuitId))
	}
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + sovCommon(uint64(k)) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContRecharge) Size() (n int) {
	var l int
	_ = l
	if m.Cycle != 0 {
		n += 1 + sovCommon(uint64(m.Cycle))
	}
	if len(m.Recharge) > 0 {
		for k, v := range m.Recharge {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCommon(uint64(k)) + 1 + sovCommon(uint64(v))
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if len(m.Receive) > 0 {
		l = 0
		for _, e := range m.Receive {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if m.TodayPay != 0 {
		n += 1 + sovCommon(uint64(m.TodayPay))
	}
	return n
}

func (m *PaoMaDengInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if m.CycleTimes != 0 {
		n += 1 + sovCommon(uint64(m.CycleTimes))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *PaoMaDengNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.PaoMaDengInfos) > 0 {
		for _, e := range m.PaoMaDengInfos {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *AncientSkill) Size() (n int) {
	var l int
	_ = l
	if m.SkillId != 0 {
		n += 1 + sovCommon(uint64(m.SkillId))
	}
	if m.Level != 0 {
		n += 1 + sovCommon(uint64(m.Level))
	}
	if m.Grade != 0 {
		n += 1 + sovCommon(uint64(m.Grade))
	}
	return n
}

func (m *Title) Size() (n int) {
	var l int
	_ = l
	if m.TitleId != 0 {
		n += 1 + sovCommon(uint64(m.TitleId))
	}
	if m.StartTime != 0 {
		n += 1 + sovCommon(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCommon(uint64(m.EndTime))
	}
	if m.IsLook {
		n += 2
	}
	return n
}

func (m *BriefServerInfo) Size() (n int) {
	var l int
	_ = l
	if m.ServerId != 0 {
		n += 1 + sovCommon(uint64(m.ServerId))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.CrossFsId != 0 {
		n += 1 + sovCommon(uint64(m.CrossFsId))
	}
	return n
}

func (m *Label) Size() (n int) {
	var l int
	_ = l
	if m.LabelId != 0 {
		n += 1 + sovCommon(uint64(m.LabelId))
	}
	if m.Job != 0 {
		n += 1 + sovCommon(uint64(m.Job))
	}
	if m.Transfer != 0 {
		n += 1 + sovCommon(uint64(m.Transfer))
	}
	if m.DayReward {
		n += 2
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ErrorAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLoginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLoginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLoginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			m.VipLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipScore", wireType)
			}
			m.VipScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageWave", wireType)
			}
			m.StageWave = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageWave |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heros = append(m.Heros, &HeroInfo{})
			if err := m.Heros[len(m.Heros)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rein", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rein == nil {
				m.Rein = &Rein{}
			}
			if err := m.Rein.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReinCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReinCost = append(m.ReinCost, &ReinCost{})
			if err := m.ReinCost[len(m.ReinCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fabao", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fabao = append(m.Fabao, &Fabao{})
			if err := m.Fabao[len(m.Fabao)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldBossInfo == nil {
				m.FieldBossInfo = &FieldBossInfo{}
			}
			if err := m.FieldBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorldBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorldBossInfo == nil {
				m.WorldBossInfo = &WorldBossInfoNtf{}
			}
			if err := m.WorldBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaFightNum", wireType)
			}
			m.ArenaFightNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArenaFightNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightModel", wireType)
			}
			m.FightModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &TaskInfoNtf{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShopInfo == nil {
				m.ShopInfo = make(map[int32]*ShopInfo)
			}
			var mapkey int32
			var mapvalue *ShopInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ShopInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ShopInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChuanqiBi", wireType)
			}
			m.ChuanqiBi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChuanqiBi |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaterialStage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaterialStage == nil {
				m.MaterialStage = make(map[int32]*MaterialStage)
			}
			var mapkey int32
			var mapvalue *MaterialStage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MaterialStage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaterialStage[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Panaceas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Panaceas == nil {
				m.Panaceas = make(map[int32]*PanaceaInfo)
			}
			var mapkey int32
			var mapvalue *PanaceaInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PanaceaInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Panaceas[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignInfo == nil {
				m.SignInfo = &SignInfo{}
			}
			if err := m.SignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayStateInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DayStateInfo == nil {
				m.DayStateInfo = &DayStateInfo{}
			}
			if err := m.DayStateInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holy = append(m.Holy, &Holy{})
			if err := m.Holy[len(m.Holy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atlases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Atlases = append(m.Atlases, &Atlas{})
			if err := m.Atlases[len(m.Atlases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtlasGathers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtlasGathers = append(m.AtlasGathers, &AtlasGather{})
			if err := m.AtlasGathers[len(m.AtlasGathers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningWorkTime", wireType)
			}
			m.MiningWorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningWorkTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpStage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpStage == nil {
				m.ExpStage = &ExpStage{}
			}
			if err := m.ExpStage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pets == nil {
				m.Pets = make(map[int32]*PetInfo)
			}
			var mapkey int32
			var mapvalue *PetInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PetInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Pets[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Juexues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Juexues = append(m.Juexues, &Juexue{})
			if err := m.Juexues[len(m.Juexues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserWear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserWear == nil {
				m.UserWear = &UserWear{}
			}
			if err := m.UserWear.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHaveGetDailyCompetitveReward", wireType)
			}
			m.IsHaveGetDailyCompetitveReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsHaveGetDailyCompetitveReward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Honour", wireType)
			}
			m.Honour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Honour |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DarkPalaceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DarkPalaceInfo == nil {
				m.DarkPalaceInfo = &DarkPalaceInfo{}
			}
			if err := m.DarkPalaceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonBoss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PersonBoss == nil {
				m.PersonBoss = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PersonBoss[mapkey] = mapvalue
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipBoss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipBoss == nil {
				m.VipBoss = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VipBoss[mapkey] = mapvalue
			iNdEx = postIndex
		case 45:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VipGift = append(m.VipGift, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VipGift = append(m.VipGift, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipGift", wireType)
			}
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &Fit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeAll", wireType)
			}
			m.RechargeAll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeAll |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AccumulativeAllGetIds = append(m.AccumulativeAllGetIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AccumulativeAllGetIds = append(m.AccumulativeAllGetIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulativeAllGetIds", wireType)
			}
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonthCard == nil {
				m.MonthCard = make(map[int32]*MonthCardUnit)
			}
			var mapkey int32
			var mapvalue *MonthCardUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MonthCardUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonthCard[mapkey] = mapvalue
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstRecharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstRecharge == nil {
				m.FirstRecharge = &FirstRecharge{}
			}
			if err := m.FirstRecharge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendRebates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpendRebates == nil {
				m.SpendRebates = &SpendRebates{}
			}
			if err := m.SpendRebates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyPack == nil {
				m.DailyPack = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DailyPack[mapkey] = mapvalue
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowFund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrowFund == nil {
				m.GrowFund = &GrowFund{}
			}
			if err := m.GrowFund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WarOrder == nil {
				m.WarOrder = &WarOrder{}
			}
			if err := m.WarOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacketGetNum", wireType)
			}
			m.RedPacketGetNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedPacketGetNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Elf == nil {
				m.Elf = &Elf{}
			}
			if err := m.Elf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutTreasureLv", wireType)
			}
			m.CutTreasureLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutTreasureLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitHolyEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FitHolyEquip == nil {
				m.FitHolyEquip = &FitHolyEquip{}
			}
			if err := m.FitHolyEquip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Recharge = append(m.Recharge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Recharge = append(m.Recharge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Recharge", wireType)
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShaBakeIsEnd", wireType)
			}
			m.ShaBakeIsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShaBakeIsEnd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossShabakeIsEnd", wireType)
			}
			m.CrossShabakeIsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossShabakeIsEnd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriendApply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFriendApply = bool(v != 0)
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingIngot", wireType)
			}
			m.BindingIngot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindingIngot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookupTime", wireType)
			}
			m.HookupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HookupTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookupBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HookupBag = append(m.HookupBag, &ItemUnit{})
			if err := m.HookupBag[len(m.HookupBag)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContRecharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContRecharge == nil {
				m.ContRecharge = &ContRecharge{}
			}
			if err := m.ContRecharge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenGift == nil {
				m.OpenGift = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OpenGift[mapkey] = mapvalue
			iNdEx = postIndex
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossChallengeIsApply", wireType)
			}
			m.CrossChallengeIsApply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossChallengeIsApply |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnouncementInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnouncementInfos = append(m.AnnouncementInfos, &AnnouncementInfo{})
			if err := m.AnnouncementInfos[len(m.AnnouncementInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipCustomer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VipCustomer = bool(v != 0)
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatBanTime", wireType)
			}
			m.ChatBanTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatBanTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveUseRecharge", wireType)
			}
			m.HaveUseRecharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HaveUseRecharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldIngot", wireType)
			}
			m.GoldIngot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldIngot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncientBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AncientBossInfo == nil {
				m.AncientBossInfo = &AncientBossInfo{}
			}
			if err := m.AncientBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 75:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TitleList = append(m.TitleList, &Title{})
			if err := m.TitleList[len(m.TitleList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 76:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiJiInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiJiInfos = append(m.MiJiInfos, &MiJiInfo{})
			if err := m.MiJiInfos[len(m.MiJiInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 77:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncientTreasureInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AncientTreasureInfo == nil {
				m.AncientTreasureInfo = make(map[int32]*AncientTreasureInfo)
			}
			var mapkey int32
			var mapvalue *AncientTreasureInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AncientTreasureInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AncientTreasureInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetAppendage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PetAppendage == nil {
				m.PetAppendage = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PetAppendage[mapkey] = mapvalue
			iNdEx = postIndex
		case 79:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HellBossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HellBossInfo == nil {
				m.HellBossInfo = &HellBossInfo{}
			}
			if err := m.HellBossInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacketNum", wireType)
			}
			m.RedPacketNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedPacketNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaBaoEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DaBaoEquip == nil {
				m.DaBaoEquip = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DaBaoEquip[mapkey] = mapvalue
			iNdEx = postIndex
		case 82:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaBaoMysteryEnergy", wireType)
			}
			m.DaBaoMysteryEnergy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DaBaoMysteryEnergy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppletsEnergy", wireType)
			}
			m.AppletsEnergy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppletsEnergy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppletsResumeTime", wireType)
			}
			m.AppletsResumeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppletsResumeTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 85:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppletsInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppletsInfos == nil {
				m.AppletsInfos = make(map[int32]*AppletsInfo)
			}
			var mapkey int32
			var mapvalue *AppletsInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AppletsInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AppletsInfos[mapkey] = mapvalue
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Label == nil {
				m.Label = &Label{}
			}
			if err := m.Label.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Subscribe = append(m.Subscribe, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Subscribe = append(m.Subscribe, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
		case 88:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Privilege = append(m.Privilege, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Privilege = append(m.Privilege, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Privilege", wireType)
			}
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRedPacketNum", wireType)
			}
			m.UseRedPacketNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseRedPacketNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyRecharge", wireType)
			}
			m.DailyRecharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyRecharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppletsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: appletsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: appletsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhuLinLv", wireType)
			}
			m.ZhuLinLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZhuLinLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarLv", wireType)
			}
			m.StarLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JueXinLv", wireType)
			}
			m.JueXinLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JueXinLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			m.Types = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Types |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiJiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiJiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiJiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnouncementInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnouncementInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnouncementInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Announcement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Announcement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[int32]*EquipUnit)
			}
			var mapkey int32
			var mapvalue *EquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipGrids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipGrids = append(m.EquipGrids, &EquipGrid{})
			if err := m.EquipGrids[len(m.EquipGrids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroProp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroProp == nil {
				m.HeroProp = &HeroProp{}
			}
			if err := m.HeroProp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wing = append(m.Wing, &Wing{})
			if err := m.Wing[len(m.Wing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zodiacs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zodiacs == nil {
				m.Zodiacs = make(map[int32]*SpecialEquipUnit)
			}
			var mapkey int32
			var mapvalue *SpecialEquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpecialEquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Zodiacs[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kingarms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kingarms == nil {
				m.Kingarms = make(map[int32]*SpecialEquipUnit)
			}
			var mapkey int32
			var mapvalue *SpecialEquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpecialEquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kingarms[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dictates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dictates = append(m.Dictates, &DictateInfo{})
			if err := m.Dictates[len(m.Dictates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingSpecial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WingSpecial = append(m.WingSpecial, &WingSpecialNtf{})
			if err := m.WingSpecial[len(m.WingSpecial)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jewels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jewels == nil {
				m.Jewels = make(map[int32]*JewelInfo)
			}
			var mapkey int32
			var mapvalue *JewelInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &JewelInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Jewels[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideInfo == nil {
				m.InsideInfo = &InsideInfo{}
			}
			if err := m.InsideInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fashions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fashions == nil {
				m.Fashions = make(map[int32]*Fashion)
			}
			var mapkey int32
			var mapvalue *Fashion
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Fashion{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fashions[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wears", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wears == nil {
				m.Wears = &Wears{}
			}
			if err := m.Wears.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rings == nil {
				m.Rings = make(map[int32]*Ring)
			}
			var mapkey int32
			var mapvalue *Ring
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ring{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Rings[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skills = append(m.Skills, &SkillUnit{})
			if err := m.Skills[len(m.Skills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBag == nil {
				m.SkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueSkills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueSkills = append(m.UniqueSkills, &SkillUnit{})
			if err := m.UniqueSkills[len(m.UniqueSkills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueSkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniqueSkillBag == nil {
				m.UniqueSkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UniqueSkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GodEquips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GodEquips == nil {
				m.GodEquips = make(map[int32]*GodEquip)
			}
			var mapkey int32
			var mapvalue *GodEquip
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GodEquip{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GodEquips[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Area == nil {
				m.Area = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Area[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipClears", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquipClears == nil {
				m.EquipClears = make(map[int32]*EquipClearArr)
			}
			var mapkey int32
			var mapvalue *EquipClearArr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EquipClearArr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EquipClears[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpLvl", wireType)
			}
			m.ExpLvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpLvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DragonEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DragonEquip == nil {
				m.DragonEquip = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DragonEquip[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MagicCircle == nil {
				m.MagicCircle = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MagicCircle[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = &TalentInfo{}
			}
			if err := m.Talents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChuanShiEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChuanShiEquip == nil {
				m.ChuanShiEquip = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChuanShiEquip[mapkey] = mapvalue
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncientSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AncientSkill == nil {
				m.AncientSkill = &AncientSkill{}
			}
			if err := m.AncientSkill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChuanShiStrengthen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChuanShiStrengthen == nil {
				m.ChuanShiStrengthen = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChuanShiStrengthen[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserWear) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserWear: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserWear: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Petid", wireType)
			}
			m.Petid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Petid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FitFashionId", wireType)
			}
			m.FitFashionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FitFashionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Wears) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wears: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wears: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionWeaponId", wireType)
			}
			m.FashionWeaponId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionWeaponId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FashionClothId", wireType)
			}
			m.FashionClothId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FashionClothId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtlasWear = append(m.AtlasWear, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtlasWear = append(m.AtlasWear, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtlasWear", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			m.WingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircleLvId", wireType)
			}
			m.MagicCircleLvId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCircleLvId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleId", wireType)
			}
			m.TitleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BriefUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BriefUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BriefUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			m.Lvl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lvl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLv", wireType)
			}
			m.MaxLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = make(map[int32]*Display)
			}
			var mapkey int32
			var mapvalue *Display
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Display{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Display[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BriefUserInfoWithDisplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BriefUserInfoWithDisplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BriefUserInfoWithDisplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &BriefUserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &DisplayNtf{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &TopDataChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopDataChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopDataChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopDataChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &ItemChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagEquipDataChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagEquipDataChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagEquipDataChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeInfos = append(m.ChangeInfos, &EquipChange{})
			if err := m.ChangeInfos[len(m.ChangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowNum", wireType)
			}
			m.NowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = &EquipUnit{}
			}
			if err := m.Equip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = &EquipUnit{}
			}
			if err := m.Equip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: itemUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: itemUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandProps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandProps = append(m.RandProps, &EquipRandProp{})
			if err := m.RandProps[len(m.RandProps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lock = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIndex", wireType)
			}
			m.EquipIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquipIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipRandProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipRandProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipRandProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipClearArr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipClearArr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipClearArr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipClearInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipClearInfo = append(m.EquipClearInfo, &EquipClearInfo{})
			if err := m.EquipClearInfo[len(m.EquipClearInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipClearInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipClearInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipClearInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropId", wireType)
			}
			m.PropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroProp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroProp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroProp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModulesCombat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModulesCombat == nil {
				m.ModulesCombat = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModulesCombat[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			m.Process = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Process |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkProcess", wireType)
			}
			m.MarkProcess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkProcess |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisplayNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisplayNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisplayNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = make(map[int32]*Display)
			}
			var mapkey int32
			var mapvalue *Display
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Display{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Display[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			m.SourceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyConditionNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyConditionNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyConditionNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyConditions == nil {
				m.DailyConditions = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DailyConditions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipGrid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipGrid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipGrid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fabao) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fabao: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fabao: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skills = append(m.Skills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skills = append(m.Skills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GodEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GodEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GodEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blood", wireType)
			}
			m.Blood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Blood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Juexue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Juexue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Juexue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fashion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fashion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fashion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Wing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WingSpecialNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WingSpecialNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WingSpecialNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialType", wireType)
			}
			m.SpecialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rein) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rein: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rein: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReinCost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReinCost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReinCost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Atlas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Atlas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Atlas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtlasGather) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtlasGather: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtlasGather: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Preference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldBossInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldBossInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldBossInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			m.PrepareTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			m.OpenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			m.CloseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipBoss) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipBoss: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipBoss: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpStages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpStages == nil {
				m.ExpStages = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExpStages[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appraise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Appraise == nil {
				m.Appraise = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Appraise[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterialStage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterialStage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterialStage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowLayer", wireType)
			}
			m.NowLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowLayer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLayer", wireType)
			}
			m.LastLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLayer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Display) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Display: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Display: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothItemId", wireType)
			}
			m.ClothItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothType", wireType)
			}
			m.ClothType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClothType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponItemId", wireType)
			}
			m.WeaponItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponType", wireType)
			}
			m.WeaponType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeaponType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			m.WingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicCircleLvId", wireType)
			}
			m.MagicCircleLvId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicCircleLvId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleId", wireType)
			}
			m.TitleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelId", wireType)
			}
			m.LabelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LabelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelJob", wireType)
			}
			m.LabelJob = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LabelJob |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialEquipUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialEquipUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialEquipUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSource == nil {
				m.GetSource = &GetSource{}
			}
			if err := m.GetSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Map = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &BriefUserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShopItem == nil {
				m.ShopItem = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ShopItem[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DictateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DictateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DictateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PanaceaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PanaceaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PanaceaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numbers", wireType)
			}
			m.Numbers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numbers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JewelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JewelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JewelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			m.Down = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Down |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DayStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DayStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DayStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankWorship", wireType)
			}
			m.RankWorship = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankWorship |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MonthCardReceive = append(m.MonthCardReceive, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MonthCardReceive = append(m.MonthCardReceive, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthCardReceive", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCount", wireType)
			}
			m.SignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignDay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignDay == nil {
				m.SignDay = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SignDay[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeDay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CumulativeDay == nil {
				m.CumulativeDay = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CumulativeDay[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsideInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsideInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsideInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acupoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acupoint == nil {
				m.Acupoint = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Acupoint[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSkill == nil {
				m.InsideSkill = make(map[int32]*InsideSkill)
			}
			var mapkey int32
			var mapvalue *InsideSkill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InsideSkill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InsideSkill[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsideSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsideSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsideSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Holy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Holy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Holy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skills == nil {
				m.Skills = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skills[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strengthen", wireType)
			}
			m.Strengthen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strengthen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talent", wireType)
			}
			m.Talent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Talent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phantom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phantom == nil {
				m.Phantom = make(map[int32]*RingPhantom)
			}
			var mapkey int32
			var mapvalue *RingPhantom
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RingPhantom{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Phantom[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RingPhantom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingPhantom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingPhantom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talent", wireType)
			}
			m.Talent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Talent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phantom", wireType)
			}
			m.Phantom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phantom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skill == nil {
				m.Skill = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skill[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Break", wireType)
			}
			m.Break = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Break |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skill = append(m.Skill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skill = append(m.Skill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Type[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDayTime", wireType)
			}
			m.NewDayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewDayTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldFightRivalUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldFightRivalUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldFightRivalUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RivalUserId", wireType)
			}
			m.RivalUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RivalUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RivalDifficult", wireType)
			}
			m.RivalDifficult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RivalDifficult |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DarkPalaceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DarkPalaceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DarkPalaceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpNum", wireType)
			}
			m.HelpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HellBossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HellBossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HellBossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpNum", wireType)
			}
			m.HelpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldBossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldBossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldBossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstReceive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FirstReceive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientBossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientBossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientBossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DareNum", wireType)
			}
			m.DareNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DareNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetPoints", wireType)
			}
			m.GetPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetPoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SurplusPoints", wireType)
			}
			m.SurplusPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SurplusPoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = make(map[int32]*TalentUnit)
			}
			var mapkey int32
			var mapvalue *TalentUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TalentUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Talents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalentUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalentUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalentUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePoints", wireType)
			}
			m.UsePoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsePoints |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talents == nil {
				m.Talents = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Talents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStart", wireType)
			}
			m.CdStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdEnd", wireType)
			}
			m.CdEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fashion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fashion == nil {
				m.Fashion = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fashion[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBag == nil {
				m.SkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lv == nil {
				m.Lv = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Lv[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skills == nil {
				m.Skills = make(map[int32]*FitSkill)
			}
			var mapkey int32
			var mapvalue *FitSkill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FitSkill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skills[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FitSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FitSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FitSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonthCardUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonthCardUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonthCardUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExpire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExpire = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstRecharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstRecharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecharge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecharge = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Days = append(m.Days, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Days = append(m.Days, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDay", wireType)
			}
			m.OpenDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendRebates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendRebates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendRebates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIngot", wireType)
			}
			m.CountIngot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountIngot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Reward = append(m.Reward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Reward = append(m.Reward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycle", wireType)
			}
			m.Cycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cycle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GrowFund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrowFund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrowFund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field One", wireType)
			}
			m.One = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.One |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Two", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Two == nil {
				m.Two = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Two[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Three", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Three == nil {
				m.Three = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Three[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &WarOrderTaskUnit{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finish = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reward = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = make(map[int32]*WarOrderTaskInfo)
			}
			var mapkey int32
			var mapvalue *WarOrderTaskInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WarOrderTaskInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Task[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Elite = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Luxury", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Luxury = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			m.Season = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Season |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLuxury", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLuxury = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &WarOrderTask{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exchange == nil {
				m.Exchange = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Exchange[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekTask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeekTask == nil {
				m.WeekTask = make(map[int32]*WarOrderTask)
			}
			var mapkey int32
			var mapvalue *WarOrderTask
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WarOrderTask{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WeekTask[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = make(map[int32]*WarOrderReward)
			}
			var mapkey int32
			var mapvalue *WarOrderReward
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WarOrderReward{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Reward[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Elf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Elf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Elf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skills == nil {
				m.Skills = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skills[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBag == nil {
				m.SkillBag = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBag[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReceiveLimit == nil {
				m.ReceiveLimit = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReceiveLimit[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendHeroInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FriendHeroInfo == nil {
				m.FriendHeroInfo = make(map[int32]*FriendHeroInfo)
			}
			var mapkey int32
			var mapvalue *FriendHeroInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FriendHeroInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FriendHeroInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendHeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendHeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendHeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[int32]*EquipUnit)
			}
			var mapkey int32
			var mapvalue *EquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FitHolyEquipUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FitHolyEquipUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FitHolyEquipUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equip[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FitHolyEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FitHolyEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FitHolyEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitId", wireType)
			}
			m.SuitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuitId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[int32]*FitHolyEquipUnit)
			}
			var mapkey int32
			var mapvalue *FitHolyEquipUnit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FitHolyEquipUnit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContRecharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContRecharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycle", wireType)
			}
			m.Cycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cycle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recharge == nil {
				m.Recharge = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Recharge[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Receive = append(m.Receive, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Receive = append(m.Receive, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayPay", wireType)
			}
			m.TodayPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayPay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaoMaDengInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaoMaDengInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaoMaDengInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CycleTimes", wireType)
			}
			m.CycleTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CycleTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaoMaDengNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaoMaDengNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaoMaDengNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaoMaDengInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaoMaDengInfos = append(m.PaoMaDengInfos, &PaoMaDengInfo{})
			if err := m.PaoMaDengInfos[len(m.PaoMaDengInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grade", wireType)
			}
			m.Grade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Grade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Title) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Title: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Title: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleId", wireType)
			}
			m.TitleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLook", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLook = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BriefServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BriefServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BriefServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossFsId", wireType)
			}
			m.CrossFsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossFsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelId", wireType)
			}
			m.LabelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LabelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			m.Transfer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transfer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayReward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DayReward = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 5955 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x7c, 0xcd, 0x73, 0x1b, 0x47,
	0x76, 0xf8, 0x0f, 0x00, 0x41, 0x82, 0x8f, 0x20, 0x45, 0xb5, 0x64, 0x79, 0xcc, 0xb5, 0x65, 0xed,
	0x58, 0x96, 0xf5, 0x93, 0x6d, 0xfa, 0x43, 0x92, 0x2d, 0xcb, 0x6b, 0x7b, 0xf9, 0x25, 0x8a, 0x32,
	0x25, 0x6b, 0x87, 0xd4, 0x72, 0xe3, 0x78, 0x93, 0x6a, 0x02, 0x0d, 0x60, 0xcc, 0xc1, 0xcc, 0x78,
	0x66, 0x00, 0x8a, 0xbb, 0x55, 0xc9, 0x21, 0x97, 0xd4, 0x56, 0x52, 0x39, 0x26, 0x97, 0x24, 0x55,
	0x7b, 0xc9, 0x21, 0xb5, 0x7f, 0x41, 0x2e, 0xa9, 0xca, 0x25, 0xc7, 0x54, 0xed, 0x1f, 0x90, 0xad,
	0xcd, 0x21, 0xff, 0x44, 0x6a, 0x93, 0x7a, 0xaf, 0x3f, 0xa6, 0x1b, 0x00, 0x2d, 0x42, 0xeb, 0xe4,
	0x84, 0x79, 0x9f, 0xfd, 0xfd, 0xfa, 0xf5, 0xeb, 0xd7, 0x80, 0x66, 0x2b, 0xe9, 0xf7, 0x93, 0x78,
	0x35, 0xcd, 0x92, 0x22, 0x61, 0xd5, 0xf4, 0xd0, 0xbf, 0x03, 0x8d, 0xad, 0x2c, 0x4b, 0xb2, 0xb5,
	0xd6, 0x11, 0x63, 0x30, 0xd3, 0x4a, 0xda, 0xc2, 0xab, 0x5c, 0xa9, 0x5c, 0xaf, 0x07, 0xf4, 0xcd,
	0x3c, 0x98, 0xeb, 0x8b, 0x3c, 0xe7, 0x5d, 0xe1, 0x55, 0xaf, 0x54, 0xae, 0xcf, 0x07, 0x1a, 0xf4,
	0x7f, 0xf1, 0x3a, 0x2c, 0x3e, 0xc9, 0x45, 0xb6, 0x9b, 0x74, 0xc3, 0x78, 0x27, 0xee, 0x24, 0xec,
	0x12, 0xcc, 0x0e, 0x72, 0x91, 0x85, 0x6d, 0xa5, 0x41, 0x41, 0x6c, 0x05, 0x1a, 0x71, 0xd8, 0x3a,
	0x7a, 0xc4, 0xfb, 0x5a, 0x89, 0x81, 0x51, 0x86, 0x0f, 0x79, 0xc1, 0x33, 0xaf, 0x46, 0x14, 0x05,
	0xa1, 0xcc, 0x30, 0x4c, 0x77, 0xc5, 0x50, 0x44, 0xde, 0x0c, 0x69, 0x33, 0xb0, 0xa2, 0xed, 0xb5,
	0x92, 0x4c, 0x78, 0x75, 0x43, 0x23, 0x98, 0x5d, 0x84, 0x7a, 0x44, 0x42, 0xb3, 0x44, 0x90, 0x00,
	0x5b, 0x86, 0x9a, 0x78, 0x9a, 0x7a, 0x73, 0x84, 0xc3, 0x4f, 0x6c, 0x6b, 0x37, 0x89, 0xda, 0x5e,
	0xe3, 0x4a, 0xe5, 0x7a, 0x2d, 0xa0, 0x6f, 0x94, 0x0d, 0xe3, 0x6e, 0x52, 0x78, 0xf3, 0x52, 0x96,
	0x00, 0x76, 0x19, 0xa0, 0x95, 0x09, 0x5e, 0x88, 0xfd, 0xb0, 0x2f, 0x3c, 0x20, 0x92, 0x85, 0xc1,
	0x1e, 0xca, 0x0b, 0xde, 0x15, 0x3b, 0x6d, 0x6f, 0x81, 0x88, 0x1a, 0x64, 0x2f, 0xc3, 0x3c, 0x7d,
	0x1e, 0xf0, 0xa1, 0xf0, 0x9a, 0x44, 0x2b, 0x11, 0xd8, 0xf2, 0x56, 0xd2, 0x3f, 0xe4, 0x85, 0xb7,
	0x44, 0x75, 0x50, 0x10, 0xf3, 0xa1, 0xde, 0x13, 0x59, 0x92, 0x7b, 0xe7, 0xae, 0xd4, 0xae, 0x2f,
	0xbc, 0xdf, 0x5c, 0x4d, 0x0f, 0x57, 0xef, 0x8b, 0x2c, 0xc1, 0x2e, 0x0e, 0x24, 0x89, 0xbd, 0x0c,
	0x33, 0x99, 0x08, 0x63, 0x6f, 0xf9, 0x4a, 0xe5, 0xfa, 0xc2, 0xfb, 0x0d, 0x64, 0x09, 0x44, 0x18,
	0x07, 0x84, 0x65, 0xd7, 0xa1, 0x81, 0xbf, 0x1b, 0x49, 0x5e, 0x78, 0xe7, 0x4b, 0x25, 0x81, 0xc2,
	0x05, 0x86, 0xca, 0x5e, 0x85, 0x7a, 0x87, 0x1f, 0xf2, 0xc4, 0x63, 0xc4, 0x36, 0x8f, 0x6c, 0xf7,
	0x10, 0x11, 0x48, 0x3c, 0xfb, 0x10, 0x16, 0x3b, 0xa1, 0x88, 0xda, 0xeb, 0x49, 0x9e, 0x63, 0x05,
	0xbc, 0x0b, 0x54, 0xe2, 0x79, 0x62, 0xb4, 0x09, 0x81, 0xcb, 0xc7, 0xee, 0xc2, 0xe2, 0x71, 0x92,
	0x59, 0x82, 0x17, 0x49, 0xf0, 0x22, 0x0a, 0x1e, 0xd8, 0x84, 0x47, 0x45, 0x27, 0x70, 0x59, 0xd9,
	0x55, 0x58, 0x5c, 0xcb, 0x44, 0xcc, 0xef, 0x85, 0xdd, 0x5e, 0xf1, 0x68, 0xd0, 0xf7, 0x5e, 0xa0,
	0xbe, 0x73, 0x91, 0x38, 0x2e, 0x1d, 0xfc, 0x7e, 0x98, 0xb4, 0x45, 0xe4, 0x5d, 0x92, 0xe3, 0x52,
	0x62, 0xd8, 0x6b, 0x30, 0x53, 0xf0, 0xfc, 0xc8, 0x7b, 0x91, 0x0a, 0x3e, 0x87, 0x05, 0xef, 0xf3,
	0xfc, 0x48, 0x97, 0x49, 0x44, 0xf6, 0x31, 0x34, 0xf2, 0x5e, 0x92, 0x52, 0x0d, 0x3d, 0xea, 0x83,
	0x57, 0x91, 0xd1, 0x99, 0xd7, 0xab, 0x7b, 0x8a, 0x63, 0x2b, 0x2e, 0xb2, 0x93, 0xc0, 0x08, 0xe0,
	0xf8, 0xb6, 0x7a, 0x03, 0x1e, 0x7f, 0x13, 0xae, 0x87, 0xde, 0x4b, 0x72, 0x7c, 0x0d, 0x82, 0x3d,
	0x80, 0xc5, 0x3e, 0x2f, 0x44, 0x16, 0xf2, 0x68, 0x0f, 0x07, 0xdd, 0x5b, 0x21, 0xfd, 0x57, 0xc7,
	0xf5, 0x3f, 0xb4, 0xd9, 0x64, 0x21, 0xae, 0x28, 0x56, 0x33, 0xe5, 0x31, 0x6f, 0x09, 0x9e, 0x7b,
	0xdf, 0x3b, 0xad, 0x9a, 0x8f, 0x15, 0x87, 0xaa, 0xa6, 0x16, 0xc0, 0xe9, 0x90, 0x87, 0x5d, 0xe2,
	0xf1, 0x5e, 0xa6, 0xce, 0xa0, 0xe9, 0xb0, 0xa7, 0x70, 0x81, 0xa1, 0xb2, 0x5b, 0xd0, 0x6c, 0xf3,
	0x93, 0xbd, 0x82, 0x17, 0x82, 0xb8, 0x5f, 0x21, 0xee, 0x65, 0xe4, 0xde, 0xb4, 0xf0, 0x81, 0xc3,
	0x85, 0xcb, 0x31, 0xe9, 0x74, 0xc2, 0x56, 0xc8, 0x23, 0xef, 0xb2, 0x5c, 0x8e, 0x1a, 0xc6, 0x89,
	0xda, 0x4b, 0xa2, 0x13, 0xef, 0x55, 0xaa, 0x34, 0x4d, 0xd4, 0xfb, 0x49, 0x74, 0x12, 0x10, 0x96,
	0xbd, 0x06, 0x73, 0xbc, 0x88, 0x78, 0x2e, 0x72, 0xef, 0x4a, 0x39, 0x01, 0xd7, 0x10, 0x15, 0x68,
	0x0a, 0xbb, 0x09, 0x4d, 0xfa, 0xdc, 0xe6, 0x45, 0x4f, 0x64, 0xb9, 0xf7, 0x7d, 0xe2, 0x3c, 0x67,
	0x38, 0x25, 0x3e, 0x70, 0x98, 0xd8, 0x35, 0x58, 0xea, 0x87, 0x71, 0x18, 0x77, 0x0f, 0x92, 0xec,
	0x88, 0x16, 0xae, 0x4f, 0x8b, 0x6c, 0x04, 0x8b, 0x4b, 0xbe, 0x1f, 0xc6, 0x22, 0xf3, 0x5e, 0x93,
	0x4b, 0x9e, 0x00, 0xec, 0x31, 0xf1, 0x34, 0x95, 0xa3, 0x76, 0xb5, 0xec, 0xb1, 0x2d, 0x85, 0x0b,
	0x0c, 0x95, 0xbd, 0x03, 0x33, 0xa9, 0x28, 0x72, 0xef, 0x75, 0xaa, 0xd4, 0xf7, 0x26, 0x0c, 0x8a,
	0x28, 0xd4, 0x80, 0x10, 0x23, 0xbb, 0x0a, 0x73, 0x5f, 0x0f, 0xc4, 0xd3, 0x81, 0xc8, 0xbd, 0x6b,
	0x24, 0x03, 0x28, 0xf3, 0x80, 0x50, 0x81, 0x26, 0x61, 0x05, 0xd0, 0x76, 0x1e, 0x08, 0x9e, 0x79,
	0x6f, 0x94, 0x15, 0x78, 0xa2, 0x70, 0x81, 0xa1, 0xb2, 0x7b, 0x70, 0x39, 0xcc, 0xef, 0xf3, 0xa1,
	0xd8, 0x16, 0xc5, 0x26, 0x0f, 0xa3, 0x93, 0x8d, 0xa4, 0x9f, 0x8a, 0x22, 0x2c, 0x86, 0x22, 0x10,
	0xc7, 0x3c, 0x6b, 0x7b, 0xd7, 0xa9, 0x65, 0xcf, 0xe0, 0x42, 0x6b, 0xd4, 0x4b, 0xe2, 0x64, 0x90,
	0x79, 0xff, 0x5f, 0x5a, 0x23, 0x09, 0xb1, 0xbb, 0xb0, 0xd4, 0xe6, 0xd9, 0xd1, 0x63, 0x1e, 0xf1,
	0x96, 0x9c, 0x14, 0x37, 0xa8, 0x3e, 0x4c, 0x4e, 0x0a, 0x9b, 0x12, 0x8c, 0x70, 0xb2, 0x35, 0x80,
	0x54, 0x64, 0x79, 0x12, 0xe3, 0xca, 0xf6, 0xde, 0xa4, 0xe6, 0x7e, 0x7f, 0x52, 0x17, 0x69, 0x1e,
	0xd9, 0x51, 0x96, 0x10, 0xbb, 0x03, 0x73, 0xc3, 0x30, 0x25, 0xf9, 0xb7, 0x48, 0xfe, 0xf2, 0xb8,
	0xfc, 0x8f, 0x25, 0x83, 0x14, 0xd6, 0xec, 0x68, 0x96, 0x87, 0x61, 0xba, 0x1d, 0x76, 0x0a, 0xef,
	0xed, 0x2b, 0x35, 0x34, 0xcb, 0x0a, 0x64, 0x2f, 0x41, 0xad, 0x13, 0x16, 0xde, 0x2a, 0xb5, 0x63,
	0x4e, 0x5a, 0xb2, 0x22, 0x40, 0x1c, 0xbb, 0x02, 0x0b, 0x99, 0x68, 0xf5, 0x78, 0xd6, 0x15, 0x6b,
	0x51, 0xe4, 0xbd, 0x43, 0x5d, 0x67, 0xa3, 0xd8, 0x2d, 0x78, 0x81, 0xb7, 0x5a, 0x83, 0xfe, 0x20,
	0xe2, 0x45, 0x38, 0x44, 0xd4, 0xb6, 0x28, 0x76, 0xda, 0xb9, 0xf7, 0x2e, 0x15, 0x32, 0x99, 0xc8,
	0x3e, 0x85, 0xf9, 0x7e, 0x12, 0x17, 0xbd, 0x0d, 0x1c, 0x90, 0xf7, 0xa8, 0x21, 0x57, 0x26, 0xd8,
	0x01, 0xcd, 0x22, 0x9b, 0x52, 0x8a, 0x48, 0x33, 0x9c, 0xe5, 0x45, 0xa0, 0x6a, 0xe2, 0xbd, 0x6f,
	0x9b, 0x61, 0x8b, 0x10, 0xb8, 0x7c, 0xb8, 0xa2, 0xf3, 0x54, 0xc4, 0xed, 0x40, 0x1c, 0xf2, 0x42,
	0xe4, 0xde, 0xcd, 0x72, 0x45, 0xef, 0x59, 0xf8, 0xc0, 0xe1, 0xc2, 0xea, 0xb6, 0x71, 0x96, 0x3c,
	0xe6, 0xad, 0x23, 0xef, 0xd6, 0x69, 0xd5, 0xdd, 0xd4, 0x2c, 0xaa, 0xba, 0x46, 0x04, 0xa7, 0x6f,
	0x37, 0x4b, 0x8e, 0xef, 0x0d, 0xe2, 0xb6, 0x77, 0xbb, 0x9c, 0xbe, 0xdb, 0x0a, 0x17, 0x18, 0x2a,
	0x72, 0x1e, 0xf3, 0xec, 0x8b, 0xac, 0x2d, 0x32, 0xef, 0x83, 0x92, 0xf3, 0x40, 0xe1, 0x02, 0x43,
	0x65, 0xd7, 0xe1, 0x5c, 0x26, 0xda, 0xa8, 0x5e, 0x14, 0xdb, 0x82, 0xb6, 0x85, 0x0f, 0x69, 0x78,
	0x46, 0xd1, 0x38, 0xbe, 0x22, 0xea, 0x78, 0x77, 0xca, 0xf1, 0xdd, 0x8a, 0x3a, 0x01, 0xe2, 0x70,
	0x67, 0x69, 0x0d, 0x8a, 0xfd, 0x4c, 0xf0, 0x7c, 0x90, 0x89, 0xdd, 0xa1, 0xf7, 0x91, 0xdc, 0x59,
	0x1c, 0x24, 0x76, 0x5a, 0x27, 0x2c, 0xd0, 0x4e, 0x6d, 0x7d, 0x33, 0x08, 0x53, 0xef, 0x6e, 0xd9,
	0x69, 0xf7, 0x2c, 0x7c, 0xe0, 0x70, 0xa1, 0x19, 0xd4, 0x13, 0xc5, 0xfb, 0x98, 0x26, 0x83, 0x81,
	0x99, 0x0f, 0xcd, 0xbc, 0xc7, 0xd7, 0xf9, 0x91, 0xd8, 0xc9, 0xb7, 0xe2, 0xb6, 0xf7, 0x03, 0x2a,
	0xd6, 0xc1, 0xb1, 0xb7, 0xe0, 0x7c, 0x2b, 0x4b, 0xf2, 0x7c, 0xaf, 0xc7, 0x0f, 0x0d, 0xe3, 0x27,
	0xc4, 0x38, 0x4e, 0xc0, 0x96, 0x84, 0xf9, 0xbd, 0x2c, 0x14, 0x71, 0x7b, 0x2d, 0x4d, 0xa3, 0x13,
	0xef, 0xd3, 0x2b, 0x95, 0xeb, 0x8d, 0xc0, 0x45, 0x62, 0xb9, 0x87, 0x61, 0xdc, 0x0e, 0xe3, 0xee,
	0x0e, 0x39, 0x36, 0x9f, 0xc9, 0x72, 0x6d, 0x1c, 0xee, 0xa3, 0xbd, 0x24, 0x39, 0x1a, 0xa4, 0x64,
	0x26, 0x7f, 0x28, 0xf7, 0xd1, 0x12, 0xc3, 0x6e, 0xc0, 0xbc, 0x84, 0xd6, 0x79, 0xd7, 0x5b, 0x2b,
	0xdd, 0x89, 0xb0, 0x10, 0xfd, 0x27, 0x71, 0x58, 0x04, 0x25, 0x19, 0x7b, 0xae, 0x95, 0xc4, 0xe5,
	0x34, 0x5d, 0x2f, 0x7b, 0x6e, 0xc3, 0xc2, 0x07, 0x0e, 0x17, 0xee, 0x6e, 0x49, 0x2a, 0x62, 0x5a,
	0xab, 0x1b, 0xa7, 0xed, 0x6e, 0x5f, 0x28, 0x0e, 0xb5, 0xbb, 0x69, 0x01, 0x5c, 0x90, 0xd4, 0x3b,
	0x1b, 0x3d, 0x1e, 0x45, 0x22, 0xee, 0x8a, 0x9d, 0x5c, 0x76, 0xc8, 0x26, 0xb5, 0x64, 0x32, 0x91,
	0xad, 0xc3, 0xf9, 0xb5, 0x38, 0x4e, 0x06, 0x71, 0x4b, 0xf4, 0x45, 0x5c, 0x60, 0x09, 0xb9, 0xb7,
	0x45, 0x65, 0x93, 0x8b, 0x32, 0x4a, 0x0c, 0xc6, 0xd9, 0xd1, 0x58, 0x0c, 0xc3, 0x74, 0x63, 0x90,
	0x17, 0x49, 0x5f, 0x64, 0xde, 0x3d, 0x1a, 0x00, 0x1b, 0x85, 0x1c, 0xad, 0x1e, 0x2f, 0xd6, 0x79,
	0x4c, 0x7d, 0xbb, 0x2d, 0xcd, 0x89, 0x85, 0xc2, 0x59, 0xdd, 0xe3, 0x43, 0xf1, 0x24, 0x17, 0xa6,
	0xcf, 0xee, 0xcb, 0x59, 0x3d, 0x82, 0x46, 0x67, 0x03, 0x9d, 0x54, 0x39, 0x8e, 0x3b, 0xd2, 0xd9,
	0x30, 0x08, 0xf6, 0x09, 0x9c, 0xe3, 0x71, 0x2b, 0x14, 0x71, 0x61, 0x1c, 0xae, 0x07, 0xd4, 0xf7,
	0x17, 0x64, 0x6b, 0x1c, 0x52, 0x30, 0xca, 0xcb, 0xde, 0x80, 0xf9, 0x22, 0x2c, 0x22, 0xb1, 0x1b,
	0xe6, 0x85, 0xf7, 0x79, 0xb9, 0x15, 0xef, 0x23, 0x32, 0x28, 0x69, 0x38, 0x19, 0xfa, 0xe1, 0x83,
	0x50, 0xf6, 0xd7, 0x6e, 0x39, 0x19, 0x1e, 0x2a, 0x64, 0x50, 0x92, 0xd9, 0x57, 0x70, 0x41, 0x95,
	0xa3, 0xd7, 0x16, 0xd5, 0xeb, 0x21, 0x49, 0xdd, 0x18, 0x1f, 0xe1, 0xb5, 0x71, 0x66, 0x39, 0xd8,
	0x93, 0xd4, 0xb0, 0x6d, 0x68, 0xa6, 0xa2, 0x58, 0x4b, 0xd1, 0x6e, 0xe1, 0x3e, 0xfd, 0x88, 0xd4,
	0xbe, 0x36, 0x71, 0x07, 0x36, 0x5c, 0x52, 0x9f, 0x23, 0x88, 0x73, 0xb6, 0x27, 0xa2, 0xc8, 0xf4,
	0xdb, 0x17, 0xe5, 0x9c, 0xbd, 0x6f, 0xe1, 0x03, 0x87, 0x0b, 0x57, 0x96, 0xb1, 0x3b, 0x68, 0x8b,
	0x1e, 0xcb, 0x95, 0x65, 0xe3, 0x70, 0xff, 0x6b, 0xf3, 0x75, 0x9e, 0x48, 0x2b, 0xf2, 0xa3, 0xd3,
	0xf6, 0xbf, 0x4d, 0xc3, 0xa3, 0xf6, 0xbf, 0x52, 0x88, 0xad, 0x02, 0x23, 0xe8, 0xe1, 0x49, 0x5e,
	0x88, 0xec, 0x64, 0x2b, 0x16, 0x59, 0xf7, 0xc4, 0x0b, 0xa8, 0xb0, 0x09, 0x14, 0x34, 0x0b, 0x3c,
	0x4d, 0x23, 0x72, 0x3a, 0x88, 0x75, 0x4f, 0x1a, 0x38, 0x07, 0x89, 0xa6, 0x46, 0x21, 0x02, 0x91,
	0x0f, 0xfa, 0xf2, 0x64, 0xb3, 0x2f, 0x4d, 0xcd, 0x18, 0x01, 0x7b, 0x5a, 0x21, 0xe5, 0xb0, 0x3f,
	0x39, 0xad, 0xa7, 0xd7, 0x2c, 0x2e, 0xd5, 0xd3, 0xb6, 0x20, 0x9e, 0x36, 0x22, 0x7e, 0x28, 0x22,
	0xef, 0xc7, 0xd4, 0xc5, 0x34, 0xc3, 0x76, 0x11, 0x11, 0x48, 0x3c, 0x1d, 0x98, 0x06, 0x87, 0x79,
	0x2b, 0x0b, 0x0f, 0x85, 0x77, 0x40, 0x36, 0xb4, 0x44, 0x20, 0x35, 0xcd, 0xc2, 0x61, 0x18, 0x89,
	0xae, 0xf0, 0x7e, 0x22, 0xa9, 0x06, 0x81, 0x2b, 0x69, 0x80, 0xcb, 0xc5, 0x1a, 0x93, 0x3f, 0x90,
	0x2b, 0x69, 0x04, 0x8d, 0x7d, 0x44, 0x5b, 0x95, 0x59, 0x71, 0x5f, 0xca, 0x3e, 0x72, 0x90, 0x2b,
	0x3b, 0xb0, 0xe8, 0xf8, 0xfd, 0x78, 0x86, 0x3c, 0x12, 0x27, 0xea, 0x68, 0x8b, 0x9f, 0x78, 0x52,
	0x1b, 0xf2, 0x68, 0x20, 0x0f, 0xb5, 0xda, 0xab, 0x56, 0x32, 0x81, 0x24, 0xdd, 0xad, 0xde, 0xa9,
	0xac, 0xec, 0x01, 0x1b, 0x77, 0xf1, 0x27, 0xe8, 0x7b, 0xc3, 0xd5, 0x47, 0xbb, 0xbb, 0x23, 0x68,
	0x2b, 0xdd, 0x85, 0x45, 0xc7, 0xe1, 0x9f, 0xa0, 0xef, 0x75, 0x57, 0x1f, 0xb9, 0xcc, 0x4a, 0x66,
	0xb4, 0x8a, 0x9b, 0x30, 0x6f, 0x3c, 0xd5, 0x09, 0x9a, 0xbe, 0xef, 0x6a, 0x5a, 0x20, 0x4d, 0xa2,
	0x18, 0xd5, 0xf2, 0x09, 0x9c, 0x1b, 0x71, 0xe6, 0x26, 0xe8, 0xba, 0x68, 0xeb, 0xaa, 0xdb, 0xe2,
	0x77, 0xa1, 0x69, 0xfb, 0x72, 0x53, 0xc9, 0x7e, 0x01, 0x4b, 0xae, 0xfb, 0x74, 0xd6, 0xfe, 0xd5,
	0x42, 0xb4, 0x95, 0x59, 0x0a, 0x7f, 0x00, 0x4b, 0xae, 0x83, 0x33, 0x55, 0x75, 0x3e, 0x86, 0x45,
	0x67, 0xc3, 0x9a, 0x4a, 0xf8, 0x8f, 0xc1, 0x3b, 0xcd, 0x16, 0x4e, 0xd0, 0xf3, 0xb6, 0xdb, 0xaa,
	0x17, 0x2d, 0x83, 0x6f, 0x8b, 0xdb, 0x05, 0x7c, 0x06, 0xe7, 0xc7, 0xac, 0xe2, 0x54, 0x35, 0xfc,
	0x04, 0xce, 0x8d, 0x58, 0xad, 0xa9, 0xc4, 0x1f, 0xc3, 0xf9, 0x31, 0x5b, 0x71, 0xc6, 0xf9, 0x6b,
	0x19, 0x14, 0x4b, 0xa3, 0xff, 0x06, 0x2c, 0x58, 0x14, 0x3b, 0x26, 0x53, 0x71, 0x62, 0x32, 0xfe,
	0xcf, 0xe1, 0xc2, 0x84, 0xce, 0x41, 0xe7, 0xed, 0x67, 0xbd, 0xc1, 0x6e, 0x18, 0xef, 0x0e, 0x95,
	0x84, 0x81, 0xf1, 0x68, 0x94, 0x17, 0x3c, 0xdb, 0x1d, 0xaa, 0x86, 0x28, 0x08, 0x65, 0xbe, 0x1e,
	0x88, 0x9f, 0x90, 0x4c, 0x4d, 0xca, 0x68, 0x18, 0xdb, 0x5e, 0x9c, 0xa4, 0x22, 0x57, 0xb1, 0x2b,
	0x09, 0xf8, 0x37, 0xa0, 0xa1, 0x37, 0x4a, 0xb6, 0x04, 0x55, 0x13, 0x28, 0xab, 0x86, 0x6d, 0x84,
	0x23, 0x5d, 0x42, 0x35, 0x1a, 0xfa, 0x5f, 0xc1, 0xf2, 0xa8, 0xcb, 0x31, 0x26, 0x83, 0xa5, 0xe0,
	0xd6, 0xac, 0xa2, 0x6a, 0x12, 0xc0, 0xad, 0x89, 0x5b, 0x92, 0x2a, 0xb0, 0xe6, 0xe0, 0xfc, 0xdf,
	0x5d, 0x80, 0x86, 0x0e, 0x2a, 0xc9, 0xb8, 0x57, 0x5b, 0x3c, 0x55, 0x9a, 0x25, 0x80, 0xe3, 0xf1,
	0x75, 0x72, 0xa8, 0x6a, 0x84, 0x9f, 0x88, 0xc9, 0xc5, 0x53, 0xd5, 0x56, 0xfc, 0x64, 0xef, 0xc2,
	0xac, 0xc0, 0x29, 0x80, 0xed, 0xc4, 0x4d, 0xc1, 0xb3, 0x83, 0x55, 0xab, 0x34, 0x3b, 0xd4, 0x4e,
	0xa0, 0xf8, 0xd8, 0xdb, 0x00, 0xf4, 0xb5, 0x9d, 0x85, 0xed, 0xdc, 0xab, 0x93, 0xd4, 0x22, 0xf9,
	0xe8, 0x1a, 0x1b, 0x58, 0x0c, 0x78, 0x3e, 0xe8, 0x89, 0x2c, 0x79, 0x9c, 0x25, 0x29, 0x45, 0xf4,
	0xac, 0x78, 0x18, 0xe2, 0x02, 0x43, 0x65, 0x2f, 0xc3, 0xcc, 0x71, 0x18, 0x77, 0xbd, 0xb9, 0x32,
	0xd2, 0x70, 0x10, 0xc6, 0xdd, 0x80, 0xb0, 0xec, 0x26, 0xcc, 0xfd, 0x2c, 0x69, 0x87, 0xbc, 0x95,
	0x7b, 0x0d, 0x62, 0x78, 0xc9, 0xa9, 0xe9, 0x97, 0x92, 0xa6, 0x8e, 0x90, 0x8a, 0x93, 0x7d, 0x00,
	0x8d, 0xa3, 0x30, 0xee, 0xf2, 0xac, 0x9f, 0x7b, 0xf3, 0x24, 0xb5, 0xe2, 0x48, 0x7d, 0xae, 0x88,
	0xca, 0x25, 0xd5, 0xbc, 0xec, 0x4d, 0x68, 0xb4, 0xc3, 0x56, 0x41, 0x07, 0x2e, 0x28, 0xa3, 0x15,
	0x9b, 0x12, 0x27, 0x63, 0x2e, 0x9a, 0x81, 0xdd, 0x82, 0x05, 0xac, 0xe1, 0x5e, 0x2a, 0x28, 0x80,
	0xb2, 0x40, 0xfc, 0x4c, 0x57, 0x5f, 0xa1, 0x1f, 0x15, 0x9d, 0xc0, 0x66, 0xc3, 0x8e, 0xff, 0x5a,
	0x1c, 0x8b, 0x28, 0xf7, 0x9a, 0x13, 0x3a, 0xfe, 0x01, 0x91, 0x54, 0xc7, 0x4b, 0x3e, 0xc6, 0x60,
	0x26, 0xe6, 0x7d, 0xe1, 0x2d, 0xd2, 0x6c, 0xa0, 0x6f, 0xb6, 0x0a, 0x10, 0xc6, 0x79, 0xd8, 0x96,
	0x8e, 0xd9, 0x12, 0xf5, 0xef, 0x12, 0x6a, 0xda, 0x31, 0xd8, 0xc0, 0xe2, 0xc0, 0x0e, 0xb9, 0xc7,
	0xf3, 0x5e, 0x98, 0xc4, 0x3a, 0x3a, 0xe9, 0x76, 0x88, 0x26, 0xaa, 0x0e, 0xd1, 0x20, 0x6e, 0xfc,
	0xc7, 0x82, 0x67, 0xb9, 0x8a, 0x57, 0xd2, 0xc6, 0x7f, 0x80, 0x88, 0x40, 0xe2, 0xd1, 0x86, 0x65,
	0x61, 0xdc, 0xcd, 0x55, 0xb8, 0xf2, 0x45, 0x47, 0x6b, 0x80, 0x14, 0xa9, 0x52, 0x72, 0xb1, 0xd7,
	0x61, 0x36, 0x3f, 0x0a, 0xa3, 0x28, 0x57, 0x71, 0x4b, 0x9a, 0x40, 0x7b, 0x88, 0x21, 0x2b, 0xae,
	0x88, 0x58, 0x5d, 0xfa, 0xc2, 0x83, 0xcb, 0x85, 0x09, 0xd5, 0xdd, 0x53, 0x44, 0x1d, 0xd7, 0x53,
	0x20, 0x7b, 0x0f, 0x9a, 0x83, 0x38, 0xfc, 0x66, 0x20, 0xf6, 0x64, 0x21, 0x17, 0x27, 0x15, 0xe2,
	0xb0, 0xb0, 0xfb, 0xb0, 0x64, 0xc1, 0x58, 0xe0, 0x0b, 0xe5, 0xb1, 0xd9, 0x14, 0xf8, 0xc4, 0x61,
	0x91, 0xc5, 0x8e, 0xc8, 0xb1, 0x8f, 0xd0, 0xcf, 0x6f, 0xcb, 0xa5, 0xe3, 0x5d, 0x2a, 0xc3, 0x4a,
	0x46, 0xc9, 0xb6, 0xa6, 0xaa, 0x63, 0xb7, 0xe1, 0x66, 0x37, 0x60, 0x86, 0x67, 0x82, 0x7b, 0x2f,
	0x92, 0xd4, 0x25, 0x47, 0x6a, 0x2d, 0x13, 0x5c, 0xc5, 0xa1, 0x90, 0x87, 0x7d, 0x06, 0x0b, 0xb4,
	0xcc, 0x36, 0x22, 0x1a, 0x18, 0x19, 0xfb, 0x7c, 0x65, 0x7c, 0xf9, 0x4a, 0xba, 0x94, 0xb4, 0x25,
	0xd0, 0x2a, 0x8a, 0xa7, 0xe9, 0xee, 0x30, 0x52, 0x91, 0x4f, 0x05, 0xa1, 0xe2, 0x76, 0xc6, 0xbb,
	0x49, 0x2c, 0xbd, 0xde, 0x95, 0x09, 0x8a, 0x37, 0x4b, 0xba, 0x52, 0x6c, 0x49, 0xa0, 0x82, 0x87,
	0xbc, 0x1b, 0xb6, 0x36, 0xc2, 0xac, 0x15, 0x09, 0x15, 0xee, 0x74, 0x15, 0x58, 0x74, 0xa5, 0xc0,
	0xc2, 0xb0, 0xeb, 0x30, 0x57, 0xf0, 0x48, 0xc4, 0x45, 0xae, 0xc2, 0x9d, 0x4b, 0x32, 0xf6, 0x1b,
	0xe9, 0xb3, 0x9c, 0x26, 0xb3, 0x2d, 0x58, 0xa4, 0x78, 0xed, 0x5e, 0x2f, 0x94, 0xb5, 0x7d, 0xa5,
	0x3c, 0x7d, 0x9a, 0xc2, 0x36, 0x6c, 0x0e, 0x15, 0x9d, 0x75, 0xa4, 0xf0, 0x04, 0xa1, 0x4e, 0x28,
	0x34, 0x8a, 0x14, 0x04, 0x55, 0x27, 0x88, 0x35, 0x0b, 0x1f, 0x38, 0x5c, 0x6c, 0x1f, 0x98, 0x56,
	0xb3, 0x57, 0x64, 0x22, 0xee, 0x16, 0x3d, 0x11, 0xab, 0x40, 0xe9, 0xd5, 0x89, 0x35, 0x28, 0xd9,
	0x64, 0x35, 0x26, 0xc8, 0xaf, 0xdc, 0x87, 0x05, 0x6b, 0x76, 0x4c, 0xd8, 0x54, 0x5f, 0x73, 0x37,
	0xd5, 0xd2, 0xf6, 0x8e, 0x3a, 0x40, 0x8f, 0xa1, 0x69, 0x9b, 0xc5, 0x09, 0xaa, 0x6e, 0xb8, 0xaa,
	0x2e, 0xaa, 0xa8, 0x12, 0x1a, 0xa8, 0x89, 0x1a, 0x7f, 0x04, 0x8b, 0x8e, 0xc9, 0xfc, 0x0e, 0x54,
	0xde, 0x87, 0x05, 0xcb, 0xd8, 0x9d, 0xb1, 0xb9, 0x24, 0x31, 0xea, 0x13, 0xdd, 0x87, 0x45, 0xc7,
	0x7c, 0x9d, 0xd1, 0x0b, 0x56, 0x32, 0xb6, 0xa6, 0x75, 0x80, 0xd2, 0x64, 0x4d, 0x50, 0x73, 0xd9,
	0x55, 0x23, 0x6f, 0x6f, 0x70, 0xab, 0x72, 0xfd, 0x47, 0xc7, 0x4c, 0x4c, 0xe5, 0x5e, 0xad, 0xc1,
	0x85, 0x09, 0x96, 0x66, 0x2a, 0x15, 0x0f, 0x60, 0xc9, 0xb5, 0x33, 0x67, 0x3c, 0xfe, 0x68, 0x21,
	0x5b, 0xd7, 0x87, 0x30, 0x6f, 0xac, 0xcf, 0x54, 0x95, 0xf8, 0x11, 0x2c, 0x8f, 0xda, 0xa0, 0x33,
	0x7a, 0xf5, 0xa5, 0xd8, 0x5a, 0x96, 0xd9, 0x2a, 0x3f, 0x85, 0xe5, 0x51, 0xeb, 0x33, 0x55, 0x95,
	0x3e, 0x85, 0xe5, 0x51, 0xe3, 0x33, 0x95, 0xfc, 0x0f, 0x81, 0x8d, 0xdb, 0x93, 0xa9, 0x34, 0x6c,
	0xc1, 0x8b, 0xa7, 0xd8, 0x83, 0x69, 0xd4, 0xf8, 0x9b, 0xd0, 0xd0, 0xb7, 0x09, 0xc8, 0x95, 0x8a,
	0xc2, 0x78, 0x96, 0x12, 0x40, 0x37, 0xb2, 0x13, 0x16, 0x6a, 0x7e, 0xef, 0xb4, 0x95, 0x0a, 0x07,
	0xe7, 0xff, 0xba, 0x02, 0x75, 0xda, 0xc8, 0xf1, 0xf8, 0xad, 0xd0, 0x07, 0x82, 0xa7, 0x24, 0x20,
	0xb5, 0x8d, 0xa2, 0xd9, 0x35, 0x58, 0x52, 0xa8, 0x8d, 0x28, 0x29, 0x7a, 0x46, 0xf3, 0x08, 0x16,
	0x8f, 0xfb, 0x74, 0xa5, 0x43, 0x97, 0x20, 0x35, 0x79, 0xdc, 0x37, 0x08, 0xdc, 0x7e, 0xd0, 0x1f,
	0xda, 0x69, 0x2b, 0x0f, 0x5b, 0x41, 0x58, 0x8f, 0x7e, 0x39, 0x40, 0xbb, 0xc3, 0x9d, 0xb6, 0xba,
	0x22, 0x1e, 0x45, 0xe3, 0x19, 0x81, 0xfc, 0xe5, 0x9d, 0xb6, 0xba, 0x2b, 0xd6, 0xa0, 0xff, 0x9b,
	0x2a, 0x2c, 0xae, 0x67, 0xa1, 0xe8, 0x60, 0x0f, 0x4d, 0x74, 0xbc, 0xb5, 0x33, 0x55, 0xb5, 0x9c,
	0xa9, 0x71, 0xef, 0x78, 0x19, 0x6a, 0xd1, 0x50, 0x5f, 0x5f, 0xe3, 0x27, 0x62, 0x86, 0x61, 0xaa,
	0x6a, 0x84, 0x9f, 0xd6, 0x2d, 0xf0, 0xac, 0x73, 0x0b, 0x5c, 0xde, 0x8b, 0xcf, 0x39, 0xf7, 0xe2,
	0xca, 0x2b, 0x6f, 0x94, 0x5e, 0xf9, 0x45, 0xa8, 0xf7, 0xf9, 0xd3, 0xdd, 0xa1, 0xbe, 0xb5, 0x26,
	0x00, 0x0f, 0x27, 0xb9, 0xc8, 0x86, 0x22, 0xdb, 0x69, 0xab, 0x3b, 0x6b, 0x03, 0xb3, 0x3b, 0x30,
	0xd7, 0x0e, 0xf3, 0x34, 0xe2, 0x27, 0xca, 0xdd, 0xa4, 0x4b, 0x15, 0xa7, 0xc5, 0xab, 0x9b, 0x92,
	0x41, 0x79, 0xc4, 0x8a, 0x7d, 0x65, 0x1b, 0x9a, 0x36, 0xe1, 0x8c, 0x36, 0x52, 0x89, 0xd8, 0xd3,
	0x2f, 0x07, 0xcf, 0x29, 0xef, 0x20, 0x2c, 0x7a, 0x8a, 0x8d, 0xbd, 0x2d, 0x2f, 0xbf, 0xc8, 0x27,
	0xad, 0x94, 0x6b, 0xda, 0xe1, 0x0f, 0x0c, 0x0b, 0x6e, 0xf7, 0xba, 0x35, 0x96, 0x07, 0xab, 0x94,
	0xa1, 0xe3, 0xac, 0xc9, 0xfe, 0x1f, 0xc2, 0xf2, 0x7e, 0x92, 0x6e, 0xf2, 0x82, 0x6f, 0xf4, 0x78,
	0xdc, 0x15, 0x8f, 0x8a, 0x0e, 0xbb, 0x49, 0x21, 0xda, 0xb8, 0x2b, 0x64, 0x6c, 0xab, 0x42, 0xfd,
	0x41, 0xe5, 0x39, 0xac, 0x81, 0xcd, 0x85, 0xc3, 0x8f, 0x07, 0x3a, 0x35, 0x71, 0xe9, 0xdb, 0xff,
	0x02, 0x16, 0x1d, 0x89, 0xb1, 0x39, 0x83, 0x23, 0x4d, 0x14, 0x12, 0xc3, 0x91, 0x96, 0x7c, 0x97,
	0x60, 0x36, 0x4e, 0x8e, 0x1f, 0x0d, 0xfa, 0x34, 0x75, 0x6a, 0x81, 0x82, 0xfc, 0x9f, 0xc0, 0xf2,
	0x3a, 0xef, 0xba, 0xb5, 0x7d, 0x77, 0x52, 0x6d, 0xa5, 0xc7, 0x5e, 0x88, 0xfe, 0x59, 0xab, 0xfa,
	0xb7, 0x15, 0x80, 0x92, 0x1f, 0xa7, 0x4a, 0x9a, 0xe4, 0x61, 0x11, 0x26, 0xb1, 0x3e, 0xfb, 0x6a,
	0x18, 0x2b, 0x17, 0x16, 0xa2, 0x6f, 0x16, 0xa9, 0x82, 0xac, 0xc6, 0xd4, 0x4e, 0x69, 0xcc, 0x8c,
	0xdd, 0x18, 0xf6, 0x26, 0xcc, 0x77, 0x45, 0xb1, 0x97, 0x0c, 0xb2, 0x96, 0xcc, 0xd9, 0x50, 0x5b,
	0xf1, 0xb6, 0x46, 0x06, 0x25, 0xdd, 0xff, 0x23, 0x78, 0x01, 0x37, 0x2d, 0xb4, 0x8f, 0x6e, 0xf3,
	0xdf, 0x9b, 0xd4, 0xfc, 0x73, 0xa5, 0xc1, 0x3f, 0x63, 0xfb, 0xff, 0xa5, 0xa2, 0x9c, 0xa4, 0xff,
	0xc3, 0x0e, 0x78, 0x0d, 0xea, 0xe4, 0x3d, 0xdb, 0x8d, 0xb7, 0x3c, 0x1a, 0xa2, 0xb9, 0xbd, 0x34,
	0xfb, 0x8c, 0x5e, 0xfa, 0x65, 0x05, 0x66, 0x70, 0x14, 0xad, 0x2a, 0x56, 0x9c, 0x2a, 0x5e, 0x84,
	0x7a, 0x2b, 0x19, 0xc4, 0x85, 0x9a, 0x6f, 0x12, 0x70, 0x1a, 0x5b, 0x1b, 0x69, 0xac, 0xa9, 0xe4,
	0xcc, 0x59, 0x2b, 0xf9, 0xac, 0xa1, 0xbc, 0x85, 0x7e, 0x44, 0xd2, 0xce, 0xcb, 0x31, 0xf4, 0xa1,
	0x8e, 0xf5, 0xd3, 0xa3, 0xe7, 0x5e, 0x25, 0x49, 0x92, 0x7f, 0x07, 0x1a, 0x1a, 0x35, 0x5d, 0xeb,
	0xfc, 0xbf, 0xab, 0xc0, 0xbc, 0xa9, 0xf1, 0xa9, 0xb2, 0xef, 0xc0, 0x7c, 0xc6, 0xe3, 0xf6, 0xe3,
	0x2c, 0x49, 0x73, 0xaf, 0x5a, 0x2e, 0x79, 0xe9, 0xba, 0x28, 0x4a, 0x50, 0xf2, 0xe0, 0x2c, 0x8a,
	0x92, 0xd6, 0x11, 0x75, 0x58, 0x23, 0xa0, 0x6f, 0x76, 0x59, 0x45, 0x32, 0x76, 0x28, 0x74, 0x22,
	0x8d, 0xbc, 0x85, 0xa1, 0x4c, 0xa4, 0x41, 0xeb, 0xe8, 0x44, 0x59, 0x7b, 0x09, 0xf8, 0x7b, 0xb0,
	0xe8, 0x94, 0x82, 0x75, 0x4c, 0xb3, 0x24, 0x2d, 0xeb, 0x28, 0x21, 0xd9, 0xbe, 0x28, 0xc9, 0xf4,
	0xd6, 0x4d, 0x40, 0xb9, 0xa1, 0xd7, 0xac, 0x0d, 0xdd, 0xff, 0x5c, 0x29, 0xd5, 0x1e, 0x0f, 0xbb,
	0x0b, 0x4b, 0xe5, 0x59, 0x4d, 0x19, 0x52, 0x13, 0x57, 0xd8, 0x72, 0x28, 0xc1, 0x08, 0xa7, 0xff,
	0x35, 0x2c, 0xb9, 0x1c, 0x58, 0x68, 0x37, 0xe3, 0x26, 0x31, 0x4c, 0x02, 0xa7, 0x54, 0xb0, 0x6c,
	0x4e, 0x6d, 0xb4, 0x39, 0xb2, 0xe2, 0x33, 0x76, 0xc5, 0xff, 0xab, 0x22, 0xc3, 0x50, 0xd4, 0x13,
	0x6f, 0x43, 0x3d, 0xa5, 0x11, 0xa9, 0xb8, 0x41, 0x00, 0x24, 0xae, 0xd2, 0x38, 0xa8, 0x20, 0x00,
	0x71, 0xe1, 0xe1, 0xad, 0x9f, 0xb4, 0x07, 0x91, 0xc8, 0x37, 0xe4, 0x06, 0x5a, 0x75, 0x0f, 0x6f,
	0x24, 0xf6, 0xd0, 0xe6, 0xd0, 0xa9, 0x35, 0x36, 0x6e, 0xe5, 0x0e, 0x40, 0xa9, 0xfb, 0x59, 0x2e,
	0x54, 0x6d, 0xc4, 0x97, 0x1b, 0x57, 0x3f, 0x8d, 0x06, 0x9f, 0xc3, 0x82, 0x95, 0x92, 0x84, 0x7d,
	0x57, 0x20, 0x68, 0xa6, 0x82, 0x84, 0xd0, 0x53, 0x49, 0xb3, 0xa4, 0x25, 0xf2, 0x5c, 0xf5, 0xb5,
	0x06, 0xd9, 0x15, 0x58, 0xe8, 0xf3, 0xec, 0xe8, 0xb1, 0xa2, 0xca, 0x2e, 0xb7, 0x51, 0xfe, 0x5f,
	0x54, 0x00, 0xca, 0xbd, 0x90, 0xdd, 0x2e, 0x37, 0xcb, 0x4a, 0x19, 0x5b, 0x28, 0x19, 0xfe, 0xb7,
	0xf7, 0xfd, 0x2f, 0xa1, 0xb1, 0x35, 0x14, 0x71, 0x81, 0x75, 0x99, 0x10, 0x01, 0x2d, 0x74, 0x0b,
	0xab, 0x05, 0x2d, 0x3a, 0x9e, 0x75, 0x73, 0xf2, 0xfd, 0xe6, 0x03, 0xfa, 0x26, 0xb7, 0x86, 0x2c,
	0x8b, 0x71, 0xfc, 0x0c, 0xec, 0xff, 0xaa, 0x02, 0xe7, 0x55, 0x72, 0x4b, 0xdc, 0x26, 0x83, 0x86,
	0xa5, 0xec, 0xc3, 0xb9, 0xb6, 0x83, 0xd4, 0xf3, 0xeb, 0x86, 0xcc, 0x60, 0x19, 0xe1, 0x1f, 0xc1,
	0xa8, 0x29, 0x37, 0xaa, 0x62, 0x65, 0x1d, 0x2e, 0x4e, 0x62, 0x9c, 0xca, 0x05, 0x7f, 0x1f, 0x1a,
	0x38, 0xf3, 0x68, 0x89, 0x9d, 0x51, 0xce, 0xff, 0x48, 0x99, 0xb7, 0xed, 0x2c, 0x6c, 0xa3, 0x50,
	0x4a, 0xdb, 0x20, 0x09, 0xa5, 0x89, 0xec, 0x1e, 0x75, 0x28, 0x50, 0x72, 0x06, 0xf6, 0x0f, 0xa0,
	0x4e, 0xa9, 0x7d, 0x93, 0xa2, 0xc8, 0x32, 0x65, 0xb2, 0x3a, 0x21, 0x65, 0xb2, 0x56, 0xa6, 0x4c,
	0x5e, 0x32, 0x51, 0xb7, 0x19, 0xf2, 0xc6, 0x15, 0xe4, 0xdf, 0x83, 0x86, 0x3e, 0xf6, 0x9d, 0x51,
	0xf7, 0x45, 0xa8, 0x1f, 0x46, 0x49, 0xa2, 0x6d, 0x84, 0x04, 0xfc, 0x55, 0x98, 0x95, 0x79, 0x50,
	0x67, 0xd3, 0xe2, 0xbf, 0x03, 0x73, 0xea, 0xc8, 0x70, 0x46, 0x81, 0xeb, 0x30, 0x73, 0x10, 0xc6,
	0xdd, 0x31, 0x6e, 0xd5, 0xd4, 0xaa, 0x69, 0xaa, 0x7f, 0x1f, 0x96, 0xdc, 0xe8, 0x2b, 0xae, 0xb4,
	0x5c, 0x42, 0xfb, 0xe8, 0x4e, 0x48, 0x61, 0x1b, 0x75, 0x7a, 0x99, 0x81, 0x08, 0xe3, 0x6f, 0x2b,
	0xb3, 0x26, 0xcb, 0x7c, 0x0b, 0x1a, 0x3a, 0x43, 0x73, 0x12, 0x77, 0x3c, 0xe8, 0xeb, 0x1a, 0xc6,
	0x83, 0xbe, 0xbf, 0x0d, 0x75, 0xca, 0x7e, 0x9b, 0x74, 0x34, 0xc9, 0xf1, 0xd8, 0xa0, 0x1c, 0x9e,
	0x5c, 0x25, 0xd3, 0x86, 0xf9, 0x5a, 0xab, 0x08, 0x87, 0x42, 0x6d, 0x61, 0x06, 0xf6, 0x1f, 0xc2,
	0x82, 0x95, 0x46, 0xf7, 0x7b, 0xab, 0xbb, 0x85, 0xe6, 0x54, 0x74, 0x44, 0x26, 0xe2, 0x96, 0x78,
	0xd6, 0xb4, 0x9e, 0xd7, 0xd3, 0xfa, 0x4f, 0x60, 0x79, 0x34, 0x29, 0x74, 0xac, 0x26, 0x57, 0x60,
	0x21, 0xcd, 0x44, 0xca, 0x33, 0x79, 0x5d, 0x2d, 0x2b, 0x64, 0xa3, 0x28, 0x11, 0x31, 0x15, 0x32,
	0xd7, 0x42, 0xb9, 0x36, 0x1a, 0xa6, 0x5c, 0xcd, 0x28, 0xc9, 0xa5, 0xec, 0x8c, 0xca, 0xd5, 0xd4,
	0x08, 0xff, 0x13, 0x98, 0xfb, 0x71, 0x99, 0x37, 0x36, 0xf9, 0xea, 0x08, 0x29, 0x6d, 0x9e, 0x89,
	0x47, 0x66, 0x20, 0x34, 0xe8, 0xff, 0x73, 0x15, 0x1a, 0x3a, 0x39, 0xd0, 0x66, 0xab, 0x38, 0x6c,
	0xb8, 0x80, 0x0e, 0x07, 0x27, 0xa5, 0xbc, 0x82, 0xd8, 0x47, 0x30, 0xaf, 0x13, 0x0a, 0xa5, 0xb5,
	0x53, 0x66, 0x59, 0xab, 0x34, 0x1f, 0x3a, 0xe4, 0x6b, 0xb8, 0xd9, 0x07, 0xd0, 0xe0, 0x69, 0x9a,
	0xf1, 0x30, 0x17, 0xea, 0x0a, 0x66, 0xc5, 0x91, 0x5c, 0x53, 0x44, 0x15, 0xe2, 0xd6, 0xbc, 0x34,
	0x59, 0xf9, 0x89, 0xc8, 0x8c, 0x73, 0x82, 0xc0, 0xca, 0x0f, 0x60, 0xc9, 0x2d, 0x6a, 0xaa, 0xfd,
	0xf0, 0x63, 0x58, 0x74, 0x8a, 0x9b, 0xca, 0x18, 0xfe, 0x1c, 0x16, 0x9d, 0xab, 0xee, 0xe7, 0xe8,
	0xc6, 0x15, 0x68, 0xc4, 0xc9, 0xf1, 0x2e, 0x35, 0x4b, 0x0d, 0xbf, 0x86, 0x71, 0xf8, 0x23, 0x9e,
	0x17, 0x92, 0xa8, 0x86, 0xdf, 0x20, 0xfc, 0xbf, 0xaf, 0xc2, 0x9c, 0x3e, 0x7d, 0x5e, 0x81, 0x85,
	0x16, 0x45, 0x20, 0x6c, 0xc7, 0xd1, 0x46, 0xa9, 0xa9, 0x54, 0xf4, 0xf6, 0xcb, 0x73, 0x45, 0x89,
	0x60, 0x3e, 0x34, 0x8f, 0x65, 0xa8, 0x43, 0x2a, 0x90, 0x35, 0x71, 0x70, 0xe8, 0x3a, 0x4a, 0x98,
	0x54, 0x28, 0xd7, 0xb1, 0xc4, 0x58, 0xc1, 0x8d, 0xfa, 0xb3, 0x82, 0x1b, 0xb3, 0xcf, 0x0c, 0x6e,
	0xcc, 0x39, 0xc1, 0x0d, 0xa4, 0x50, 0xb2, 0xc5, 0x4e, 0x5b, 0x05, 0x11, 0x34, 0x88, 0xfd, 0x47,
	0x9f, 0x0f, 0x92, 0x43, 0x15, 0x4b, 0x30, 0xb0, 0x7f, 0x00, 0xcb, 0xa3, 0x61, 0xd8, 0x53, 0xbd,
	0x6b, 0xe7, 0x80, 0x50, 0x7d, 0xc6, 0x01, 0x21, 0x87, 0x79, 0x83, 0xc7, 0x09, 0xd3, 0xe7, 0x29,
	0xa9, 0x9b, 0x0f, 0xf0, 0x93, 0x9e, 0x1f, 0x24, 0x71, 0x5e, 0x88, 0xcc, 0x3c, 0x3f, 0x90, 0x20,
	0xe5, 0x8a, 0xd0, 0x65, 0x4c, 0x2e, 0xf4, 0xdb, 0x81, 0x12, 0x61, 0xa8, 0x9b, 0xbc, 0x90, 0x1d,
	0xac, 0xa9, 0x88, 0xf0, 0x7f, 0x51, 0x81, 0x46, 0xc0, 0x63, 0x72, 0xbc, 0xd0, 0xc2, 0x65, 0x3c,
	0x3e, 0xd2, 0xaf, 0x1e, 0xf0, 0x1b, 0xe7, 0x69, 0x4e, 0xcf, 0x0b, 0xd4, 0x24, 0x27, 0xc0, 0x09,
	0x4c, 0xd4, 0x9e, 0x1d, 0x98, 0x78, 0xbd, 0xf4, 0xb5, 0x66, 0xc6, 0x9d, 0x22, 0x13, 0x95, 0xc8,
	0x61, 0xde, 0xdc, 0x2a, 0x91, 0xf5, 0x41, 0xc0, 0xb2, 0x3e, 0x12, 0x3c, 0x65, 0x27, 0x95, 0x4f,
	0x0c, 0xb2, 0xc2, 0xd8, 0xbc, 0x5a, 0x50, 0x22, 0x50, 0x9b, 0x88, 0xdb, 0xc6, 0xe4, 0xd5, 0x02,
	0x0d, 0xfa, 0x7f, 0x0a, 0x0d, 0x9d, 0xa9, 0x42, 0xd7, 0x64, 0xf8, 0x5d, 0x88, 0xbe, 0x72, 0x8d,
	0x56, 0xec, 0x4c, 0x16, 0xf9, 0x51, 0x88, 0xbe, 0x9d, 0xfe, 0x5e, 0x88, 0x3e, 0xc5, 0xa8, 0x6d,
	0xd2, 0x54, 0xeb, 0xfd, 0x43, 0x58, 0xb0, 0xee, 0x43, 0xcd, 0x31, 0xbd, 0x52, 0x1e, 0xd3, 0x4f,
	0xd9, 0x50, 0x3f, 0x83, 0x05, 0x2b, 0x87, 0x05, 0x9b, 0x18, 0x0f, 0xfa, 0x87, 0x22, 0xd3, 0x7e,
	0x90, 0x06, 0xe9, 0x24, 0x4e, 0x9f, 0xda, 0x4c, 0x48, 0xc8, 0xdf, 0x81, 0x79, 0x73, 0x01, 0x40,
	0x07, 0x3b, 0xd1, 0x29, 0x74, 0xb9, 0xf8, 0x8d, 0xe5, 0x66, 0x61, 0xb7, 0x57, 0xe8, 0x72, 0x09,
	0x40, 0xce, 0x76, 0x72, 0xac, 0xcf, 0xcc, 0xf4, 0xed, 0x7f, 0x05, 0x4d, 0x3b, 0x2f, 0x9e, 0xd2,
	0x87, 0x79, 0x7c, 0x74, 0x90, 0x64, 0x79, 0x2f, 0x4c, 0xb5, 0xed, 0xb0, 0x50, 0xec, 0x06, 0x2c,
	0x9b, 0xac, 0xde, 0x40, 0xb4, 0x04, 0x6e, 0xa1, 0x55, 0xf2, 0xa6, 0xc6, 0xf0, 0xfe, 0x2f, 0xab,
	0xd0, 0xd0, 0x49, 0xfa, 0x34, 0xd0, 0x61, 0x37, 0xde, 0xa0, 0x23, 0x6f, 0x45, 0xbd, 0x25, 0xd1,
	0x08, 0x76, 0x13, 0xe6, 0x10, 0xd8, 0xe4, 0x27, 0xea, 0x14, 0xf4, 0x92, 0x9d, 0xe1, 0x4f, 0x1f,
	0x9b, 0xc6, 0xa9, 0x57, 0x9c, 0x74, 0xfb, 0x65, 0x72, 0x95, 0x51, 0xb4, 0x56, 0x1e, 0xa0, 0x8c,
	0xe8, 0x86, 0xcd, 0xa1, 0x6f, 0xbf, 0x6c, 0xdc, 0xca, 0x5d, 0x68, 0xda, 0xfa, 0xa7, 0x0e, 0x87,
	0x8f, 0x15, 0x30, 0xd5, 0x3c, 0xfa, 0xeb, 0x2a, 0x40, 0x79, 0x5b, 0xcd, 0xee, 0x40, 0x83, 0xb7,
	0x06, 0x69, 0x12, 0x52, 0x2f, 0x61, 0x73, 0x5e, 0x76, 0xef, 0xb3, 0x57, 0xd7, 0x14, 0x59, 0xef,
	0x88, 0x0a, 0x64, 0x6b, 0xb0, 0x20, 0x6f, 0xba, 0xe5, 0x1d, 0x9e, 0x75, 0x98, 0xb4, 0x84, 0x77,
	0x4a, 0x0e, 0x75, 0xf1, 0x68, 0xc9, 0xd0, 0x06, 0x68, 0x6b, 0x9f, 0x32, 0x81, 0x69, 0x79, 0x54,
	0xfb, 0x19, 0x53, 0x62, 0x2c, 0x31, 0xbb, 0x67, 0x6e, 0xc3, 0x82, 0x45, 0x29, 0x57, 0x53, 0x65,
	0x82, 0x97, 0x6f, 0xb9, 0xbe, 0xff, 0x50, 0x81, 0x99, 0xfb, 0x49, 0x74, 0xf2, 0xdc, 0xc7, 0x84,
	0xb7, 0x9c, 0x63, 0x82, 0xba, 0xc3, 0x43, 0x8d, 0xf2, 0xf2, 0x5c, 0xa7, 0x25, 0x48, 0x9e, 0x95,
	0x8f, 0x60, 0xc1, 0x42, 0x4f, 0x35, 0xf4, 0xbf, 0xa9, 0xc0, 0x4c, 0x80, 0xfe, 0xfc, 0x32, 0xd4,
	0xca, 0x47, 0x67, 0xf8, 0x89, 0x1b, 0x6c, 0x5e, 0xde, 0xa9, 0x4a, 0x49, 0x0b, 0x43, 0x27, 0xa7,
	0x50, 0xef, 0xcd, 0xf8, 0x29, 0xcf, 0xde, 0x91, 0x88, 0x0b, 0x7d, 0x9f, 0x20, 0x21, 0xf6, 0x0e,
	0xcc, 0xa5, 0x3d, 0x1e, 0x17, 0x49, 0x5f, 0x25, 0xab, 0xbc, 0xa0, 0xaf, 0xeb, 0x56, 0x1f, 0x4b,
	0xbc, 0x5a, 0x55, 0x8a, 0x6b, 0xe5, 0x73, 0x68, 0xda, 0x84, 0x33, 0x8e, 0x21, 0x2a, 0x54, 0x62,
	0x76, 0x13, 0xff, 0xb1, 0x02, 0x0b, 0x16, 0xc9, 0xaa, 0x65, 0xc5, 0xa9, 0xa5, 0x57, 0xd6, 0x52,
	0x47, 0x08, 0x94, 0xc4, 0xbb, 0x50, 0xa7, 0x9e, 0x56, 0x8b, 0x7b, 0x65, 0xa4, 0xb0, 0x55, 0x6b,
	0x2e, 0x4b, 0xc6, 0x95, 0x3b, 0x00, 0xdf, 0x3a, 0x05, 0x4f, 0x1f, 0x90, 0x3e, 0xcc, 0xa9, 0xa4,
	0x40, 0x95, 0xcd, 0x54, 0xd1, 0xd9, 0x4c, 0xe3, 0xf3, 0xac, 0x0c, 0x2a, 0xd5, 0x46, 0x82, 0x4a,
	0x87, 0x99, 0xe0, 0x47, 0x3a, 0x4c, 0x44, 0x00, 0x6d, 0xc7, 0xd4, 0x88, 0x3a, 0x99, 0x4a, 0x09,
	0xf8, 0x7f, 0x85, 0xbb, 0xb8, 0xc8, 0x05, 0x05, 0x13, 0x6e, 0x98, 0x0d, 0xc4, 0xe4, 0x3e, 0x68,
	0xda, 0x2a, 0xfa, 0x54, 0x2a, 0xf7, 0x81, 0x36, 0x96, 0xcb, 0x00, 0xb1, 0x38, 0xde, 0xe4, 0x27,
	0xd6, 0x41, 0xc2, 0xc2, 0xac, 0x7c, 0x08, 0xf3, 0x46, 0x64, 0xaa, 0x0e, 0x68, 0xc1, 0x8b, 0xf4,
	0x28, 0x8e, 0xde, 0xa8, 0x05, 0xe1, 0x90, 0x47, 0xe6, 0x06, 0x09, 0xb7, 0x06, 0x83, 0x30, 0x6e,
	0xa5, 0x85, 0x62, 0xd7, 0x60, 0x89, 0xc0, 0xcd, 0xb0, 0xd3, 0x09, 0x5b, 0x83, 0x48, 0xef, 0x3f,
	0x23, 0x58, 0xff, 0x2b, 0x58, 0x72, 0xdf, 0xdd, 0x3c, 0x87, 0xab, 0xec, 0xc1, 0x5c, 0x4f, 0x44,
	0xa9, 0xbe, 0x74, 0xa8, 0x07, 0x1a, 0xf4, 0xbf, 0x84, 0xa6, 0x9d, 0xf5, 0xfc, 0x9d, 0xea, 0x16,
	0xb0, 0xe8, 0xbc, 0x19, 0x7c, 0x0e, 0xe5, 0x74, 0x29, 0x29, 0x1f, 0xb8, 0x88, 0xf2, 0xf8, 0xe9,
	0xe0, 0xfc, 0x0d, 0x38, 0x37, 0x92, 0xf0, 0x3e, 0x7d, 0x41, 0xfe, 0xaf, 0x2b, 0x00, 0x65, 0xca,
	0x08, 0x65, 0xdf, 0x8b, 0xe2, 0x31, 0x9a, 0x76, 0xed, 0x68, 0x94, 0x08, 0x76, 0x15, 0x16, 0xf3,
	0x41, 0x96, 0x46, 0x83, 0x5c, 0x71, 0x48, 0x5d, 0x2e, 0x92, 0xdd, 0x2e, 0xf3, 0x52, 0xac, 0x43,
	0x5e, 0x59, 0x88, 0xfa, 0xd4, 0x59, 0x68, 0x8a, 0x77, 0xe5, 0x01, 0x34, 0x6d, 0xc2, 0x84, 0x09,
	0x79, 0xd5, 0x35, 0x28, 0x56, 0xba, 0xcb, 0x48, 0xba, 0x04, 0xdd, 0xfc, 0x94, 0x14, 0x6c, 0xd5,
	0x20, 0x17, 0x6e, 0xab, 0x0c, 0xc2, 0xae, 0x6f, 0x75, 0xb4, 0xbe, 0x28, 0x7e, 0x4a, 0x7d, 0xef,
	0x3e, 0xb3, 0xbe, 0xa7, 0x2f, 0xa0, 0x7f, 0xaf, 0x41, 0xed, 0x9e, 0x74, 0x83, 0x5b, 0xed, 0x3d,
	0xf4, 0x63, 0x49, 0xae, 0x16, 0x68, 0x90, 0xa2, 0xce, 0xed, 0xad, 0xb8, 0x6d, 0xc2, 0xfe, 0x08,
	0xb0, 0x55, 0x98, 0xeb, 0xc8, 0x50, 0x90, 0xea, 0xda, 0x8b, 0xea, 0xb1, 0x8e, 0xce, 0xcf, 0x50,
	0x75, 0x54, 0x4c, 0xec, 0x3d, 0x2b, 0x33, 0x6c, 0xa6, 0x34, 0xeb, 0x28, 0x70, 0x5a, 0x52, 0xd8,
	0xab, 0x64, 0xd1, 0xea, 0xe5, 0x95, 0x13, 0x32, 0xef, 0x0e, 0x25, 0x1b, 0x9a, 0xb8, 0x37, 0xcd,
	0xbe, 0x37, 0x4b, 0x4c, 0x17, 0x1c, 0x8d, 0x23, 0xdb, 0xde, 0x5d, 0x68, 0xda, 0x35, 0x9b, 0x36,
	0xb7, 0xf8, 0xf9, 0x13, 0x3b, 0x6e, 0xc3, 0x9c, 0xaa, 0xf4, 0x54, 0x62, 0xdb, 0xcf, 0xda, 0xa6,
	0x27, 0x25, 0x83, 0xdc, 0x0b, 0x8b, 0x31, 0xaf, 0x64, 0x15, 0x1a, 0x1a, 0x3d, 0xb6, 0x49, 0x4c,
	0x88, 0x35, 0xf9, 0x2d, 0x58, 0x74, 0x52, 0xb4, 0xdd, 0x13, 0x4f, 0xe5, 0x5b, 0x4e, 0x3c, 0x55,
	0xe7, 0xc4, 0x23, 0x83, 0x56, 0x5b, 0x4f, 0xd3, 0x30, 0xb3, 0x82, 0x56, 0x12, 0xf6, 0x7f, 0x8a,
	0x86, 0xc9, 0x7e, 0x36, 0x77, 0x19, 0x20, 0xcc, 0xcd, 0xfb, 0x80, 0x0a, 0xb1, 0x5b, 0x18, 0x3a,
	0x0c, 0xf0, 0x93, 0x5c, 0xb9, 0xee, 0xf4, 0x8d, 0x45, 0x27, 0xa9, 0x88, 0xa5, 0x23, 0x4d, 0x45,
	0x2b, 0xd0, 0xcf, 0xa0, 0x69, 0x3f, 0xb6, 0xa3, 0x17, 0xe5, 0xe8, 0xb6, 0xcb, 0xb7, 0x3c, 0x15,
	0xf5, 0xa2, 0xdc, 0x60, 0xca, 0x77, 0xe8, 0x55, 0xfb, 0x1d, 0xfa, 0x25, 0x98, 0xcd, 0xe4, 0x8b,
	0x4e, 0x99, 0x0c, 0xa1, 0x20, 0x5a, 0x11, 0x27, 0xad, 0xc8, 0xdc, 0xac, 0x10, 0xe0, 0xbf, 0x0f,
	0x0d, 0xfd, 0xdc, 0x8e, 0xf4, 0xe5, 0xeb, 0x83, 0x13, 0xd5, 0x10, 0x09, 0xe0, 0x18, 0x86, 0x6d,
	0xdd, 0x04, 0xfc, 0xf4, 0x7f, 0x57, 0x81, 0x65, 0xfd, 0xf2, 0x6e, 0x9f, 0xe7, 0x47, 0xd4, 0xdf,
	0xcb, 0x50, 0x4b, 0x62, 0x7d, 0x30, 0xc3, 0x4f, 0xf6, 0x0e, 0xd4, 0x8a, 0xe3, 0x44, 0xd9, 0x84,
	0x57, 0xec, 0xe7, 0x7a, 0x5a, 0x68, 0x75, 0xff, 0x58, 0x3d, 0xdd, 0x41, 0x4e, 0x76, 0x1b, 0xea,
	0x45, 0x2f, 0x13, 0xc2, 0x3e, 0x60, 0x8c, 0x8b, 0x20, 0x87, 0x72, 0x44, 0x88, 0x7b, 0xe5, 0x03,
	0x68, 0x68, 0x3d, 0x53, 0xcd, 0xd5, 0x3b, 0x00, 0xa5, 0xb2, 0xa9, 0xcc, 0xcf, 0xd7, 0x6e, 0xfb,
	0xc9, 0xf2, 0x5f, 0x83, 0xda, 0x90, 0x47, 0x2a, 0x11, 0xe1, 0xe2, 0xa4, 0xaa, 0x07, 0xc8, 0x80,
	0xc3, 0xd3, 0x09, 0xe3, 0x30, 0x97, 0x81, 0xf7, 0x46, 0xa0, 0x20, 0x67, 0xd8, 0x08, 0x2f, 0x21,
	0xff, 0x2f, 0x2b, 0xd0, 0xb4, 0x35, 0xb1, 0x55, 0xf5, 0x5e, 0xdd, 0x3a, 0x82, 0xdb, 0x74, 0x7a,
	0xbc, 0xae, 0xbd, 0x18, 0x9e, 0x1f, 0xad, 0x3c, 0x84, 0x79, 0x83, 0x3a, 0x63, 0x26, 0xdd, 0x68,
	0xe3, 0xec, 0xb6, 0x7f, 0x0a, 0x4b, 0xe6, 0xd5, 0xa5, 0x99, 0x58, 0x22, 0x0a, 0x0b, 0x3d, 0xff,
	0x25, 0x80, 0xed, 0x89, 0x06, 0x4f, 0x07, 0xd9, 0x89, 0x6e, 0xa7, 0x84, 0xfc, 0x7f, 0x9a, 0x81,
	0x86, 0x56, 0x70, 0x06, 0xf7, 0xef, 0x12, 0xcc, 0xe6, 0x82, 0xe7, 0xe6, 0x12, 0x5a, 0x41, 0xee,
	0xf2, 0x9e, 0xf9, 0x96, 0xe5, 0x5d, 0x9f, 0xb0, 0xbc, 0x77, 0x65, 0xc5, 0x66, 0xf5, 0xf2, 0x96,
	0x30, 0xbb, 0xaa, 0x7a, 0x76, 0xae, 0xcc, 0xcb, 0xb4, 0x7b, 0x42, 0xfd, 0x15, 0xc0, 0x07, 0xd0,
	0x10, 0x4f, 0xd5, 0x9d, 0x7e, 0x63, 0x7c, 0x0c, 0x56, 0xb7, 0x14, 0x51, 0x6d, 0x0c, 0x9a, 0x17,
	0xe5, 0x8e, 0x85, 0x38, 0x42, 0x4d, 0x76, 0x96, 0xb8, 0x91, 0x3b, 0x50, 0x44, 0x25, 0xa7, 0x79,
	0xd9, 0xbb, 0x66, 0x62, 0x40, 0x99, 0xc2, 0x6d, 0xa4, 0xe4, 0x18, 0xa8, 0x4d, 0x43, 0xf2, 0xa1,
	0xe1, 0x77, 0x2a, 0x31, 0xd5, 0xaa, 0x78, 0x08, 0x8b, 0x4e, 0x4d, 0x26, 0x08, 0x5f, 0x73, 0xa7,
	0xcc, 0x78, 0x47, 0x39, 0xea, 0x16, 0xac, 0x2a, 0x4e, 0x50, 0x76, 0xdd, 0x55, 0xc6, 0x9c, 0x67,
	0xbd, 0x24, 0x69, 0xcf, 0xbe, 0xff, 0xae, 0x42, 0x6d, 0x2b, 0xea, 0x9c, 0x61, 0xe2, 0x94, 0xdb,
	0x6c, 0xad, 0xdc, 0x66, 0xb7, 0xa2, 0xce, 0xa4, 0x6d, 0xf6, 0xb4, 0x7d, 0xde, 0xb0, 0x4f, 0xd8,
	0xe7, 0x3f, 0x81, 0x66, 0x26, 0x1d, 0xc9, 0xdd, 0xb0, 0x1f, 0x16, 0x6a, 0xc7, 0x7f, 0x49, 0x8b,
	0x05, 0x16, 0x4d, 0xbd, 0x71, 0xb3, 0xd9, 0x7f, 0x8f, 0xf3, 0xec, 0xef, 0xb7, 0xaf, 0x7f, 0x06,
	0xe7, 0xc7, 0xaa, 0x36, 0x95, 0xed, 0xfb, 0xcf, 0x0a, 0x2c, 0xc9, 0xa7, 0xc3, 0xe6, 0xcc, 0x72,
	0x09, 0x66, 0x9d, 0xe3, 0x8a, 0x82, 0xac, 0x9c, 0xb5, 0xaa, 0x93, 0xb3, 0xf6, 0x08, 0x96, 0x3a,
	0xa4, 0x41, 0x67, 0x2e, 0xab, 0x21, 0xba, 0x46, 0xce, 0x80, 0xa3, 0x5b, 0x81, 0x9a, 0x51, 0xa5,
	0xc2, 0xbb, 0xd2, 0x2b, 0x4f, 0xe0, 0xc2, 0x04, 0xb6, 0x33, 0xce, 0x35, 0x57, 0xd2, 0x6e, 0xe9,
	0x9f, 0xd7, 0x74, 0x4b, 0xcd, 0x0b, 0x98, 0x0f, 0xcc, 0x3b, 0x96, 0x4a, 0x99, 0x10, 0xe7, 0xf2,
	0x4c, 0x7c, 0xcd, 0x72, 0x53, 0xa7, 0x2c, 0x58, 0x9b, 0xe1, 0x88, 0xd8, 0x78, 0xe2, 0x82, 0x4a,
	0xe1, 0xab, 0x8d, 0x3d, 0xac, 0x99, 0x29, 0x53, 0x07, 0x97, 0x94, 0xb7, 0xa9, 0xd7, 0x81, 0x15,
	0x4b, 0x9e, 0x3d, 0x3d, 0x96, 0x6c, 0xf2, 0x12, 0xe7, 0xac, 0xbc, 0xc4, 0x72, 0xb4, 0x1a, 0xf6,
	0x68, 0x7d, 0x87, 0x99, 0xe2, 0xcf, 0x9d, 0x42, 0xe1, 0xff, 0x59, 0x05, 0x96, 0xed, 0x27, 0xf5,
	0xe4, 0x71, 0xdc, 0xd6, 0x59, 0x48, 0x95, 0xd2, 0x5d, 0x18, 0x65, 0x5a, 0xb5, 0xb2, 0xf1, 0x25,
	0x37, 0xd6, 0xe2, 0xf9, 0x52, 0x6a, 0xfd, 0x5f, 0x55, 0xa0, 0x69, 0x17, 0x40, 0x9b, 0xd3, 0x20,
	0x2c, 0xca, 0x89, 0x2f, 0x21, 0x76, 0xcb, 0x4c, 0x93, 0x6a, 0x19, 0x5b, 0xb4, 0x25, 0x27, 0x4d,
	0x92, 0x95, 0x2f, 0x9e, 0xd5, 0xd1, 0x93, 0xb6, 0xea, 0xd1, 0x06, 0xdb, 0xf5, 0xfd, 0x75, 0x05,
	0x9a, 0xf6, 0x73, 0xfa, 0xd2, 0x05, 0xac, 0x58, 0x2e, 0x20, 0xbb, 0x6b, 0xfd, 0x21, 0x41, 0xb5,
	0x9c, 0xd6, 0xb6, 0xe4, 0xaa, 0xfe, 0x50, 0x56, 0xd0, 0xfc, 0x61, 0x81, 0x07, 0x73, 0x99, 0x39,
	0x62, 0xd3, 0xbf, 0x67, 0x28, 0x10, 0x37, 0xda, 0x22, 0x69, 0xf3, 0x93, 0xc7, 0xea, 0x5a, 0xa3,
	0x1e, 0x18, 0x18, 0x2d, 0x98, 0xa3, 0x70, 0xaa, 0x51, 0xf8, 0x29, 0x2c, 0x3e, 0xe6, 0xc9, 0x43,
	0xbe, 0x29, 0xe2, 0xee, 0xa9, 0x77, 0x02, 0xe8, 0x3a, 0x63, 0xe3, 0x70, 0xcf, 0xd7, 0xc7, 0x6c,
	0x0b, 0x43, 0x07, 0xc7, 0x24, 0x2e, 0xca, 0x67, 0x6f, 0x1a, 0xf4, 0x77, 0xa0, 0x69, 0xd4, 0x3f,
	0x2a, 0x3a, 0xec, 0x23, 0x58, 0x72, 0x8a, 0x73, 0x72, 0x3f, 0x1d, 0x4a, 0x30, 0xc2, 0xe8, 0xef,
	0x43, 0xd3, 0x7e, 0xd7, 0x31, 0xf5, 0xa5, 0xcd, 0xc4, 0xd0, 0x97, 0xff, 0x0d, 0xd4, 0xe9, 0xb9,
	0xbd, 0x7d, 0x77, 0x57, 0x71, 0xef, 0xee, 0x1c, 0xe7, 0xa8, 0xfa, 0x2d, 0xce, 0x51, 0xcd, 0x75,
	0x8e, 0x2e, 0xc1, 0x6c, 0x98, 0xef, 0x26, 0x89, 0x0c, 0xab, 0x35, 0x02, 0x05, 0xf9, 0x47, 0x70,
	0x8e, 0x2e, 0xaf, 0xf6, 0x64, 0x66, 0xb0, 0x7a, 0x08, 0x69, 0xf2, 0x86, 0x2b, 0x23, 0x79, 0xc3,
	0x97, 0x01, 0xe4, 0xb7, 0xf5, 0x4f, 0x5e, 0x16, 0x86, 0x2e, 0x46, 0xb3, 0x24, 0xcf, 0xef, 0xe5,
	0xe6, 0xde, 0xb3, 0x44, 0xf8, 0x7d, 0xa8, 0xd3, 0x63, 0x6f, 0xfb, 0x06, 0xb2, 0xe2, 0xde, 0x40,
	0x8e, 0x3f, 0x39, 0xc4, 0xd9, 0x96, 0xf1, 0x38, 0xef, 0x94, 0x77, 0xba, 0x1a, 0xc6, 0xe2, 0xda,
	0xfc, 0x44, 0xfd, 0xcb, 0x8d, 0x6c, 0x58, 0x89, 0x58, 0x5f, 0xfe, 0xd7, 0xdf, 0x5e, 0xae, 0xfc,
	0xdb, 0x6f, 0x2f, 0x57, 0x7e, 0xf3, 0xdb, 0xcb, 0x95, 0xbf, 0xf9, 0x8f, 0xcb, 0xff, 0xef, 0x70,
	0x96, 0xfe, 0xf5, 0xec, 0xe6, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x1a, 0xd1, 0x9e, 0x85, 0x05,
	0x4d, 0x00, 0x00,
}
