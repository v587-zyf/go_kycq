// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ancientTreasures.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AncientTreasuresLoadReq struct {
}

func (m *AncientTreasuresLoadReq) Reset()         { *m = AncientTreasuresLoadReq{} }
func (m *AncientTreasuresLoadReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresLoadReq) ProtoMessage()    {}
func (*AncientTreasuresLoadReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{0}
}

type AncientTreasuresLoadAck struct {
	AncientTreasuresInfos map[int32]*AncientTreasuresInfo `protobuf:"bytes,1,rep,name=AncientTreasuresInfos" json:"AncientTreasuresInfos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AncientTreasuresLoadAck) Reset()         { *m = AncientTreasuresLoadAck{} }
func (m *AncientTreasuresLoadAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresLoadAck) ProtoMessage()    {}
func (*AncientTreasuresLoadAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{1}
}

func (m *AncientTreasuresLoadAck) GetAncientTreasuresInfos() map[int32]*AncientTreasuresInfo {
	if m != nil {
		return m.AncientTreasuresInfos
	}
	return nil
}

type AncientTreasuresInfo struct {
	ZhuLinLv    int32 `protobuf:"varint,1,opt,name=zhuLinLv,proto3" json:"zhuLinLv,omitempty"`
	StarLv      int32 `protobuf:"varint,2,opt,name=starLv,proto3" json:"starLv,omitempty"`
	IsAwakening int32 `protobuf:"varint,3,opt,name=isAwakening,proto3" json:"isAwakening,omitempty"`
	Types       int32 `protobuf:"varint,4,opt,name=types,proto3" json:"types,omitempty"`
}

func (m *AncientTreasuresInfo) Reset()         { *m = AncientTreasuresInfo{} }
func (m *AncientTreasuresInfo) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresInfo) ProtoMessage()    {}
func (*AncientTreasuresInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{2}
}

func (m *AncientTreasuresInfo) GetZhuLinLv() int32 {
	if m != nil {
		return m.ZhuLinLv
	}
	return 0
}

func (m *AncientTreasuresInfo) GetStarLv() int32 {
	if m != nil {
		return m.StarLv
	}
	return 0
}

func (m *AncientTreasuresInfo) GetIsAwakening() int32 {
	if m != nil {
		return m.IsAwakening
	}
	return 0
}

func (m *AncientTreasuresInfo) GetTypes() int32 {
	if m != nil {
		return m.Types
	}
	return 0
}

// 远古宝物 激活
type AncientTreasuresActivateReq struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresActivateReq) Reset()         { *m = AncientTreasuresActivateReq{} }
func (m *AncientTreasuresActivateReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresActivateReq) ProtoMessage()    {}
func (*AncientTreasuresActivateReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{3}
}

func (m *AncientTreasuresActivateReq) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

type AncientTreasuresActivateAck struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresActivateAck) Reset()         { *m = AncientTreasuresActivateAck{} }
func (m *AncientTreasuresActivateAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresActivateAck) ProtoMessage()    {}
func (*AncientTreasuresActivateAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{4}
}

func (m *AncientTreasuresActivateAck) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

// 远古宝物 注灵
type AncientTreasuresZhuLinReq struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresZhuLinReq) Reset()         { *m = AncientTreasuresZhuLinReq{} }
func (m *AncientTreasuresZhuLinReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresZhuLinReq) ProtoMessage()    {}
func (*AncientTreasuresZhuLinReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{5}
}

func (m *AncientTreasuresZhuLinReq) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

type AncientTreasuresZhuLinAck struct {
	ZhuLinLv   int32 `protobuf:"varint,1,opt,name=zhuLinLv,proto3" json:"zhuLinLv,omitempty"`
	TreasureId int32 `protobuf:"varint,2,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresZhuLinAck) Reset()         { *m = AncientTreasuresZhuLinAck{} }
func (m *AncientTreasuresZhuLinAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresZhuLinAck) ProtoMessage()    {}
func (*AncientTreasuresZhuLinAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{6}
}

func (m *AncientTreasuresZhuLinAck) GetZhuLinLv() int32 {
	if m != nil {
		return m.ZhuLinLv
	}
	return 0
}

func (m *AncientTreasuresZhuLinAck) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

// 远古宝物 升星
type AncientTreasuresUpStarReq struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresUpStarReq) Reset()         { *m = AncientTreasuresUpStarReq{} }
func (m *AncientTreasuresUpStarReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresUpStarReq) ProtoMessage()    {}
func (*AncientTreasuresUpStarReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{7}
}

func (m *AncientTreasuresUpStarReq) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

type AncientTreasuresUpStarAck struct {
	StarLv     int32 `protobuf:"varint,1,opt,name=starLv,proto3" json:"starLv,omitempty"`
	TreasureId int32 `protobuf:"varint,2,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresUpStarAck) Reset()         { *m = AncientTreasuresUpStarAck{} }
func (m *AncientTreasuresUpStarAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresUpStarAck) ProtoMessage()    {}
func (*AncientTreasuresUpStarAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{8}
}

func (m *AncientTreasuresUpStarAck) GetStarLv() int32 {
	if m != nil {
		return m.StarLv
	}
	return 0
}

func (m *AncientTreasuresUpStarAck) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

// 觉醒
type AncientTreasuresJueXingReq struct {
	TreasureId      int32   `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
	ChooseItemInfos []int32 `protobuf:"varint,2,rep,packed,name=chooseItemInfos" json:"chooseItemInfos,omitempty"`
	Index           int32   `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *AncientTreasuresJueXingReq) Reset()         { *m = AncientTreasuresJueXingReq{} }
func (m *AncientTreasuresJueXingReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresJueXingReq) ProtoMessage()    {}
func (*AncientTreasuresJueXingReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{9}
}

func (m *AncientTreasuresJueXingReq) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

func (m *AncientTreasuresJueXingReq) GetChooseItemInfos() []int32 {
	if m != nil {
		return m.ChooseItemInfos
	}
	return nil
}

func (m *AncientTreasuresJueXingReq) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type AncientTreasuresJueXingAck struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresJueXingAck) Reset()         { *m = AncientTreasuresJueXingAck{} }
func (m *AncientTreasuresJueXingAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresJueXingAck) ProtoMessage()    {}
func (*AncientTreasuresJueXingAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{10}
}

func (m *AncientTreasuresJueXingAck) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

// 远古宝物重置
type AncientTreasuresResertReq struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresResertReq) Reset()         { *m = AncientTreasuresResertReq{} }
func (m *AncientTreasuresResertReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresResertReq) ProtoMessage()    {}
func (*AncientTreasuresResertReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{11}
}

func (m *AncientTreasuresResertReq) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

type AncientTreasuresResertAck struct {
	TreasureId int32 `protobuf:"varint,1,opt,name=treasureId,proto3" json:"treasureId,omitempty"`
}

func (m *AncientTreasuresResertAck) Reset()         { *m = AncientTreasuresResertAck{} }
func (m *AncientTreasuresResertAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresResertAck) ProtoMessage()    {}
func (*AncientTreasuresResertAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{12}
}

func (m *AncientTreasuresResertAck) GetTreasureId() int32 {
	if m != nil {
		return m.TreasureId
	}
	return 0
}

type AncientTreasuresCondotionInfosReq struct {
}

func (m *AncientTreasuresCondotionInfosReq) Reset()         { *m = AncientTreasuresCondotionInfosReq{} }
func (m *AncientTreasuresCondotionInfosReq) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresCondotionInfosReq) ProtoMessage()    {}
func (*AncientTreasuresCondotionInfosReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{13}
}

type AncientTreasuresCondotionInfosAck struct {
	AncientTreasureConditionInfos map[int32]int32 `protobuf:"bytes,1,rep,name=ancientTreasureConditionInfos" json:"ancientTreasureConditionInfos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AncientTreasuresCondotionInfosAck) Reset()         { *m = AncientTreasuresCondotionInfosAck{} }
func (m *AncientTreasuresCondotionInfosAck) String() string { return proto.CompactTextString(m) }
func (*AncientTreasuresCondotionInfosAck) ProtoMessage()    {}
func (*AncientTreasuresCondotionInfosAck) Descriptor() ([]byte, []int) {
	return fileDescriptorAncientTreasures, []int{14}
}

func (m *AncientTreasuresCondotionInfosAck) GetAncientTreasureConditionInfos() map[int32]int32 {
	if m != nil {
		return m.AncientTreasureConditionInfos
	}
	return nil
}

func init() {
	proto.RegisterType((*AncientTreasuresLoadReq)(nil), "pb.AncientTreasuresLoadReq")
	proto.RegisterType((*AncientTreasuresLoadAck)(nil), "pb.AncientTreasuresLoadAck")
	proto.RegisterType((*AncientTreasuresInfo)(nil), "pb.AncientTreasuresInfo")
	proto.RegisterType((*AncientTreasuresActivateReq)(nil), "pb.AncientTreasuresActivateReq")
	proto.RegisterType((*AncientTreasuresActivateAck)(nil), "pb.AncientTreasuresActivateAck")
	proto.RegisterType((*AncientTreasuresZhuLinReq)(nil), "pb.AncientTreasuresZhuLinReq")
	proto.RegisterType((*AncientTreasuresZhuLinAck)(nil), "pb.AncientTreasuresZhuLinAck")
	proto.RegisterType((*AncientTreasuresUpStarReq)(nil), "pb.AncientTreasuresUpStarReq")
	proto.RegisterType((*AncientTreasuresUpStarAck)(nil), "pb.AncientTreasuresUpStarAck")
	proto.RegisterType((*AncientTreasuresJueXingReq)(nil), "pb.AncientTreasuresJueXingReq")
	proto.RegisterType((*AncientTreasuresJueXingAck)(nil), "pb.AncientTreasuresJueXingAck")
	proto.RegisterType((*AncientTreasuresResertReq)(nil), "pb.AncientTreasuresResertReq")
	proto.RegisterType((*AncientTreasuresResertAck)(nil), "pb.AncientTreasuresResertAck")
	proto.RegisterType((*AncientTreasuresCondotionInfosReq)(nil), "pb.AncientTreasuresCondotionInfosReq")
	proto.RegisterType((*AncientTreasuresCondotionInfosAck)(nil), "pb.AncientTreasuresCondotionInfosAck")
}
func (m *AncientTreasuresLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AncientTreasuresLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AncientTreasuresInfos) > 0 {
		for k, _ := range m.AncientTreasuresInfos {
			dAtA[i] = 0xa
			i++
			v := m.AncientTreasuresInfos[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAncientTreasures(uint64(msgSize))
			}
			mapSize := 1 + sovAncientTreasures(uint64(k)) + msgSize
			i = encodeVarintAncientTreasures(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintAncientTreasures(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAncientTreasures(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *AncientTreasuresInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.ZhuLinLv))
	}
	if m.StarLv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.StarLv))
	}
	if m.IsAwakening != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.IsAwakening))
	}
	if m.Types != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.Types))
	}
	return i, nil
}

func (m *AncientTreasuresActivateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresActivateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresActivateAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresActivateAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresZhuLinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresZhuLinReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresZhuLinAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresZhuLinAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.ZhuLinLv))
	}
	if m.TreasureId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresUpStarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresUpStarReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresUpStarAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresUpStarAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarLv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.StarLv))
	}
	if m.TreasureId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresJueXingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresJueXingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	if len(m.ChooseItemInfos) > 0 {
		dAtA3 := make([]byte, len(m.ChooseItemInfos)*10)
		var j2 int
		for _, num1 := range m.ChooseItemInfos {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.Index != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.Index))
	}
	return i, nil
}

func (m *AncientTreasuresJueXingAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresJueXingAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresResertReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresResertReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresResertAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresResertAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAncientTreasures(dAtA, i, uint64(m.TreasureId))
	}
	return i, nil
}

func (m *AncientTreasuresCondotionInfosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresCondotionInfosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AncientTreasuresCondotionInfosAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientTreasuresCondotionInfosAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AncientTreasureConditionInfos) > 0 {
		for k, _ := range m.AncientTreasureConditionInfos {
			dAtA[i] = 0xa
			i++
			v := m.AncientTreasureConditionInfos[k]
			mapSize := 1 + sovAncientTreasures(uint64(k)) + 1 + sovAncientTreasures(uint64(v))
			i = encodeVarintAncientTreasures(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintAncientTreasures(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintAncientTreasures(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeVarintAncientTreasures(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AncientTreasuresLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AncientTreasuresLoadAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AncientTreasuresInfos) > 0 {
		for k, v := range m.AncientTreasuresInfos {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAncientTreasures(uint64(l))
			}
			mapEntrySize := 1 + sovAncientTreasures(uint64(k)) + l
			n += mapEntrySize + 1 + sovAncientTreasures(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AncientTreasuresInfo) Size() (n int) {
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		n += 1 + sovAncientTreasures(uint64(m.ZhuLinLv))
	}
	if m.StarLv != 0 {
		n += 1 + sovAncientTreasures(uint64(m.StarLv))
	}
	if m.IsAwakening != 0 {
		n += 1 + sovAncientTreasures(uint64(m.IsAwakening))
	}
	if m.Types != 0 {
		n += 1 + sovAncientTreasures(uint64(m.Types))
	}
	return n
}

func (m *AncientTreasuresActivateReq) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresActivateAck) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresZhuLinReq) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresZhuLinAck) Size() (n int) {
	var l int
	_ = l
	if m.ZhuLinLv != 0 {
		n += 1 + sovAncientTreasures(uint64(m.ZhuLinLv))
	}
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresUpStarReq) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresUpStarAck) Size() (n int) {
	var l int
	_ = l
	if m.StarLv != 0 {
		n += 1 + sovAncientTreasures(uint64(m.StarLv))
	}
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresJueXingReq) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	if len(m.ChooseItemInfos) > 0 {
		l = 0
		for _, e := range m.ChooseItemInfos {
			l += sovAncientTreasures(uint64(e))
		}
		n += 1 + sovAncientTreasures(uint64(l)) + l
	}
	if m.Index != 0 {
		n += 1 + sovAncientTreasures(uint64(m.Index))
	}
	return n
}

func (m *AncientTreasuresJueXingAck) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresResertReq) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresResertAck) Size() (n int) {
	var l int
	_ = l
	if m.TreasureId != 0 {
		n += 1 + sovAncientTreasures(uint64(m.TreasureId))
	}
	return n
}

func (m *AncientTreasuresCondotionInfosReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AncientTreasuresCondotionInfosAck) Size() (n int) {
	var l int
	_ = l
	if len(m.AncientTreasureConditionInfos) > 0 {
		for k, v := range m.AncientTreasureConditionInfos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAncientTreasures(uint64(k)) + 1 + sovAncientTreasures(uint64(v))
			n += mapEntrySize + 1 + sovAncientTreasures(uint64(mapEntrySize))
		}
	}
	return n
}

func sovAncientTreasures(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAncientTreasures(x uint64) (n int) {
	return sovAncientTreasures(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AncientTreasuresLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncientTreasuresInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AncientTreasuresInfos == nil {
				m.AncientTreasuresInfos = make(map[int32]*AncientTreasuresInfo)
			}
			var mapkey int32
			var mapvalue *AncientTreasuresInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAncientTreasures
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAncientTreasures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAncientTreasures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAncientTreasures
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAncientTreasures
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AncientTreasuresInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAncientTreasures(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAncientTreasures
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AncientTreasuresInfos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhuLinLv", wireType)
			}
			m.ZhuLinLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZhuLinLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarLv", wireType)
			}
			m.StarLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAwakening", wireType)
			}
			m.IsAwakening = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsAwakening |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			m.Types = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Types |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresActivateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresActivateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresActivateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresActivateAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresActivateAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresActivateAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresZhuLinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresZhuLinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresZhuLinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresZhuLinAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresZhuLinAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresZhuLinAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhuLinLv", wireType)
			}
			m.ZhuLinLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZhuLinLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresUpStarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresUpStarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresUpStarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresUpStarAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresUpStarAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresUpStarAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarLv", wireType)
			}
			m.StarLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresJueXingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresJueXingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresJueXingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAncientTreasures
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChooseItemInfos = append(m.ChooseItemInfos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAncientTreasures
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAncientTreasures
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAncientTreasures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChooseItemInfos = append(m.ChooseItemInfos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseItemInfos", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresJueXingAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresJueXingAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresJueXingAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresResertReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresResertReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresResertReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresResertAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresResertAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresResertAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureId", wireType)
			}
			m.TreasureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresCondotionInfosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresCondotionInfosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresCondotionInfosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientTreasuresCondotionInfosAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientTreasuresCondotionInfosAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientTreasuresCondotionInfosAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncientTreasureConditionInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AncientTreasureConditionInfos == nil {
				m.AncientTreasureConditionInfos = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAncientTreasures
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAncientTreasures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAncientTreasures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAncientTreasures(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAncientTreasures
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AncientTreasureConditionInfos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAncientTreasures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAncientTreasures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAncientTreasures(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAncientTreasures
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAncientTreasures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAncientTreasures
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAncientTreasures
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAncientTreasures(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAncientTreasures = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAncientTreasures   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ancientTreasures.proto", fileDescriptorAncientTreasures) }

var fileDescriptorAncientTreasures = []byte{
	// 477 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x3d, 0x8f, 0xd3, 0x40,
	0x10, 0x65, 0x1d, 0x7c, 0x42, 0x93, 0x82, 0xd3, 0x2a, 0x1c, 0xbe, 0x20, 0x2c, 0x63, 0x1a, 0x57,
	0x2e, 0x0e, 0x09, 0x21, 0x3e, 0x8a, 0x80, 0x90, 0x08, 0x4a, 0x81, 0x7c, 0x20, 0x10, 0xdd, 0x26,
	0x19, 0xee, 0x56, 0x39, 0x76, 0x7d, 0xde, 0x4d, 0x20, 0x88, 0x8a, 0x82, 0x92, 0x9a, 0x9f, 0x44,
	0xc9, 0x4f, 0x40, 0xa1, 0xe4, 0x4f, 0xa0, 0xb5, 0xad, 0x23, 0xd9, 0xd8, 0xb1, 0x45, 0xe7, 0xf9,
	0x78, 0xf3, 0x9e, 0x77, 0x76, 0x1f, 0x1c, 0x30, 0x31, 0xe1, 0x28, 0xf4, 0xcb, 0x0c, 0x99, 0x9a,
	0x67, 0xa8, 0xe2, 0x34, 0x93, 0x5a, 0x52, 0x27, 0x1d, 0x87, 0x87, 0x70, 0x7d, 0x60, 0x55, 0x47,
	0x92, 0x4d, 0x13, 0x3c, 0x0f, 0xff, 0x90, 0xea, 0xda, 0x60, 0x32, 0xa3, 0x67, 0x70, 0xcd, 0x2e,
	0x0d, 0xc5, 0x3b, 0xa9, 0x3c, 0x12, 0x74, 0xa2, 0xee, 0xd1, 0xdd, 0x38, 0x1d, 0xc7, 0x35, 0xd8,
	0xb8, 0x12, 0xf8, 0x54, 0xe8, 0x6c, 0x99, 0x54, 0x0f, 0xed, 0x8f, 0xa1, 0x5f, 0x0f, 0xa2, 0xfb,
	0xd0, 0x99, 0xe1, 0xd2, 0x23, 0x01, 0x89, 0xdc, 0xc4, 0x7c, 0xd2, 0x18, 0xdc, 0x05, 0x3b, 0x9b,
	0xa3, 0xe7, 0x04, 0x24, 0xea, 0x1e, 0x79, 0x55, 0x6a, 0xcc, 0x80, 0xa4, 0x68, 0xbb, 0xef, 0xdc,
	0x23, 0xe1, 0x17, 0x02, 0xbd, 0xaa, 0x1e, 0xda, 0x87, 0x2b, 0x9f, 0x4e, 0xe7, 0x23, 0x2e, 0x46,
	0x8b, 0x92, 0xe3, 0x22, 0xa6, 0x07, 0xb0, 0xa7, 0x34, 0xcb, 0x46, 0x8b, 0x9c, 0xc9, 0x4d, 0xca,
	0x88, 0x06, 0xd0, 0xe5, 0x6a, 0xf0, 0x81, 0xcd, 0x50, 0x70, 0x71, 0xe2, 0x75, 0xf2, 0xe2, 0x7a,
	0x8a, 0xf6, 0xc0, 0xd5, 0xcb, 0x14, 0x95, 0x77, 0x39, 0xaf, 0x15, 0x41, 0xf8, 0x08, 0x6e, 0xd8,
	0x1a, 0x06, 0x13, 0xcd, 0x17, 0x4c, 0x63, 0x82, 0xe7, 0xd4, 0x07, 0xd0, 0x65, 0x7e, 0x38, 0x2d,
	0xc5, 0xac, 0x65, 0x76, 0xc1, 0xcd, 0xd2, 0x9a, 0xe0, 0x0f, 0xe0, 0xd0, 0x86, 0xbf, 0xcd, 0xff,
	0xb4, 0x0d, 0xf7, 0xeb, 0x3a, 0xb0, 0x61, 0xde, 0x75, 0x86, 0x9b, 0x83, 0x9d, 0x36, 0xaa, 0x5e,
	0xa5, 0xc7, 0x9a, 0x65, 0x6d, 0x54, 0x1d, 0xd7, 0x81, 0x8d, 0xaa, 0x7f, 0xdb, 0x23, 0x1b, 0xdb,
	0x6b, 0x52, 0xf4, 0x79, 0xfb, 0x3a, 0x3e, 0x9f, 0xe3, 0x1b, 0x2e, 0x4e, 0x5a, 0x48, 0xa2, 0x11,
	0x5c, 0x9d, 0x9c, 0x4a, 0xa9, 0x70, 0xa8, 0xf1, 0x7d, 0xf1, 0x68, 0x9c, 0xa0, 0x13, 0xb9, 0x89,
	0x9d, 0x36, 0x77, 0x84, 0x8b, 0x29, 0x7e, 0x2c, 0xef, 0x4f, 0x11, 0x84, 0x0f, 0x6b, 0xd9, 0xff,
	0x73, 0xc7, 0x09, 0x2a, 0xcc, 0x74, 0x9b, 0xd3, 0xac, 0x05, 0xb7, 0x61, 0xbe, 0x0d, 0xb7, 0x6c,
	0xf0, 0x13, 0x29, 0xa6, 0x52, 0x73, 0x29, 0xf2, 0xff, 0x35, 0x9e, 0xf3, 0xd5, 0x69, 0xea, 0x32,
	0x54, 0xdf, 0x08, 0xdc, 0xb4, 0x3c, 0xcd, 0x34, 0xf1, 0x8b, 0xa6, 0xd2, 0x86, 0x9e, 0x55, 0x3d,
	0xfc, 0xad, 0x71, 0x76, 0xc7, 0xe6, 0xa8, 0xc2, 0x98, 0x76, 0xd3, 0xf5, 0x5f, 0x40, 0xd8, 0x3c,
	0xa4, 0xc2, 0xa8, 0x7a, 0xeb, 0x46, 0xe5, 0xae, 0xd9, 0xd1, 0xe3, 0xfd, 0x1f, 0x2b, 0x9f, 0xfc,
	0x5c, 0xf9, 0xe4, 0xd7, 0xca, 0x27, 0xdf, 0x7f, 0xfb, 0x97, 0xc6, 0x7b, 0xb9, 0x69, 0xdf, 0xf9,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0x78, 0x0d, 0xac, 0x2e, 0xce, 0x05, 0x00, 0x00,
}
