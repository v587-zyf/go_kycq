// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: treasureShop.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 信息加载
type TreasureShopLoadReq struct {
}

func (m *TreasureShopLoadReq) Reset()                    { *m = TreasureShopLoadReq{} }
func (m *TreasureShopLoadReq) String() string            { return proto.CompactTextString(m) }
func (*TreasureShopLoadReq) ProtoMessage()               {}
func (*TreasureShopLoadReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasureShop, []int{0} }

type TreasureShopLoadAck struct {
	BuyNum      int32           `protobuf:"varint,1,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	RefreshFree bool            `protobuf:"varint,2,opt,name=refreshFree,proto3" json:"refreshFree,omitempty"`
	RefreshTime int64           `protobuf:"varint,3,opt,name=refreshTime,proto3" json:"refreshTime,omitempty"`
	Shop        map[int32]bool  `protobuf:"bytes,4,rep,name=shop" json:"shop,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Car         map[int32]int32 `protobuf:"bytes,5,rep,name=car" json:"car,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EndTime     int64           `protobuf:"varint,6,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *TreasureShopLoadAck) Reset()                    { *m = TreasureShopLoadAck{} }
func (m *TreasureShopLoadAck) String() string            { return proto.CompactTextString(m) }
func (*TreasureShopLoadAck) ProtoMessage()               {}
func (*TreasureShopLoadAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasureShop, []int{1} }

func (m *TreasureShopLoadAck) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *TreasureShopLoadAck) GetRefreshFree() bool {
	if m != nil {
		return m.RefreshFree
	}
	return false
}

func (m *TreasureShopLoadAck) GetRefreshTime() int64 {
	if m != nil {
		return m.RefreshTime
	}
	return 0
}

func (m *TreasureShopLoadAck) GetShop() map[int32]bool {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *TreasureShopLoadAck) GetCar() map[int32]int32 {
	if m != nil {
		return m.Car
	}
	return nil
}

func (m *TreasureShopLoadAck) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 变更购物车
type TreasureShopCarChangeReq struct {
	ShopId int32 `protobuf:"varint,1,opt,name=shopId,proto3" json:"shopId,omitempty"`
	IsAdd  bool  `protobuf:"varint,2,opt,name=isAdd,proto3" json:"isAdd,omitempty"`
}

func (m *TreasureShopCarChangeReq) Reset()         { *m = TreasureShopCarChangeReq{} }
func (m *TreasureShopCarChangeReq) String() string { return proto.CompactTextString(m) }
func (*TreasureShopCarChangeReq) ProtoMessage()    {}
func (*TreasureShopCarChangeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasureShop, []int{2}
}

func (m *TreasureShopCarChangeReq) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *TreasureShopCarChangeReq) GetIsAdd() bool {
	if m != nil {
		return m.IsAdd
	}
	return false
}

type TreasureShopCarChangeAck struct {
	Car    map[int32]int32 `protobuf:"bytes,1,rep,name=car" json:"car,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ShopId int32           `protobuf:"varint,2,opt,name=shopId,proto3" json:"shopId,omitempty"`
	IsAdd  bool            `protobuf:"varint,3,opt,name=isAdd,proto3" json:"isAdd,omitempty"`
	Shop   map[int32]bool  `protobuf:"bytes,4,rep,name=shop" json:"shop,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TreasureShopCarChangeAck) Reset()         { *m = TreasureShopCarChangeAck{} }
func (m *TreasureShopCarChangeAck) String() string { return proto.CompactTextString(m) }
func (*TreasureShopCarChangeAck) ProtoMessage()    {}
func (*TreasureShopCarChangeAck) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasureShop, []int{3}
}

func (m *TreasureShopCarChangeAck) GetCar() map[int32]int32 {
	if m != nil {
		return m.Car
	}
	return nil
}

func (m *TreasureShopCarChangeAck) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *TreasureShopCarChangeAck) GetIsAdd() bool {
	if m != nil {
		return m.IsAdd
	}
	return false
}

func (m *TreasureShopCarChangeAck) GetShop() map[int32]bool {
	if m != nil {
		return m.Shop
	}
	return nil
}

// 购买
type TreasureShopBuyReq struct {
	Shop []int32 `protobuf:"varint,1,rep,packed,name=shop" json:"shop,omitempty"`
}

func (m *TreasureShopBuyReq) Reset()                    { *m = TreasureShopBuyReq{} }
func (m *TreasureShopBuyReq) String() string            { return proto.CompactTextString(m) }
func (*TreasureShopBuyReq) ProtoMessage()               {}
func (*TreasureShopBuyReq) Descriptor() ([]byte, []int) { return fileDescriptorTreasureShop, []int{4} }

func (m *TreasureShopBuyReq) GetShop() []int32 {
	if m != nil {
		return m.Shop
	}
	return nil
}

type TreasureShopBuyAck struct {
	BuyNum int32           `protobuf:"varint,1,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	Goods  *GoodsChangeNtf `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
	Shop   map[int32]bool  `protobuf:"bytes,4,rep,name=shop" json:"shop,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Car    map[int32]int32 `protobuf:"bytes,5,rep,name=car" json:"car,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *TreasureShopBuyAck) Reset()                    { *m = TreasureShopBuyAck{} }
func (m *TreasureShopBuyAck) String() string            { return proto.CompactTextString(m) }
func (*TreasureShopBuyAck) ProtoMessage()               {}
func (*TreasureShopBuyAck) Descriptor() ([]byte, []int) { return fileDescriptorTreasureShop, []int{5} }

func (m *TreasureShopBuyAck) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *TreasureShopBuyAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *TreasureShopBuyAck) GetShop() map[int32]bool {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *TreasureShopBuyAck) GetCar() map[int32]int32 {
	if m != nil {
		return m.Car
	}
	return nil
}

// 手动刷新
type TreasureShopRefreshReq struct {
}

func (m *TreasureShopRefreshReq) Reset()         { *m = TreasureShopRefreshReq{} }
func (m *TreasureShopRefreshReq) String() string { return proto.CompactTextString(m) }
func (*TreasureShopRefreshReq) ProtoMessage()    {}
func (*TreasureShopRefreshReq) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasureShop, []int{6}
}

// 手动或自动刷新推送
type TreasureShopRefreshNtf struct {
	Shop        map[int32]bool  `protobuf:"bytes,1,rep,name=shop" json:"shop,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RefreshTime int64           `protobuf:"varint,2,opt,name=refreshTime,proto3" json:"refreshTime,omitempty"`
	Car         map[int32]int32 `protobuf:"bytes,3,rep,name=car" json:"car,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RefreshFree bool            `protobuf:"varint,4,opt,name=refreshFree,proto3" json:"refreshFree,omitempty"`
}

func (m *TreasureShopRefreshNtf) Reset()         { *m = TreasureShopRefreshNtf{} }
func (m *TreasureShopRefreshNtf) String() string { return proto.CompactTextString(m) }
func (*TreasureShopRefreshNtf) ProtoMessage()    {}
func (*TreasureShopRefreshNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasureShop, []int{7}
}

func (m *TreasureShopRefreshNtf) GetShop() map[int32]bool {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *TreasureShopRefreshNtf) GetRefreshTime() int64 {
	if m != nil {
		return m.RefreshTime
	}
	return 0
}

func (m *TreasureShopRefreshNtf) GetCar() map[int32]int32 {
	if m != nil {
		return m.Car
	}
	return nil
}

func (m *TreasureShopRefreshNtf) GetRefreshFree() bool {
	if m != nil {
		return m.RefreshFree
	}
	return false
}

func init() {
	proto.RegisterType((*TreasureShopLoadReq)(nil), "pb.TreasureShopLoadReq")
	proto.RegisterType((*TreasureShopLoadAck)(nil), "pb.TreasureShopLoadAck")
	proto.RegisterType((*TreasureShopCarChangeReq)(nil), "pb.TreasureShopCarChangeReq")
	proto.RegisterType((*TreasureShopCarChangeAck)(nil), "pb.TreasureShopCarChangeAck")
	proto.RegisterType((*TreasureShopBuyReq)(nil), "pb.TreasureShopBuyReq")
	proto.RegisterType((*TreasureShopBuyAck)(nil), "pb.TreasureShopBuyAck")
	proto.RegisterType((*TreasureShopRefreshReq)(nil), "pb.TreasureShopRefreshReq")
	proto.RegisterType((*TreasureShopRefreshNtf)(nil), "pb.TreasureShopRefreshNtf")
}
func (m *TreasureShopLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TreasureShopLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.BuyNum))
	}
	if m.RefreshFree {
		dAtA[i] = 0x10
		i++
		if m.RefreshFree {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RefreshTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.RefreshTime))
	}
	if len(m.Shop) > 0 {
		for k, _ := range m.Shop {
			dAtA[i] = 0x22
			i++
			v := m.Shop[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Car) > 0 {
		for k, _ := range m.Car {
			dAtA[i] = 0x2a
			i++
			v := m.Car[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(v))
		}
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *TreasureShopCarChangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopCarChangeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.ShopId))
	}
	if m.IsAdd {
		dAtA[i] = 0x10
		i++
		if m.IsAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TreasureShopCarChangeAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopCarChangeAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Car) > 0 {
		for k, _ := range m.Car {
			dAtA[i] = 0xa
			i++
			v := m.Car[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(v))
		}
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.ShopId))
	}
	if m.IsAdd {
		dAtA[i] = 0x18
		i++
		if m.IsAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Shop) > 0 {
		for k, _ := range m.Shop {
			dAtA[i] = 0x22
			i++
			v := m.Shop[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *TreasureShopBuyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopBuyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shop) > 0 {
		dAtA2 := make([]byte, len(m.Shop)*10)
		var j1 int
		for _, num1 := range m.Shop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *TreasureShopBuyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopBuyAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.BuyNum))
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.Goods.Size()))
		n3, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Shop) > 0 {
		for k, _ := range m.Shop {
			dAtA[i] = 0x22
			i++
			v := m.Shop[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Car) > 0 {
		for k, _ := range m.Car {
			dAtA[i] = 0x2a
			i++
			v := m.Car[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TreasureShopRefreshReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopRefreshReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TreasureShopRefreshNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreasureShopRefreshNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shop) > 0 {
		for k, _ := range m.Shop {
			dAtA[i] = 0xa
			i++
			v := m.Shop[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.RefreshTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasureShop(dAtA, i, uint64(m.RefreshTime))
	}
	if len(m.Car) > 0 {
		for k, _ := range m.Car {
			dAtA[i] = 0x1a
			i++
			v := m.Car[k]
			mapSize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			i = encodeVarintTreasureShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTreasureShop(dAtA, i, uint64(v))
		}
	}
	if m.RefreshFree {
		dAtA[i] = 0x20
		i++
		if m.RefreshFree {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintTreasureShop(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TreasureShopLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TreasureShopLoadAck) Size() (n int) {
	var l int
	_ = l
	if m.BuyNum != 0 {
		n += 1 + sovTreasureShop(uint64(m.BuyNum))
	}
	if m.RefreshFree {
		n += 2
	}
	if m.RefreshTime != 0 {
		n += 1 + sovTreasureShop(uint64(m.RefreshTime))
	}
	if len(m.Shop) > 0 {
		for k, v := range m.Shop {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if len(m.Car) > 0 {
		for k, v := range m.Car {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if m.EndTime != 0 {
		n += 1 + sovTreasureShop(uint64(m.EndTime))
	}
	return n
}

func (m *TreasureShopCarChangeReq) Size() (n int) {
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovTreasureShop(uint64(m.ShopId))
	}
	if m.IsAdd {
		n += 2
	}
	return n
}

func (m *TreasureShopCarChangeAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Car) > 0 {
		for k, v := range m.Car {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if m.ShopId != 0 {
		n += 1 + sovTreasureShop(uint64(m.ShopId))
	}
	if m.IsAdd {
		n += 2
	}
	if len(m.Shop) > 0 {
		for k, v := range m.Shop {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TreasureShopBuyReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Shop) > 0 {
		l = 0
		for _, e := range m.Shop {
			l += sovTreasureShop(uint64(e))
		}
		n += 1 + sovTreasureShop(uint64(l)) + l
	}
	return n
}

func (m *TreasureShopBuyAck) Size() (n int) {
	var l int
	_ = l
	if m.BuyNum != 0 {
		n += 1 + sovTreasureShop(uint64(m.BuyNum))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovTreasureShop(uint64(l))
	}
	if len(m.Shop) > 0 {
		for k, v := range m.Shop {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if len(m.Car) > 0 {
		for k, v := range m.Car {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TreasureShopRefreshReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TreasureShopRefreshNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.Shop) > 0 {
		for k, v := range m.Shop {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if m.RefreshTime != 0 {
		n += 1 + sovTreasureShop(uint64(m.RefreshTime))
	}
	if len(m.Car) > 0 {
		for k, v := range m.Car {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTreasureShop(uint64(k)) + 1 + sovTreasureShop(uint64(v))
			n += mapEntrySize + 1 + sovTreasureShop(uint64(mapEntrySize))
		}
	}
	if m.RefreshFree {
		n += 2
	}
	return n
}

func sovTreasureShop(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTreasureShop(x uint64) (n int) {
	return sovTreasureShop(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TreasureShopLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFree", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshFree = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTime", wireType)
			}
			m.RefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Shop[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Car", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Car == nil {
				m.Car = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Car[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopCarChangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopCarChangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopCarChangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopCarChangeAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopCarChangeAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopCarChangeAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Car", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Car == nil {
				m.Car = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Car[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Shop[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopBuyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopBuyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopBuyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shop = append(m.Shop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasureShop
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shop = append(m.Shop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopBuyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopBuyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopBuyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Shop[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Car", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Car == nil {
				m.Car = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Car[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopRefreshReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopRefreshReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopRefreshReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreasureShopRefreshNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreasureShopRefreshNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreasureShopRefreshNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Shop[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTime", wireType)
			}
			m.RefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Car", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasureShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Car == nil {
				m.Car = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasureShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTreasureShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTreasureShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Car[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFree", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshFree = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTreasureShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasureShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTreasureShop(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTreasureShop
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasureShop
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTreasureShop
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTreasureShop
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTreasureShop(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTreasureShop = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTreasureShop   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("treasureShop.proto", fileDescriptorTreasureShop) }

var fileDescriptorTreasureShop = []byte{
	// 494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x66, 0xd7, 0x71, 0x28, 0x1b, 0x0e, 0xd5, 0x02, 0xd5, 0x2a, 0x87, 0x60, 0xcc, 0x8f, 0x7c,
	0x8a, 0x84, 0xf9, 0x69, 0xd5, 0x5b, 0x1b, 0xf1, 0x27, 0xa1, 0x1c, 0x96, 0xbe, 0x80, 0x1d, 0x6f,
	0xea, 0xaa, 0xd8, 0xeb, 0xae, 0x6d, 0x24, 0xbf, 0x09, 0x4f, 0x81, 0x78, 0x02, 0xce, 0x1c, 0x79,
	0x04, 0x14, 0x0e, 0xbc, 0x06, 0xda, 0xdd, 0x98, 0xae, 0x7f, 0x92, 0x4a, 0x3d, 0xf4, 0xe6, 0x19,
	0x7f, 0x33, 0xf3, 0xcd, 0x37, 0xb3, 0x83, 0x70, 0x21, 0x58, 0x90, 0x97, 0x82, 0x7d, 0x8a, 0x79,
	0x36, 0xcd, 0x04, 0x2f, 0x38, 0x86, 0x59, 0x38, 0xbe, 0xbb, 0xe0, 0x49, 0xc2, 0x53, 0xed, 0x71,
	0x1f, 0xa0, 0x7b, 0x27, 0x06, 0xee, 0x23, 0x0f, 0x22, 0xca, 0x2e, 0xdc, 0xbf, 0xb0, 0xeb, 0x3f,
	0x5a, 0x9c, 0xe3, 0x3d, 0x34, 0x0c, 0xcb, 0x6a, 0x5e, 0x26, 0x04, 0x38, 0xc0, 0xb3, 0xe9, 0xda,
	0xc2, 0x0e, 0x1a, 0x09, 0xb6, 0x14, 0x2c, 0x8f, 0xdf, 0x0a, 0xc6, 0x08, 0x74, 0x80, 0xb7, 0x43,
	0x4d, 0x97, 0x81, 0x38, 0x39, 0x4b, 0x18, 0xb1, 0x1c, 0xe0, 0x59, 0xd4, 0x74, 0xe1, 0x57, 0x68,
	0x90, 0xc7, 0x3c, 0x23, 0x03, 0xc7, 0xf2, 0x46, 0xfe, 0xa3, 0x69, 0x16, 0x4e, 0x7b, 0x28, 0x4c,
	0xe5, 0xf7, 0x9b, 0xb4, 0x10, 0x15, 0x55, 0x70, 0xec, 0x23, 0x6b, 0x11, 0x08, 0x62, 0xab, 0x28,
	0x67, 0x53, 0xd4, 0x2c, 0x10, 0x3a, 0x48, 0x82, 0x31, 0x41, 0xb7, 0x59, 0x1a, 0x29, 0x22, 0x43,
	0x45, 0xa4, 0x36, 0xc7, 0xfb, 0xe8, 0xce, 0xff, 0x02, 0x78, 0x17, 0x59, 0xe7, 0xac, 0x5a, 0xb7,
	0x2a, 0x3f, 0xf1, 0x7d, 0x64, 0x7f, 0x09, 0x3e, 0x97, 0x75, 0x87, 0xda, 0x38, 0x84, 0x07, 0x60,
	0xfc, 0x1a, 0xed, 0xd4, 0x35, 0xae, 0x8a, 0xb3, 0x8d, 0x38, 0xf7, 0x3d, 0x22, 0x26, 0xdf, 0x59,
	0x20, 0x66, 0x71, 0x90, 0x9e, 0x32, 0xca, 0x2e, 0xa4, 0xda, 0xb2, 0xc5, 0x0f, 0x51, 0xad, 0xb6,
	0xb6, 0x64, 0xb6, 0xb3, 0xfc, 0x28, 0x8a, 0x6a, 0x16, 0xca, 0x70, 0xbf, 0xc1, 0x0d, 0xa9, 0xe4,
	0xe0, 0xf6, 0xb5, 0x4a, 0x40, 0xa9, 0xf4, 0xb4, 0xad, 0x92, 0x09, 0x6d, 0x49, 0x75, 0xc9, 0x01,
	0xf6, 0x73, 0xb0, 0x0c, 0x0e, 0xf8, 0xb0, 0x31, 0xc3, 0x67, 0x5b, 0xeb, 0xb4, 0x06, 0x79, 0x5d,
	0x05, 0xaf, 0x3d, 0x32, 0xd7, 0x43, 0xd8, 0x24, 0x77, 0x5c, 0x56, 0x52, 0x74, 0xbc, 0x6e, 0x41,
	0x4a, 0x65, 0x6b, 0x6a, 0xee, 0x77, 0xd8, 0x81, 0x6e, 0x7b, 0x0d, 0x1e, 0xb2, 0x4f, 0x39, 0x8f,
	0x72, 0x55, 0x72, 0xe4, 0x63, 0x29, 0xc3, 0x3b, 0xe9, 0xd0, 0xcd, 0xcf, 0x8b, 0x25, 0xd5, 0x00,
	0xfc, 0xb2, 0xa1, 0x57, 0x67, 0x7b, 0x75, 0x9d, 0xce, 0xca, 0x3f, 0x37, 0x57, 0xfe, 0xe1, 0x86,
	0xa0, 0xc6, 0x18, 0x6f, 0x7e, 0xaf, 0x09, 0xda, 0x33, 0x49, 0x51, 0xfd, 0xd0, 0xe5, 0x6d, 0xf9,
	0x01, 0x7b, 0x7f, 0xcd, 0x8b, 0x25, 0x3e, 0x30, 0xb4, 0x1f, 0xf9, 0x4f, 0xda, 0x9d, 0x5d, 0x22,
	0x3b, 0x92, 0xb4, 0xce, 0x0b, 0xec, 0x3b, 0x2f, 0x4a, 0x34, 0x4b, 0xa5, 0x7e, 0xbc, 0x25, 0x75,
	0x73, 0xff, 0x5b, 0x97, 0x6d, 0xd0, 0xb9, 0x6c, 0x37, 0x2e, 0xed, 0xf1, 0xee, 0xcf, 0xd5, 0x04,
	0xfc, 0x5a, 0x4d, 0xc0, 0xef, 0xd5, 0x04, 0x7c, 0xfd, 0x33, 0xb9, 0x15, 0x0e, 0xd5, 0x31, 0x7f,
	0xf1, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x9b, 0xfa, 0x6a, 0xb2, 0xf4, 0x05, 0x00, 0x00,
}
