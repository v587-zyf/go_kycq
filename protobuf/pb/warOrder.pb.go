// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: warOrder.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 战令任务完成推送
type WarOrderTaskNtf struct {
	Task     *WarOrderTask           `protobuf:"bytes,1,opt,name=task" json:"task,omitempty"`
	WeekTask map[int32]*WarOrderTask `protobuf:"bytes,2,rep,name=weekTask" json:"weekTask,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Lv       int32                   `protobuf:"varint,3,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp      int32                   `protobuf:"varint,4,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *WarOrderTaskNtf) Reset()                    { *m = WarOrderTaskNtf{} }
func (m *WarOrderTaskNtf) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskNtf) ProtoMessage()               {}
func (*WarOrderTaskNtf) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{0} }

func (m *WarOrderTaskNtf) GetTask() *WarOrderTask {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *WarOrderTaskNtf) GetWeekTask() map[int32]*WarOrderTask {
	if m != nil {
		return m.WeekTask
	}
	return nil
}

func (m *WarOrderTaskNtf) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrderTaskNtf) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// 战令任务打开
type WarOrderOpenReq struct {
}

func (m *WarOrderOpenReq) Reset()                    { *m = WarOrderOpenReq{} }
func (m *WarOrderOpenReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderOpenReq) ProtoMessage()               {}
func (*WarOrderOpenReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{1} }

type WarOrderOpenAck struct {
	WarOrderInfo *WarOrderTaskNtf `protobuf:"bytes,1,opt,name=warOrderInfo" json:"warOrderInfo,omitempty"`
}

func (m *WarOrderOpenAck) Reset()                    { *m = WarOrderOpenAck{} }
func (m *WarOrderOpenAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderOpenAck) ProtoMessage()               {}
func (*WarOrderOpenAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{2} }

func (m *WarOrderOpenAck) GetWarOrderInfo() *WarOrderTaskNtf {
	if m != nil {
		return m.WarOrderInfo
	}
	return nil
}

// 战令任务直接完成
type WarOrderTaskFinishReq struct {
	TaskId     int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Week       int32 `protobuf:"varint,2,opt,name=week,proto3" json:"week,omitempty"`
	IsWeekTask bool  `protobuf:"varint,3,opt,name=isWeekTask,proto3" json:"isWeekTask,omitempty"`
}

func (m *WarOrderTaskFinishReq) Reset()                    { *m = WarOrderTaskFinishReq{} }
func (m *WarOrderTaskFinishReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskFinishReq) ProtoMessage()               {}
func (*WarOrderTaskFinishReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{3} }

func (m *WarOrderTaskFinishReq) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *WarOrderTaskFinishReq) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *WarOrderTaskFinishReq) GetIsWeekTask() bool {
	if m != nil {
		return m.IsWeekTask
	}
	return false
}

type WarOrderTaskFinishAck struct {
	TaskId     int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Week       int32 `protobuf:"varint,2,opt,name=week,proto3" json:"week,omitempty"`
	IsWeekTask bool  `protobuf:"varint,3,opt,name=isWeekTask,proto3" json:"isWeekTask,omitempty"`
}

func (m *WarOrderTaskFinishAck) Reset()                    { *m = WarOrderTaskFinishAck{} }
func (m *WarOrderTaskFinishAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskFinishAck) ProtoMessage()               {}
func (*WarOrderTaskFinishAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{4} }

func (m *WarOrderTaskFinishAck) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *WarOrderTaskFinishAck) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *WarOrderTaskFinishAck) GetIsWeekTask() bool {
	if m != nil {
		return m.IsWeekTask
	}
	return false
}

// 战令任务领取奖励
type WarOrderTaskRewardReq struct {
	TaskId     int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Week       int32 `protobuf:"varint,2,opt,name=week,proto3" json:"week,omitempty"`
	IsWeekTask bool  `protobuf:"varint,3,opt,name=isWeekTask,proto3" json:"isWeekTask,omitempty"`
}

func (m *WarOrderTaskRewardReq) Reset()                    { *m = WarOrderTaskRewardReq{} }
func (m *WarOrderTaskRewardReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskRewardReq) ProtoMessage()               {}
func (*WarOrderTaskRewardReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{5} }

func (m *WarOrderTaskRewardReq) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *WarOrderTaskRewardReq) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *WarOrderTaskRewardReq) GetIsWeekTask() bool {
	if m != nil {
		return m.IsWeekTask
	}
	return false
}

type WarOrderTaskRewardAck struct {
	TaskId     int32 `protobuf:"varint,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Week       int32 `protobuf:"varint,2,opt,name=week,proto3" json:"week,omitempty"`
	IsWeekTask bool  `protobuf:"varint,3,opt,name=isWeekTask,proto3" json:"isWeekTask,omitempty"`
	Lv         int32 `protobuf:"varint,4,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp        int32 `protobuf:"varint,5,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *WarOrderTaskRewardAck) Reset()                    { *m = WarOrderTaskRewardAck{} }
func (m *WarOrderTaskRewardAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderTaskRewardAck) ProtoMessage()               {}
func (*WarOrderTaskRewardAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{6} }

func (m *WarOrderTaskRewardAck) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *WarOrderTaskRewardAck) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *WarOrderTaskRewardAck) GetIsWeekTask() bool {
	if m != nil {
		return m.IsWeekTask
	}
	return false
}

func (m *WarOrderTaskRewardAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrderTaskRewardAck) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// 购买豪华战令
type WarOrderBuyLuxuryReq struct {
}

func (m *WarOrderBuyLuxuryReq) Reset()                    { *m = WarOrderBuyLuxuryReq{} }
func (m *WarOrderBuyLuxuryReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderBuyLuxuryReq) ProtoMessage()               {}
func (*WarOrderBuyLuxuryReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{7} }

type WarOrderBuyLuxuryAck struct {
	IsLuxury bool `protobuf:"varint,1,opt,name=isLuxury,proto3" json:"isLuxury,omitempty"`
}

func (m *WarOrderBuyLuxuryAck) Reset()                    { *m = WarOrderBuyLuxuryAck{} }
func (m *WarOrderBuyLuxuryAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderBuyLuxuryAck) ProtoMessage()               {}
func (*WarOrderBuyLuxuryAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{8} }

func (m *WarOrderBuyLuxuryAck) GetIsLuxury() bool {
	if m != nil {
		return m.IsLuxury
	}
	return false
}

// 购买战令经验
type WarOrderBuyExpReq struct {
}

func (m *WarOrderBuyExpReq) Reset()                    { *m = WarOrderBuyExpReq{} }
func (m *WarOrderBuyExpReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderBuyExpReq) ProtoMessage()               {}
func (*WarOrderBuyExpReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{9} }

type WarOrderBuyExpAck struct {
	Lv  int32 `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *WarOrderBuyExpAck) Reset()                    { *m = WarOrderBuyExpAck{} }
func (m *WarOrderBuyExpAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderBuyExpAck) ProtoMessage()               {}
func (*WarOrderBuyExpAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{10} }

func (m *WarOrderBuyExpAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrderBuyExpAck) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// 领取战令等级奖励
type WarOrderLvRewardReq struct {
	Lv int32 `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
}

func (m *WarOrderLvRewardReq) Reset()                    { *m = WarOrderLvRewardReq{} }
func (m *WarOrderLvRewardReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderLvRewardReq) ProtoMessage()               {}
func (*WarOrderLvRewardReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{11} }

func (m *WarOrderLvRewardReq) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

type WarOrderLvRewardAck struct {
	Lv    int32           `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Goods *GoodsChangeNtf `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
}

func (m *WarOrderLvRewardAck) Reset()                    { *m = WarOrderLvRewardAck{} }
func (m *WarOrderLvRewardAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderLvRewardAck) ProtoMessage()               {}
func (*WarOrderLvRewardAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{12} }

func (m *WarOrderLvRewardAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrderLvRewardAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 战令兑换
type WarOrderExchangeReq struct {
	ExchangeId int32 `protobuf:"varint,1,opt,name=exchangeId,proto3" json:"exchangeId,omitempty"`
	Num        int32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *WarOrderExchangeReq) Reset()                    { *m = WarOrderExchangeReq{} }
func (m *WarOrderExchangeReq) String() string            { return proto.CompactTextString(m) }
func (*WarOrderExchangeReq) ProtoMessage()               {}
func (*WarOrderExchangeReq) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{13} }

func (m *WarOrderExchangeReq) GetExchangeId() int32 {
	if m != nil {
		return m.ExchangeId
	}
	return 0
}

func (m *WarOrderExchangeReq) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type WarOrderExchangeAck struct {
	Exp        int32           `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
	ExchangeId int32           `protobuf:"varint,2,opt,name=exchangeId,proto3" json:"exchangeId,omitempty"`
	Num        int32           `protobuf:"varint,3,opt,name=num,proto3" json:"num,omitempty"`
	Goods      *GoodsChangeNtf `protobuf:"bytes,4,opt,name=goods" json:"goods,omitempty"`
}

func (m *WarOrderExchangeAck) Reset()                    { *m = WarOrderExchangeAck{} }
func (m *WarOrderExchangeAck) String() string            { return proto.CompactTextString(m) }
func (*WarOrderExchangeAck) ProtoMessage()               {}
func (*WarOrderExchangeAck) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{14} }

func (m *WarOrderExchangeAck) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *WarOrderExchangeAck) GetExchangeId() int32 {
	if m != nil {
		return m.ExchangeId
	}
	return 0
}

func (m *WarOrderExchangeAck) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *WarOrderExchangeAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 战令经验、等级推送
type WarOrderLvNtf struct {
	Lv  int32 `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp int32 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *WarOrderLvNtf) Reset()                    { *m = WarOrderLvNtf{} }
func (m *WarOrderLvNtf) String() string            { return proto.CompactTextString(m) }
func (*WarOrderLvNtf) ProtoMessage()               {}
func (*WarOrderLvNtf) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{15} }

func (m *WarOrderLvNtf) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *WarOrderLvNtf) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// 战令重置
type WarOrderResetNtf struct {
	WarOrder *WarOrder `protobuf:"bytes,1,opt,name=warOrder" json:"warOrder,omitempty"`
}

func (m *WarOrderResetNtf) Reset()                    { *m = WarOrderResetNtf{} }
func (m *WarOrderResetNtf) String() string            { return proto.CompactTextString(m) }
func (*WarOrderResetNtf) ProtoMessage()               {}
func (*WarOrderResetNtf) Descriptor() ([]byte, []int) { return fileDescriptorWarOrder, []int{16} }

func (m *WarOrderResetNtf) GetWarOrder() *WarOrder {
	if m != nil {
		return m.WarOrder
	}
	return nil
}

func init() {
	proto.RegisterType((*WarOrderTaskNtf)(nil), "pb.WarOrderTaskNtf")
	proto.RegisterType((*WarOrderOpenReq)(nil), "pb.WarOrderOpenReq")
	proto.RegisterType((*WarOrderOpenAck)(nil), "pb.WarOrderOpenAck")
	proto.RegisterType((*WarOrderTaskFinishReq)(nil), "pb.WarOrderTaskFinishReq")
	proto.RegisterType((*WarOrderTaskFinishAck)(nil), "pb.WarOrderTaskFinishAck")
	proto.RegisterType((*WarOrderTaskRewardReq)(nil), "pb.WarOrderTaskRewardReq")
	proto.RegisterType((*WarOrderTaskRewardAck)(nil), "pb.WarOrderTaskRewardAck")
	proto.RegisterType((*WarOrderBuyLuxuryReq)(nil), "pb.WarOrderBuyLuxuryReq")
	proto.RegisterType((*WarOrderBuyLuxuryAck)(nil), "pb.WarOrderBuyLuxuryAck")
	proto.RegisterType((*WarOrderBuyExpReq)(nil), "pb.WarOrderBuyExpReq")
	proto.RegisterType((*WarOrderBuyExpAck)(nil), "pb.WarOrderBuyExpAck")
	proto.RegisterType((*WarOrderLvRewardReq)(nil), "pb.WarOrderLvRewardReq")
	proto.RegisterType((*WarOrderLvRewardAck)(nil), "pb.WarOrderLvRewardAck")
	proto.RegisterType((*WarOrderExchangeReq)(nil), "pb.WarOrderExchangeReq")
	proto.RegisterType((*WarOrderExchangeAck)(nil), "pb.WarOrderExchangeAck")
	proto.RegisterType((*WarOrderLvNtf)(nil), "pb.WarOrderLvNtf")
	proto.RegisterType((*WarOrderResetNtf)(nil), "pb.WarOrderResetNtf")
}
func (m *WarOrderTaskNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Task != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Task.Size()))
		n1, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.WeekTask) > 0 {
		for k, _ := range m.WeekTask {
			dAtA[i] = 0x12
			i++
			v := m.WeekTask[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovWarOrder(uint64(msgSize))
			}
			mapSize := 1 + sovWarOrder(uint64(k)) + msgSize
			i = encodeVarintWarOrder(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintWarOrder(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintWarOrder(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.Lv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WarOrderOpenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderOpenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WarOrderOpenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderOpenAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WarOrderInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.WarOrderInfo.Size()))
		n3, err := m.WarOrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *WarOrderTaskFinishReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskFinishReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.TaskId))
	}
	if m.Week != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Week))
	}
	if m.IsWeekTask {
		dAtA[i] = 0x18
		i++
		if m.IsWeekTask {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrderTaskFinishAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskFinishAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.TaskId))
	}
	if m.Week != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Week))
	}
	if m.IsWeekTask {
		dAtA[i] = 0x18
		i++
		if m.IsWeekTask {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrderTaskRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskRewardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.TaskId))
	}
	if m.Week != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Week))
	}
	if m.IsWeekTask {
		dAtA[i] = 0x18
		i++
		if m.IsWeekTask {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrderTaskRewardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderTaskRewardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.TaskId))
	}
	if m.Week != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Week))
	}
	if m.IsWeekTask {
		dAtA[i] = 0x18
		i++
		if m.IsWeekTask {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WarOrderBuyLuxuryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderBuyLuxuryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WarOrderBuyLuxuryAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderBuyLuxuryAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsLuxury {
		dAtA[i] = 0x8
		i++
		if m.IsLuxury {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WarOrderBuyExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderBuyExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WarOrderBuyExpAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderBuyExpAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WarOrderLvRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderLvRewardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	return i, nil
}

func (m *WarOrderLvRewardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderLvRewardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Goods.Size()))
		n4, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *WarOrderExchangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderExchangeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExchangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.ExchangeId))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *WarOrderExchangeAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderExchangeAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Exp))
	}
	if m.ExchangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.ExchangeId))
	}
	if m.Num != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Num))
	}
	if m.Goods != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Goods.Size()))
		n5, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *WarOrderLvNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderLvNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *WarOrderResetNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarOrderResetNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WarOrder != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWarOrder(dAtA, i, uint64(m.WarOrder.Size()))
		n6, err := m.WarOrder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func encodeVarintWarOrder(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *WarOrderTaskNtf) Size() (n int) {
	var l int
	_ = l
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovWarOrder(uint64(l))
	}
	if len(m.WeekTask) > 0 {
		for k, v := range m.WeekTask {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWarOrder(uint64(l))
			}
			mapEntrySize := 1 + sovWarOrder(uint64(k)) + l
			n += mapEntrySize + 1 + sovWarOrder(uint64(mapEntrySize))
		}
	}
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovWarOrder(uint64(m.Exp))
	}
	return n
}

func (m *WarOrderOpenReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WarOrderOpenAck) Size() (n int) {
	var l int
	_ = l
	if m.WarOrderInfo != nil {
		l = m.WarOrderInfo.Size()
		n += 1 + l + sovWarOrder(uint64(l))
	}
	return n
}

func (m *WarOrderTaskFinishReq) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovWarOrder(uint64(m.TaskId))
	}
	if m.Week != 0 {
		n += 1 + sovWarOrder(uint64(m.Week))
	}
	if m.IsWeekTask {
		n += 2
	}
	return n
}

func (m *WarOrderTaskFinishAck) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovWarOrder(uint64(m.TaskId))
	}
	if m.Week != 0 {
		n += 1 + sovWarOrder(uint64(m.Week))
	}
	if m.IsWeekTask {
		n += 2
	}
	return n
}

func (m *WarOrderTaskRewardReq) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovWarOrder(uint64(m.TaskId))
	}
	if m.Week != 0 {
		n += 1 + sovWarOrder(uint64(m.Week))
	}
	if m.IsWeekTask {
		n += 2
	}
	return n
}

func (m *WarOrderTaskRewardAck) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovWarOrder(uint64(m.TaskId))
	}
	if m.Week != 0 {
		n += 1 + sovWarOrder(uint64(m.Week))
	}
	if m.IsWeekTask {
		n += 2
	}
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovWarOrder(uint64(m.Exp))
	}
	return n
}

func (m *WarOrderBuyLuxuryReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WarOrderBuyLuxuryAck) Size() (n int) {
	var l int
	_ = l
	if m.IsLuxury {
		n += 2
	}
	return n
}

func (m *WarOrderBuyExpReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WarOrderBuyExpAck) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovWarOrder(uint64(m.Exp))
	}
	return n
}

func (m *WarOrderLvRewardReq) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	return n
}

func (m *WarOrderLvRewardAck) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovWarOrder(uint64(l))
	}
	return n
}

func (m *WarOrderExchangeReq) Size() (n int) {
	var l int
	_ = l
	if m.ExchangeId != 0 {
		n += 1 + sovWarOrder(uint64(m.ExchangeId))
	}
	if m.Num != 0 {
		n += 1 + sovWarOrder(uint64(m.Num))
	}
	return n
}

func (m *WarOrderExchangeAck) Size() (n int) {
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovWarOrder(uint64(m.Exp))
	}
	if m.ExchangeId != 0 {
		n += 1 + sovWarOrder(uint64(m.ExchangeId))
	}
	if m.Num != 0 {
		n += 1 + sovWarOrder(uint64(m.Num))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovWarOrder(uint64(l))
	}
	return n
}

func (m *WarOrderLvNtf) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovWarOrder(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovWarOrder(uint64(m.Exp))
	}
	return n
}

func (m *WarOrderResetNtf) Size() (n int) {
	var l int
	_ = l
	if m.WarOrder != nil {
		l = m.WarOrder.Size()
		n += 1 + l + sovWarOrder(uint64(l))
	}
	return n
}

func sovWarOrder(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWarOrder(x uint64) (n int) {
	return sovWarOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WarOrderTaskNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &WarOrderTask{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekTask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeekTask == nil {
				m.WeekTask = make(map[int32]*WarOrderTask)
			}
			var mapkey int32
			var mapvalue *WarOrderTask
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWarOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWarOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWarOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWarOrder
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthWarOrder
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WarOrderTask{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWarOrder(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWarOrder
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WeekTask[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderOpenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderOpenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderOpenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderOpenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderOpenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderOpenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarOrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WarOrderInfo == nil {
				m.WarOrderInfo = &WarOrderTaskNtf{}
			}
			if err := m.WarOrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskFinishReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskFinishReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskFinishReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWeekTask", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWeekTask = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskFinishAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskFinishAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskFinishAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWeekTask", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWeekTask = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWeekTask", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWeekTask = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderTaskRewardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderTaskRewardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderTaskRewardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWeekTask", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWeekTask = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderBuyLuxuryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderBuyLuxuryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderBuyLuxuryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderBuyLuxuryAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderBuyLuxuryAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderBuyLuxuryAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLuxury", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLuxury = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderBuyExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderBuyExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderBuyExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderBuyExpAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderBuyExpAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderBuyExpAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderLvRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderLvRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderLvRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderLvRewardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderLvRewardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderLvRewardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderExchangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderExchangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderExchangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			m.ExchangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderExchangeAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderExchangeAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderExchangeAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			m.ExchangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderLvNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderLvNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderLvNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarOrderResetNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarOrderResetNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarOrderResetNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWarOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WarOrder == nil {
				m.WarOrder = &WarOrder{}
			}
			if err := m.WarOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWarOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWarOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWarOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWarOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWarOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWarOrder
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWarOrder
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWarOrder(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWarOrder = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWarOrder   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("warOrder.proto", fileDescriptorWarOrder) }

var fileDescriptorWarOrder = []byte{
	// 527 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0x65, 0x1c, 0xbb, 0xb2, 0x6e, 0x1f, 0xa4, 0x13, 0xa8, 0xac, 0x2c, 0xac, 0x60, 0x01, 0xf2,
	0x2a, 0x12, 0x41, 0x08, 0x84, 0x60, 0x41, 0x51, 0xa8, 0x8a, 0x4a, 0x23, 0x8d, 0x90, 0xba, 0x76,
	0x92, 0x49, 0x1b, 0x39, 0xb1, 0x5d, 0x3f, 0xf2, 0x58, 0x23, 0xfe, 0x81, 0x4f, 0x62, 0xc9, 0x27,
	0xa0, 0xb0, 0xe0, 0x37, 0xd0, 0x1d, 0x8f, 0x1f, 0x71, 0x5d, 0x75, 0x53, 0x76, 0x33, 0x67, 0xce,
	0x3d, 0x73, 0xce, 0xf5, 0xf5, 0xc0, 0xc1, 0xd2, 0x09, 0x07, 0xe1, 0x98, 0x87, 0xdd, 0x20, 0xf4,
	0x63, 0x9f, 0x2a, 0xc1, 0xb0, 0xbd, 0x37, 0xf2, 0xe7, 0x73, 0xdf, 0x4b, 0x11, 0xeb, 0x2f, 0x81,
	0x87, 0x17, 0x92, 0xf4, 0xd5, 0x89, 0xdc, 0xf3, 0x78, 0x42, 0x9f, 0x82, 0x1a, 0x3b, 0x91, 0x6b,
	0x90, 0x0e, 0xb1, 0x77, 0x7b, 0xcd, 0x6e, 0x30, 0xec, 0x96, 0x29, 0x4c, 0x9c, 0xd2, 0xf7, 0xa0,
	0x2f, 0x39, 0x77, 0x11, 0x31, 0x94, 0x4e, 0xc3, 0xde, 0xed, 0x3d, 0xa9, 0x32, 0xcf, 0xe3, 0x49,
	0xf7, 0x42, 0x72, 0xfa, 0x5e, 0x1c, 0xae, 0x59, 0x5e, 0x42, 0x0f, 0x40, 0x99, 0x2d, 0x8c, 0x46,
	0x87, 0xd8, 0x1a, 0x53, 0x66, 0x0b, 0xda, 0x84, 0x06, 0x5f, 0x05, 0x86, 0x2a, 0x00, 0x5c, 0xb6,
	0xbf, 0xc0, 0xfe, 0x56, 0x31, 0x52, 0x5c, 0xbe, 0x16, 0xb6, 0x34, 0x86, 0x4b, 0xfa, 0x1c, 0xb4,
	0x85, 0x33, 0x4b, 0xb8, 0xa1, 0xdc, 0x62, 0x35, 0x3d, 0x7e, 0xab, 0xbc, 0x21, 0xd6, 0x61, 0x11,
	0x74, 0x10, 0x70, 0x8f, 0xf1, 0x6b, 0xeb, 0xf3, 0x36, 0xf4, 0x61, 0xe4, 0xd2, 0xd7, 0xb0, 0x97,
	0xf5, 0xec, 0xd4, 0x9b, 0xf8, 0xb2, 0x07, 0xad, 0x9a, 0x64, 0x6c, 0x8b, 0x68, 0x8d, 0xe0, 0x71,
	0x99, 0xf0, 0x69, 0xea, 0x4d, 0xa3, 0x2b, 0xc6, 0xaf, 0xe9, 0x11, 0xec, 0x60, 0xbf, 0x4e, 0xc7,
	0xd2, 0xb8, 0xdc, 0x51, 0x0a, 0x2a, 0x36, 0x43, 0x58, 0xd7, 0x98, 0x58, 0x53, 0x13, 0x60, 0x1a,
	0x65, 0xa1, 0x45, 0x73, 0x74, 0x56, 0x42, 0xea, 0x2f, 0x41, 0xdb, 0xff, 0xf1, 0x12, 0xc6, 0x97,
	0x4e, 0x38, 0xbe, 0xef, 0x24, 0xdf, 0x49, 0xdd, 0x2d, 0xf7, 0x1c, 0x45, 0x0e, 0x99, 0x5a, 0x1d,
	0x32, 0x2d, 0x1f, 0x32, 0xeb, 0x08, 0x1e, 0x65, 0x36, 0x8e, 0x93, 0xf5, 0x59, 0xb2, 0x4a, 0xc2,
	0x35, 0x8e, 0x46, 0xaf, 0x06, 0x47, 0x77, 0x6d, 0xd0, 0xa7, 0x51, 0xba, 0x15, 0xfe, 0x74, 0x96,
	0xef, 0xad, 0x16, 0x1c, 0x96, 0x6a, 0xfa, 0xab, 0x00, 0x85, 0x5e, 0x55, 0x41, 0x54, 0x49, 0x7d,
	0x91, 0xaa, 0x2f, 0xa5, 0xf0, 0xf5, 0x0c, 0x5a, 0x59, 0xd9, 0xd9, 0xa2, 0xf8, 0x04, 0x95, 0x42,
	0x6b, 0x70, 0x93, 0x56, 0xa7, 0x6f, 0x83, 0x76, 0xe9, 0xfb, 0xe3, 0x48, 0xfe, 0x27, 0x14, 0xc7,
	0xf9, 0x04, 0x81, 0x8f, 0x57, 0x8e, 0x77, 0xc9, 0x71, 0x9a, 0x53, 0x82, 0x75, 0x52, 0x08, 0xf6,
	0x57, 0x23, 0x71, 0x8a, 0xf7, 0x9a, 0x00, 0x5c, 0x6e, 0xf3, 0x0f, 0x53, 0x42, 0x30, 0x80, 0x97,
	0xcc, 0xb3, 0x00, 0x5e, 0x32, 0xb7, 0xbe, 0x91, 0x9b, 0x4a, 0x68, 0x4d, 0x46, 0x25, 0x79, 0xd4,
	0x8a, 0xb6, 0x72, 0x9b, 0x76, 0x23, 0xd7, 0x2e, 0xe2, 0xa8, 0x77, 0xc5, 0x79, 0x01, 0xfb, 0x45,
	0x7f, 0xf0, 0x6d, 0xbb, 0xbb, 0xf3, 0xef, 0xa0, 0x99, 0x95, 0x30, 0x1e, 0xf1, 0x18, 0xab, 0x6c,
	0xd0, 0xb3, 0x9f, 0x5d, 0xbe, 0x08, 0x7b, 0xe5, 0x17, 0x81, 0xe5, 0xa7, 0xc7, 0xcd, 0x9f, 0x1b,
	0x93, 0xfc, 0xda, 0x98, 0xe4, 0xf7, 0xc6, 0x24, 0x3f, 0xfe, 0x98, 0x0f, 0x86, 0x3b, 0xe2, 0xa1,
	0x7d, 0xf9, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xbc, 0x16, 0x5d, 0x7e, 0x8c, 0x05, 0x00, 0x00,
}
