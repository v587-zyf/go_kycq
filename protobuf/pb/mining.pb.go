// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mining.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 获取挖矿数据
type MiningLoadReq struct {
}

func (m *MiningLoadReq) Reset()                    { *m = MiningLoadReq{} }
func (m *MiningLoadReq) String() string            { return proto.CompactTextString(m) }
func (*MiningLoadReq) ProtoMessage()               {}
func (*MiningLoadReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{0} }

type MiningLoadAck struct {
	Mining *MiningInfo `protobuf:"bytes,1,opt,name=mining" json:"mining,omitempty"`
}

func (m *MiningLoadAck) Reset()                    { *m = MiningLoadAck{} }
func (m *MiningLoadAck) String() string            { return proto.CompactTextString(m) }
func (*MiningLoadAck) ProtoMessage()               {}
func (*MiningLoadAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{1} }

func (m *MiningLoadAck) GetMining() *MiningInfo {
	if m != nil {
		return m.Mining
	}
	return nil
}

// 升级矿工
type MiningUpMinerReq struct {
	IsMax bool `protobuf:"varint,1,opt,name=isMax,proto3" json:"isMax,omitempty"`
}

func (m *MiningUpMinerReq) Reset()                    { *m = MiningUpMinerReq{} }
func (m *MiningUpMinerReq) String() string            { return proto.CompactTextString(m) }
func (*MiningUpMinerReq) ProtoMessage()               {}
func (*MiningUpMinerReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{2} }

func (m *MiningUpMinerReq) GetIsMax() bool {
	if m != nil {
		return m.IsMax
	}
	return false
}

type MiningUpMinerAck struct {
	Miner int32 `protobuf:"varint,1,opt,name=miner,proto3" json:"miner,omitempty"`
	Luck  int32 `protobuf:"varint,2,opt,name=luck,proto3" json:"luck,omitempty"`
	IsUp  bool  `protobuf:"varint,3,opt,name=isUp,proto3" json:"isUp,omitempty"`
}

func (m *MiningUpMinerAck) Reset()                    { *m = MiningUpMinerAck{} }
func (m *MiningUpMinerAck) String() string            { return proto.CompactTextString(m) }
func (*MiningUpMinerAck) ProtoMessage()               {}
func (*MiningUpMinerAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{3} }

func (m *MiningUpMinerAck) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *MiningUpMinerAck) GetLuck() int32 {
	if m != nil {
		return m.Luck
	}
	return 0
}

func (m *MiningUpMinerAck) GetIsUp() bool {
	if m != nil {
		return m.IsUp
	}
	return false
}

// 购买次数
type MiningBuyNumReq struct {
}

func (m *MiningBuyNumReq) Reset()                    { *m = MiningBuyNumReq{} }
func (m *MiningBuyNumReq) String() string            { return proto.CompactTextString(m) }
func (*MiningBuyNumReq) ProtoMessage()               {}
func (*MiningBuyNumReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{4} }

type MiningBuyNumAck struct {
	BuyNum int32 `protobuf:"varint,1,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
}

func (m *MiningBuyNumAck) Reset()                    { *m = MiningBuyNumAck{} }
func (m *MiningBuyNumAck) String() string            { return proto.CompactTextString(m) }
func (*MiningBuyNumAck) ProtoMessage()               {}
func (*MiningBuyNumAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{5} }

func (m *MiningBuyNumAck) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

// 开始挖矿
type MiningStartReq struct {
}

func (m *MiningStartReq) Reset()                    { *m = MiningStartReq{} }
func (m *MiningStartReq) String() string            { return proto.CompactTextString(m) }
func (*MiningStartReq) ProtoMessage()               {}
func (*MiningStartReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{6} }

type MiningStartAck struct {
	WorkTime int64 `protobuf:"varint,1,opt,name=workTime,proto3" json:"workTime,omitempty"`
	WorkNum  int32 `protobuf:"varint,2,opt,name=workNum,proto3" json:"workNum,omitempty"`
}

func (m *MiningStartAck) Reset()                    { *m = MiningStartAck{} }
func (m *MiningStartAck) String() string            { return proto.CompactTextString(m) }
func (*MiningStartAck) ProtoMessage()               {}
func (*MiningStartAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{7} }

func (m *MiningStartAck) GetWorkTime() int64 {
	if m != nil {
		return m.WorkTime
	}
	return 0
}

func (m *MiningStartAck) GetWorkNum() int32 {
	if m != nil {
		return m.WorkNum
	}
	return 0
}

// 掠夺
type MiningRobReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningRobReq) Reset()                    { *m = MiningRobReq{} }
func (m *MiningRobReq) String() string            { return proto.CompactTextString(m) }
func (*MiningRobReq) ProtoMessage()               {}
func (*MiningRobReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{8} }

func (m *MiningRobReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MiningRobAck struct {
	Result int32           `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Goods  *GoodsChangeNtf `protobuf:"bytes,1,opt,name=goods" json:"goods,omitempty"`
	RobNum int32           `protobuf:"varint,3,opt,name=robNum,proto3" json:"robNum,omitempty"`
}

func (m *MiningRobAck) Reset()                    { *m = MiningRobAck{} }
func (m *MiningRobAck) String() string            { return proto.CompactTextString(m) }
func (*MiningRobAck) ProtoMessage()               {}
func (*MiningRobAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{9} }

func (m *MiningRobAck) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *MiningRobAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *MiningRobAck) GetRobNum() int32 {
	if m != nil {
		return m.RobNum
	}
	return 0
}

type MiningRobFightAck struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningRobFightAck) Reset()                    { *m = MiningRobFightAck{} }
func (m *MiningRobFightAck) String() string            { return proto.CompactTextString(m) }
func (*MiningRobFightAck) ProtoMessage()               {}
func (*MiningRobFightAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{10} }

func (m *MiningRobFightAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 夺回奖励
type MiningRobBackReq struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningRobBackReq) Reset()                    { *m = MiningRobBackReq{} }
func (m *MiningRobBackReq) String() string            { return proto.CompactTextString(m) }
func (*MiningRobBackReq) ProtoMessage()               {}
func (*MiningRobBackReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{11} }

func (m *MiningRobBackReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MiningRobBackAck struct {
	Result int32           `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Goods  *GoodsChangeNtf `protobuf:"bytes,1,opt,name=goods" json:"goods,omitempty"`
}

func (m *MiningRobBackAck) Reset()                    { *m = MiningRobBackAck{} }
func (m *MiningRobBackAck) String() string            { return proto.CompactTextString(m) }
func (*MiningRobBackAck) ProtoMessage()               {}
func (*MiningRobBackAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{12} }

func (m *MiningRobBackAck) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *MiningRobBackAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

type MiningRobBackFightAck struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningRobBackFightAck) Reset()                    { *m = MiningRobBackFightAck{} }
func (m *MiningRobBackFightAck) String() string            { return proto.CompactTextString(m) }
func (*MiningRobBackFightAck) ProtoMessage()               {}
func (*MiningRobBackFightAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{13} }

func (m *MiningRobBackFightAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 被掠夺列表
type MiningRobListReq struct {
}

func (m *MiningRobListReq) Reset()                    { *m = MiningRobListReq{} }
func (m *MiningRobListReq) String() string            { return proto.CompactTextString(m) }
func (*MiningRobListReq) ProtoMessage()               {}
func (*MiningRobListReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{14} }

type MiningRobListAck struct {
	MineRob map[int64]*MiningRob `protobuf:"bytes,1,rep,name=mineRob" json:"mineRob,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MiningRobListAck) Reset()                    { *m = MiningRobListAck{} }
func (m *MiningRobListAck) String() string            { return proto.CompactTextString(m) }
func (*MiningRobListAck) ProtoMessage()               {}
func (*MiningRobListAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{15} }

func (m *MiningRobListAck) GetMineRob() map[int64]*MiningRob {
	if m != nil {
		return m.MineRob
	}
	return nil
}

// 挖矿列表
type MiningListReq struct {
}

func (m *MiningListReq) Reset()                    { *m = MiningListReq{} }
func (m *MiningListReq) String() string            { return proto.CompactTextString(m) }
func (*MiningListReq) ProtoMessage()               {}
func (*MiningListReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{16} }

type MiningListAck struct {
	MiningList map[int64]*MiningListInfo `protobuf:"bytes,1,rep,name=miningList" json:"miningList,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MiningListAck) Reset()                    { *m = MiningListAck{} }
func (m *MiningListAck) String() string            { return proto.CompactTextString(m) }
func (*MiningListAck) ProtoMessage()               {}
func (*MiningListAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{17} }

func (m *MiningListAck) GetMiningList() map[int64]*MiningListInfo {
	if m != nil {
		return m.MiningList
	}
	return nil
}

// 领取奖励加载
type MiningDrawLoadReq struct {
}

func (m *MiningDrawLoadReq) Reset()                    { *m = MiningDrawLoadReq{} }
func (m *MiningDrawLoadReq) String() string            { return proto.CompactTextString(m) }
func (*MiningDrawLoadReq) ProtoMessage()               {}
func (*MiningDrawLoadReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{18} }

type MiningDrawLoadAck struct {
	Status  bool   `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	RobId   int64  `protobuf:"varint,2,opt,name=robId,proto3" json:"robId,omitempty"`
	RobName string `protobuf:"bytes,3,opt,name=robName,proto3" json:"robName,omitempty"`
	RobTime int64  `protobuf:"varint,4,opt,name=robTime,proto3" json:"robTime,omitempty"`
	RId     int64  `protobuf:"varint,5,opt,name=rId,proto3" json:"rId,omitempty"`
}

func (m *MiningDrawLoadAck) Reset()                    { *m = MiningDrawLoadAck{} }
func (m *MiningDrawLoadAck) String() string            { return proto.CompactTextString(m) }
func (*MiningDrawLoadAck) ProtoMessage()               {}
func (*MiningDrawLoadAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{19} }

func (m *MiningDrawLoadAck) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *MiningDrawLoadAck) GetRobId() int64 {
	if m != nil {
		return m.RobId
	}
	return 0
}

func (m *MiningDrawLoadAck) GetRobName() string {
	if m != nil {
		return m.RobName
	}
	return ""
}

func (m *MiningDrawLoadAck) GetRobTime() int64 {
	if m != nil {
		return m.RobTime
	}
	return 0
}

func (m *MiningDrawLoadAck) GetRId() int64 {
	if m != nil {
		return m.RId
	}
	return 0
}

// 领取奖励
type MiningDrawReq struct {
}

func (m *MiningDrawReq) Reset()                    { *m = MiningDrawReq{} }
func (m *MiningDrawReq) String() string            { return proto.CompactTextString(m) }
func (*MiningDrawReq) ProtoMessage()               {}
func (*MiningDrawReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{20} }

type MiningDrawAck struct {
	Goods *GoodsChangeNtf `protobuf:"bytes,1,opt,name=goods" json:"goods,omitempty"`
}

func (m *MiningDrawAck) Reset()                    { *m = MiningDrawAck{} }
func (m *MiningDrawAck) String() string            { return proto.CompactTextString(m) }
func (*MiningDrawAck) ProtoMessage()               {}
func (*MiningDrawAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{21} }

func (m *MiningDrawAck) GetGoods() *GoodsChangeNtf {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 进入矿洞
type MiningInReq struct {
}

func (m *MiningInReq) Reset()                    { *m = MiningInReq{} }
func (m *MiningInReq) String() string            { return proto.CompactTextString(m) }
func (*MiningInReq) ProtoMessage()               {}
func (*MiningInReq) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{22} }

type MiningInAck struct {
}

func (m *MiningInAck) Reset()                    { *m = MiningInAck{} }
func (m *MiningInAck) String() string            { return proto.CompactTextString(m) }
func (*MiningInAck) ProtoMessage()               {}
func (*MiningInAck) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{23} }

type MiningInfo struct {
	WorkTime int64 `protobuf:"varint,1,opt,name=workTime,proto3" json:"workTime,omitempty"`
	WorkNum  int32 `protobuf:"varint,2,opt,name=workNum,proto3" json:"workNum,omitempty"`
	RobNum   int32 `protobuf:"varint,3,opt,name=robNum,proto3" json:"robNum,omitempty"`
	BuyNum   int32 `protobuf:"varint,4,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	Miner    int32 `protobuf:"varint,5,opt,name=miner,proto3" json:"miner,omitempty"`
	Luck     int32 `protobuf:"varint,6,opt,name=luck,proto3" json:"luck,omitempty"`
}

func (m *MiningInfo) Reset()                    { *m = MiningInfo{} }
func (m *MiningInfo) String() string            { return proto.CompactTextString(m) }
func (*MiningInfo) ProtoMessage()               {}
func (*MiningInfo) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{24} }

func (m *MiningInfo) GetWorkTime() int64 {
	if m != nil {
		return m.WorkTime
	}
	return 0
}

func (m *MiningInfo) GetWorkNum() int32 {
	if m != nil {
		return m.WorkNum
	}
	return 0
}

func (m *MiningInfo) GetRobNum() int32 {
	if m != nil {
		return m.RobNum
	}
	return 0
}

func (m *MiningInfo) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

func (m *MiningInfo) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *MiningInfo) GetLuck() int32 {
	if m != nil {
		return m.Luck
	}
	return 0
}

type MiningRob struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Combat  int64  `protobuf:"varint,2,opt,name=combat,proto3" json:"combat,omitempty"`
	Miner   int32  `protobuf:"varint,3,opt,name=miner,proto3" json:"miner,omitempty"`
	RobTime int64  `protobuf:"varint,4,opt,name=robTime,proto3" json:"robTime,omitempty"`
	Id      int64  `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningRob) Reset()                    { *m = MiningRob{} }
func (m *MiningRob) String() string            { return proto.CompactTextString(m) }
func (*MiningRob) ProtoMessage()               {}
func (*MiningRob) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{25} }

func (m *MiningRob) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MiningRob) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *MiningRob) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *MiningRob) GetRobTime() int64 {
	if m != nil {
		return m.RobTime
	}
	return 0
}

func (m *MiningRob) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MiningListInfo struct {
	Uid    int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Combat int64  `protobuf:"varint,3,opt,name=combat,proto3" json:"combat,omitempty"`
	Time   int64  `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	Miner  int32  `protobuf:"varint,5,opt,name=miner,proto3" json:"miner,omitempty"`
	Id     int64  `protobuf:"varint,6,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MiningListInfo) Reset()                    { *m = MiningListInfo{} }
func (m *MiningListInfo) String() string            { return proto.CompactTextString(m) }
func (*MiningListInfo) ProtoMessage()               {}
func (*MiningListInfo) Descriptor() ([]byte, []int) { return fileDescriptorMining, []int{26} }

func (m *MiningListInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MiningListInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MiningListInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *MiningListInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MiningListInfo) GetMiner() int32 {
	if m != nil {
		return m.Miner
	}
	return 0
}

func (m *MiningListInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func init() {
	proto.RegisterType((*MiningLoadReq)(nil), "pb.MiningLoadReq")
	proto.RegisterType((*MiningLoadAck)(nil), "pb.MiningLoadAck")
	proto.RegisterType((*MiningUpMinerReq)(nil), "pb.MiningUpMinerReq")
	proto.RegisterType((*MiningUpMinerAck)(nil), "pb.MiningUpMinerAck")
	proto.RegisterType((*MiningBuyNumReq)(nil), "pb.MiningBuyNumReq")
	proto.RegisterType((*MiningBuyNumAck)(nil), "pb.MiningBuyNumAck")
	proto.RegisterType((*MiningStartReq)(nil), "pb.MiningStartReq")
	proto.RegisterType((*MiningStartAck)(nil), "pb.MiningStartAck")
	proto.RegisterType((*MiningRobReq)(nil), "pb.MiningRobReq")
	proto.RegisterType((*MiningRobAck)(nil), "pb.MiningRobAck")
	proto.RegisterType((*MiningRobFightAck)(nil), "pb.MiningRobFightAck")
	proto.RegisterType((*MiningRobBackReq)(nil), "pb.MiningRobBackReq")
	proto.RegisterType((*MiningRobBackAck)(nil), "pb.MiningRobBackAck")
	proto.RegisterType((*MiningRobBackFightAck)(nil), "pb.MiningRobBackFightAck")
	proto.RegisterType((*MiningRobListReq)(nil), "pb.MiningRobListReq")
	proto.RegisterType((*MiningRobListAck)(nil), "pb.MiningRobListAck")
	proto.RegisterType((*MiningListReq)(nil), "pb.MiningListReq")
	proto.RegisterType((*MiningListAck)(nil), "pb.MiningListAck")
	proto.RegisterType((*MiningDrawLoadReq)(nil), "pb.MiningDrawLoadReq")
	proto.RegisterType((*MiningDrawLoadAck)(nil), "pb.MiningDrawLoadAck")
	proto.RegisterType((*MiningDrawReq)(nil), "pb.MiningDrawReq")
	proto.RegisterType((*MiningDrawAck)(nil), "pb.MiningDrawAck")
	proto.RegisterType((*MiningInReq)(nil), "pb.MiningInReq")
	proto.RegisterType((*MiningInAck)(nil), "pb.MiningInAck")
	proto.RegisterType((*MiningInfo)(nil), "pb.MiningInfo")
	proto.RegisterType((*MiningRob)(nil), "pb.MiningRob")
	proto.RegisterType((*MiningListInfo)(nil), "pb.MiningListInfo")
}
func (m *MiningLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mining != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Mining.Size()))
		n1, err := m.Mining.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MiningUpMinerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningUpMinerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsMax {
		dAtA[i] = 0x8
		i++
		if m.IsMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningUpMinerAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningUpMinerAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Miner != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Miner))
	}
	if m.Luck != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Luck))
	}
	if m.IsUp {
		dAtA[i] = 0x18
		i++
		if m.IsUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningBuyNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningBuyNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningBuyNumAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningBuyNumAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.BuyNum))
	}
	return i, nil
}

func (m *MiningStartReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningStartReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningStartAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WorkTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.WorkTime))
	}
	if m.WorkNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.WorkNum))
	}
	return i, nil
}

func (m *MiningRobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MiningRobAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Goods.Size()))
		n2, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Result))
	}
	if m.RobNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RobNum))
	}
	return i, nil
}

func (m *MiningRobFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MiningRobBackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobBackReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MiningRobBackAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobBackAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Goods.Size()))
		n3, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MiningRobBackFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobBackFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MiningRobListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningRobListAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRobListAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MineRob) > 0 {
		for k, _ := range m.MineRob {
			dAtA[i] = 0xa
			i++
			v := m.MineRob[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMining(uint64(msgSize))
			}
			mapSize := 1 + sovMining(uint64(k)) + msgSize
			i = encodeVarintMining(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMining(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMining(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *MiningListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningListAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningListAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MiningList) > 0 {
		for k, _ := range m.MiningList {
			dAtA[i] = 0xa
			i++
			v := m.MiningList[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMining(uint64(msgSize))
			}
			mapSize := 1 + sovMining(uint64(k)) + msgSize
			i = encodeVarintMining(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMining(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMining(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	return i, nil
}

func (m *MiningDrawLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningDrawLoadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningDrawLoadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningDrawLoadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RobId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RobId))
	}
	if len(m.RobName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMining(dAtA, i, uint64(len(m.RobName)))
		i += copy(dAtA[i:], m.RobName)
	}
	if m.RobTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RobTime))
	}
	if m.RId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RId))
	}
	return i, nil
}

func (m *MiningDrawReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningDrawReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningDrawAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningDrawAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Goods.Size()))
		n6, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *MiningInReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningInReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningInAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningInAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiningInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WorkTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.WorkTime))
	}
	if m.WorkNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.WorkNum))
	}
	if m.RobNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RobNum))
	}
	if m.BuyNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.BuyNum))
	}
	if m.Miner != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Miner))
	}
	if m.Luck != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Luck))
	}
	return i, nil
}

func (m *MiningRob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMining(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Combat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Combat))
	}
	if m.Miner != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Miner))
	}
	if m.RobTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.RobTime))
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MiningListInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningListInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMining(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Combat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Combat))
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Time))
	}
	if m.Miner != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Miner))
	}
	if m.Id != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMining(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func encodeVarintMining(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MiningLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningLoadAck) Size() (n int) {
	var l int
	_ = l
	if m.Mining != nil {
		l = m.Mining.Size()
		n += 1 + l + sovMining(uint64(l))
	}
	return n
}

func (m *MiningUpMinerReq) Size() (n int) {
	var l int
	_ = l
	if m.IsMax {
		n += 2
	}
	return n
}

func (m *MiningUpMinerAck) Size() (n int) {
	var l int
	_ = l
	if m.Miner != 0 {
		n += 1 + sovMining(uint64(m.Miner))
	}
	if m.Luck != 0 {
		n += 1 + sovMining(uint64(m.Luck))
	}
	if m.IsUp {
		n += 2
	}
	return n
}

func (m *MiningBuyNumReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningBuyNumAck) Size() (n int) {
	var l int
	_ = l
	if m.BuyNum != 0 {
		n += 1 + sovMining(uint64(m.BuyNum))
	}
	return n
}

func (m *MiningStartReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningStartAck) Size() (n int) {
	var l int
	_ = l
	if m.WorkTime != 0 {
		n += 1 + sovMining(uint64(m.WorkTime))
	}
	if m.WorkNum != 0 {
		n += 1 + sovMining(uint64(m.WorkNum))
	}
	return n
}

func (m *MiningRobReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func (m *MiningRobAck) Size() (n int) {
	var l int
	_ = l
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovMining(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovMining(uint64(m.Result))
	}
	if m.RobNum != 0 {
		n += 1 + sovMining(uint64(m.RobNum))
	}
	return n
}

func (m *MiningRobFightAck) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func (m *MiningRobBackReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func (m *MiningRobBackAck) Size() (n int) {
	var l int
	_ = l
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovMining(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovMining(uint64(m.Result))
	}
	return n
}

func (m *MiningRobBackFightAck) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func (m *MiningRobListReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningRobListAck) Size() (n int) {
	var l int
	_ = l
	if len(m.MineRob) > 0 {
		for k, v := range m.MineRob {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMining(uint64(l))
			}
			mapEntrySize := 1 + sovMining(uint64(k)) + l
			n += mapEntrySize + 1 + sovMining(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MiningListReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningListAck) Size() (n int) {
	var l int
	_ = l
	if len(m.MiningList) > 0 {
		for k, v := range m.MiningList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMining(uint64(l))
			}
			mapEntrySize := 1 + sovMining(uint64(k)) + l
			n += mapEntrySize + 1 + sovMining(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MiningDrawLoadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningDrawLoadAck) Size() (n int) {
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.RobId != 0 {
		n += 1 + sovMining(uint64(m.RobId))
	}
	l = len(m.RobName)
	if l > 0 {
		n += 1 + l + sovMining(uint64(l))
	}
	if m.RobTime != 0 {
		n += 1 + sovMining(uint64(m.RobTime))
	}
	if m.RId != 0 {
		n += 1 + sovMining(uint64(m.RId))
	}
	return n
}

func (m *MiningDrawReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningDrawAck) Size() (n int) {
	var l int
	_ = l
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovMining(uint64(l))
	}
	return n
}

func (m *MiningInReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningInAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiningInfo) Size() (n int) {
	var l int
	_ = l
	if m.WorkTime != 0 {
		n += 1 + sovMining(uint64(m.WorkTime))
	}
	if m.WorkNum != 0 {
		n += 1 + sovMining(uint64(m.WorkNum))
	}
	if m.RobNum != 0 {
		n += 1 + sovMining(uint64(m.RobNum))
	}
	if m.BuyNum != 0 {
		n += 1 + sovMining(uint64(m.BuyNum))
	}
	if m.Miner != 0 {
		n += 1 + sovMining(uint64(m.Miner))
	}
	if m.Luck != 0 {
		n += 1 + sovMining(uint64(m.Luck))
	}
	return n
}

func (m *MiningRob) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMining(uint64(l))
	}
	if m.Combat != 0 {
		n += 1 + sovMining(uint64(m.Combat))
	}
	if m.Miner != 0 {
		n += 1 + sovMining(uint64(m.Miner))
	}
	if m.RobTime != 0 {
		n += 1 + sovMining(uint64(m.RobTime))
	}
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func (m *MiningListInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMining(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMining(uint64(l))
	}
	if m.Combat != 0 {
		n += 1 + sovMining(uint64(m.Combat))
	}
	if m.Time != 0 {
		n += 1 + sovMining(uint64(m.Time))
	}
	if m.Miner != 0 {
		n += 1 + sovMining(uint64(m.Miner))
	}
	if m.Id != 0 {
		n += 1 + sovMining(uint64(m.Id))
	}
	return n
}

func sovMining(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMining(x uint64) (n int) {
	return sovMining(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MiningLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mining", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mining == nil {
				m.Mining = &MiningInfo{}
			}
			if err := m.Mining.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningUpMinerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningUpMinerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningUpMinerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMax = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningUpMinerAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningUpMinerAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningUpMinerAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Luck", wireType)
			}
			m.Luck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Luck |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningBuyNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningBuyNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningBuyNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningBuyNumAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningBuyNumAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningBuyNumAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningStartReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningStartReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningStartReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkTime", wireType)
			}
			m.WorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkNum", wireType)
			}
			m.WorkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobNum", wireType)
			}
			m.RobNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobBackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobBackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobBackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobBackAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobBackAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobBackAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobBackFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobBackFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobBackFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRobListAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRobListAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRobListAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MineRob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MineRob == nil {
				m.MineRob = make(map[int64]*MiningRob)
			}
			var mapkey int64
			var mapvalue *MiningRob
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMining
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMining
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMining
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMining
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMining
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MiningRob{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMining(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMining
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MineRob[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningListAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningListAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningListAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MiningList == nil {
				m.MiningList = make(map[int64]*MiningListInfo)
			}
			var mapkey int64
			var mapvalue *MiningListInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMining
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMining
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMining
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMining
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMining
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MiningListInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMining(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMining
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MiningList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningDrawLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningDrawLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningDrawLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningDrawLoadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningDrawLoadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningDrawLoadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobId", wireType)
			}
			m.RobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobTime", wireType)
			}
			m.RobTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RId", wireType)
			}
			m.RId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningDrawReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningDrawReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningDrawReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningDrawAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningDrawAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningDrawAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &GoodsChangeNtf{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningInReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningInReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningInReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningInAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningInAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningInAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkTime", wireType)
			}
			m.WorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkNum", wireType)
			}
			m.WorkNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobNum", wireType)
			}
			m.RobNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Luck", wireType)
			}
			m.Luck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Luck |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobTime", wireType)
			}
			m.RobTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningListInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMining
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningListInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningListInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMining
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			m.Miner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Miner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMining
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMining(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMining
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMining(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMining
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMining
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMining
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMining
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMining
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMining(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMining = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMining   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mining.proto", fileDescriptorMining) }

var fileDescriptorMining = []byte{
	// 697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0x9c, 0xb6, 0x93, 0xfe, 0xa4, 0xa6, 0xa0, 0x28, 0x87, 0xa8, 0x6c, 0x25, 0x08,
	0x97, 0x1e, 0xca, 0x81, 0xbf, 0x53, 0x0b, 0x14, 0x45, 0x6a, 0x2b, 0x58, 0xda, 0x07, 0xb0, 0x63,
	0x37, 0xb5, 0x52, 0x7b, 0x53, 0xff, 0x50, 0xfa, 0x04, 0xf0, 0x08, 0x08, 0x71, 0xe5, 0x5d, 0x38,
	0xf2, 0x08, 0xa8, 0xbc, 0x08, 0x9a, 0xd9, 0x5d, 0x7b, 0x1d, 0xd2, 0x03, 0x88, 0xdb, 0xcc, 0xb7,
	0x33, 0xf3, 0x7d, 0xeb, 0x9d, 0x19, 0xc3, 0x72, 0x1c, 0x25, 0x51, 0x32, 0xde, 0x9e, 0xa6, 0x22,
	0x17, 0x6e, 0x63, 0xea, 0xf7, 0x96, 0x47, 0x22, 0x8e, 0x45, 0x22, 0x11, 0xb6, 0x06, 0x2b, 0x87,
	0x14, 0x71, 0x20, 0xbc, 0x80, 0x87, 0x17, 0xec, 0xb1, 0x09, 0xec, 0x8e, 0x26, 0xee, 0x7d, 0x68,
	0xc9, 0x1a, 0x5d, 0x6b, 0xd3, 0x1a, 0xb4, 0x77, 0x56, 0xb7, 0xa7, 0xfe, 0xb6, 0x0c, 0x19, 0x26,
	0xa7, 0x82, 0xab, 0x53, 0x36, 0x80, 0x8e, 0x44, 0x4f, 0xa6, 0x87, 0x51, 0x12, 0xa6, 0x3c, 0xbc,
	0x70, 0x37, 0xc0, 0x89, 0xb2, 0x43, 0xef, 0x03, 0xa5, 0x2e, 0x72, 0xe9, 0xb0, 0x37, 0x33, 0x91,
	0xc8, 0xb2, 0x01, 0x4e, 0x8c, 0x36, 0x45, 0x3a, 0x5c, 0x3a, 0xae, 0x0b, 0xcd, 0xf3, 0x62, 0x34,
	0xe9, 0x36, 0x08, 0x24, 0x1b, 0xb1, 0x28, 0x3b, 0x99, 0x76, 0x6d, 0x2a, 0x49, 0x36, 0x5b, 0x87,
	0x35, 0x59, 0x71, 0xaf, 0xb8, 0x3a, 0x2a, 0x62, 0xbc, 0xc7, 0xc3, 0x3a, 0x84, 0x1c, 0x77, 0xa1,
	0xe5, 0x93, 0xa3, 0x48, 0x94, 0xc7, 0x3a, 0xb0, 0x2a, 0x43, 0xdf, 0xe5, 0x5e, 0x9a, 0x63, 0xf2,
	0x7e, 0x0d, 0xc1, 0xdc, 0x1e, 0x2c, 0x5e, 0x8a, 0x74, 0x72, 0x1c, 0xc5, 0x21, 0x65, 0xdb, 0xbc,
	0xf4, 0xdd, 0x2e, 0x2c, 0xa0, 0x8d, 0x85, 0xa5, 0x50, 0xed, 0xb2, 0x3e, 0x2c, 0xcb, 0x3a, 0x5c,
	0xf8, 0xf8, 0x3d, 0x56, 0xa1, 0x11, 0x05, 0x8a, 0xbd, 0x11, 0x05, 0xec, 0xcc, 0x38, 0x47, 0x96,
	0x01, 0x38, 0x63, 0x21, 0x82, 0x4c, 0x7d, 0x6a, 0x17, 0x3f, 0xf5, 0x6b, 0x04, 0x5e, 0x9c, 0x79,
	0xc9, 0x38, 0x3c, 0xca, 0x4f, 0xb9, 0x0c, 0xc0, 0xbb, 0xa4, 0x61, 0x56, 0x9c, 0xe7, 0x8a, 0x52,
	0x79, 0x84, 0x0b, 0x1f, 0xa5, 0xd8, 0x0a, 0x27, 0x8f, 0x6d, 0xc1, 0x7a, 0xc9, 0xb4, 0x1f, 0x8d,
	0xcf, 0xe8, 0x52, 0xb3, 0x72, 0x98, 0x7e, 0x18, 0x2e, 0xfc, 0x3d, 0x6f, 0x34, 0xa9, 0x4b, 0xb6,
	0x29, 0xe6, 0x78, 0x26, 0xe6, 0xbf, 0xc8, 0x66, 0x0f, 0xe0, 0x4e, 0xad, 0xea, 0x1c, 0x89, 0x92,
	0xde, 0x35, 0xe8, 0x0f, 0xa2, 0x8c, 0x5e, 0xeb, 0x8b, 0x35, 0x03, 0x62, 0xe2, 0x73, 0x58, 0xc0,
	0x1e, 0xe2, 0xc2, 0xef, 0x5a, 0x9b, 0xf6, 0xa0, 0xbd, 0x73, 0xaf, 0xea, 0xdb, 0x2a, 0x0c, 0x01,
	0x8c, 0x79, 0x95, 0xe4, 0xe9, 0x15, 0xd7, 0x19, 0xbd, 0x21, 0xbd, 0x4b, 0x79, 0xe0, 0x76, 0xc0,
	0x9e, 0x84, 0x57, 0x4a, 0x06, 0x9a, 0xee, 0x16, 0x38, 0xef, 0xbd, 0xf3, 0x22, 0xa4, 0x7b, 0xb4,
	0x77, 0x56, 0x6a, 0xc5, 0xb9, 0x3c, 0x7b, 0xd6, 0x78, 0x62, 0x19, 0x03, 0xa6, 0xd4, 0x7e, 0xb3,
	0x4c, 0x04, 0xa5, 0xee, 0x02, 0xc4, 0x25, 0xf0, 0xa7, 0x5a, 0x43, 0xaa, 0xf2, 0xa4, 0x5a, 0x23,
	0xa9, 0xf7, 0x56, 0x77, 0x7b, 0x79, 0x3c, 0x47, 0xf3, 0xa0, 0xae, 0xd9, 0xad, 0x53, 0xd0, 0x30,
	0x1b, 0xc2, 0x6f, 0xeb, 0x8e, 0x79, 0x99, 0x7a, 0x97, 0x7a, 0x3b, 0x7c, 0xb4, 0x66, 0x51, 0x35,
	0x58, 0x59, 0xee, 0xe5, 0x45, 0xa6, 0xe6, 0x5c, 0x79, 0x38, 0xd4, 0xa9, 0xf0, 0x87, 0x01, 0x11,
	0xda, 0x5c, 0x3a, 0x38, 0x2e, 0xd8, 0x94, 0x5e, 0x1c, 0x52, 0x8f, 0x2e, 0x71, 0xed, 0xaa, 0x13,
	0x9a, 0xb1, 0x26, 0x65, 0x68, 0x17, 0x2f, 0x93, 0x0e, 0x83, 0xae, 0x23, 0x2f, 0x93, 0x0e, 0x83,
	0xea, 0xbb, 0xa2, 0x10, 0x94, 0xf6, 0xd4, 0x04, 0xfe, 0xaa, 0x2b, 0xd9, 0x0a, 0xb4, 0xf5, 0x42,
	0xc3, 0x4a, 0x86, 0xbb, 0x3b, 0x9a, 0xb0, 0xaf, 0x16, 0x40, 0xb5, 0xef, 0xfe, 0x6d, 0x13, 0xdc,
	0x34, 0x97, 0xc6, 0x4e, 0x6a, 0x9a, 0x3b, 0xa9, 0xda, 0x87, 0xce, 0xbc, 0x7d, 0xd8, 0xaa, 0xf6,
	0x21, 0xbb, 0x84, 0xa5, 0xb2, 0xf1, 0x30, 0x20, 0xf1, 0x94, 0xb0, 0x25, 0x4e, 0x36, 0x52, 0x8c,
	0x44, 0xec, 0x7b, 0xb9, 0x7a, 0x06, 0xe5, 0x55, 0x14, 0xb6, 0x49, 0x71, 0xf3, 0x1b, 0xc8, 0x51,
	0x74, 0xca, 0x51, 0xfc, 0x64, 0xe9, 0x2d, 0xa9, 0xdb, 0x07, 0x9f, 0xa9, 0x28, 0x37, 0x0a, 0x9a,
	0xa5, 0xa0, 0xc6, 0x5c, 0x41, 0x76, 0x4d, 0x90, 0x0b, 0xcd, 0xbc, 0xe2, 0x25, 0xfb, 0x86, 0xef,
	0x20, 0xa5, 0xb4, 0xb4, 0x94, 0xbd, 0xce, 0xf7, 0xeb, 0xbe, 0xf5, 0xe3, 0xba, 0x6f, 0xfd, 0xbc,
	0xee, 0x5b, 0x9f, 0x7f, 0xf5, 0x6f, 0xf9, 0x2d, 0xfa, 0xbd, 0x3d, 0xfa, 0x1d, 0x00, 0x00, 0xff,
	0xff, 0x79, 0xb1, 0xc0, 0x28, 0x00, 0x07, 0x00, 0x00,
}
