// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: crossAuction.proto

package pbserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// gs->ccs 请求拍卖物品的信息
type GsAuctionInfoNtf struct {
	UserId      int64  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId    int32  `protobuf:"varint,2,opt,name=serverId,proto3" json:"serverId,omitempty"`
	CrossGroup  string `protobuf:"bytes,3,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	AuctionType int32  `protobuf:"varint,4,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	GuildId     int32  `protobuf:"varint,5,opt,name=guildId,proto3" json:"guildId,omitempty"`
}

func (m *GsAuctionInfoNtf) Reset()                    { *m = GsAuctionInfoNtf{} }
func (m *GsAuctionInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*GsAuctionInfoNtf) ProtoMessage()               {}
func (*GsAuctionInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{0} }

func (m *GsAuctionInfoNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsAuctionInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *GsAuctionInfoNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsAuctionInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *GsAuctionInfoNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

// ccs->gs 回复gs拍卖物品的信息
type CrossAuctionInfoNtf struct {
	UserId           int64              `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId         int32              `protobuf:"varint,2,opt,name=serverId,proto3" json:"serverId,omitempty"`
	AuctionType      int32              `protobuf:"varint,3,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionItemInfos []*AuctionItemInfo `protobuf:"bytes,4,rep,name=AuctionItemInfos" json:"AuctionItemInfos,omitempty"`
}

func (m *CrossAuctionInfoNtf) Reset()                    { *m = CrossAuctionInfoNtf{} }
func (m *CrossAuctionInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossAuctionInfoNtf) ProtoMessage()               {}
func (*CrossAuctionInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{1} }

func (m *CrossAuctionInfoNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CrossAuctionInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossAuctionInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *CrossAuctionInfoNtf) GetAuctionItemInfos() []*AuctionItemInfo {
	if m != nil {
		return m.AuctionItemInfos
	}
	return nil
}

// 竞拍物品信息
type AuctionItemInfo struct {
	AuctionId              int64   `protobuf:"varint,1,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	ItemId                 int32   `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	AuctionTime            int64   `protobuf:"varint,3,opt,name=auctionTime,proto3" json:"auctionTime,omitempty"`
	AuctionDuration        int32   `protobuf:"varint,4,opt,name=auctionDuration,proto3" json:"auctionDuration,omitempty"`
	NowBidPrice            int32   `protobuf:"varint,5,opt,name=nowBidPrice,proto3" json:"nowBidPrice,omitempty"`
	NowBidUserId           int64   `protobuf:"varint,6,opt,name=nowBidUserId,proto3" json:"nowBidUserId,omitempty"`
	AuctionType            int32   `protobuf:"varint,7,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	NowBidderNickname      string  `protobuf:"bytes,8,opt,name=nowBidderNickname,proto3" json:"nowBidderNickname,omitempty"`
	NowBidderAvatar        string  `protobuf:"bytes,9,opt,name=nowBidderAvatar,proto3" json:"nowBidderAvatar,omitempty"`
	AuctionSrc             int32   `protobuf:"varint,10,opt,name=auctionSrc,proto3" json:"auctionSrc,omitempty"`
	NowBidPlayerCrossGroup string  `protobuf:"bytes,11,opt,name=nowBidPlayerCrossGroup,proto3" json:"nowBidPlayerCrossGroup,omitempty"`
	BidGuildId             []int32 `protobuf:"varint,12,rep,packed,name=bidGuildId" json:"bidGuildId,omitempty"`
	DropState              int32   `protobuf:"varint,13,opt,name=dropState,proto3" json:"dropState,omitempty"`
	DropTime               int32   `protobuf:"varint,14,opt,name=dropTime,proto3" json:"dropTime,omitempty"`
}

func (m *AuctionItemInfo) Reset()                    { *m = AuctionItemInfo{} }
func (m *AuctionItemInfo) String() string            { return proto.CompactTextString(m) }
func (*AuctionItemInfo) ProtoMessage()               {}
func (*AuctionItemInfo) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{2} }

func (m *AuctionItemInfo) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionItemInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionTime() int64 {
	if m != nil {
		return m.AuctionTime
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionDuration() int32 {
	if m != nil {
		return m.AuctionDuration
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidPrice() int32 {
	if m != nil {
		return m.NowBidPrice
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidUserId() int64 {
	if m != nil {
		return m.NowBidUserId
	}
	return 0
}

func (m *AuctionItemInfo) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidderNickname() string {
	if m != nil {
		return m.NowBidderNickname
	}
	return ""
}

func (m *AuctionItemInfo) GetNowBidderAvatar() string {
	if m != nil {
		return m.NowBidderAvatar
	}
	return ""
}

func (m *AuctionItemInfo) GetAuctionSrc() int32 {
	if m != nil {
		return m.AuctionSrc
	}
	return 0
}

func (m *AuctionItemInfo) GetNowBidPlayerCrossGroup() string {
	if m != nil {
		return m.NowBidPlayerCrossGroup
	}
	return ""
}

func (m *AuctionItemInfo) GetBidGuildId() []int32 {
	if m != nil {
		return m.BidGuildId
	}
	return nil
}

func (m *AuctionItemInfo) GetDropState() int32 {
	if m != nil {
		return m.DropState
	}
	return 0
}

func (m *AuctionItemInfo) GetDropTime() int32 {
	if m != nil {
		return m.DropTime
	}
	return 0
}

// gs->ccs gs请求拍卖物品的信息ntf
type GsBidInfoNtf struct {
	AuctionType int32  `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionId   int64  `protobuf:"varint,2,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	ItemId      int32  `protobuf:"varint,3,opt,name=itemId,proto3" json:"itemId,omitempty"`
	UserId      int64  `protobuf:"varint,4,opt,name=userId,proto3" json:"userId,omitempty"`
	CrossGroup  string `protobuf:"bytes,5,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	ServerId    int32  `protobuf:"varint,6,opt,name=serverId,proto3" json:"serverId,omitempty"`
	GuildId     int32  `protobuf:"varint,7,opt,name=guildId,proto3" json:"guildId,omitempty"`
	IsBuyNow    bool   `protobuf:"varint,8,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
}

func (m *GsBidInfoNtf) Reset()                    { *m = GsBidInfoNtf{} }
func (m *GsBidInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*GsBidInfoNtf) ProtoMessage()               {}
func (*GsBidInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{3} }

func (m *GsBidInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *GsBidInfoNtf) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *GsBidInfoNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *GsBidInfoNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsBidInfoNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsBidInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *GsBidInfoNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GsBidInfoNtf) GetIsBuyNow() bool {
	if m != nil {
		return m.IsBuyNow
	}
	return false
}

// ccs->gs ccs回复gs拍卖物品信息ntf
type CrossBidInfoNtf struct {
	AuctionType int32            `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionInfo *AuctionItemInfo `protobuf:"bytes,3,opt,name=auctionInfo" json:"auctionInfo,omitempty"`
	UserId      int64            `protobuf:"varint,4,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId    int32            `protobuf:"varint,5,opt,name=serverId,proto3" json:"serverId,omitempty"`
	Code        int32            `protobuf:"varint,6,opt,name=code,proto3" json:"code,omitempty"`
	IsBuyNow    bool             `protobuf:"varint,7,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
}

func (m *CrossBidInfoNtf) Reset()                    { *m = CrossBidInfoNtf{} }
func (m *CrossBidInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossBidInfoNtf) ProtoMessage()               {}
func (*CrossBidInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{4} }

func (m *CrossBidInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *CrossBidInfoNtf) GetAuctionInfo() *AuctionItemInfo {
	if m != nil {
		return m.AuctionInfo
	}
	return nil
}

func (m *CrossBidInfoNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CrossBidInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossBidInfoNtf) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CrossBidInfoNtf) GetIsBuyNow() bool {
	if m != nil {
		return m.IsBuyNow
	}
	return false
}

// gs->ccs user bid request
type GsBidNtf struct {
	AuctionType      int32   `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionId        int64   `protobuf:"varint,3,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	ItemId           int32   `protobuf:"varint,4,opt,name=itemId,proto3" json:"itemId,omitempty"`
	BidPrice         int32   `protobuf:"varint,5,opt,name=bidPrice,proto3" json:"bidPrice,omitempty"`
	UserId           int64   `protobuf:"varint,6,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId         int32   `protobuf:"varint,7,opt,name=serverId,proto3" json:"serverId,omitempty"`
	CrossGroup       string  `protobuf:"bytes,8,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	IsBuyNow         int32   `protobuf:"varint,9,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
	GuildId          int32   `protobuf:"varint,10,opt,name=guildId,proto3" json:"guildId,omitempty"`
	BidGuildId       []int32 `protobuf:"varint,11,rep,packed,name=bidGuildId" json:"bidGuildId,omitempty"`
	DropTime         int32   `protobuf:"varint,12,opt,name=dropTime,proto3" json:"dropTime,omitempty"`
	RobotNickName    string  `protobuf:"bytes,13,opt,name=RobotNickName,proto3" json:"RobotNickName,omitempty"`
	RobotAvatar      string  `protobuf:"bytes,14,opt,name=RobotAvatar,proto3" json:"RobotAvatar,omitempty"`
	SkyCustomsUserId int64   `protobuf:"varint,15,opt,name=skyCustomsUserId,proto3" json:"skyCustomsUserId,omitempty"`
}

func (m *GsBidNtf) Reset()                    { *m = GsBidNtf{} }
func (m *GsBidNtf) String() string            { return proto.CompactTextString(m) }
func (*GsBidNtf) ProtoMessage()               {}
func (*GsBidNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{5} }

func (m *GsBidNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *GsBidNtf) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *GsBidNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *GsBidNtf) GetBidPrice() int32 {
	if m != nil {
		return m.BidPrice
	}
	return 0
}

func (m *GsBidNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsBidNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *GsBidNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsBidNtf) GetIsBuyNow() int32 {
	if m != nil {
		return m.IsBuyNow
	}
	return 0
}

func (m *GsBidNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GsBidNtf) GetBidGuildId() []int32 {
	if m != nil {
		return m.BidGuildId
	}
	return nil
}

func (m *GsBidNtf) GetDropTime() int32 {
	if m != nil {
		return m.DropTime
	}
	return 0
}

func (m *GsBidNtf) GetRobotNickName() string {
	if m != nil {
		return m.RobotNickName
	}
	return ""
}

func (m *GsBidNtf) GetRobotAvatar() string {
	if m != nil {
		return m.RobotAvatar
	}
	return ""
}

func (m *GsBidNtf) GetSkyCustomsUserId() int64 {
	if m != nil {
		return m.SkyCustomsUserId
	}
	return 0
}

// ccs->gs user bid result
type CrossBidNtf struct {
	AuctionType int32            `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	AuctionInfo *AuctionItemInfo `protobuf:"bytes,3,opt,name=auctionInfo" json:"auctionInfo,omitempty"`
	Code        int32            `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	UserId      int64            `protobuf:"varint,5,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId    int32            `protobuf:"varint,6,opt,name=serverId,proto3" json:"serverId,omitempty"`
	IsBuyNow    int32            `protobuf:"varint,7,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
}

func (m *CrossBidNtf) Reset()                    { *m = CrossBidNtf{} }
func (m *CrossBidNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossBidNtf) ProtoMessage()               {}
func (*CrossBidNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{6} }

func (m *CrossBidNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *CrossBidNtf) GetAuctionInfo() *AuctionItemInfo {
	if m != nil {
		return m.AuctionInfo
	}
	return nil
}

func (m *CrossBidNtf) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CrossBidNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CrossBidNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossBidNtf) GetIsBuyNow() int32 {
	if m != nil {
		return m.IsBuyNow
	}
	return 0
}

// gs->ccs request my bid infos
type GsMyBidNtf struct {
	UserId             int64                  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId           int32                  `protobuf:"varint,2,opt,name=serverId,proto3" json:"serverId,omitempty"`
	CrossGroup         string                 `protobuf:"bytes,3,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	WorldBidBriefInfos []*AuctionBidBriefInfo `protobuf:"bytes,4,rep,name=worldBidBriefInfos" json:"worldBidBriefInfos,omitempty"`
	GuildBidBriefInfos []*AuctionBidBriefInfo `protobuf:"bytes,5,rep,name=guildBidBriefInfos" json:"guildBidBriefInfos,omitempty"`
	AllBidBriefInfos   []*AuctionBidBriefInfo `protobuf:"bytes,6,rep,name=allBidBriefInfos" json:"allBidBriefInfos,omitempty"`
	GuildId            int32                  `protobuf:"varint,7,opt,name=guildId,proto3" json:"guildId,omitempty"`
}

func (m *GsMyBidNtf) Reset()                    { *m = GsMyBidNtf{} }
func (m *GsMyBidNtf) String() string            { return proto.CompactTextString(m) }
func (*GsMyBidNtf) ProtoMessage()               {}
func (*GsMyBidNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{7} }

func (m *GsMyBidNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsMyBidNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *GsMyBidNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsMyBidNtf) GetWorldBidBriefInfos() []*AuctionBidBriefInfo {
	if m != nil {
		return m.WorldBidBriefInfos
	}
	return nil
}

func (m *GsMyBidNtf) GetGuildBidBriefInfos() []*AuctionBidBriefInfo {
	if m != nil {
		return m.GuildBidBriefInfos
	}
	return nil
}

func (m *GsMyBidNtf) GetAllBidBriefInfos() []*AuctionBidBriefInfo {
	if m != nil {
		return m.AllBidBriefInfos
	}
	return nil
}

func (m *GsMyBidNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

// ccs->gs user bid infos
type CrossMyBidNtf struct {
	UserId   int64              `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerId int32              `protobuf:"varint,2,opt,name=serverId,proto3" json:"serverId,omitempty"`
	BidInfos []*AuctionItemInfo `protobuf:"bytes,3,rep,name=bidInfos" json:"bidInfos,omitempty"`
}

func (m *CrossMyBidNtf) Reset()                    { *m = CrossMyBidNtf{} }
func (m *CrossMyBidNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossMyBidNtf) ProtoMessage()               {}
func (*CrossMyBidNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{8} }

func (m *CrossMyBidNtf) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CrossMyBidNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossMyBidNtf) GetBidInfos() []*AuctionItemInfo {
	if m != nil {
		return m.BidInfos
	}
	return nil
}

// auction bid brief info
type AuctionBidBriefInfo struct {
	AuctionId int64 `protobuf:"varint,1,opt,name=AuctionId,proto3" json:"AuctionId,omitempty"`
	ItemId    int32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
}

func (m *AuctionBidBriefInfo) Reset()                    { *m = AuctionBidBriefInfo{} }
func (m *AuctionBidBriefInfo) String() string            { return proto.CompactTextString(m) }
func (*AuctionBidBriefInfo) ProtoMessage()               {}
func (*AuctionBidBriefInfo) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{9} }

func (m *AuctionBidBriefInfo) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionBidBriefInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

// ccs broadcast updated bid info to bid users and return last bid user mi
type CrossBroadcastUpdateBidInfoNtf struct {
	NeedReturn    bool             `protobuf:"varint,1,opt,name=needReturn,proto3" json:"needReturn,omitempty"`
	LastUserId    int64            `protobuf:"varint,2,opt,name=lastUserId,proto3" json:"lastUserId,omitempty"`
	LastPrice     int32            `protobuf:"varint,3,opt,name=lastPrice,proto3" json:"lastPrice,omitempty"`
	UserIds       []int64          `protobuf:"varint,4,rep,packed,name=userIds" json:"userIds,omitempty"`
	BroadcastInfo *AuctionItemInfo `protobuf:"bytes,5,opt,name=broadcastInfo" json:"broadcastInfo,omitempty"`
	ItemStatus    int32            `protobuf:"varint,6,opt,name=itemStatus,proto3" json:"itemStatus,omitempty"`
	ServerId      int32            `protobuf:"varint,7,opt,name=serverId,proto3" json:"serverId,omitempty"`
	AuctionType   int32            `protobuf:"varint,8,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
}

func (m *CrossBroadcastUpdateBidInfoNtf) Reset()         { *m = CrossBroadcastUpdateBidInfoNtf{} }
func (m *CrossBroadcastUpdateBidInfoNtf) String() string { return proto.CompactTextString(m) }
func (*CrossBroadcastUpdateBidInfoNtf) ProtoMessage()    {}
func (*CrossBroadcastUpdateBidInfoNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorCrossAuction, []int{10}
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetNeedReturn() bool {
	if m != nil {
		return m.NeedReturn
	}
	return false
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetLastUserId() int64 {
	if m != nil {
		return m.LastUserId
	}
	return 0
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetLastPrice() int32 {
	if m != nil {
		return m.LastPrice
	}
	return 0
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetUserIds() []int64 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetBroadcastInfo() *AuctionItemInfo {
	if m != nil {
		return m.BroadcastInfo
	}
	return nil
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetItemStatus() int32 {
	if m != nil {
		return m.ItemStatus
	}
	return 0
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossBroadcastUpdateBidInfoNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

// gs->ccs 拍卖物品ntf
type GsAuctionItemNtf struct {
	AuctionType   int32  `protobuf:"varint,1,opt,name=auctionType,proto3" json:"auctionType,omitempty"`
	ItemId        int32  `protobuf:"varint,3,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ArtifactUuid  int64  `protobuf:"varint,4,opt,name=artifactUuid,proto3" json:"artifactUuid,omitempty"`
	AuctionUserId int64  `protobuf:"varint,5,opt,name=auctionUserId,proto3" json:"auctionUserId,omitempty"`
	ServerId      int32  `protobuf:"varint,6,opt,name=serverId,proto3" json:"serverId,omitempty"`
	CrossGroup    string `protobuf:"bytes,7,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	AuctionSrc    int32  `protobuf:"varint,8,opt,name=auctionSrc,proto3" json:"auctionSrc,omitempty"`
	AuctionGuild  int32  `protobuf:"varint,9,opt,name=auctionGuild,proto3" json:"auctionGuild,omitempty"`
	ItemType      int32  `protobuf:"varint,10,opt,name=itemType,proto3" json:"itemType,omitempty"`
	NeedItemId    int32  `protobuf:"varint,11,opt,name=needItemId,proto3" json:"needItemId,omitempty"`
}

func (m *GsAuctionItemNtf) Reset()                    { *m = GsAuctionItemNtf{} }
func (m *GsAuctionItemNtf) String() string            { return proto.CompactTextString(m) }
func (*GsAuctionItemNtf) ProtoMessage()               {}
func (*GsAuctionItemNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{11} }

func (m *GsAuctionItemNtf) GetAuctionType() int32 {
	if m != nil {
		return m.AuctionType
	}
	return 0
}

func (m *GsAuctionItemNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *GsAuctionItemNtf) GetArtifactUuid() int64 {
	if m != nil {
		return m.ArtifactUuid
	}
	return 0
}

func (m *GsAuctionItemNtf) GetAuctionUserId() int64 {
	if m != nil {
		return m.AuctionUserId
	}
	return 0
}

func (m *GsAuctionItemNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *GsAuctionItemNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsAuctionItemNtf) GetAuctionSrc() int32 {
	if m != nil {
		return m.AuctionSrc
	}
	return 0
}

func (m *GsAuctionItemNtf) GetAuctionGuild() int32 {
	if m != nil {
		return m.AuctionGuild
	}
	return 0
}

func (m *GsAuctionItemNtf) GetItemType() int32 {
	if m != nil {
		return m.ItemType
	}
	return 0
}

func (m *GsAuctionItemNtf) GetNeedItemId() int32 {
	if m != nil {
		return m.NeedItemId
	}
	return 0
}

// ccs->gs 拍卖物品ntf
type CrossAuctionItemNtf struct {
	ArtifactUuid  int64 `protobuf:"varint,1,opt,name=artifactUuid,proto3" json:"artifactUuid,omitempty"`
	AuctionUserId int64 `protobuf:"varint,2,opt,name=auctionUserId,proto3" json:"auctionUserId,omitempty"`
	ServerId      int32 `protobuf:"varint,3,opt,name=serverId,proto3" json:"serverId,omitempty"`
	AuctionId     int64 `protobuf:"varint,4,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	Code          int32 `protobuf:"varint,5,opt,name=code,proto3" json:"code,omitempty"`
	ItemId        int32 `protobuf:"varint,6,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemType      int32 `protobuf:"varint,7,opt,name=itemType,proto3" json:"itemType,omitempty"`
}

func (m *CrossAuctionItemNtf) Reset()                    { *m = CrossAuctionItemNtf{} }
func (m *CrossAuctionItemNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossAuctionItemNtf) ProtoMessage()               {}
func (*CrossAuctionItemNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{12} }

func (m *CrossAuctionItemNtf) GetArtifactUuid() int64 {
	if m != nil {
		return m.ArtifactUuid
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetAuctionUserId() int64 {
	if m != nil {
		return m.AuctionUserId
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CrossAuctionItemNtf) GetItemType() int32 {
	if m != nil {
		return m.ItemType
	}
	return 0
}

// 竞拍时间到，给拍卖玩家发放元宝（扣除抽成）
type CrossAuctionItemEndNtf struct {
	ItemId        int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ArtifactUuid  int64 `protobuf:"varint,2,opt,name=artifactUuid,proto3" json:"artifactUuid,omitempty"`
	AuctionUserId int64 `protobuf:"varint,3,opt,name=auctionUserId,proto3" json:"auctionUserId,omitempty"`
	EarnMi        int32 `protobuf:"varint,4,opt,name=earnMi,proto3" json:"earnMi,omitempty"`
	AuctionResult int32 `protobuf:"varint,5,opt,name=auctionResult,proto3" json:"auctionResult,omitempty"`
	AuctionSrc    int32 `protobuf:"varint,6,opt,name=auctionSrc,proto3" json:"auctionSrc,omitempty"`
}

func (m *CrossAuctionItemEndNtf) Reset()         { *m = CrossAuctionItemEndNtf{} }
func (m *CrossAuctionItemEndNtf) String() string { return proto.CompactTextString(m) }
func (*CrossAuctionItemEndNtf) ProtoMessage()    {}
func (*CrossAuctionItemEndNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorCrossAuction, []int{13}
}

func (m *CrossAuctionItemEndNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CrossAuctionItemEndNtf) GetArtifactUuid() int64 {
	if m != nil {
		return m.ArtifactUuid
	}
	return 0
}

func (m *CrossAuctionItemEndNtf) GetAuctionUserId() int64 {
	if m != nil {
		return m.AuctionUserId
	}
	return 0
}

func (m *CrossAuctionItemEndNtf) GetEarnMi() int32 {
	if m != nil {
		return m.EarnMi
	}
	return 0
}

func (m *CrossAuctionItemEndNtf) GetAuctionResult() int32 {
	if m != nil {
		return m.AuctionResult
	}
	return 0
}

func (m *CrossAuctionItemEndNtf) GetAuctionSrc() int32 {
	if m != nil {
		return m.AuctionSrc
	}
	return 0
}

// 竞拍时间到或者一口价 给竞拍玩家发放道具
type CrossBidItemEndNtf struct {
	ItemId        int32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	BidUserId     int64 `protobuf:"varint,2,opt,name=bidUserId,proto3" json:"bidUserId,omitempty"`
	AuctionId     int64 `protobuf:"varint,3,opt,name=auctionId,proto3" json:"auctionId,omitempty"`
	IsBuyNow      bool  `protobuf:"varint,4,opt,name=isBuyNow,proto3" json:"isBuyNow,omitempty"`
	BidMiNum      int32 `protobuf:"varint,5,opt,name=bidMiNum,proto3" json:"bidMiNum,omitempty"`
	AuctionUserId int64 `protobuf:"varint,6,opt,name=auctionUserId,proto3" json:"auctionUserId,omitempty"`
	UserServerId  int32 `protobuf:"varint,7,opt,name=userServerId,proto3" json:"userServerId,omitempty"`
}

func (m *CrossBidItemEndNtf) Reset()                    { *m = CrossBidItemEndNtf{} }
func (m *CrossBidItemEndNtf) String() string            { return proto.CompactTextString(m) }
func (*CrossBidItemEndNtf) ProtoMessage()               {}
func (*CrossBidItemEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorCrossAuction, []int{14} }

func (m *CrossBidItemEndNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CrossBidItemEndNtf) GetBidUserId() int64 {
	if m != nil {
		return m.BidUserId
	}
	return 0
}

func (m *CrossBidItemEndNtf) GetAuctionId() int64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *CrossBidItemEndNtf) GetIsBuyNow() bool {
	if m != nil {
		return m.IsBuyNow
	}
	return false
}

func (m *CrossBidItemEndNtf) GetBidMiNum() int32 {
	if m != nil {
		return m.BidMiNum
	}
	return 0
}

func (m *CrossBidItemEndNtf) GetAuctionUserId() int64 {
	if m != nil {
		return m.AuctionUserId
	}
	return 0
}

func (m *CrossBidItemEndNtf) GetUserServerId() int32 {
	if m != nil {
		return m.UserServerId
	}
	return 0
}

// gs->ccs, 处理门派掉落神兵
type GsGuildAuctionDropNtf struct {
	GuildId    int32   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	CrossGroup string  `protobuf:"bytes,2,opt,name=crossGroup,proto3" json:"crossGroup,omitempty"`
	ItemId     int32   `protobuf:"varint,3,opt,name=itemId,proto3" json:"itemId,omitempty"`
	ItemNum    int32   `protobuf:"varint,4,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
	BidGuildId []int32 `protobuf:"varint,5,rep,packed,name=bidGuildId" json:"bidGuildId,omitempty"`
	DropState  int32   `protobuf:"varint,6,opt,name=dropState,proto3" json:"dropState,omitempty"`
	DropTime   int32   `protobuf:"varint,7,opt,name=dropTime,proto3" json:"dropTime,omitempty"`
}

func (m *GsGuildAuctionDropNtf) Reset()         { *m = GsGuildAuctionDropNtf{} }
func (m *GsGuildAuctionDropNtf) String() string { return proto.CompactTextString(m) }
func (*GsGuildAuctionDropNtf) ProtoMessage()    {}
func (*GsGuildAuctionDropNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorCrossAuction, []int{15}
}

func (m *GsGuildAuctionDropNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GsGuildAuctionDropNtf) GetCrossGroup() string {
	if m != nil {
		return m.CrossGroup
	}
	return ""
}

func (m *GsGuildAuctionDropNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *GsGuildAuctionDropNtf) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *GsGuildAuctionDropNtf) GetBidGuildId() []int32 {
	if m != nil {
		return m.BidGuildId
	}
	return nil
}

func (m *GsGuildAuctionDropNtf) GetDropState() int32 {
	if m != nil {
		return m.DropState
	}
	return 0
}

func (m *GsGuildAuctionDropNtf) GetDropTime() int32 {
	if m != nil {
		return m.DropTime
	}
	return 0
}

// ccs->gs, 拍卖行公告
type CrossAuctionNoticeNtf struct {
	NoticeType    int32  `protobuf:"varint,1,opt,name=noticeType,proto3" json:"noticeType,omitempty"`
	NoticeContent string `protobuf:"bytes,2,opt,name=noticeContent,proto3" json:"noticeContent,omitempty"`
	ChatMsgType   int32  `protobuf:"varint,3,opt,name=chatMsgType,proto3" json:"chatMsgType,omitempty"`
}

func (m *CrossAuctionNoticeNtf) Reset()         { *m = CrossAuctionNoticeNtf{} }
func (m *CrossAuctionNoticeNtf) String() string { return proto.CompactTextString(m) }
func (*CrossAuctionNoticeNtf) ProtoMessage()    {}
func (*CrossAuctionNoticeNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorCrossAuction, []int{16}
}

func (m *CrossAuctionNoticeNtf) GetNoticeType() int32 {
	if m != nil {
		return m.NoticeType
	}
	return 0
}

func (m *CrossAuctionNoticeNtf) GetNoticeContent() string {
	if m != nil {
		return m.NoticeContent
	}
	return ""
}

func (m *CrossAuctionNoticeNtf) GetChatMsgType() int32 {
	if m != nil {
		return m.ChatMsgType
	}
	return 0
}

func init() {
	proto.RegisterType((*GsAuctionInfoNtf)(nil), "pbserver.GsAuctionInfoNtf")
	proto.RegisterType((*CrossAuctionInfoNtf)(nil), "pbserver.CrossAuctionInfoNtf")
	proto.RegisterType((*AuctionItemInfo)(nil), "pbserver.AuctionItemInfo")
	proto.RegisterType((*GsBidInfoNtf)(nil), "pbserver.GsBidInfoNtf")
	proto.RegisterType((*CrossBidInfoNtf)(nil), "pbserver.CrossBidInfoNtf")
	proto.RegisterType((*GsBidNtf)(nil), "pbserver.GsBidNtf")
	proto.RegisterType((*CrossBidNtf)(nil), "pbserver.CrossBidNtf")
	proto.RegisterType((*GsMyBidNtf)(nil), "pbserver.GsMyBidNtf")
	proto.RegisterType((*CrossMyBidNtf)(nil), "pbserver.CrossMyBidNtf")
	proto.RegisterType((*AuctionBidBriefInfo)(nil), "pbserver.AuctionBidBriefInfo")
	proto.RegisterType((*CrossBroadcastUpdateBidInfoNtf)(nil), "pbserver.CrossBroadcastUpdateBidInfoNtf")
	proto.RegisterType((*GsAuctionItemNtf)(nil), "pbserver.GsAuctionItemNtf")
	proto.RegisterType((*CrossAuctionItemNtf)(nil), "pbserver.CrossAuctionItemNtf")
	proto.RegisterType((*CrossAuctionItemEndNtf)(nil), "pbserver.CrossAuctionItemEndNtf")
	proto.RegisterType((*CrossBidItemEndNtf)(nil), "pbserver.CrossBidItemEndNtf")
	proto.RegisterType((*GsGuildAuctionDropNtf)(nil), "pbserver.GsGuildAuctionDropNtf")
	proto.RegisterType((*CrossAuctionNoticeNtf)(nil), "pbserver.CrossAuctionNoticeNtf")
}
func (m *GsAuctionInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsAuctionInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.GuildId))
	}
	return i, nil
}

func (m *CrossAuctionInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossAuctionInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if len(m.AuctionItemInfos) > 0 {
		for _, msg := range m.AuctionItemInfos {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCrossAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuctionItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionItemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.AuctionTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionTime))
	}
	if m.AuctionDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionDuration))
	}
	if m.NowBidPrice != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.NowBidPrice))
	}
	if m.NowBidUserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.NowBidUserId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if len(m.NowBidderNickname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.NowBidderNickname)))
		i += copy(dAtA[i:], m.NowBidderNickname)
	}
	if len(m.NowBidderAvatar) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.NowBidderAvatar)))
		i += copy(dAtA[i:], m.NowBidderAvatar)
	}
	if m.AuctionSrc != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionSrc))
	}
	if len(m.NowBidPlayerCrossGroup) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.NowBidPlayerCrossGroup)))
		i += copy(dAtA[i:], m.NowBidPlayerCrossGroup)
	}
	if len(m.BidGuildId) > 0 {
		dAtA2 := make([]byte, len(m.BidGuildId)*10)
		var j1 int
		for _, num1 := range m.BidGuildId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.DropState != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.DropState))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *GsBidInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsBidInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.GuildId))
	}
	if m.IsBuyNow {
		dAtA[i] = 0x40
		i++
		if m.IsBuyNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CrossBidInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossBidInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionInfo.Size()))
		n3, err := m.AuctionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.Code))
	}
	if m.IsBuyNow {
		dAtA[i] = 0x38
		i++
		if m.IsBuyNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsBidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsBidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.BidPrice != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.BidPrice))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if m.IsBuyNow != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.IsBuyNow))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.GuildId))
	}
	if len(m.BidGuildId) > 0 {
		dAtA5 := make([]byte, len(m.BidGuildId)*10)
		var j4 int
		for _, num1 := range m.BidGuildId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.DropTime))
	}
	if len(m.RobotNickName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.RobotNickName)))
		i += copy(dAtA[i:], m.RobotNickName)
	}
	if len(m.RobotAvatar) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.RobotAvatar)))
		i += copy(dAtA[i:], m.RobotAvatar)
	}
	if m.SkyCustomsUserId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.SkyCustomsUserId))
	}
	return i, nil
}

func (m *CrossBidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossBidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionInfo.Size()))
		n6, err := m.AuctionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Code != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.IsBuyNow != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.IsBuyNow))
	}
	return i, nil
}

func (m *GsMyBidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsMyBidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if len(m.WorldBidBriefInfos) > 0 {
		for _, msg := range m.WorldBidBriefInfos {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCrossAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildBidBriefInfos) > 0 {
		for _, msg := range m.GuildBidBriefInfos {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCrossAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllBidBriefInfos) > 0 {
		for _, msg := range m.AllBidBriefInfos {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCrossAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.GuildId))
	}
	return i, nil
}

func (m *CrossMyBidNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossMyBidNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if len(m.BidInfos) > 0 {
		for _, msg := range m.BidInfos {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCrossAuction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuctionBidBriefInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionBidBriefInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *CrossBroadcastUpdateBidInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossBroadcastUpdateBidInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedReturn {
		dAtA[i] = 0x8
		i++
		if m.NeedReturn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.LastUserId))
	}
	if m.LastPrice != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.LastPrice))
	}
	if len(m.UserIds) > 0 {
		dAtA8 := make([]byte, len(m.UserIds)*10)
		var j7 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.BroadcastInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.BroadcastInfo.Size()))
		n9, err := m.BroadcastInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ItemStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemStatus))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.AuctionType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	return i, nil
}

func (m *GsAuctionItemNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsAuctionItemNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuctionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionType))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.ArtifactUuid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionUserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if m.AuctionSrc != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionSrc))
	}
	if m.AuctionGuild != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionGuild))
	}
	if m.ItemType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemType))
	}
	if m.NeedItemId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.NeedItemId))
	}
	return i, nil
}

func (m *CrossAuctionItemNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossAuctionItemNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArtifactUuid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionUserId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ServerId))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.Code))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemType))
	}
	return i, nil
}

func (m *CrossAuctionItemEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossAuctionItemEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.ArtifactUuid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionUserId))
	}
	if m.EarnMi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.EarnMi))
	}
	if m.AuctionResult != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionResult))
	}
	if m.AuctionSrc != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionSrc))
	}
	return i, nil
}

func (m *CrossBidItemEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossBidItemEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.BidUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.BidUserId))
	}
	if m.AuctionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionId))
	}
	if m.IsBuyNow {
		dAtA[i] = 0x20
		i++
		if m.IsBuyNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BidMiNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.BidMiNum))
	}
	if m.AuctionUserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.AuctionUserId))
	}
	if m.UserServerId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.UserServerId))
	}
	return i, nil
}

func (m *GsGuildAuctionDropNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsGuildAuctionDropNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuildId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.GuildId))
	}
	if len(m.CrossGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.CrossGroup)))
		i += copy(dAtA[i:], m.CrossGroup)
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ItemNum))
	}
	if len(m.BidGuildId) > 0 {
		dAtA11 := make([]byte, len(m.BidGuildId)*10)
		var j10 int
		for _, num1 := range m.BidGuildId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.DropState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.DropState))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *CrossAuctionNoticeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossAuctionNoticeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NoticeType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.NoticeType))
	}
	if len(m.NoticeContent) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(len(m.NoticeContent)))
		i += copy(dAtA[i:], m.NoticeContent)
	}
	if m.ChatMsgType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCrossAuction(dAtA, i, uint64(m.ChatMsgType))
	}
	return i, nil
}

func encodeVarintCrossAuction(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GsAuctionInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.GuildId != 0 {
		n += 1 + sovCrossAuction(uint64(m.GuildId))
	}
	return n
}

func (m *CrossAuctionInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if len(m.AuctionItemInfos) > 0 {
		for _, e := range m.AuctionItemInfos {
			l = e.Size()
			n += 1 + l + sovCrossAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionItemInfo) Size() (n int) {
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.AuctionTime != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionTime))
	}
	if m.AuctionDuration != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionDuration))
	}
	if m.NowBidPrice != 0 {
		n += 1 + sovCrossAuction(uint64(m.NowBidPrice))
	}
	if m.NowBidUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.NowBidUserId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	l = len(m.NowBidderNickname)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	l = len(m.NowBidderAvatar)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.AuctionSrc != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionSrc))
	}
	l = len(m.NowBidPlayerCrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if len(m.BidGuildId) > 0 {
		l = 0
		for _, e := range m.BidGuildId {
			l += sovCrossAuction(uint64(e))
		}
		n += 1 + sovCrossAuction(uint64(l)) + l
	}
	if m.DropState != 0 {
		n += 1 + sovCrossAuction(uint64(m.DropState))
	}
	if m.DropTime != 0 {
		n += 1 + sovCrossAuction(uint64(m.DropTime))
	}
	return n
}

func (m *GsBidInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.GuildId != 0 {
		n += 1 + sovCrossAuction(uint64(m.GuildId))
	}
	if m.IsBuyNow {
		n += 2
	}
	return n
}

func (m *CrossBidInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		l = m.AuctionInfo.Size()
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.Code != 0 {
		n += 1 + sovCrossAuction(uint64(m.Code))
	}
	if m.IsBuyNow {
		n += 2
	}
	return n
}

func (m *GsBidNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.BidPrice != 0 {
		n += 1 + sovCrossAuction(uint64(m.BidPrice))
	}
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.IsBuyNow != 0 {
		n += 1 + sovCrossAuction(uint64(m.IsBuyNow))
	}
	if m.GuildId != 0 {
		n += 1 + sovCrossAuction(uint64(m.GuildId))
	}
	if len(m.BidGuildId) > 0 {
		l = 0
		for _, e := range m.BidGuildId {
			l += sovCrossAuction(uint64(e))
		}
		n += 1 + sovCrossAuction(uint64(l)) + l
	}
	if m.DropTime != 0 {
		n += 1 + sovCrossAuction(uint64(m.DropTime))
	}
	l = len(m.RobotNickName)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	l = len(m.RobotAvatar)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.SkyCustomsUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.SkyCustomsUserId))
	}
	return n
}

func (m *CrossBidNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.AuctionInfo != nil {
		l = m.AuctionInfo.Size()
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovCrossAuction(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.IsBuyNow != 0 {
		n += 1 + sovCrossAuction(uint64(m.IsBuyNow))
	}
	return n
}

func (m *GsMyBidNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if len(m.WorldBidBriefInfos) > 0 {
		for _, e := range m.WorldBidBriefInfos {
			l = e.Size()
			n += 1 + l + sovCrossAuction(uint64(l))
		}
	}
	if len(m.GuildBidBriefInfos) > 0 {
		for _, e := range m.GuildBidBriefInfos {
			l = e.Size()
			n += 1 + l + sovCrossAuction(uint64(l))
		}
	}
	if len(m.AllBidBriefInfos) > 0 {
		for _, e := range m.AllBidBriefInfos {
			l = e.Size()
			n += 1 + l + sovCrossAuction(uint64(l))
		}
	}
	if m.GuildId != 0 {
		n += 1 + sovCrossAuction(uint64(m.GuildId))
	}
	return n
}

func (m *CrossMyBidNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if len(m.BidInfos) > 0 {
		for _, e := range m.BidInfos {
			l = e.Size()
			n += 1 + l + sovCrossAuction(uint64(l))
		}
	}
	return n
}

func (m *AuctionBidBriefInfo) Size() (n int) {
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	return n
}

func (m *CrossBroadcastUpdateBidInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.NeedReturn {
		n += 2
	}
	if m.LastUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.LastUserId))
	}
	if m.LastPrice != 0 {
		n += 1 + sovCrossAuction(uint64(m.LastPrice))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovCrossAuction(uint64(e))
		}
		n += 1 + sovCrossAuction(uint64(l)) + l
	}
	if m.BroadcastInfo != nil {
		l = m.BroadcastInfo.Size()
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.ItemStatus != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemStatus))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	return n
}

func (m *GsAuctionItemNtf) Size() (n int) {
	var l int
	_ = l
	if m.AuctionType != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionType))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.ArtifactUuid != 0 {
		n += 1 + sovCrossAuction(uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionUserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.AuctionSrc != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionSrc))
	}
	if m.AuctionGuild != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionGuild))
	}
	if m.ItemType != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemType))
	}
	if m.NeedItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.NeedItemId))
	}
	return n
}

func (m *CrossAuctionItemNtf) Size() (n int) {
	var l int
	_ = l
	if m.ArtifactUuid != 0 {
		n += 1 + sovCrossAuction(uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionUserId))
	}
	if m.ServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ServerId))
	}
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.Code != 0 {
		n += 1 + sovCrossAuction(uint64(m.Code))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.ItemType != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemType))
	}
	return n
}

func (m *CrossAuctionItemEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.ArtifactUuid != 0 {
		n += 1 + sovCrossAuction(uint64(m.ArtifactUuid))
	}
	if m.AuctionUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionUserId))
	}
	if m.EarnMi != 0 {
		n += 1 + sovCrossAuction(uint64(m.EarnMi))
	}
	if m.AuctionResult != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionResult))
	}
	if m.AuctionSrc != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionSrc))
	}
	return n
}

func (m *CrossBidItemEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.BidUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.BidUserId))
	}
	if m.AuctionId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionId))
	}
	if m.IsBuyNow {
		n += 2
	}
	if m.BidMiNum != 0 {
		n += 1 + sovCrossAuction(uint64(m.BidMiNum))
	}
	if m.AuctionUserId != 0 {
		n += 1 + sovCrossAuction(uint64(m.AuctionUserId))
	}
	if m.UserServerId != 0 {
		n += 1 + sovCrossAuction(uint64(m.UserServerId))
	}
	return n
}

func (m *GsGuildAuctionDropNtf) Size() (n int) {
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovCrossAuction(uint64(m.GuildId))
	}
	l = len(m.CrossGroup)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.ItemId != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemId))
	}
	if m.ItemNum != 0 {
		n += 1 + sovCrossAuction(uint64(m.ItemNum))
	}
	if len(m.BidGuildId) > 0 {
		l = 0
		for _, e := range m.BidGuildId {
			l += sovCrossAuction(uint64(e))
		}
		n += 1 + sovCrossAuction(uint64(l)) + l
	}
	if m.DropState != 0 {
		n += 1 + sovCrossAuction(uint64(m.DropState))
	}
	if m.DropTime != 0 {
		n += 1 + sovCrossAuction(uint64(m.DropTime))
	}
	return n
}

func (m *CrossAuctionNoticeNtf) Size() (n int) {
	var l int
	_ = l
	if m.NoticeType != 0 {
		n += 1 + sovCrossAuction(uint64(m.NoticeType))
	}
	l = len(m.NoticeContent)
	if l > 0 {
		n += 1 + l + sovCrossAuction(uint64(l))
	}
	if m.ChatMsgType != 0 {
		n += 1 + sovCrossAuction(uint64(m.ChatMsgType))
	}
	return n
}

func sovCrossAuction(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCrossAuction(x uint64) (n int) {
	return sovCrossAuction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GsAuctionInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsAuctionInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsAuctionInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossAuctionInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossAuctionInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossAuctionInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionItemInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuctionItemInfos = append(m.AuctionItemInfos, &AuctionItemInfo{})
			if err := m.AuctionItemInfos[len(m.AuctionItemInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionTime", wireType)
			}
			m.AuctionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionDuration", wireType)
			}
			m.AuctionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidPrice", wireType)
			}
			m.NowBidPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowBidPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidUserId", wireType)
			}
			m.NowBidUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowBidUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidderNickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NowBidderNickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidderAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NowBidderAvatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionSrc", wireType)
			}
			m.AuctionSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionSrc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowBidPlayerCrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NowBidPlayerCrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BidGuildId = append(m.BidGuildId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCrossAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BidGuildId = append(m.BidGuildId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BidGuildId", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropState", wireType)
			}
			m.DropState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsBidInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsBidInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsBidInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuyNow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossBidInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossBidInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossBidInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionInfo == nil {
				m.AuctionInfo = &AuctionItemInfo{}
			}
			if err := m.AuctionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuyNow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsBidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsBidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsBidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidPrice", wireType)
			}
			m.BidPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			m.IsBuyNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBuyNow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BidGuildId = append(m.BidGuildId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCrossAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BidGuildId = append(m.BidGuildId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BidGuildId", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotNickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RobotNickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RobotAvatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkyCustomsUserId", wireType)
			}
			m.SkyCustomsUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkyCustomsUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossBidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossBidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossBidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionInfo == nil {
				m.AuctionInfo = &AuctionItemInfo{}
			}
			if err := m.AuctionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			m.IsBuyNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBuyNow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsMyBidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsMyBidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsMyBidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorldBidBriefInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorldBidBriefInfos = append(m.WorldBidBriefInfos, &AuctionBidBriefInfo{})
			if err := m.WorldBidBriefInfos[len(m.WorldBidBriefInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildBidBriefInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildBidBriefInfos = append(m.GuildBidBriefInfos, &AuctionBidBriefInfo{})
			if err := m.GuildBidBriefInfos[len(m.GuildBidBriefInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllBidBriefInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllBidBriefInfos = append(m.AllBidBriefInfos, &AuctionBidBriefInfo{})
			if err := m.AllBidBriefInfos[len(m.AllBidBriefInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossMyBidNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossMyBidNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossMyBidNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidInfos = append(m.BidInfos, &AuctionItemInfo{})
			if err := m.BidInfos[len(m.BidInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionBidBriefInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionBidBriefInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionBidBriefInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossBroadcastUpdateBidInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossBroadcastUpdateBidInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossBroadcastUpdateBidInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedReturn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedReturn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUserId", wireType)
			}
			m.LastUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
			}
			m.LastPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCrossAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BroadcastInfo == nil {
				m.BroadcastInfo = &AuctionItemInfo{}
			}
			if err := m.BroadcastInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemStatus", wireType)
			}
			m.ItemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsAuctionItemNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsAuctionItemNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsAuctionItemNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			m.AuctionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactUuid", wireType)
			}
			m.ArtifactUuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactUuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionUserId", wireType)
			}
			m.AuctionUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionSrc", wireType)
			}
			m.AuctionSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionSrc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionGuild", wireType)
			}
			m.AuctionGuild = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionGuild |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemType", wireType)
			}
			m.ItemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedItemId", wireType)
			}
			m.NeedItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossAuctionItemNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossAuctionItemNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossAuctionItemNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactUuid", wireType)
			}
			m.ArtifactUuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactUuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionUserId", wireType)
			}
			m.AuctionUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemType", wireType)
			}
			m.ItemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossAuctionItemEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossAuctionItemEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossAuctionItemEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactUuid", wireType)
			}
			m.ArtifactUuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactUuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionUserId", wireType)
			}
			m.AuctionUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarnMi", wireType)
			}
			m.EarnMi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EarnMi |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionResult", wireType)
			}
			m.AuctionResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionResult |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionSrc", wireType)
			}
			m.AuctionSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionSrc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossBidItemEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossBidItemEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossBidItemEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidUserId", wireType)
			}
			m.BidUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuyNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuyNow = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidMiNum", wireType)
			}
			m.BidMiNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidMiNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionUserId", wireType)
			}
			m.AuctionUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserServerId", wireType)
			}
			m.UserServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsGuildAuctionDropNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsGuildAuctionDropNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsGuildAuctionDropNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BidGuildId = append(m.BidGuildId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCrossAuction
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossAuction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BidGuildId = append(m.BidGuildId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BidGuildId", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropState", wireType)
			}
			m.DropState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossAuctionNoticeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossAuctionNoticeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossAuctionNoticeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeType", wireType)
			}
			m.NoticeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoticeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoticeContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatMsgType", wireType)
			}
			m.ChatMsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatMsgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCrossAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossAuction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossAuction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCrossAuction
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCrossAuction
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCrossAuction(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCrossAuction = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossAuction   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("crossAuction.proto", fileDescriptorCrossAuction) }

var fileDescriptorCrossAuction = []byte{
	// 1186 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcb, 0x8e, 0xe3, 0x44,
	0x17, 0xfe, 0x1d, 0x27, 0x8e, 0xfb, 0x24, 0x3d, 0x9d, 0xdf, 0xa3, 0x69, 0x99, 0xd1, 0x10, 0x45,
	0x16, 0x8b, 0x08, 0xa1, 0x5e, 0x80, 0x60, 0xc3, 0x02, 0x75, 0x7a, 0x46, 0x51, 0x84, 0x12, 0x21,
	0x37, 0xfd, 0x00, 0x8e, 0x5d, 0x3d, 0x58, 0x93, 0xd8, 0x51, 0xb9, 0x3c, 0xad, 0xb0, 0x61, 0xc5,
	0x3b, 0xb0, 0xe6, 0x11, 0xd8, 0xc0, 0x23, 0xb0, 0x1c, 0x21, 0x16, 0x6c, 0x90, 0xa0, 0x67, 0xc7,
	0x8a, 0x47, 0x40, 0x75, 0x73, 0xaa, 0xca, 0xb9, 0xc1, 0x08, 0x56, 0x9d, 0xf3, 0xb9, 0x2e, 0xe7,
	0x7c, 0xe7, 0x5a, 0x0d, 0x5e, 0x8c, 0xf3, 0xa2, 0xb8, 0x2c, 0x63, 0x92, 0xe6, 0xd9, 0xc5, 0x0a,
	0xe7, 0x24, 0xf7, 0xdc, 0xd5, 0xbc, 0x40, 0xf8, 0x25, 0xc2, 0xc1, 0xb7, 0x16, 0xf4, 0xc6, 0xf2,
	0xeb, 0x24, 0xbb, 0xcd, 0x67, 0xe4, 0xd6, 0x3b, 0x07, 0xa7, 0x2c, 0x10, 0x9e, 0x24, 0xbe, 0x35,
	0xb0, 0x86, 0x76, 0x28, 0x24, 0xef, 0x31, 0xb8, 0x7c, 0xdb, 0x24, 0xf1, 0x1b, 0x03, 0x6b, 0xd8,
	0x0a, 0x2b, 0xd9, 0xeb, 0x03, 0xb0, 0x8b, 0xc6, 0x38, 0x2f, 0x57, 0xbe, 0x3d, 0xb0, 0x86, 0x27,
	0xa1, 0x82, 0x78, 0x03, 0xe8, 0x44, 0xfc, 0x96, 0xcf, 0xd7, 0x2b, 0xe4, 0x37, 0xd9, 0x76, 0x15,
	0xf2, 0x7c, 0x68, 0x3f, 0x2f, 0xd3, 0x45, 0x32, 0x49, 0xfc, 0x16, 0xfb, 0x2a, 0xc5, 0xe0, 0x3b,
	0x0b, 0x1e, 0x5e, 0x29, 0x56, 0xbc, 0x89, 0x9e, 0x86, 0x1e, 0x76, 0x5d, 0x8f, 0x67, 0xd0, 0x93,
	0xf7, 0x10, 0xb4, 0xa4, 0x77, 0x15, 0x7e, 0x73, 0x60, 0x0f, 0x3b, 0xef, 0xbf, 0x75, 0x21, 0x79,
	0xbb, 0x30, 0x56, 0x84, 0xb5, 0x2d, 0xc1, 0xd7, 0x4d, 0x38, 0x33, 0x40, 0xef, 0x09, 0x9c, 0x88,
	0x9b, 0x2a, 0x9d, 0x37, 0x00, 0x35, 0x27, 0xa5, 0x2b, 0xa5, 0xd2, 0x42, 0x52, 0x55, 0x4e, 0x97,
	0x5c, 0x65, 0x3b, 0x54, 0x21, 0x6f, 0x08, 0x67, 0x42, 0x7c, 0x5a, 0xe2, 0x88, 0xfe, 0x15, 0x04,
	0x9b, 0x30, 0x3d, 0x2b, 0xcb, 0xef, 0x46, 0x69, 0xf2, 0x19, 0x4e, 0x63, 0x24, 0x88, 0x56, 0x21,
	0x2f, 0x80, 0x2e, 0x17, 0x6f, 0x38, 0xb5, 0x0e, 0xbb, 0x4e, 0xc3, 0x4c, 0x12, 0xdb, 0x75, 0x12,
	0xdf, 0x83, 0xff, 0xf3, 0x1d, 0x09, 0xc2, 0xb3, 0x34, 0x7e, 0x91, 0x45, 0x4b, 0xe4, 0xbb, 0x2c,
	0x2a, 0xea, 0x1f, 0xa8, 0xfe, 0x15, 0x78, 0xf9, 0x32, 0x22, 0x11, 0xf6, 0x4f, 0xd8, 0x5a, 0x13,
	0xa6, 0x61, 0x26, 0xae, 0xb9, 0xc6, 0xb1, 0x0f, 0xec, 0x62, 0x05, 0xf1, 0x3e, 0x82, 0x73, 0x61,
	0xcc, 0x22, 0x5a, 0x23, 0x7c, 0xb5, 0x09, 0xc9, 0x0e, 0x3b, 0x70, 0xc7, 0x57, 0x7a, 0xee, 0x3c,
	0x4d, 0xc6, 0x22, 0xfe, 0xba, 0x03, 0x9b, 0x9e, 0xbb, 0x41, 0xa8, 0xe7, 0x12, 0x9c, 0xaf, 0xae,
	0x49, 0x44, 0x90, 0x7f, 0xca, 0xae, 0xdd, 0x00, 0x34, 0xe0, 0xa8, 0xc0, 0xdc, 0xf3, 0x80, 0x07,
	0x9c, 0x94, 0x83, 0x3f, 0x2d, 0xe8, 0x8e, 0x8b, 0x51, 0x9a, 0xc8, 0xa8, 0x35, 0xc8, 0xb3, 0xea,
	0xe4, 0x69, 0x61, 0xd2, 0xd8, 0x1d, 0x26, 0xb6, 0x16, 0x26, 0x9b, 0x6c, 0x68, 0x6a, 0xd9, 0xa0,
	0x67, 0x66, 0xab, 0x96, 0x99, 0x6a, 0xb6, 0x38, 0x46, 0xb6, 0x28, 0x39, 0xd9, 0xd6, 0x72, 0x92,
	0xee, 0x4a, 0x8b, 0x51, 0xb9, 0x9e, 0xe5, 0x77, 0xcc, 0xaf, 0x6e, 0x58, 0xc9, 0xc1, 0xcf, 0x16,
	0x9c, 0x31, 0x6e, 0xff, 0x96, 0xd5, 0x1f, 0x57, 0x2b, 0xe8, 0x1e, 0x66, 0xdc, 0xde, 0x94, 0x53,
	0x57, 0xef, 0x34, 0x5e, 0x35, 0xae, 0x65, 0x18, 0xe7, 0x41, 0x33, 0xce, 0x13, 0x24, 0x8c, 0x66,
	0xbf, 0x35, 0xb3, 0xda, 0x86, 0x59, 0x3f, 0xd8, 0xe0, 0x32, 0x4f, 0xfe, 0x03, 0x2f, 0xda, 0xbb,
	0xbd, 0xd8, 0xd4, 0xbc, 0xf8, 0x18, 0xdc, 0xb9, 0x9e, 0x9d, 0x95, 0xac, 0x18, 0xe9, 0xec, 0x34,
	0xb2, 0xbd, 0xb7, 0x2e, 0xbb, 0xdb, 0xbc, 0x5f, 0x19, 0x7c, 0xc2, 0xf7, 0x4a, 0x59, 0xf5, 0x3e,
	0xe8, 0xde, 0xd7, 0xd3, 0xa5, 0x53, 0x4b, 0x17, 0x35, 0x21, 0xba, 0x7a, 0x42, 0x78, 0xef, 0xc0,
	0x69, 0x98, 0xcf, 0x73, 0x42, 0xb3, 0x7f, 0x46, 0xcb, 0xc2, 0x29, 0x53, 0x4a, 0x07, 0x29, 0xbf,
	0x0c, 0x10, 0xe5, 0xe0, 0x01, 0x5b, 0xa3, 0x42, 0xde, 0xbb, 0xd0, 0x2b, 0x5e, 0xac, 0xaf, 0xca,
	0x82, 0xe4, 0xcb, 0x42, 0x14, 0xab, 0x33, 0xc6, 0x4b, 0x0d, 0x0f, 0x5e, 0x59, 0xd0, 0x91, 0x11,
	0xf9, 0x1f, 0x44, 0xa3, 0x8c, 0xac, 0xa6, 0x12, 0x59, 0x1b, 0xe7, 0xb5, 0x76, 0x3a, 0xcf, 0x4c,
	0x3f, 0x33, 0x1a, 0x15, 0xe7, 0x04, 0xaf, 0x1b, 0x00, 0xe3, 0x62, 0xba, 0x16, 0x16, 0xfd, 0x1b,
	0x3d, 0x7b, 0x0a, 0xde, 0x5d, 0x8e, 0x17, 0xc9, 0x28, 0x4d, 0x46, 0x38, 0x45, 0xb7, 0x6a, 0x2f,
	0x7c, 0xbb, 0x46, 0x85, 0xba, 0x2a, 0xdc, 0xb2, 0x91, 0x1e, 0xc7, 0xe2, 0x47, 0x3f, 0xae, 0x75,
	0xd4, 0x71, 0xf5, 0x8d, 0xde, 0x04, 0x7a, 0xd1, 0x62, 0xa1, 0x1f, 0xe6, 0x1c, 0x73, 0x58, 0x6d,
	0xdb, 0xee, 0x32, 0x17, 0x7c, 0x09, 0xa7, 0x2c, 0x6e, 0xde, 0x88, 0xe7, 0x0f, 0x59, 0x4e, 0x73,
	0x0d, 0xed, 0x43, 0x93, 0x44, 0xb5, 0x34, 0xf8, 0x14, 0x1e, 0x6e, 0x51, 0x9f, 0xd6, 0x95, 0x4b,
	0x73, 0x88, 0xb8, 0x3c, 0x34, 0x44, 0x04, 0xdf, 0x37, 0xa0, 0xcf, 0x33, 0x00, 0xe7, 0x51, 0x12,
	0x47, 0x05, 0xb9, 0x59, 0x25, 0x11, 0x41, 0x4a, 0x89, 0xee, 0x03, 0x64, 0x08, 0x25, 0x21, 0x22,
	0x25, 0xce, 0xd8, 0xc9, 0x6e, 0xa8, 0x20, 0xf4, 0xfb, 0x82, 0xee, 0x2b, 0x2a, 0x23, 0xed, 0x50,
	0x41, 0xa8, 0x62, 0x54, 0xe2, 0xb5, 0x8b, 0xf7, 0xa6, 0x0d, 0x40, 0x39, 0xe6, 0x54, 0xf1, 0x08,
	0xb2, 0x43, 0x29, 0x7a, 0x9f, 0xc0, 0xe9, 0x5c, 0x2a, 0xc5, 0x92, 0xad, 0x75, 0x28, 0xd9, 0xf4,
	0xf5, 0x54, 0x31, 0x6a, 0x25, 0xed, 0xc5, 0x65, 0x21, 0x92, 0x48, 0x41, 0xf6, 0xd6, 0x47, 0xa3,
	0x12, 0xb8, 0xb5, 0x4a, 0x10, 0xfc, 0xd4, 0x50, 0x47, 0x64, 0x82, 0x96, 0xc7, 0x15, 0x90, 0x5d,
	0x6d, 0x3a, 0x80, 0x6e, 0x84, 0x49, 0x7a, 0x1b, 0xc5, 0xe4, 0xa6, 0x4c, 0x65, 0xbf, 0xd2, 0x30,
	0x5a, 0x22, 0xc5, 0x51, 0x37, 0x6a, 0xc9, 0xd0, 0xc1, 0xbd, 0x95, 0x43, 0x4f, 0xed, 0x76, 0x2d,
	0xb5, 0xf5, 0x39, 0xca, 0xad, 0xcd, 0x51, 0x54, 0x4b, 0x2e, 0xb1, 0x92, 0x2e, 0x5a, 0x83, 0x86,
	0xb1, 0xea, 0x44, 0xd0, 0x92, 0x11, 0x00, 0xa2, 0x3a, 0x09, 0x59, 0xc6, 0xd2, 0x84, 0x33, 0xd0,
	0xe1, 0xe7, 0x6f, 0x90, 0xe0, 0x77, 0x73, 0xa4, 0x17, 0xbc, 0x9a, 0xec, 0x58, 0xc7, 0xb0, 0xd3,
	0x38, 0xc4, 0x8e, 0x6d, 0xb0, 0xa3, 0xb5, 0xe6, 0xa6, 0xd9, 0x9a, 0x65, 0xf5, 0x6e, 0xe9, 0xd5,
	0x5b, 0x78, 0xd3, 0x31, 0xdb, 0x75, 0xc5, 0x41, 0x5b, 0xe7, 0x20, 0xf8, 0xc5, 0x82, 0x73, 0xd3,
	0xc6, 0x67, 0x99, 0xac, 0x22, 0xe2, 0x38, 0x6b, 0x6f, 0x70, 0x34, 0x8e, 0x31, 0xdf, 0xde, 0x66,
	0xfe, 0x39, 0x38, 0x28, 0xc2, 0xd9, 0x34, 0x95, 0xf3, 0x05, 0x97, 0x94, 0xdd, 0x21, 0x2a, 0xca,
	0x05, 0x11, 0x56, 0xea, 0xa0, 0x11, 0x1e, 0x8e, 0x19, 0x1e, 0xc1, 0x1f, 0x16, 0x78, 0xd5, 0x84,
	0x77, 0xd8, 0xac, 0x27, 0x70, 0x32, 0xaf, 0x1e, 0x14, 0x62, 0xa0, 0xad, 0x80, 0x03, 0x83, 0x92,
	0xda, 0x03, 0x9b, 0xfa, 0x44, 0x26, 0x86, 0xa5, 0x69, 0x3a, 0x2b, 0x97, 0xca, 0xb0, 0xc4, 0xe4,
	0x3a, 0x4d, 0xce, 0x36, 0x9a, 0x02, 0xe8, 0xd2, 0x32, 0x74, 0xad, 0x97, 0x07, 0x0d, 0x0b, 0x7e,
	0xb5, 0xe0, 0xd1, 0xb8, 0x60, 0x31, 0x2f, 0x3c, 0xf9, 0x14, 0xe7, 0x2b, 0x6a, 0xaf, 0xd2, 0x37,
	0xac, 0xda, 0x80, 0xa4, 0xe4, 0x5f, 0xa3, 0x96, 0x7f, 0xbb, 0xaa, 0x83, 0x0f, 0x6d, 0xfa, 0x8b,
	0x1a, 0xc4, 0xfd, 0x26, 0x45, 0x63, 0xe4, 0x6a, 0xed, 0x7f, 0xa1, 0x38, 0xfb, 0x5e, 0x28, 0x6d,
	0xe3, 0x85, 0xf2, 0x15, 0x3c, 0x52, 0xc3, 0x74, 0x96, 0x93, 0x34, 0x46, 0xb2, 0x21, 0x30, 0x41,
	0xa9, 0x71, 0x0a, 0x42, 0x29, 0xe6, 0xd2, 0x55, 0x9e, 0x11, 0x94, 0x11, 0x61, 0xa7, 0x0e, 0xd2,
	0x52, 0x19, 0x7f, 0x11, 0x91, 0x69, 0xf1, 0x5c, 0x7d, 0x71, 0x2b, 0xd0, 0xa8, 0xf7, 0xe3, 0x7d,
	0xdf, 0x7a, 0x75, 0xdf, 0xb7, 0x7e, 0xbb, 0xef, 0x5b, 0xdf, 0xbc, 0xee, 0xff, 0x6f, 0xee, 0xb0,
	0xff, 0x53, 0x7c, 0xf0, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x90, 0x9c, 0xee, 0xf1, 0xbd, 0x10,
	0x00, 0x00,
}
