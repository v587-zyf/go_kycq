// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs_server.proto

package pbserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type FSFightType int32

const (
	FSFightType_Boss FSFightType = 0
)

var FSFightType_name = map[int32]string{
	0: "Boss",
}
var FSFightType_value = map[string]int32{
	"Boss": 0,
}

func (x FSFightType) String() string {
	return proto.EnumName(FSFightType_name, int32(x))
}
func (FSFightType) EnumDescriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{0} }

// gs请求到指定战斗
type GsRouteMessageToFight struct {
	FightId int32  `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
	CmdId   int32  `protobuf:"varint,2,opt,name=cmdId,proto3" json:"cmdId,omitempty"`
	MsgData []byte `protobuf:"bytes,3,opt,name=msgData,proto3" json:"msgData,omitempty"`
}

func (m *GsRouteMessageToFight) Reset()                    { *m = GsRouteMessageToFight{} }
func (m *GsRouteMessageToFight) String() string            { return proto.CompactTextString(m) }
func (*GsRouteMessageToFight) ProtoMessage()               {}
func (*GsRouteMessageToFight) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{0} }

func (m *GsRouteMessageToFight) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

func (m *GsRouteMessageToFight) GetCmdId() int32 {
	if m != nil {
		return m.CmdId
	}
	return 0
}

func (m *GsRouteMessageToFight) GetMsgData() []byte {
	if m != nil {
		return m.MsgData
	}
	return nil
}

type FSCreateFightReq struct {
	StageId int32  `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	CpData  []byte `protobuf:"bytes,2,opt,name=cpData,proto3" json:"cpData,omitempty"`
}

func (m *FSCreateFightReq) Reset()                    { *m = FSCreateFightReq{} }
func (m *FSCreateFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSCreateFightReq) ProtoMessage()               {}
func (*FSCreateFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{1} }

func (m *FSCreateFightReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FSCreateFightReq) GetCpData() []byte {
	if m != nil {
		return m.CpData
	}
	return nil
}

type FSCreateFightAck struct {
	FightId uint32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSCreateFightAck) Reset()                    { *m = FSCreateFightAck{} }
func (m *FSCreateFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSCreateFightAck) ProtoMessage()               {}
func (*FSCreateFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{2} }

func (m *FSCreateFightAck) GetFightId() uint32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

// gs->fs申请同步常驻战斗id
type GsToFsResidentFightReq struct {
	ServerId int32 `protobuf:"varint,1,opt,name=serverId,proto3" json:"serverId,omitempty"`
}

func (m *GsToFsResidentFightReq) Reset()                    { *m = GsToFsResidentFightReq{} }
func (m *GsToFsResidentFightReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsResidentFightReq) ProtoMessage()               {}
func (*GsToFsResidentFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{3} }

func (m *GsToFsResidentFightReq) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

// fs->gs推送所有常驻战斗id
type FsResidentFightNtf struct {
	ResidentFights     map[int32]uint32              `protobuf:"bytes,1,rep,name=residentFights" json:"residentFights,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FieldBossFightInfo map[int32]*FsFieldBossInfoNtf `protobuf:"bytes,2,rep,name=fieldBossFightInfo" json:"fieldBossFightInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FsResidentFightNtf) Reset()                    { *m = FsResidentFightNtf{} }
func (m *FsResidentFightNtf) String() string            { return proto.CompactTextString(m) }
func (*FsResidentFightNtf) ProtoMessage()               {}
func (*FsResidentFightNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{4} }

func (m *FsResidentFightNtf) GetResidentFights() map[int32]uint32 {
	if m != nil {
		return m.ResidentFights
	}
	return nil
}

func (m *FsResidentFightNtf) GetFieldBossFightInfo() map[int32]*FsFieldBossInfoNtf {
	if m != nil {
		return m.FieldBossFightInfo
	}
	return nil
}

// fs->gs 野外boss血量 复活时间
type FsFieldBossInfoNtf struct {
	StageId    int32   `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Hp         float32 `protobuf:"fixed32,2,opt,name=hp,proto3" json:"hp,omitempty"`
	ReliveTime int64   `protobuf:"varint,3,opt,name=reliveTime,proto3" json:"reliveTime,omitempty"`
	UserCount  int32   `protobuf:"varint,4,opt,name=userCount,proto3" json:"userCount,omitempty"`
}

func (m *FsFieldBossInfoNtf) Reset()                    { *m = FsFieldBossInfoNtf{} }
func (m *FsFieldBossInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*FsFieldBossInfoNtf) ProtoMessage()               {}
func (*FsFieldBossInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{5} }

func (m *FsFieldBossInfoNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FsFieldBossInfoNtf) GetHp() float32 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *FsFieldBossInfoNtf) GetReliveTime() int64 {
	if m != nil {
		return m.ReliveTime
	}
	return 0
}

func (m *FsFieldBossInfoNtf) GetUserCount() int32 {
	if m != nil {
		return m.UserCount
	}
	return 0
}

// 战斗继续
type FSContinueFightReq struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *FSContinueFightReq) Reset()                    { *m = FSContinueFightReq{} }
func (m *FSContinueFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSContinueFightReq) ProtoMessage()               {}
func (*FSContinueFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{6} }

func (m *FSContinueFightReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

type FSFightEndNtf struct {
	FightType int32   `protobuf:"varint,1,opt,name=fightType,proto3" json:"fightType,omitempty"`
	StageId   int32   `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Winners   []int32 `protobuf:"varint,3,rep,packed,name=winners" json:"winners,omitempty"`
	Losers    []int32 `protobuf:"varint,4,rep,packed,name=losers" json:"losers,omitempty"`
	UseTime   int32   `protobuf:"varint,5,opt,name=useTime,proto3" json:"useTime,omitempty"`
	CpData    []byte  `protobuf:"bytes,6,opt,name=cpData,proto3" json:"cpData,omitempty"`
}

func (m *FSFightEndNtf) Reset()                    { *m = FSFightEndNtf{} }
func (m *FSFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*FSFightEndNtf) ProtoMessage()               {}
func (*FSFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{7} }

func (m *FSFightEndNtf) GetFightType() int32 {
	if m != nil {
		return m.FightType
	}
	return 0
}

func (m *FSFightEndNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *FSFightEndNtf) GetWinners() []int32 {
	if m != nil {
		return m.Winners
	}
	return nil
}

func (m *FSFightEndNtf) GetLosers() []int32 {
	if m != nil {
		return m.Losers
	}
	return nil
}

func (m *FSFightEndNtf) GetUseTime() int32 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

func (m *FSFightEndNtf) GetCpData() []byte {
	if m != nil {
		return m.CpData
	}
	return nil
}

type FSEnterFightReq struct {
	FightUser *User `protobuf:"bytes,1,opt,name=fightUser" json:"fightUser,omitempty"`
	EnterType int32 `protobuf:"varint,2,opt,name=enterType,proto3" json:"enterType,omitempty"`
}

func (m *FSEnterFightReq) Reset()                    { *m = FSEnterFightReq{} }
func (m *FSEnterFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSEnterFightReq) ProtoMessage()               {}
func (*FSEnterFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{8} }

func (m *FSEnterFightReq) GetFightUser() *User {
	if m != nil {
		return m.FightUser
	}
	return nil
}

func (m *FSEnterFightReq) GetEnterType() int32 {
	if m != nil {
		return m.EnterType
	}
	return 0
}

type FSEnterFightAck struct {
	Refuse bool `protobuf:"varint,1,opt,name=refuse,proto3" json:"refuse,omitempty"`
}

func (m *FSEnterFightAck) Reset()                    { *m = FSEnterFightAck{} }
func (m *FSEnterFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSEnterFightAck) ProtoMessage()               {}
func (*FSEnterFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{9} }

func (m *FSEnterFightAck) GetRefuse() bool {
	if m != nil {
		return m.Refuse
	}
	return false
}

type FSUpdateUserInfoNtf struct {
	UserInfo *Actor `protobuf:"bytes,1,opt,name=userInfo" json:"userInfo,omitempty"`
}

func (m *FSUpdateUserInfoNtf) Reset()                    { *m = FSUpdateUserInfoNtf{} }
func (m *FSUpdateUserInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*FSUpdateUserInfoNtf) ProtoMessage()               {}
func (*FSUpdateUserInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{10} }

func (m *FSUpdateUserInfoNtf) GetUserInfo() *Actor {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

type FSUpdateUserInfoAck struct {
	Refuse bool `protobuf:"varint,1,opt,name=refuse,proto3" json:"refuse,omitempty"`
}

func (m *FSUpdateUserInfoAck) Reset()                    { *m = FSUpdateUserInfoAck{} }
func (m *FSUpdateUserInfoAck) String() string            { return proto.CompactTextString(m) }
func (*FSUpdateUserInfoAck) ProtoMessage()               {}
func (*FSUpdateUserInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{11} }

func (m *FSUpdateUserInfoAck) GetRefuse() bool {
	if m != nil {
		return m.Refuse
	}
	return false
}

type GsToFsUpdateUserElfReq struct {
	UserId int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Elf    *ElfInfo `protobuf:"bytes,2,opt,name=elf" json:"elf,omitempty"`
}

func (m *GsToFsUpdateUserElfReq) Reset()                    { *m = GsToFsUpdateUserElfReq{} }
func (m *GsToFsUpdateUserElfReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUpdateUserElfReq) ProtoMessage()               {}
func (*GsToFsUpdateUserElfReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{12} }

func (m *GsToFsUpdateUserElfReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUpdateUserElfReq) GetElf() *ElfInfo {
	if m != nil {
		return m.Elf
	}
	return nil
}

type FsToGsUpdateUserElfAck struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsUpdateUserElfAck) Reset()                    { *m = FsToGsUpdateUserElfAck{} }
func (m *FsToGsUpdateUserElfAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUpdateUserElfAck) ProtoMessage()               {}
func (*FsToGsUpdateUserElfAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{13} }

func (m *FsToGsUpdateUserElfAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type FSLeaveFightReq struct {
	ActorSessionId uint32 `protobuf:"varint,1,opt,name=actorSessionId,proto3" json:"actorSessionId,omitempty"`
	Reason         uint32 `protobuf:"varint,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *FSLeaveFightReq) Reset()                    { *m = FSLeaveFightReq{} }
func (m *FSLeaveFightReq) String() string            { return proto.CompactTextString(m) }
func (*FSLeaveFightReq) ProtoMessage()               {}
func (*FSLeaveFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{14} }

func (m *FSLeaveFightReq) GetActorSessionId() uint32 {
	if m != nil {
		return m.ActorSessionId
	}
	return 0
}

func (m *FSLeaveFightReq) GetReason() uint32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type FSLeaveFightAck struct {
}

func (m *FSLeaveFightAck) Reset()                    { *m = FSLeaveFightAck{} }
func (m *FSLeaveFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSLeaveFightAck) ProtoMessage()               {}
func (*FSLeaveFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{15} }

type GSToFsUpdateUserFightModel struct {
	UserId     int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	FigthModel int32 `protobuf:"varint,2,opt,name=figthModel,proto3" json:"figthModel,omitempty"`
}

func (m *GSToFsUpdateUserFightModel) Reset()         { *m = GSToFsUpdateUserFightModel{} }
func (m *GSToFsUpdateUserFightModel) String() string { return proto.CompactTextString(m) }
func (*GSToFsUpdateUserFightModel) ProtoMessage()    {}
func (*GSToFsUpdateUserFightModel) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{16}
}

func (m *GSToFsUpdateUserFightModel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GSToFsUpdateUserFightModel) GetFigthModel() int32 {
	if m != nil {
		return m.FigthModel
	}
	return 0
}

type GsToFSUserReliveReq struct {
	UserId     int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ReliveType int32 `protobuf:"varint,2,opt,name=reliveType,proto3" json:"reliveType,omitempty"`
}

func (m *GsToFSUserReliveReq) Reset()                    { *m = GsToFSUserReliveReq{} }
func (m *GsToFSUserReliveReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFSUserReliveReq) ProtoMessage()               {}
func (*GsToFSUserReliveReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{17} }

func (m *GsToFSUserReliveReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFSUserReliveReq) GetReliveType() int32 {
	if m != nil {
		return m.ReliveType
	}
	return 0
}

type FSToGsUserReliveAck struct {
	ReliveTimes        int32 `protobuf:"varint,1,opt,name=reliveTimes,proto3" json:"reliveTimes,omitempty"`
	ReliveByIngotTimes int32 `protobuf:"varint,2,opt,name=reliveByIngotTimes,proto3" json:"reliveByIngotTimes,omitempty"`
}

func (m *FSToGsUserReliveAck) Reset()                    { *m = FSToGsUserReliveAck{} }
func (m *FSToGsUserReliveAck) String() string            { return proto.CompactTextString(m) }
func (*FSToGsUserReliveAck) ProtoMessage()               {}
func (*FSToGsUserReliveAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{18} }

func (m *FSToGsUserReliveAck) GetReliveTimes() int32 {
	if m != nil {
		return m.ReliveTimes
	}
	return 0
}

func (m *FSToGsUserReliveAck) GetReliveByIngotTimes() int32 {
	if m != nil {
		return m.ReliveByIngotTimes
	}
	return 0
}

type GsToFSCheckUserReliveReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFSCheckUserReliveReq) Reset()         { *m = GsToFSCheckUserReliveReq{} }
func (m *GsToFSCheckUserReliveReq) String() string { return proto.CompactTextString(m) }
func (*GsToFSCheckUserReliveReq) ProtoMessage()    {}
func (*GsToFSCheckUserReliveReq) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{19}
}

func (m *GsToFSCheckUserReliveReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGSCheckUserReliveAck struct {
	IsDie              bool  `protobuf:"varint,1,opt,name=isDie,proto3" json:"isDie,omitempty"`
	ReliveTimes        int32 `protobuf:"varint,2,opt,name=reliveTimes,proto3" json:"reliveTimes,omitempty"`
	ReliveByIngotTimes int32 `protobuf:"varint,3,opt,name=reliveByIngotTimes,proto3" json:"reliveByIngotTimes,omitempty"`
}

func (m *FsToGSCheckUserReliveAck) Reset()         { *m = FsToGSCheckUserReliveAck{} }
func (m *FsToGSCheckUserReliveAck) String() string { return proto.CompactTextString(m) }
func (*FsToGSCheckUserReliveAck) ProtoMessage()    {}
func (*FsToGSCheckUserReliveAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{20}
}

func (m *FsToGSCheckUserReliveAck) GetIsDie() bool {
	if m != nil {
		return m.IsDie
	}
	return false
}

func (m *FsToGSCheckUserReliveAck) GetReliveTimes() int32 {
	if m != nil {
		return m.ReliveTimes
	}
	return 0
}

func (m *FsToGSCheckUserReliveAck) GetReliveByIngotTimes() int32 {
	if m != nil {
		return m.ReliveByIngotTimes
	}
	return 0
}

type FSGetFightIdReq struct {
	FightType FSFightType `protobuf:"varint,1,opt,name=fightType,proto3,enum=pbserver.FSFightType" json:"fightType,omitempty"`
}

func (m *FSGetFightIdReq) Reset()                    { *m = FSGetFightIdReq{} }
func (m *FSGetFightIdReq) String() string            { return proto.CompactTextString(m) }
func (*FSGetFightIdReq) ProtoMessage()               {}
func (*FSGetFightIdReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{21} }

func (m *FSGetFightIdReq) GetFightType() FSFightType {
	if m != nil {
		return m.FightType
	}
	return FSFightType_Boss
}

type FSGetFightIdAck struct {
	FightId uint32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSGetFightIdAck) Reset()                    { *m = FSGetFightIdAck{} }
func (m *FSGetFightIdAck) String() string            { return proto.CompactTextString(m) }
func (*FSGetFightIdAck) ProtoMessage()               {}
func (*FSGetFightIdAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{22} }

func (m *FSGetFightIdAck) GetFightId() uint32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type User struct {
	SessionId       uint32 `protobuf:"varint,1,opt,name=sessionId,proto3" json:"sessionId,omitempty"`
	LocatedServerId uint32 `protobuf:"varint,2,opt,name=locatedServerId,proto3" json:"locatedServerId,omitempty"`
	UserInfo        *Actor `protobuf:"bytes,3,opt,name=userInfo" json:"userInfo,omitempty"`
	TeamId          int32  `protobuf:"varint,4,opt,name=teamId,proto3" json:"teamId,omitempty"`
	FightModel      int32  `protobuf:"varint,5,opt,name=fightModel,proto3" json:"fightModel,omitempty"`
	BirthArea       int32  `protobuf:"varint,6,opt,name=birthArea,proto3" json:"birthArea,omitempty"`
	UserType        int32  `protobuf:"varint,7,opt,name=userType,proto3" json:"userType,omitempty"`
	ToHelpUserId    int32  `protobuf:"varint,8,opt,name=toHelpUserId,proto3" json:"toHelpUserId,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{23} }

func (m *User) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *User) GetLocatedServerId() uint32 {
	if m != nil {
		return m.LocatedServerId
	}
	return 0
}

func (m *User) GetUserInfo() *Actor {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *User) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *User) GetFightModel() int32 {
	if m != nil {
		return m.FightModel
	}
	return 0
}

func (m *User) GetBirthArea() int32 {
	if m != nil {
		return m.BirthArea
	}
	return 0
}

func (m *User) GetUserType() int32 {
	if m != nil {
		return m.UserType
	}
	return 0
}

func (m *User) GetToHelpUserId() int32 {
	if m != nil {
		return m.ToHelpUserId
	}
	return 0
}

type UserDropReq struct {
	FightType int32 `protobuf:"varint,1,opt,name=fightType,proto3" json:"fightType,omitempty"`
	StageId   int32 `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	UserId    int32 `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *UserDropReq) Reset()                    { *m = UserDropReq{} }
func (m *UserDropReq) String() string            { return proto.CompactTextString(m) }
func (*UserDropReq) ProtoMessage()               {}
func (*UserDropReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{24} }

func (m *UserDropReq) GetFightType() int32 {
	if m != nil {
		return m.FightType
	}
	return 0
}

func (m *UserDropReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *UserDropReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UserDropAck struct {
	Items []*ItemUnit `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *UserDropAck) Reset()                    { *m = UserDropAck{} }
func (m *UserDropAck) String() string            { return proto.CompactTextString(m) }
func (*UserDropAck) ProtoMessage()               {}
func (*UserDropAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{25} }

func (m *UserDropAck) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

type FSAddItemReq struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	OpType int32           `protobuf:"varint,3,opt,name=OpType,proto3" json:"OpType,omitempty"`
}

func (m *FSAddItemReq) Reset()                    { *m = FSAddItemReq{} }
func (m *FSAddItemReq) String() string            { return proto.CompactTextString(m) }
func (*FSAddItemReq) ProtoMessage()               {}
func (*FSAddItemReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{26} }

func (m *FSAddItemReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FSAddItemReq) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *FSAddItemReq) GetOpType() int32 {
	if m != nil {
		return m.OpType
	}
	return 0
}

type FSAddItemAck struct {
	IsSuccess bool `protobuf:"varint,1,opt,name=isSuccess,proto3" json:"isSuccess,omitempty"`
}

func (m *FSAddItemAck) Reset()                    { *m = FSAddItemAck{} }
func (m *FSAddItemAck) String() string            { return proto.CompactTextString(m) }
func (*FSAddItemAck) ProtoMessage()               {}
func (*FSAddItemAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{27} }

func (m *FSAddItemAck) GetIsSuccess() bool {
	if m != nil {
		return m.IsSuccess
	}
	return false
}

type GsTOFsPickUpReq struct {
	UseId  int32   `protobuf:"varint,1,opt,name=useId,proto3" json:"useId,omitempty"`
	ObjIds []int32 `protobuf:"varint,2,rep,packed,name=objIds" json:"objIds,omitempty"`
	IsPick bool    `protobuf:"varint,3,opt,name=isPick,proto3" json:"isPick,omitempty"`
}

func (m *GsTOFsPickUpReq) Reset()                    { *m = GsTOFsPickUpReq{} }
func (m *GsTOFsPickUpReq) String() string            { return proto.CompactTextString(m) }
func (*GsTOFsPickUpReq) ProtoMessage()               {}
func (*GsTOFsPickUpReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{28} }

func (m *GsTOFsPickUpReq) GetUseId() int32 {
	if m != nil {
		return m.UseId
	}
	return 0
}

func (m *GsTOFsPickUpReq) GetObjIds() []int32 {
	if m != nil {
		return m.ObjIds
	}
	return nil
}

func (m *GsTOFsPickUpReq) GetIsPick() bool {
	if m != nil {
		return m.IsPick
	}
	return false
}

type FsTOGsPickUpAck struct {
	Items  map[int32]*ItemUnitForPickUp `protobuf:"bytes,1,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	IsPick bool                         `protobuf:"varint,2,opt,name=isPick,proto3" json:"isPick,omitempty"`
}

func (m *FsTOGsPickUpAck) Reset()                    { *m = FsTOGsPickUpAck{} }
func (m *FsTOGsPickUpAck) String() string            { return proto.CompactTextString(m) }
func (*FsTOGsPickUpAck) ProtoMessage()               {}
func (*FsTOGsPickUpAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{29} }

func (m *FsTOGsPickUpAck) GetItems() map[int32]*ItemUnitForPickUp {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *FsTOGsPickUpAck) GetIsPick() bool {
	if m != nil {
		return m.IsPick
	}
	return false
}

type GsToFsPickRedPacketInfo struct {
	UserId    int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	RedPacket *ActorRedPacket `protobuf:"bytes,2,opt,name=redPacket" json:"redPacket,omitempty"`
}

func (m *GsToFsPickRedPacketInfo) Reset()                    { *m = GsToFsPickRedPacketInfo{} }
func (m *GsToFsPickRedPacketInfo) String() string            { return proto.CompactTextString(m) }
func (*GsToFsPickRedPacketInfo) ProtoMessage()               {}
func (*GsToFsPickRedPacketInfo) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{30} }

func (m *GsToFsPickRedPacketInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsPickRedPacketInfo) GetRedPacket() *ActorRedPacket {
	if m != nil {
		return m.RedPacket
	}
	return nil
}

// 玩家技能使用
type FsSkillUseNtf struct {
	UseId          int32   `protobuf:"varint,1,opt,name=useId,proto3" json:"useId,omitempty"`
	HeroIndex      int32   `protobuf:"varint,2,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	SkillId        int32   `protobuf:"varint,3,opt,name=skillId,proto3" json:"skillId,omitempty"`
	CdStartTime    int64   `protobuf:"varint,4,opt,name=cdStartTime,proto3" json:"cdStartTime,omitempty"`
	CdStopTime     int64   `protobuf:"varint,5,opt,name=cdStopTime,proto3" json:"cdStopTime,omitempty"`
	KillMonsterIds []int32 `protobuf:"varint,6,rep,packed,name=killMonsterIds" json:"killMonsterIds,omitempty"`
	KillUserNum    int32   `protobuf:"varint,7,opt,name=killUserNum,proto3" json:"killUserNum,omitempty"`
}

func (m *FsSkillUseNtf) Reset()                    { *m = FsSkillUseNtf{} }
func (m *FsSkillUseNtf) String() string            { return proto.CompactTextString(m) }
func (*FsSkillUseNtf) ProtoMessage()               {}
func (*FsSkillUseNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{31} }

func (m *FsSkillUseNtf) GetUseId() int32 {
	if m != nil {
		return m.UseId
	}
	return 0
}

func (m *FsSkillUseNtf) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *FsSkillUseNtf) GetSkillId() int32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *FsSkillUseNtf) GetCdStartTime() int64 {
	if m != nil {
		return m.CdStartTime
	}
	return 0
}

func (m *FsSkillUseNtf) GetCdStopTime() int64 {
	if m != nil {
		return m.CdStopTime
	}
	return 0
}

func (m *FsSkillUseNtf) GetKillMonsterIds() []int32 {
	if m != nil {
		return m.KillMonsterIds
	}
	return nil
}

func (m *FsSkillUseNtf) GetKillUserNum() int32 {
	if m != nil {
		return m.KillUserNum
	}
	return 0
}

type FsToGsActorKillNtf struct {
	Killer   int32 `protobuf:"varint,1,opt,name=killer,proto3" json:"killer,omitempty"`
	BeKiller int32 `protobuf:"varint,2,opt,name=beKiller,proto3" json:"beKiller,omitempty"`
	IsPlayer bool  `protobuf:"varint,3,opt,name=isPlayer,proto3" json:"isPlayer,omitempty"`
}

func (m *FsToGsActorKillNtf) Reset()                    { *m = FsToGsActorKillNtf{} }
func (m *FsToGsActorKillNtf) String() string            { return proto.CompactTextString(m) }
func (*FsToGsActorKillNtf) ProtoMessage()               {}
func (*FsToGsActorKillNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{32} }

func (m *FsToGsActorKillNtf) GetKiller() int32 {
	if m != nil {
		return m.Killer
	}
	return 0
}

func (m *FsToGsActorKillNtf) GetBeKiller() int32 {
	if m != nil {
		return m.BeKiller
	}
	return 0
}

func (m *FsToGsActorKillNtf) GetIsPlayer() bool {
	if m != nil {
		return m.IsPlayer
	}
	return false
}

// 清理武将技能CD
type FsTOGsClearSkillCdNtf struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	HeroIndex int32 `protobuf:"varint,2,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
}

func (m *FsTOGsClearSkillCdNtf) Reset()                    { *m = FsTOGsClearSkillCdNtf{} }
func (m *FsTOGsClearSkillCdNtf) String() string            { return proto.CompactTextString(m) }
func (*FsTOGsClearSkillCdNtf) ProtoMessage()               {}
func (*FsTOGsClearSkillCdNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{33} }

func (m *FsTOGsClearSkillCdNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsTOGsClearSkillCdNtf) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

type FsRandomDeliveryNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Rand   bool  `protobuf:"varint,2,opt,name=rand,proto3" json:"rand,omitempty"`
}

func (m *FsRandomDeliveryNtf) Reset()                    { *m = FsRandomDeliveryNtf{} }
func (m *FsRandomDeliveryNtf) String() string            { return proto.CompactTextString(m) }
func (*FsRandomDeliveryNtf) ProtoMessage()               {}
func (*FsRandomDeliveryNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{34} }

func (m *FsRandomDeliveryNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsRandomDeliveryNtf) GetRand() bool {
	if m != nil {
		return m.Rand
	}
	return false
}

// game推送fs使用道具
type GsToFsUseItemNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ItemId int32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
}

func (m *GsToFsUseItemNtf) Reset()                    { *m = GsToFsUseItemNtf{} }
func (m *GsToFsUseItemNtf) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUseItemNtf) ProtoMessage()               {}
func (*GsToFsUseItemNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{35} }

func (m *GsToFsUseItemNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUseItemNtf) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

// 检查战斗是否存在
type GSTOFSCheckFightReq struct {
	FightId int32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *GSTOFSCheckFightReq) Reset()                    { *m = GSTOFSCheckFightReq{} }
func (m *GSTOFSCheckFightReq) String() string            { return proto.CompactTextString(m) }
func (*GSTOFSCheckFightReq) ProtoMessage()               {}
func (*GSTOFSCheckFightReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{36} }

func (m *GSTOFSCheckFightReq) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type FSTOGSCheckFightAck struct {
	FightId int32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSTOGSCheckFightAck) Reset()                    { *m = FSTOGSCheckFightAck{} }
func (m *FSTOGSCheckFightAck) String() string            { return proto.CompactTextString(m) }
func (*FSTOGSCheckFightAck) ProtoMessage()               {}
func (*FSTOGSCheckFightAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{37} }

func (m *FSTOGSCheckFightAck) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

// 获取战斗ID
type GSTOFSGetFightIdReq struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Ext     int32 `protobuf:"varint,2,opt,name=ext,proto3" json:"ext,omitempty"`
}

func (m *GSTOFSGetFightIdReq) Reset()                    { *m = GSTOFSGetFightIdReq{} }
func (m *GSTOFSGetFightIdReq) String() string            { return proto.CompactTextString(m) }
func (*GSTOFSGetFightIdReq) ProtoMessage()               {}
func (*GSTOFSGetFightIdReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{38} }

func (m *GSTOFSGetFightIdReq) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *GSTOFSGetFightIdReq) GetExt() int32 {
	if m != nil {
		return m.Ext
	}
	return 0
}

type FSTOGSGetFightIdAck struct {
	FightId int32 `protobuf:"varint,1,opt,name=fightId,proto3" json:"fightId,omitempty"`
}

func (m *FSTOGSGetFightIdAck) Reset()                    { *m = FSTOGSGetFightIdAck{} }
func (m *FSTOGSGetFightIdAck) String() string            { return proto.CompactTextString(m) }
func (*FSTOGSGetFightIdAck) ProtoMessage()               {}
func (*FSTOGSGetFightIdAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{39} }

func (m *FSTOGSGetFightIdAck) GetFightId() int32 {
	if m != nil {
		return m.FightId
	}
	return 0
}

type GsToFsGetCheerNumReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsGetCheerNumReq) Reset()                    { *m = GsToFsGetCheerNumReq{} }
func (m *GsToFsGetCheerNumReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGetCheerNumReq) ProtoMessage()               {}
func (*GsToFsGetCheerNumReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{40} }

func (m *GsToFsGetCheerNumReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsGetCheerNumAck struct {
	UserId        int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	CheerNum      int32 `protobuf:"varint,2,opt,name=cheerNum,proto3" json:"cheerNum,omitempty"`
	GuildCheerNum int32 `protobuf:"varint,3,opt,name=guildCheerNum,proto3" json:"guildCheerNum,omitempty"`
}

func (m *FsToGsGetCheerNumAck) Reset()                    { *m = FsToGsGetCheerNumAck{} }
func (m *FsToGsGetCheerNumAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsGetCheerNumAck) ProtoMessage()               {}
func (*FsToGsGetCheerNumAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{41} }

func (m *FsToGsGetCheerNumAck) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsGetCheerNumAck) GetCheerNum() int32 {
	if m != nil {
		return m.CheerNum
	}
	return 0
}

func (m *FsToGsGetCheerNumAck) GetGuildCheerNum() int32 {
	if m != nil {
		return m.GuildCheerNum
	}
	return 0
}

type GsToFsCheerReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsCheerReq) Reset()                    { *m = GsToFsCheerReq{} }
func (m *GsToFsCheerReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsCheerReq) ProtoMessage()               {}
func (*GsToFsCheerReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{42} }

func (m *GsToFsCheerReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsCheerAck struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsCheerAck) Reset()                    { *m = FsToGsCheerAck{} }
func (m *FsToGsCheerAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCheerAck) ProtoMessage()               {}
func (*FsToGsCheerAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{43} }

func (m *FsToGsCheerAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type GsToFsGetPotionCdReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsGetPotionCdReq) Reset()                    { *m = GsToFsGetPotionCdReq{} }
func (m *GsToFsGetPotionCdReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGetPotionCdReq) ProtoMessage()               {}
func (*GsToFsGetPotionCdReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{44} }

func (m *GsToFsGetPotionCdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsGetPotionCdAck struct {
	UserId  int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	UseTime int64 `protobuf:"varint,2,opt,name=useTime,proto3" json:"useTime,omitempty"`
}

func (m *FsToGsGetPotionCdAck) Reset()                    { *m = FsToGsGetPotionCdAck{} }
func (m *FsToGsGetPotionCdAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsGetPotionCdAck) ProtoMessage()               {}
func (*FsToGsGetPotionCdAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{45} }

func (m *FsToGsGetPotionCdAck) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsGetPotionCdAck) GetUseTime() int64 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

type GsToFsUsePotionReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsUsePotionReq) Reset()                    { *m = GsToFsUsePotionReq{} }
func (m *GsToFsUsePotionReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUsePotionReq) ProtoMessage()               {}
func (*GsToFsUsePotionReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{46} }

func (m *GsToFsUsePotionReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsUsePotionAck struct {
	Result  bool  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	UseTime int64 `protobuf:"varint,2,opt,name=useTime,proto3" json:"useTime,omitempty"`
}

func (m *FsToGsUsePotionAck) Reset()                    { *m = FsToGsUsePotionAck{} }
func (m *FsToGsUsePotionAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUsePotionAck) ProtoMessage()               {}
func (*FsToGsUsePotionAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{47} }

func (m *FsToGsUsePotionAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *FsToGsUsePotionAck) GetUseTime() int64 {
	if m != nil {
		return m.UseTime
	}
	return 0
}

type GsToFsCollectionReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ObjId  int32 `protobuf:"varint,2,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *GsToFsCollectionReq) Reset()                    { *m = GsToFsCollectionReq{} }
func (m *GsToFsCollectionReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsCollectionReq) ProtoMessage()               {}
func (*GsToFsCollectionReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{48} }

func (m *GsToFsCollectionReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsCollectionReq) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type FsToGsCollectionAck struct {
	StartTime int64 `protobuf:"varint,1,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
}

func (m *FsToGsCollectionAck) Reset()                    { *m = FsToGsCollectionAck{} }
func (m *FsToGsCollectionAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCollectionAck) ProtoMessage()               {}
func (*FsToGsCollectionAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{49} }

func (m *FsToGsCollectionAck) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *FsToGsCollectionAck) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type GsToFsCollectionCancelReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ObjId  int32 `protobuf:"varint,2,opt,name=objId,proto3" json:"objId,omitempty"`
}

func (m *GsToFsCollectionCancelReq) Reset()         { *m = GsToFsCollectionCancelReq{} }
func (m *GsToFsCollectionCancelReq) String() string { return proto.CompactTextString(m) }
func (*GsToFsCollectionCancelReq) ProtoMessage()    {}
func (*GsToFsCollectionCancelReq) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{50}
}

func (m *GsToFsCollectionCancelReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsCollectionCancelReq) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

type FsToGsCollectionCancelAck struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsCollectionCancelAck) Reset()         { *m = FsToGsCollectionCancelAck{} }
func (m *FsToGsCollectionCancelAck) String() string { return proto.CompactTextString(m) }
func (*FsToGsCollectionCancelAck) ProtoMessage()    {}
func (*FsToGsCollectionCancelAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{51}
}

func (m *FsToGsCollectionCancelAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type FsToGsCollectionNtf struct {
	UserId    int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageType int32           `protobuf:"varint,2,opt,name=stageType,proto3" json:"stageType,omitempty"`
	Items     map[int32]int32 `protobuf:"bytes,3,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FsToGsCollectionNtf) Reset()                    { *m = FsToGsCollectionNtf{} }
func (m *FsToGsCollectionNtf) String() string            { return proto.CompactTextString(m) }
func (*FsToGsCollectionNtf) ProtoMessage()               {}
func (*FsToGsCollectionNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{52} }

func (m *FsToGsCollectionNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsCollectionNtf) GetStageType() int32 {
	if m != nil {
		return m.StageType
	}
	return 0
}

func (m *FsToGsCollectionNtf) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

// 使用合体
type GsToFsUseFitReq struct {
	UserId int32     `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Fit    *ActorFit `protobuf:"bytes,2,opt,name=fit" json:"fit,omitempty"`
}

func (m *GsToFsUseFitReq) Reset()                    { *m = GsToFsUseFitReq{} }
func (m *GsToFsUseFitReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUseFitReq) ProtoMessage()               {}
func (*GsToFsUseFitReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{53} }

func (m *GsToFsUseFitReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUseFitReq) GetFit() *ActorFit {
	if m != nil {
		return m.Fit
	}
	return nil
}

type FsToGsUseFitAck struct {
	IsSuccess bool `protobuf:"varint,1,opt,name=isSuccess,proto3" json:"isSuccess,omitempty"`
}

func (m *FsToGsUseFitAck) Reset()                    { *m = FsToGsUseFitAck{} }
func (m *FsToGsUseFitAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUseFitAck) ProtoMessage()               {}
func (*FsToGsUseFitAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{54} }

func (m *FsToGsUseFitAck) GetIsSuccess() bool {
	if m != nil {
		return m.IsSuccess
	}
	return false
}

type GsToFsFitCacelReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsFitCacelReq) Reset()                    { *m = GsToFsFitCacelReq{} }
func (m *GsToFsFitCacelReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsFitCacelReq) ProtoMessage()               {}
func (*GsToFsFitCacelReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{55} }

func (m *GsToFsFitCacelReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type FsToGsFitCacelAck struct {
}

func (m *FsToGsFitCacelAck) Reset()                    { *m = FsToGsFitCacelAck{} }
func (m *FsToGsFitCacelAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsFitCacelAck) ProtoMessage()               {}
func (*FsToGsFitCacelAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{56} }

type GsToFsUpdatePetReq struct {
	UserId int32     `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Pet    *ActorPet `protobuf:"bytes,2,opt,name=pet" json:"pet,omitempty"`
}

func (m *GsToFsUpdatePetReq) Reset()                    { *m = GsToFsUpdatePetReq{} }
func (m *GsToFsUpdatePetReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUpdatePetReq) ProtoMessage()               {}
func (*GsToFsUpdatePetReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{57} }

func (m *GsToFsUpdatePetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUpdatePetReq) GetPet() *ActorPet {
	if m != nil {
		return m.Pet
	}
	return nil
}

type FsToGsUpdatePetAck struct {
}

func (m *FsToGsUpdatePetAck) Reset()                    { *m = FsToGsUpdatePetAck{} }
func (m *FsToGsUpdatePetAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUpdatePetAck) ProtoMessage()               {}
func (*FsToGsUpdatePetAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{58} }

type GsToFsGmReq struct {
	UserId int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Cmd    string `protobuf:"bytes,2,opt,name=cmd,proto3" json:"cmd,omitempty"`
}

func (m *GsToFsGmReq) Reset()                    { *m = GsToFsGmReq{} }
func (m *GsToFsGmReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGmReq) ProtoMessage()               {}
func (*GsToFsGmReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{59} }

func (m *GsToFsGmReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsGmReq) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

type FsToGsGmAck struct {
	Result string `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsGmAck) Reset()                    { *m = FsToGsGmAck{} }
func (m *FsToGsGmAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsGmAck) ProtoMessage()               {}
func (*FsToGsGmAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{60} }

func (m *FsToGsGmAck) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type GsToFsUseCutTreasureReq struct {
	UserId        int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	CutTreasureLv int32 `protobuf:"varint,2,opt,name=cutTreasureLv,proto3" json:"cutTreasureLv,omitempty"`
}

func (m *GsToFsUseCutTreasureReq) Reset()                    { *m = GsToFsUseCutTreasureReq{} }
func (m *GsToFsUseCutTreasureReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsUseCutTreasureReq) ProtoMessage()               {}
func (*GsToFsUseCutTreasureReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{61} }

func (m *GsToFsUseCutTreasureReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsUseCutTreasureReq) GetCutTreasureLv() int32 {
	if m != nil {
		return m.CutTreasureLv
	}
	return 0
}

type FsToGsUseCutTreasureAck struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FsToGsUseCutTreasureAck) Reset()                    { *m = FsToGsUseCutTreasureAck{} }
func (m *FsToGsUseCutTreasureAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsUseCutTreasureAck) ProtoMessage()               {}
func (*FsToGsUseCutTreasureAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{62} }

func (m *FsToGsUseCutTreasureAck) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 检查是否可以请求帮助
type GsToFsCheckForHelpReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *GsToFsCheckForHelpReq) Reset()                    { *m = GsToFsCheckForHelpReq{} }
func (m *GsToFsCheckForHelpReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsCheckForHelpReq) ProtoMessage()               {}
func (*GsToFsCheckForHelpReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{63} }

func (m *GsToFsCheckForHelpReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 检查是否可以请求帮助结果
type FsToGsCheckForHelpResultAck struct {
	CanGetHelp bool `protobuf:"varint,1,opt,name=canGetHelp,proto3" json:"canGetHelp,omitempty"`
}

func (m *FsToGsCheckForHelpResultAck) Reset()         { *m = FsToGsCheckForHelpResultAck{} }
func (m *FsToGsCheckForHelpResultAck) String() string { return proto.CompactTextString(m) }
func (*FsToGsCheckForHelpResultAck) ProtoMessage()    {}
func (*FsToGsCheckForHelpResultAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{64}
}

func (m *FsToGsCheckForHelpResultAck) GetCanGetHelp() bool {
	if m != nil {
		return m.CanGetHelp
	}
	return false
}

type GsToFsChangeToHelperReq struct {
	UserId       int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ToHelpUserId int32 `protobuf:"varint,2,opt,name=toHelpUserId,proto3" json:"toHelpUserId,omitempty"`
}

func (m *GsToFsChangeToHelperReq) Reset()                    { *m = GsToFsChangeToHelperReq{} }
func (m *GsToFsChangeToHelperReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsChangeToHelperReq) ProtoMessage()               {}
func (*GsToFsChangeToHelperReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{65} }

func (m *GsToFsChangeToHelperReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsChangeToHelperReq) GetToHelpUserId() int32 {
	if m != nil {
		return m.ToHelpUserId
	}
	return 0
}

type GsToFsFightNumChangeReq struct {
	UserId         int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	FightNumChange int32 `protobuf:"varint,2,opt,name=fightNumChange,proto3" json:"fightNumChange,omitempty"`
}

func (m *GsToFsFightNumChangeReq) Reset()                    { *m = GsToFsFightNumChangeReq{} }
func (m *GsToFsFightNumChangeReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsFightNumChangeReq) ProtoMessage()               {}
func (*GsToFsFightNumChangeReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{66} }

func (m *GsToFsFightNumChangeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsFightNumChangeReq) GetFightNumChange() int32 {
	if m != nil {
		return m.FightNumChange
	}
	return 0
}

type GsToFsFightNpcEventReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	NpcId  int32 `protobuf:"varint,2,opt,name=npcId,proto3" json:"npcId,omitempty"`
}

func (m *GsToFsFightNpcEventReq) Reset()                    { *m = GsToFsFightNpcEventReq{} }
func (m *GsToFsFightNpcEventReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsFightNpcEventReq) ProtoMessage()               {}
func (*GsToFsFightNpcEventReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{67} }

func (m *GsToFsFightNpcEventReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsFightNpcEventReq) GetNpcId() int32 {
	if m != nil {
		return m.NpcId
	}
	return 0
}

type FsToGsFightNpcEventAck struct {
}

func (m *FsToGsFightNpcEventAck) Reset()                    { *m = FsToGsFightNpcEventAck{} }
func (m *FsToGsFightNpcEventAck) String() string            { return proto.CompactTextString(m) }
func (*FsToGsFightNpcEventAck) ProtoMessage()               {}
func (*FsToGsFightNpcEventAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{68} }

type GsToFsGamedbReloadReq struct {
}

func (m *GsToFsGamedbReloadReq) Reset()                    { *m = GsToFsGamedbReloadReq{} }
func (m *GsToFsGamedbReloadReq) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGamedbReloadReq) ProtoMessage()               {}
func (*GsToFsGamedbReloadReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{69} }

type GsToFsGamedbReloadAck struct {
}

func (m *GsToFsGamedbReloadAck) Reset()                    { *m = GsToFsGamedbReloadAck{} }
func (m *GsToFsGamedbReloadAck) String() string            { return proto.CompactTextString(m) }
func (*GsToFsGamedbReloadAck) ProtoMessage()               {}
func (*GsToFsGamedbReloadAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{70} }

type WorldBossStatusNtf struct {
	StageId int32 `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Status  int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WorldBossStatusNtf) Reset()                    { *m = WorldBossStatusNtf{} }
func (m *WorldBossStatusNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldBossStatusNtf) ProtoMessage()               {}
func (*WorldBossStatusNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{71} }

func (m *WorldBossStatusNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *WorldBossStatusNtf) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ExpStageKillMonsterNtf struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
}

func (m *ExpStageKillMonsterNtf) Reset()                    { *m = ExpStageKillMonsterNtf{} }
func (m *ExpStageKillMonsterNtf) String() string            { return proto.CompactTextString(m) }
func (*ExpStageKillMonsterNtf) ProtoMessage()               {}
func (*ExpStageKillMonsterNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{72} }

func (m *ExpStageKillMonsterNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type PersonFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *PersonFightResult) Reset()                    { *m = PersonFightResult{} }
func (m *PersonFightResult) String() string            { return proto.CompactTextString(m) }
func (*PersonFightResult) ProtoMessage()               {}
func (*PersonFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{73} }

func (m *PersonFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PersonFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *PersonFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type VipBossFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *VipBossFightResult) Reset()                    { *m = VipBossFightResult{} }
func (m *VipBossFightResult) String() string            { return proto.CompactTextString(m) }
func (*VipBossFightResult) ProtoMessage()               {}
func (*VipBossFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{74} }

func (m *VipBossFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *VipBossFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *VipBossFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type TowerFightResult struct {
	UserId int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Items  map[int32]int32 `protobuf:"bytes,2,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Result int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *TowerFightResult) Reset()                    { *m = TowerFightResult{} }
func (m *TowerFightResult) String() string            { return proto.CompactTextString(m) }
func (*TowerFightResult) ProtoMessage()               {}
func (*TowerFightResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{75} }

func (m *TowerFightResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TowerFightResult) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *TowerFightResult) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type FieldBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FieldBossResult) Reset()                    { *m = FieldBossResult{} }
func (m *FieldBossResult) String() string            { return proto.CompactTextString(m) }
func (*FieldBossResult) ProtoMessage()               {}
func (*FieldBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{76} }

func (m *FieldBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *FieldBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

type DarkPalaceBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Helper        map[int32]int32      `protobuf:"bytes,3,rep,name=helper" json:"helper,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *DarkPalaceBossResult) Reset()                    { *m = DarkPalaceBossResult{} }
func (m *DarkPalaceBossResult) String() string            { return proto.CompactTextString(m) }
func (*DarkPalaceBossResult) ProtoMessage()               {}
func (*DarkPalaceBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{77} }

func (m *DarkPalaceBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *DarkPalaceBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

func (m *DarkPalaceBossResult) GetHelper() map[int32]int32 {
	if m != nil {
		return m.Helper
	}
	return nil
}

type AncientBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AncientBossResult) Reset()                    { *m = AncientBossResult{} }
func (m *AncientBossResult) String() string            { return proto.CompactTextString(m) }
func (*AncientBossResult) ProtoMessage()               {}
func (*AncientBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{78} }

func (m *AncientBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *AncientBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

type HellBossResult struct {
	SendWinner    bool                 `protobuf:"varint,1,opt,name=sendWinner,proto3" json:"sendWinner,omitempty"`
	UserPickItems map[int32]*ItemUnits `protobuf:"bytes,2,rep,name=userPickItems" json:"userPickItems,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Helper        map[int32]int32      `protobuf:"bytes,3,rep,name=helper" json:"helper,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HellBossResult) Reset()                    { *m = HellBossResult{} }
func (m *HellBossResult) String() string            { return proto.CompactTextString(m) }
func (*HellBossResult) ProtoMessage()               {}
func (*HellBossResult) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{79} }

func (m *HellBossResult) GetSendWinner() bool {
	if m != nil {
		return m.SendWinner
	}
	return false
}

func (m *HellBossResult) GetUserPickItems() map[int32]*ItemUnits {
	if m != nil {
		return m.UserPickItems
	}
	return nil
}

func (m *HellBossResult) GetHelper() map[int32]int32 {
	if m != nil {
		return m.Helper
	}
	return nil
}

// 推送打宝秘境玩家击杀怪物
type DaBaoKillMonsterNtf struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	MonsterId int32 `protobuf:"varint,2,opt,name=monsterId,proto3" json:"monsterId,omitempty"`
	Energy    int32 `protobuf:"varint,3,opt,name=energy,proto3" json:"energy,omitempty"`
}

func (m *DaBaoKillMonsterNtf) Reset()                    { *m = DaBaoKillMonsterNtf{} }
func (m *DaBaoKillMonsterNtf) String() string            { return proto.CompactTextString(m) }
func (*DaBaoKillMonsterNtf) ProtoMessage()               {}
func (*DaBaoKillMonsterNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{80} }

func (m *DaBaoKillMonsterNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DaBaoKillMonsterNtf) GetMonsterId() int32 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *DaBaoKillMonsterNtf) GetEnergy() int32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

type DaBaoResumeEnergyReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Energy int32 `protobuf:"varint,2,opt,name=energy,proto3" json:"energy,omitempty"`
}

func (m *DaBaoResumeEnergyReq) Reset()                    { *m = DaBaoResumeEnergyReq{} }
func (m *DaBaoResumeEnergyReq) String() string            { return proto.CompactTextString(m) }
func (*DaBaoResumeEnergyReq) ProtoMessage()               {}
func (*DaBaoResumeEnergyReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{81} }

func (m *DaBaoResumeEnergyReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DaBaoResumeEnergyReq) GetEnergy() int32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

type MiningNewFightInfoReq struct {
	MiningId     int32 `protobuf:"varint,1,opt,name=miningId,proto3" json:"miningId,omitempty"`
	MiningUserId int32 `protobuf:"varint,2,opt,name=miningUserId,proto3" json:"miningUserId,omitempty"`
	IsRetake     bool  `protobuf:"varint,3,opt,name=isRetake,proto3" json:"isRetake,omitempty"`
}

func (m *MiningNewFightInfoReq) Reset()                    { *m = MiningNewFightInfoReq{} }
func (m *MiningNewFightInfoReq) String() string            { return proto.CompactTextString(m) }
func (*MiningNewFightInfoReq) ProtoMessage()               {}
func (*MiningNewFightInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{82} }

func (m *MiningNewFightInfoReq) GetMiningId() int32 {
	if m != nil {
		return m.MiningId
	}
	return 0
}

func (m *MiningNewFightInfoReq) GetMiningUserId() int32 {
	if m != nil {
		return m.MiningUserId
	}
	return 0
}

func (m *MiningNewFightInfoReq) GetIsRetake() bool {
	if m != nil {
		return m.IsRetake
	}
	return false
}

type MiningNewFightInfoAck struct {
	ReadyOk bool `protobuf:"varint,1,opt,name=readyOk,proto3" json:"readyOk,omitempty"`
}

func (m *MiningNewFightInfoAck) Reset()                    { *m = MiningNewFightInfoAck{} }
func (m *MiningNewFightInfoAck) String() string            { return proto.CompactTextString(m) }
func (*MiningNewFightInfoAck) ProtoMessage()               {}
func (*MiningNewFightInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{83} }

func (m *MiningNewFightInfoAck) GetReadyOk() bool {
	if m != nil {
		return m.ReadyOk
	}
	return false
}

type MiningFightResultNtf struct {
	UserId       int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	MiningId     int32 `protobuf:"varint,2,opt,name=miningId,proto3" json:"miningId,omitempty"`
	MiningUserId int32 `protobuf:"varint,3,opt,name=miningUserId,proto3" json:"miningUserId,omitempty"`
	IsRetake     bool  `protobuf:"varint,4,opt,name=isRetake,proto3" json:"isRetake,omitempty"`
	Result       int32 `protobuf:"varint,5,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *MiningFightResultNtf) Reset()                    { *m = MiningFightResultNtf{} }
func (m *MiningFightResultNtf) String() string            { return proto.CompactTextString(m) }
func (*MiningFightResultNtf) ProtoMessage()               {}
func (*MiningFightResultNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{84} }

func (m *MiningFightResultNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MiningFightResultNtf) GetMiningId() int32 {
	if m != nil {
		return m.MiningId
	}
	return 0
}

func (m *MiningFightResultNtf) GetMiningUserId() int32 {
	if m != nil {
		return m.MiningUserId
	}
	return 0
}

func (m *MiningFightResultNtf) GetIsRetake() bool {
	if m != nil {
		return m.IsRetake
	}
	return false
}

func (m *MiningFightResultNtf) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 推送玩家击杀一波怪物
type HangUpKillWaveNtf struct {
	UserId  int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageId int32 `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
}

func (m *HangUpKillWaveNtf) Reset()                    { *m = HangUpKillWaveNtf{} }
func (m *HangUpKillWaveNtf) String() string            { return proto.CompactTextString(m) }
func (*HangUpKillWaveNtf) ProtoMessage()               {}
func (*HangUpKillWaveNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{85} }

func (m *HangUpKillWaveNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HangUpKillWaveNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

// 推送玩家击杀挂机BOSS
type HangUpBossFightEndNtf struct {
	UserId  int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	StageId int32           `protobuf:"varint,2,opt,name=stageId,proto3" json:"stageId,omitempty"`
	Result  int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	Items   map[int32]int32 `protobuf:"bytes,4,rep,name=items" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HangUpBossFightEndNtf) Reset()                    { *m = HangUpBossFightEndNtf{} }
func (m *HangUpBossFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*HangUpBossFightEndNtf) ProtoMessage()               {}
func (*HangUpBossFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{86} }

func (m *HangUpBossFightEndNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *HangUpBossFightEndNtf) GetItems() map[int32]int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

type FightTotalData struct {
	Damage   int64 `protobuf:"varint,1,opt,name=damage,proto3" json:"damage,omitempty"`
	BeDamage int64 `protobuf:"varint,2,opt,name=beDamage,proto3" json:"beDamage,omitempty"`
	Treat    int64 `protobuf:"varint,3,opt,name=treat,proto3" json:"treat,omitempty"`
}

func (m *FightTotalData) Reset()                    { *m = FightTotalData{} }
func (m *FightTotalData) String() string            { return proto.CompactTextString(m) }
func (*FightTotalData) ProtoMessage()               {}
func (*FightTotalData) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{87} }

func (m *FightTotalData) GetDamage() int64 {
	if m != nil {
		return m.Damage
	}
	return 0
}

func (m *FightTotalData) GetBeDamage() int64 {
	if m != nil {
		return m.BeDamage
	}
	return 0
}

func (m *FightTotalData) GetTreat() int64 {
	if m != nil {
		return m.Treat
	}
	return 0
}

type GuildbonfireExpAddNtf struct {
	GuildId int32   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=userIds" json:"userIds,omitempty"`
}

func (m *GuildbonfireExpAddNtf) Reset()                    { *m = GuildbonfireExpAddNtf{} }
func (m *GuildbonfireExpAddNtf) String() string            { return proto.CompactTextString(m) }
func (*GuildbonfireExpAddNtf) ProtoMessage()               {}
func (*GuildbonfireExpAddNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{88} }

func (m *GuildbonfireExpAddNtf) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GuildbonfireExpAddNtf) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type PaodianGoodsAddNtf struct {
	StageId int32           `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	UserIds map[int32]int32 `protobuf:"bytes,2,rep,name=userIds" json:"userIds,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *PaodianGoodsAddNtf) Reset()                    { *m = PaodianGoodsAddNtf{} }
func (m *PaodianGoodsAddNtf) String() string            { return proto.CompactTextString(m) }
func (*PaodianGoodsAddNtf) ProtoMessage()               {}
func (*PaodianGoodsAddNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{89} }

func (m *PaodianGoodsAddNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *PaodianGoodsAddNtf) GetUserIds() map[int32]int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type ShabakeFightEndNtf struct {
	UserRank  []*ShabakeRankScore `protobuf:"bytes,1,rep,name=userRank" json:"userRank,omitempty"`
	GuildRank []*ShabakeRankScore `protobuf:"bytes,2,rep,name=guildRank" json:"guildRank,omitempty"`
}

func (m *ShabakeFightEndNtf) Reset()                    { *m = ShabakeFightEndNtf{} }
func (m *ShabakeFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeFightEndNtf) ProtoMessage()               {}
func (*ShabakeFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{90} }

func (m *ShabakeFightEndNtf) GetUserRank() []*ShabakeRankScore {
	if m != nil {
		return m.UserRank
	}
	return nil
}

func (m *ShabakeFightEndNtf) GetGuildRank() []*ShabakeRankScore {
	if m != nil {
		return m.GuildRank
	}
	return nil
}

type ShabakeRankScore struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Score int32 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *ShabakeRankScore) Reset()                    { *m = ShabakeRankScore{} }
func (m *ShabakeRankScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeRankScore) ProtoMessage()               {}
func (*ShabakeRankScore) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{91} }

func (m *ShabakeRankScore) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ShabakeRankScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ShabakeCrossFightEndNtf struct {
	ServerRank []*ShabakeRankScore      `protobuf:"bytes,1,rep,name=serverRank" json:"serverRank,omitempty"`
	GuildRank  []*ShabakeCrossRankScore `protobuf:"bytes,2,rep,name=guildRank" json:"guildRank,omitempty"`
}

func (m *ShabakeCrossFightEndNtf) Reset()                    { *m = ShabakeCrossFightEndNtf{} }
func (m *ShabakeCrossFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*ShabakeCrossFightEndNtf) ProtoMessage()               {}
func (*ShabakeCrossFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{92} }

func (m *ShabakeCrossFightEndNtf) GetServerRank() []*ShabakeRankScore {
	if m != nil {
		return m.ServerRank
	}
	return nil
}

func (m *ShabakeCrossFightEndNtf) GetGuildRank() []*ShabakeCrossRankScore {
	if m != nil {
		return m.GuildRank
	}
	return nil
}

type ShabakeCrossRankScore struct {
	ServerId int32   `protobuf:"varint,1,opt,name=serverId,proto3" json:"serverId,omitempty"`
	GuildId  int32   `protobuf:"varint,2,opt,name=guildId,proto3" json:"guildId,omitempty"`
	Score    int32   `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	Users    []int32 `protobuf:"varint,4,rep,packed,name=users" json:"users,omitempty"`
}

func (m *ShabakeCrossRankScore) Reset()                    { *m = ShabakeCrossRankScore{} }
func (m *ShabakeCrossRankScore) String() string            { return proto.CompactTextString(m) }
func (*ShabakeCrossRankScore) ProtoMessage()               {}
func (*ShabakeCrossRankScore) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{93} }

func (m *ShabakeCrossRankScore) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *ShabakeCrossRankScore) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *ShabakeCrossRankScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ShabakeCrossRankScore) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

// 推送世界首领结果
type WorldLeaderFightEndNtf struct {
	StageId      int32                  `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	LastAttacker int32                  `protobuf:"varint,2,opt,name=lastAttacker,proto3" json:"lastAttacker,omitempty"`
	Ranks        []*WorldLeaderRankUnit `protobuf:"bytes,3,rep,name=ranks" json:"ranks,omitempty"`
}

func (m *WorldLeaderFightEndNtf) Reset()                    { *m = WorldLeaderFightEndNtf{} }
func (m *WorldLeaderFightEndNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldLeaderFightEndNtf) ProtoMessage()               {}
func (*WorldLeaderFightEndNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{94} }

func (m *WorldLeaderFightEndNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *WorldLeaderFightEndNtf) GetLastAttacker() int32 {
	if m != nil {
		return m.LastAttacker
	}
	return 0
}

func (m *WorldLeaderFightEndNtf) GetRanks() []*WorldLeaderRankUnit {
	if m != nil {
		return m.Ranks
	}
	return nil
}

// 推送世界首领排行
type WorldLeaderFightRankNtf struct {
	StageId int32                  `protobuf:"varint,1,opt,name=stageId,proto3" json:"stageId,omitempty"`
	BossHp  int32                  `protobuf:"varint,2,opt,name=bossHp,proto3" json:"bossHp,omitempty"`
	Ranks   []*WorldLeaderRankUnit `protobuf:"bytes,3,rep,name=ranks" json:"ranks,omitempty"`
}

func (m *WorldLeaderFightRankNtf) Reset()                    { *m = WorldLeaderFightRankNtf{} }
func (m *WorldLeaderFightRankNtf) String() string            { return proto.CompactTextString(m) }
func (*WorldLeaderFightRankNtf) ProtoMessage()               {}
func (*WorldLeaderFightRankNtf) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{95} }

func (m *WorldLeaderFightRankNtf) GetStageId() int32 {
	if m != nil {
		return m.StageId
	}
	return 0
}

func (m *WorldLeaderFightRankNtf) GetBossHp() int32 {
	if m != nil {
		return m.BossHp
	}
	return 0
}

func (m *WorldLeaderFightRankNtf) GetRanks() []*WorldLeaderRankUnit {
	if m != nil {
		return m.Ranks
	}
	return nil
}

type WorldLeaderRankUnit struct {
	Rank      int32   `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	GuildId   int32   `protobuf:"varint,2,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildName string  `protobuf:"bytes,3,opt,name=guildName,proto3" json:"guildName,omitempty"`
	Score     int64   `protobuf:"varint,4,opt,name=score,proto3" json:"score,omitempty"`
	ServerId  int32   `protobuf:"varint,5,opt,name=serverId,proto3" json:"serverId,omitempty"`
	Users     []int32 `protobuf:"varint,6,rep,packed,name=users" json:"users,omitempty"`
}

func (m *WorldLeaderRankUnit) Reset()                    { *m = WorldLeaderRankUnit{} }
func (m *WorldLeaderRankUnit) String() string            { return proto.CompactTextString(m) }
func (*WorldLeaderRankUnit) ProtoMessage()               {}
func (*WorldLeaderRankUnit) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{96} }

func (m *WorldLeaderRankUnit) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *WorldLeaderRankUnit) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *WorldLeaderRankUnit) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *WorldLeaderRankUnit) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *WorldLeaderRankUnit) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *WorldLeaderRankUnit) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

type GuardPillarFightEnd struct {
	Wave  int32   `protobuf:"varint,1,opt,name=wave,proto3" json:"wave,omitempty"`
	Users []int32 `protobuf:"varint,2,rep,packed,name=users" json:"users,omitempty"`
}

func (m *GuardPillarFightEnd) Reset()                    { *m = GuardPillarFightEnd{} }
func (m *GuardPillarFightEnd) String() string            { return proto.CompactTextString(m) }
func (*GuardPillarFightEnd) ProtoMessage()               {}
func (*GuardPillarFightEnd) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{97} }

func (m *GuardPillarFightEnd) GetWave() int32 {
	if m != nil {
		return m.Wave
	}
	return 0
}

func (m *GuardPillarFightEnd) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

// fs->gs 野外boss玩家死亡时间
type FsFieldBossDieUserInfoNtf struct {
	DieUserId int32 `protobuf:"varint,1,opt,name=dieUserId,proto3" json:"dieUserId,omitempty"`
	DieTime   int64 `protobuf:"varint,2,opt,name=dieTime,proto3" json:"dieTime,omitempty"`
}

func (m *FsFieldBossDieUserInfoNtf) Reset()         { *m = FsFieldBossDieUserInfoNtf{} }
func (m *FsFieldBossDieUserInfoNtf) String() string { return proto.CompactTextString(m) }
func (*FsFieldBossDieUserInfoNtf) ProtoMessage()    {}
func (*FsFieldBossDieUserInfoNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{98}
}

func (m *FsFieldBossDieUserInfoNtf) GetDieUserId() int32 {
	if m != nil {
		return m.DieUserId
	}
	return 0
}

func (m *FsFieldBossDieUserInfoNtf) GetDieTime() int64 {
	if m != nil {
		return m.DieTime
	}
	return 0
}

type MagicTowerFightEnd struct {
	UserRank []*ShabakeRankScore `protobuf:"bytes,1,rep,name=userRank" json:"userRank,omitempty"`
}

func (m *MagicTowerFightEnd) Reset()                    { *m = MagicTowerFightEnd{} }
func (m *MagicTowerFightEnd) String() string            { return proto.CompactTextString(m) }
func (*MagicTowerFightEnd) ProtoMessage()               {}
func (*MagicTowerFightEnd) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{99} }

func (m *MagicTowerFightEnd) GetUserRank() []*ShabakeRankScore {
	if m != nil {
		return m.UserRank
	}
	return nil
}

type GsToFsFightScoreLessReq struct {
	UserId  int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	LessNum int32 `protobuf:"varint,2,opt,name=lessNum,proto3" json:"lessNum,omitempty"`
}

func (m *GsToFsFightScoreLessReq) Reset()         { *m = GsToFsFightScoreLessReq{} }
func (m *GsToFsFightScoreLessReq) String() string { return proto.CompactTextString(m) }
func (*GsToFsFightScoreLessReq) ProtoMessage()    {}
func (*GsToFsFightScoreLessReq) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{100}
}

func (m *GsToFsFightScoreLessReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GsToFsFightScoreLessReq) GetLessNum() int32 {
	if m != nil {
		return m.LessNum
	}
	return 0
}

type FsToGsFightScoreLessAck struct {
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Score  int32 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *FsToGsFightScoreLessAck) Reset()         { *m = FsToGsFightScoreLessAck{} }
func (m *FsToGsFightScoreLessAck) String() string { return proto.CompactTextString(m) }
func (*FsToGsFightScoreLessAck) ProtoMessage()    {}
func (*FsToGsFightScoreLessAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{101}
}

func (m *FsToGsFightScoreLessAck) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FsToGsFightScoreLessAck) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 获取玩家当前分数
type MagicTowerGetUserInfoReq struct {
	UserId     int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	IsGetAward bool  `protobuf:"varint,2,opt,name=isGetAward,proto3" json:"isGetAward,omitempty"`
}

func (m *MagicTowerGetUserInfoReq) Reset()         { *m = MagicTowerGetUserInfoReq{} }
func (m *MagicTowerGetUserInfoReq) String() string { return proto.CompactTextString(m) }
func (*MagicTowerGetUserInfoReq) ProtoMessage()    {}
func (*MagicTowerGetUserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{102}
}

func (m *MagicTowerGetUserInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MagicTowerGetUserInfoReq) GetIsGetAward() bool {
	if m != nil {
		return m.IsGetAward
	}
	return false
}

// 获取玩家当前分数
type MagicTowerGetUserInfoAck struct {
	Score       int32 `protobuf:"varint,1,opt,name=score,proto3" json:"score,omitempty"`
	IsGetAward  bool  `protobuf:"varint,2,opt,name=isGetAward,proto3" json:"isGetAward,omitempty"`
	CanGetAward bool  `protobuf:"varint,3,opt,name=canGetAward,proto3" json:"canGetAward,omitempty"`
}

func (m *MagicTowerGetUserInfoAck) Reset()         { *m = MagicTowerGetUserInfoAck{} }
func (m *MagicTowerGetUserInfoAck) String() string { return proto.CompactTextString(m) }
func (*MagicTowerGetUserInfoAck) ProtoMessage()    {}
func (*MagicTowerGetUserInfoAck) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{103}
}

func (m *MagicTowerGetUserInfoAck) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *MagicTowerGetUserInfoAck) GetIsGetAward() bool {
	if m != nil {
		return m.IsGetAward
	}
	return false
}

func (m *MagicTowerGetUserInfoAck) GetCanGetAward() bool {
	if m != nil {
		return m.CanGetAward
	}
	return false
}

// 推送沙巴克击杀boss
type FsToGsShabakeKillBossNtf struct {
	Infos string `protobuf:"bytes,1,opt,name=infos,proto3" json:"infos,omitempty"`
}

func (m *FsToGsShabakeKillBossNtf) Reset()         { *m = FsToGsShabakeKillBossNtf{} }
func (m *FsToGsShabakeKillBossNtf) String() string { return proto.CompactTextString(m) }
func (*FsToGsShabakeKillBossNtf) ProtoMessage()    {}
func (*FsToGsShabakeKillBossNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorFsServer, []int{104}
}

func (m *FsToGsShabakeKillBossNtf) GetInfos() string {
	if m != nil {
		return m.Infos
	}
	return ""
}

type BossFamilyBossInfoReq struct {
	BossFamilyType int32 `protobuf:"varint,1,opt,name=bossFamilyType,proto3" json:"bossFamilyType,omitempty"`
}

func (m *BossFamilyBossInfoReq) Reset()                    { *m = BossFamilyBossInfoReq{} }
func (m *BossFamilyBossInfoReq) String() string            { return proto.CompactTextString(m) }
func (*BossFamilyBossInfoReq) ProtoMessage()               {}
func (*BossFamilyBossInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{105} }

func (m *BossFamilyBossInfoReq) GetBossFamilyType() int32 {
	if m != nil {
		return m.BossFamilyType
	}
	return 0
}

type BossFamilyBossInfoAck struct {
	BossFamilyInfo map[int32]int32 `protobuf:"bytes,1,rep,name=bossFamilyInfo" json:"bossFamilyInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *BossFamilyBossInfoAck) Reset()                    { *m = BossFamilyBossInfoAck{} }
func (m *BossFamilyBossInfoAck) String() string            { return proto.CompactTextString(m) }
func (*BossFamilyBossInfoAck) ProtoMessage()               {}
func (*BossFamilyBossInfoAck) Descriptor() ([]byte, []int) { return fileDescriptorFsServer, []int{106} }

func (m *BossFamilyBossInfoAck) GetBossFamilyInfo() map[int32]int32 {
	if m != nil {
		return m.BossFamilyInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*GsRouteMessageToFight)(nil), "pbserver.GsRouteMessageToFight")
	proto.RegisterType((*FSCreateFightReq)(nil), "pbserver.FSCreateFightReq")
	proto.RegisterType((*FSCreateFightAck)(nil), "pbserver.FSCreateFightAck")
	proto.RegisterType((*GsToFsResidentFightReq)(nil), "pbserver.GsToFsResidentFightReq")
	proto.RegisterType((*FsResidentFightNtf)(nil), "pbserver.FsResidentFightNtf")
	proto.RegisterType((*FsFieldBossInfoNtf)(nil), "pbserver.FsFieldBossInfoNtf")
	proto.RegisterType((*FSContinueFightReq)(nil), "pbserver.FSContinueFightReq")
	proto.RegisterType((*FSFightEndNtf)(nil), "pbserver.FSFightEndNtf")
	proto.RegisterType((*FSEnterFightReq)(nil), "pbserver.FSEnterFightReq")
	proto.RegisterType((*FSEnterFightAck)(nil), "pbserver.FSEnterFightAck")
	proto.RegisterType((*FSUpdateUserInfoNtf)(nil), "pbserver.FSUpdateUserInfoNtf")
	proto.RegisterType((*FSUpdateUserInfoAck)(nil), "pbserver.FSUpdateUserInfoAck")
	proto.RegisterType((*GsToFsUpdateUserElfReq)(nil), "pbserver.GsToFsUpdateUserElfReq")
	proto.RegisterType((*FsToGsUpdateUserElfAck)(nil), "pbserver.FsToGsUpdateUserElfAck")
	proto.RegisterType((*FSLeaveFightReq)(nil), "pbserver.FSLeaveFightReq")
	proto.RegisterType((*FSLeaveFightAck)(nil), "pbserver.FSLeaveFightAck")
	proto.RegisterType((*GSToFsUpdateUserFightModel)(nil), "pbserver.GSToFsUpdateUserFightModel")
	proto.RegisterType((*GsToFSUserReliveReq)(nil), "pbserver.GsToFSUserReliveReq")
	proto.RegisterType((*FSToGsUserReliveAck)(nil), "pbserver.FSToGsUserReliveAck")
	proto.RegisterType((*GsToFSCheckUserReliveReq)(nil), "pbserver.GsToFSCheckUserReliveReq")
	proto.RegisterType((*FsToGSCheckUserReliveAck)(nil), "pbserver.FsToGSCheckUserReliveAck")
	proto.RegisterType((*FSGetFightIdReq)(nil), "pbserver.FSGetFightIdReq")
	proto.RegisterType((*FSGetFightIdAck)(nil), "pbserver.FSGetFightIdAck")
	proto.RegisterType((*User)(nil), "pbserver.User")
	proto.RegisterType((*UserDropReq)(nil), "pbserver.UserDropReq")
	proto.RegisterType((*UserDropAck)(nil), "pbserver.UserDropAck")
	proto.RegisterType((*FSAddItemReq)(nil), "pbserver.FSAddItemReq")
	proto.RegisterType((*FSAddItemAck)(nil), "pbserver.FSAddItemAck")
	proto.RegisterType((*GsTOFsPickUpReq)(nil), "pbserver.GsTOFsPickUpReq")
	proto.RegisterType((*FsTOGsPickUpAck)(nil), "pbserver.FsTOGsPickUpAck")
	proto.RegisterType((*GsToFsPickRedPacketInfo)(nil), "pbserver.GsToFsPickRedPacketInfo")
	proto.RegisterType((*FsSkillUseNtf)(nil), "pbserver.FsSkillUseNtf")
	proto.RegisterType((*FsToGsActorKillNtf)(nil), "pbserver.FsToGsActorKillNtf")
	proto.RegisterType((*FsTOGsClearSkillCdNtf)(nil), "pbserver.FsTOGsClearSkillCdNtf")
	proto.RegisterType((*FsRandomDeliveryNtf)(nil), "pbserver.FsRandomDeliveryNtf")
	proto.RegisterType((*GsToFsUseItemNtf)(nil), "pbserver.GsToFsUseItemNtf")
	proto.RegisterType((*GSTOFSCheckFightReq)(nil), "pbserver.GSTOFSCheckFightReq")
	proto.RegisterType((*FSTOGSCheckFightAck)(nil), "pbserver.FSTOGSCheckFightAck")
	proto.RegisterType((*GSTOFSGetFightIdReq)(nil), "pbserver.GSTOFSGetFightIdReq")
	proto.RegisterType((*FSTOGSGetFightIdAck)(nil), "pbserver.FSTOGSGetFightIdAck")
	proto.RegisterType((*GsToFsGetCheerNumReq)(nil), "pbserver.GsToFsGetCheerNumReq")
	proto.RegisterType((*FsToGsGetCheerNumAck)(nil), "pbserver.FsToGsGetCheerNumAck")
	proto.RegisterType((*GsToFsCheerReq)(nil), "pbserver.GsToFsCheerReq")
	proto.RegisterType((*FsToGsCheerAck)(nil), "pbserver.FsToGsCheerAck")
	proto.RegisterType((*GsToFsGetPotionCdReq)(nil), "pbserver.GsToFsGetPotionCdReq")
	proto.RegisterType((*FsToGsGetPotionCdAck)(nil), "pbserver.FsToGsGetPotionCdAck")
	proto.RegisterType((*GsToFsUsePotionReq)(nil), "pbserver.GsToFsUsePotionReq")
	proto.RegisterType((*FsToGsUsePotionAck)(nil), "pbserver.FsToGsUsePotionAck")
	proto.RegisterType((*GsToFsCollectionReq)(nil), "pbserver.GsToFsCollectionReq")
	proto.RegisterType((*FsToGsCollectionAck)(nil), "pbserver.FsToGsCollectionAck")
	proto.RegisterType((*GsToFsCollectionCancelReq)(nil), "pbserver.GsToFsCollectionCancelReq")
	proto.RegisterType((*FsToGsCollectionCancelAck)(nil), "pbserver.FsToGsCollectionCancelAck")
	proto.RegisterType((*FsToGsCollectionNtf)(nil), "pbserver.FsToGsCollectionNtf")
	proto.RegisterType((*GsToFsUseFitReq)(nil), "pbserver.GsToFsUseFitReq")
	proto.RegisterType((*FsToGsUseFitAck)(nil), "pbserver.FsToGsUseFitAck")
	proto.RegisterType((*GsToFsFitCacelReq)(nil), "pbserver.GsToFsFitCacelReq")
	proto.RegisterType((*FsToGsFitCacelAck)(nil), "pbserver.FsToGsFitCacelAck")
	proto.RegisterType((*GsToFsUpdatePetReq)(nil), "pbserver.GsToFsUpdatePetReq")
	proto.RegisterType((*FsToGsUpdatePetAck)(nil), "pbserver.FsToGsUpdatePetAck")
	proto.RegisterType((*GsToFsGmReq)(nil), "pbserver.GsToFsGmReq")
	proto.RegisterType((*FsToGsGmAck)(nil), "pbserver.FsToGsGmAck")
	proto.RegisterType((*GsToFsUseCutTreasureReq)(nil), "pbserver.GsToFsUseCutTreasureReq")
	proto.RegisterType((*FsToGsUseCutTreasureAck)(nil), "pbserver.FsToGsUseCutTreasureAck")
	proto.RegisterType((*GsToFsCheckForHelpReq)(nil), "pbserver.GsToFsCheckForHelpReq")
	proto.RegisterType((*FsToGsCheckForHelpResultAck)(nil), "pbserver.FsToGsCheckForHelpResultAck")
	proto.RegisterType((*GsToFsChangeToHelperReq)(nil), "pbserver.GsToFsChangeToHelperReq")
	proto.RegisterType((*GsToFsFightNumChangeReq)(nil), "pbserver.GsToFsFightNumChangeReq")
	proto.RegisterType((*GsToFsFightNpcEventReq)(nil), "pbserver.GsToFsFightNpcEventReq")
	proto.RegisterType((*FsToGsFightNpcEventAck)(nil), "pbserver.FsToGsFightNpcEventAck")
	proto.RegisterType((*GsToFsGamedbReloadReq)(nil), "pbserver.GsToFsGamedbReloadReq")
	proto.RegisterType((*GsToFsGamedbReloadAck)(nil), "pbserver.GsToFsGamedbReloadAck")
	proto.RegisterType((*WorldBossStatusNtf)(nil), "pbserver.WorldBossStatusNtf")
	proto.RegisterType((*ExpStageKillMonsterNtf)(nil), "pbserver.ExpStageKillMonsterNtf")
	proto.RegisterType((*PersonFightResult)(nil), "pbserver.PersonFightResult")
	proto.RegisterType((*VipBossFightResult)(nil), "pbserver.VipBossFightResult")
	proto.RegisterType((*TowerFightResult)(nil), "pbserver.TowerFightResult")
	proto.RegisterType((*FieldBossResult)(nil), "pbserver.FieldBossResult")
	proto.RegisterType((*DarkPalaceBossResult)(nil), "pbserver.DarkPalaceBossResult")
	proto.RegisterType((*AncientBossResult)(nil), "pbserver.AncientBossResult")
	proto.RegisterType((*HellBossResult)(nil), "pbserver.HellBossResult")
	proto.RegisterType((*DaBaoKillMonsterNtf)(nil), "pbserver.DaBaoKillMonsterNtf")
	proto.RegisterType((*DaBaoResumeEnergyReq)(nil), "pbserver.DaBaoResumeEnergyReq")
	proto.RegisterType((*MiningNewFightInfoReq)(nil), "pbserver.MiningNewFightInfoReq")
	proto.RegisterType((*MiningNewFightInfoAck)(nil), "pbserver.MiningNewFightInfoAck")
	proto.RegisterType((*MiningFightResultNtf)(nil), "pbserver.MiningFightResultNtf")
	proto.RegisterType((*HangUpKillWaveNtf)(nil), "pbserver.HangUpKillWaveNtf")
	proto.RegisterType((*HangUpBossFightEndNtf)(nil), "pbserver.HangUpBossFightEndNtf")
	proto.RegisterType((*FightTotalData)(nil), "pbserver.FightTotalData")
	proto.RegisterType((*GuildbonfireExpAddNtf)(nil), "pbserver.GuildbonfireExpAddNtf")
	proto.RegisterType((*PaodianGoodsAddNtf)(nil), "pbserver.PaodianGoodsAddNtf")
	proto.RegisterType((*ShabakeFightEndNtf)(nil), "pbserver.ShabakeFightEndNtf")
	proto.RegisterType((*ShabakeRankScore)(nil), "pbserver.ShabakeRankScore")
	proto.RegisterType((*ShabakeCrossFightEndNtf)(nil), "pbserver.ShabakeCrossFightEndNtf")
	proto.RegisterType((*ShabakeCrossRankScore)(nil), "pbserver.ShabakeCrossRankScore")
	proto.RegisterType((*WorldLeaderFightEndNtf)(nil), "pbserver.WorldLeaderFightEndNtf")
	proto.RegisterType((*WorldLeaderFightRankNtf)(nil), "pbserver.WorldLeaderFightRankNtf")
	proto.RegisterType((*WorldLeaderRankUnit)(nil), "pbserver.WorldLeaderRankUnit")
	proto.RegisterType((*GuardPillarFightEnd)(nil), "pbserver.GuardPillarFightEnd")
	proto.RegisterType((*FsFieldBossDieUserInfoNtf)(nil), "pbserver.FsFieldBossDieUserInfoNtf")
	proto.RegisterType((*MagicTowerFightEnd)(nil), "pbserver.MagicTowerFightEnd")
	proto.RegisterType((*GsToFsFightScoreLessReq)(nil), "pbserver.GsToFsFightScoreLessReq")
	proto.RegisterType((*FsToGsFightScoreLessAck)(nil), "pbserver.FsToGsFightScoreLessAck")
	proto.RegisterType((*MagicTowerGetUserInfoReq)(nil), "pbserver.MagicTowerGetUserInfoReq")
	proto.RegisterType((*MagicTowerGetUserInfoAck)(nil), "pbserver.MagicTowerGetUserInfoAck")
	proto.RegisterType((*FsToGsShabakeKillBossNtf)(nil), "pbserver.FsToGsShabakeKillBossNtf")
	proto.RegisterType((*BossFamilyBossInfoReq)(nil), "pbserver.BossFamilyBossInfoReq")
	proto.RegisterType((*BossFamilyBossInfoAck)(nil), "pbserver.BossFamilyBossInfoAck")
	proto.RegisterEnum("pbserver.FSFightType", FSFightType_name, FSFightType_value)
}
func (m *GsRouteMessageToFight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsRouteMessageToFight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	if m.CmdId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CmdId))
	}
	if len(m.MsgData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.MsgData)))
		i += copy(dAtA[i:], m.MsgData)
	}
	return i, nil
}

func (m *FSCreateFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSCreateFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.CpData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.CpData)))
		i += copy(dAtA[i:], m.CpData)
	}
	return i, nil
}

func (m *FSCreateFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSCreateFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *GsToFsResidentFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsResidentFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ServerId))
	}
	return i, nil
}

func (m *FsResidentFightNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsResidentFightNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResidentFights) > 0 {
		for k, _ := range m.ResidentFights {
			dAtA[i] = 0xa
			i++
			v := m.ResidentFights[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if len(m.FieldBossFightInfo) > 0 {
		for k, _ := range m.FieldBossFightInfo {
			dAtA[i] = 0x12
			i++
			v := m.FieldBossFightInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *FsFieldBossInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsFieldBossInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Hp != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Hp))))
		i += 4
	}
	if m.ReliveTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTime))
	}
	if m.UserCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserCount))
	}
	return i, nil
}

func (m *FSContinueFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSContinueFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *FSFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.Winners) > 0 {
		dAtA3 := make([]byte, len(m.Winners)*10)
		var j2 int
		for _, num1 := range m.Winners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Losers) > 0 {
		dAtA5 := make([]byte, len(m.Losers)*10)
		var j4 int
		for _, num1 := range m.Losers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	if len(m.CpData) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.CpData)))
		i += copy(dAtA[i:], m.CpData)
	}
	return i, nil
}

func (m *FSEnterFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSEnterFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightUser.Size()))
		n6, err := m.FightUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.EnterType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.EnterType))
	}
	return i, nil
}

func (m *FSEnterFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSEnterFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Refuse {
		dAtA[i] = 0x8
		i++
		if m.Refuse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FSUpdateUserInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSUpdateUserInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserInfo.Size()))
		n7, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *FSUpdateUserInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSUpdateUserInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Refuse {
		dAtA[i] = 0x8
		i++
		if m.Refuse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsUpdateUserElfReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUpdateUserElfReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Elf != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Elf.Size()))
		n8, err := m.Elf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *FsToGsUpdateUserElfAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUpdateUserElfAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FSLeaveFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSLeaveFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActorSessionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ActorSessionId))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *FSLeaveFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSLeaveFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GSToFsUpdateUserFightModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSToFsUpdateUserFightModel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.FigthModel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FigthModel))
	}
	return i, nil
}

func (m *GsToFSUserReliveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFSUserReliveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ReliveType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveType))
	}
	return i, nil
}

func (m *FSToGsUserReliveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSToGsUserReliveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveByIngotTimes))
	}
	return i, nil
}

func (m *GsToFSCheckUserReliveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFSCheckUserReliveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGSCheckUserReliveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGSCheckUserReliveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsDie {
		dAtA[i] = 0x8
		i++
		if m.IsDie {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReliveTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ReliveByIngotTimes))
	}
	return i, nil
}

func (m *FSGetFightIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSGetFightIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	return i, nil
}

func (m *FSGetFightIdAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSGetFightIdAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.SessionId))
	}
	if m.LocatedServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.LocatedServerId))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserInfo.Size()))
		n9, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.TeamId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.TeamId))
	}
	if m.FightModel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightModel))
	}
	if m.BirthArea != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BirthArea))
	}
	if m.UserType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserType))
	}
	if m.ToHelpUserId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ToHelpUserId))
	}
	return i, nil
}

func (m *UserDropReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDropReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightType))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *UserDropAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDropAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FSAddItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSAddItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.OpType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.OpType))
	}
	return i, nil
}

func (m *FSAddItemAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSAddItemAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSuccess {
		dAtA[i] = 0x8
		i++
		if m.IsSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsTOFsPickUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsTOFsPickUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseId))
	}
	if len(m.ObjIds) > 0 {
		dAtA11 := make([]byte, len(m.ObjIds)*10)
		var j10 int
		for _, num1 := range m.ObjIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.IsPick {
		dAtA[i] = 0x18
		i++
		if m.IsPick {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FsTOGsPickUpAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsTOGsPickUpAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0xa
			i++
			v := m.Items[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	if m.IsPick {
		dAtA[i] = 0x10
		i++
		if m.IsPick {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsPickRedPacketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsPickRedPacketInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.RedPacket != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.RedPacket.Size()))
		n13, err := m.RedPacket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *FsSkillUseNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsSkillUseNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseId))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.HeroIndex))
	}
	if m.SkillId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.SkillId))
	}
	if m.CdStartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CdStartTime))
	}
	if m.CdStopTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CdStopTime))
	}
	if len(m.KillMonsterIds) > 0 {
		dAtA15 := make([]byte, len(m.KillMonsterIds)*10)
		var j14 int
		for _, num1 := range m.KillMonsterIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.KillUserNum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.KillUserNum))
	}
	return i, nil
}

func (m *FsToGsActorKillNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsActorKillNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Killer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Killer))
	}
	if m.BeKiller != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BeKiller))
	}
	if m.IsPlayer {
		dAtA[i] = 0x18
		i++
		if m.IsPlayer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FsTOGsClearSkillCdNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsTOGsClearSkillCdNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.HeroIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.HeroIndex))
	}
	return i, nil
}

func (m *FsRandomDeliveryNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsRandomDeliveryNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Rand {
		dAtA[i] = 0x10
		i++
		if m.Rand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsUseItemNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUseItemNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *GSTOFSCheckFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSTOFSCheckFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *FSTOGSCheckFightAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSTOGSCheckFightAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *GSTOFSGetFightIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GSTOFSGetFightIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Ext != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Ext))
	}
	return i, nil
}

func (m *FSTOGSGetFightIdAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSTOGSGetFightIdAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightId))
	}
	return i, nil
}

func (m *GsToFsGetCheerNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGetCheerNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsGetCheerNumAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsGetCheerNumAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.CheerNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CheerNum))
	}
	if m.GuildCheerNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.GuildCheerNum))
	}
	return i, nil
}

func (m *GsToFsCheerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCheerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsCheerAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCheerAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsGetPotionCdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGetPotionCdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsGetPotionCdAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsGetPotionCdAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	return i, nil
}

func (m *GsToFsUsePotionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUsePotionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsUsePotionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUsePotionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UseTime))
	}
	return i, nil
}

func (m *GsToFsCollectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCollectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *FsToGsCollectionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCollectionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *GsToFsCollectionCancelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCollectionCancelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ObjId))
	}
	return i, nil
}

func (m *FsToGsCollectionCancelAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCollectionCancelAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FsToGsCollectionNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCollectionNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageType))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x1a
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *GsToFsUseFitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUseFitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Fit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Fit.Size()))
		n16, err := m.Fit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *FsToGsUseFitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUseFitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSuccess {
		dAtA[i] = 0x8
		i++
		if m.IsSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsFitCacelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsFitCacelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsFitCacelAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsFitCacelAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GsToFsUpdatePetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUpdatePetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Pet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Pet.Size()))
		n17, err := m.Pet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *FsToGsUpdatePetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUpdatePetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GsToFsGmReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGmReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Cmd) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	return i, nil
}

func (m *FsToGsGmAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsGmAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	return i, nil
}

func (m *GsToFsUseCutTreasureReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsUseCutTreasureReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.CutTreasureLv != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.CutTreasureLv))
	}
	return i, nil
}

func (m *FsToGsUseCutTreasureAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsUseCutTreasureAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsCheckForHelpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsCheckForHelpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *FsToGsCheckForHelpResultAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsCheckForHelpResultAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CanGetHelp {
		dAtA[i] = 0x8
		i++
		if m.CanGetHelp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GsToFsChangeToHelperReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsChangeToHelperReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.ToHelpUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ToHelpUserId))
	}
	return i, nil
}

func (m *GsToFsFightNumChangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsFightNumChangeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.FightNumChange != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.FightNumChange))
	}
	return i, nil
}

func (m *GsToFsFightNpcEventReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsFightNpcEventReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.NpcId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.NpcId))
	}
	return i, nil
}

func (m *FsToGsFightNpcEventAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsFightNpcEventAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GsToFsGamedbReloadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGamedbReloadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GsToFsGamedbReloadAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsGamedbReloadAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WorldBossStatusNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldBossStatusNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *ExpStageKillMonsterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpStageKillMonsterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *PersonFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersonFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *VipBossFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipBossFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *TowerFightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerFightResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x12
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *FieldBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	return i, nil
}

func (m *DarkPalaceBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DarkPalaceBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	if len(m.Helper) > 0 {
		for k, _ := range m.Helper {
			dAtA[i] = 0x1a
			i++
			v := m.Helper[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *AncientBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AncientBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n20, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n20
			}
		}
	}
	return i, nil
}

func (m *HellBossResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HellBossResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendWinner {
		dAtA[i] = 0x8
		i++
		if m.SendWinner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UserPickItems) > 0 {
		for k, _ := range m.UserPickItems {
			dAtA[i] = 0x12
			i++
			v := m.UserPickItems[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFsServer(uint64(msgSize))
			}
			mapSize := 1 + sovFsServer(uint64(k)) + msgSize
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintFsServer(dAtA, i, uint64(v.Size()))
				n21, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	if len(m.Helper) > 0 {
		for k, _ := range m.Helper {
			dAtA[i] = 0x1a
			i++
			v := m.Helper[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DaBaoKillMonsterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaBaoKillMonsterNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.MonsterId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MonsterId))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Energy))
	}
	return i, nil
}

func (m *DaBaoResumeEnergyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaBaoResumeEnergyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Energy))
	}
	return i, nil
}

func (m *MiningNewFightInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningNewFightInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MiningId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningUserId))
	}
	if m.IsRetake {
		dAtA[i] = 0x18
		i++
		if m.IsRetake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningNewFightInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningNewFightInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadyOk {
		dAtA[i] = 0x8
		i++
		if m.ReadyOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MiningFightResultNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningFightResultNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.MiningId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.MiningUserId))
	}
	if m.IsRetake {
		dAtA[i] = 0x20
		i++
		if m.IsRetake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Result != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *HangUpKillWaveNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HangUpKillWaveNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	return i, nil
}

func (m *HangUpBossFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HangUpBossFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.StageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Result))
	}
	if len(m.Items) > 0 {
		for k, _ := range m.Items {
			dAtA[i] = 0x22
			i++
			v := m.Items[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *FightTotalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightTotalData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Damage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Damage))
	}
	if m.BeDamage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BeDamage))
	}
	if m.Treat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Treat))
	}
	return i, nil
}

func (m *GuildbonfireExpAddNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildbonfireExpAddNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuildId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.GuildId))
	}
	if len(m.UserIds) > 0 {
		dAtA23 := make([]byte, len(m.UserIds)*10)
		var j22 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	return i, nil
}

func (m *PaodianGoodsAddNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaodianGoodsAddNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if len(m.UserIds) > 0 {
		for k, _ := range m.UserIds {
			dAtA[i] = 0x12
			i++
			v := m.UserIds[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ShabakeFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, msg := range m.UserRank {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildRank) > 0 {
		for _, msg := range m.GuildRank {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeRankScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeRankScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Id))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ShabakeCrossFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeCrossFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerRank) > 0 {
		for _, msg := range m.ServerRank {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildRank) > 0 {
		for _, msg := range m.GuildRank {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShabakeCrossRankScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShabakeCrossRankScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ServerId))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.GuildId))
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	if len(m.Users) > 0 {
		dAtA25 := make([]byte, len(m.Users)*10)
		var j24 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	return i, nil
}

func (m *WorldLeaderFightEndNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldLeaderFightEndNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.LastAttacker != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.LastAttacker))
	}
	if len(m.Ranks) > 0 {
		for _, msg := range m.Ranks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WorldLeaderFightRankNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldLeaderFightRankNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.StageId))
	}
	if m.BossHp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BossHp))
	}
	if len(m.Ranks) > 0 {
		for _, msg := range m.Ranks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WorldLeaderRankUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorldLeaderRankUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Rank))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.Score != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.ServerId))
	}
	if len(m.Users) > 0 {
		dAtA27 := make([]byte, len(m.Users)*10)
		var j26 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	return i, nil
}

func (m *GuardPillarFightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuardPillarFightEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Wave != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Wave))
	}
	if len(m.Users) > 0 {
		dAtA29 := make([]byte, len(m.Users)*10)
		var j28 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	return i, nil
}

func (m *FsFieldBossDieUserInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsFieldBossDieUserInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DieUserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.DieUserId))
	}
	if m.DieTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.DieTime))
	}
	return i, nil
}

func (m *MagicTowerFightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MagicTowerFightEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, msg := range m.UserRank {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GsToFsFightScoreLessReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GsToFsFightScoreLessReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.LessNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.LessNum))
	}
	return i, nil
}

func (m *FsToGsFightScoreLessAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsFightScoreLessAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *MagicTowerGetUserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MagicTowerGetUserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.UserId))
	}
	if m.IsGetAward {
		dAtA[i] = 0x10
		i++
		if m.IsGetAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MagicTowerGetUserInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MagicTowerGetUserInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.Score))
	}
	if m.IsGetAward {
		dAtA[i] = 0x10
		i++
		if m.IsGetAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanGetAward {
		dAtA[i] = 0x18
		i++
		if m.CanGetAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FsToGsShabakeKillBossNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsToGsShabakeKillBossNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(len(m.Infos)))
		i += copy(dAtA[i:], m.Infos)
	}
	return i, nil
}

func (m *BossFamilyBossInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossFamilyBossInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BossFamilyType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFsServer(dAtA, i, uint64(m.BossFamilyType))
	}
	return i, nil
}

func (m *BossFamilyBossInfoAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossFamilyBossInfoAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BossFamilyInfo) > 0 {
		for k, _ := range m.BossFamilyInfo {
			dAtA[i] = 0xa
			i++
			v := m.BossFamilyInfo[k]
			mapSize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			i = encodeVarintFsServer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintFsServer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeVarintFsServer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GsRouteMessageToFight) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	if m.CmdId != 0 {
		n += 1 + sovFsServer(uint64(m.CmdId))
	}
	l = len(m.MsgData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSCreateFightReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	l = len(m.CpData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSCreateFightAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *GsToFsResidentFightReq) Size() (n int) {
	var l int
	_ = l
	if m.ServerId != 0 {
		n += 1 + sovFsServer(uint64(m.ServerId))
	}
	return n
}

func (m *FsResidentFightNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ResidentFights) > 0 {
		for k, v := range m.ResidentFights {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if len(m.FieldBossFightInfo) > 0 {
		for k, v := range m.FieldBossFightInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FsFieldBossInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Hp != 0 {
		n += 5
	}
	if m.ReliveTime != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTime))
	}
	if m.UserCount != 0 {
		n += 1 + sovFsServer(uint64(m.UserCount))
	}
	return n
}

func (m *FSContinueFightReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	return n
}

func (m *FSFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if len(m.Winners) > 0 {
		l = 0
		for _, e := range m.Winners {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if len(m.Losers) > 0 {
		l = 0
		for _, e := range m.Losers {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	l = len(m.CpData)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSEnterFightReq) Size() (n int) {
	var l int
	_ = l
	if m.FightUser != nil {
		l = m.FightUser.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	if m.EnterType != 0 {
		n += 1 + sovFsServer(uint64(m.EnterType))
	}
	return n
}

func (m *FSEnterFightAck) Size() (n int) {
	var l int
	_ = l
	if m.Refuse {
		n += 2
	}
	return n
}

func (m *FSUpdateUserInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FSUpdateUserInfoAck) Size() (n int) {
	var l int
	_ = l
	if m.Refuse {
		n += 2
	}
	return n
}

func (m *GsToFsUpdateUserElfReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Elf != nil {
		l = m.Elf.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsUpdateUserElfAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *FSLeaveFightReq) Size() (n int) {
	var l int
	_ = l
	if m.ActorSessionId != 0 {
		n += 1 + sovFsServer(uint64(m.ActorSessionId))
	}
	if m.Reason != 0 {
		n += 1 + sovFsServer(uint64(m.Reason))
	}
	return n
}

func (m *FSLeaveFightAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GSToFsUpdateUserFightModel) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.FigthModel != 0 {
		n += 1 + sovFsServer(uint64(m.FigthModel))
	}
	return n
}

func (m *GsToFSUserReliveReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ReliveType != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveType))
	}
	return n
}

func (m *FSToGsUserReliveAck) Size() (n int) {
	var l int
	_ = l
	if m.ReliveTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveByIngotTimes))
	}
	return n
}

func (m *GsToFSCheckUserReliveReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGSCheckUserReliveAck) Size() (n int) {
	var l int
	_ = l
	if m.IsDie {
		n += 2
	}
	if m.ReliveTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveTimes))
	}
	if m.ReliveByIngotTimes != 0 {
		n += 1 + sovFsServer(uint64(m.ReliveByIngotTimes))
	}
	return n
}

func (m *FSGetFightIdReq) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	return n
}

func (m *FSGetFightIdAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.SessionId != 0 {
		n += 1 + sovFsServer(uint64(m.SessionId))
	}
	if m.LocatedServerId != 0 {
		n += 1 + sovFsServer(uint64(m.LocatedServerId))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	if m.TeamId != 0 {
		n += 1 + sovFsServer(uint64(m.TeamId))
	}
	if m.FightModel != 0 {
		n += 1 + sovFsServer(uint64(m.FightModel))
	}
	if m.BirthArea != 0 {
		n += 1 + sovFsServer(uint64(m.BirthArea))
	}
	if m.UserType != 0 {
		n += 1 + sovFsServer(uint64(m.UserType))
	}
	if m.ToHelpUserId != 0 {
		n += 1 + sovFsServer(uint64(m.ToHelpUserId))
	}
	return n
}

func (m *UserDropReq) Size() (n int) {
	var l int
	_ = l
	if m.FightType != 0 {
		n += 1 + sovFsServer(uint64(m.FightType))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *UserDropAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *FSAddItemReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.OpType != 0 {
		n += 1 + sovFsServer(uint64(m.OpType))
	}
	return n
}

func (m *FSAddItemAck) Size() (n int) {
	var l int
	_ = l
	if m.IsSuccess {
		n += 2
	}
	return n
}

func (m *GsTOFsPickUpReq) Size() (n int) {
	var l int
	_ = l
	if m.UseId != 0 {
		n += 1 + sovFsServer(uint64(m.UseId))
	}
	if len(m.ObjIds) > 0 {
		l = 0
		for _, e := range m.ObjIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if m.IsPick {
		n += 2
	}
	return n
}

func (m *FsTOGsPickUpAck) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.IsPick {
		n += 2
	}
	return n
}

func (m *GsToFsPickRedPacketInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.RedPacket != nil {
		l = m.RedPacket.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsSkillUseNtf) Size() (n int) {
	var l int
	_ = l
	if m.UseId != 0 {
		n += 1 + sovFsServer(uint64(m.UseId))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovFsServer(uint64(m.HeroIndex))
	}
	if m.SkillId != 0 {
		n += 1 + sovFsServer(uint64(m.SkillId))
	}
	if m.CdStartTime != 0 {
		n += 1 + sovFsServer(uint64(m.CdStartTime))
	}
	if m.CdStopTime != 0 {
		n += 1 + sovFsServer(uint64(m.CdStopTime))
	}
	if len(m.KillMonsterIds) > 0 {
		l = 0
		for _, e := range m.KillMonsterIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	if m.KillUserNum != 0 {
		n += 1 + sovFsServer(uint64(m.KillUserNum))
	}
	return n
}

func (m *FsToGsActorKillNtf) Size() (n int) {
	var l int
	_ = l
	if m.Killer != 0 {
		n += 1 + sovFsServer(uint64(m.Killer))
	}
	if m.BeKiller != 0 {
		n += 1 + sovFsServer(uint64(m.BeKiller))
	}
	if m.IsPlayer {
		n += 2
	}
	return n
}

func (m *FsTOGsClearSkillCdNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.HeroIndex != 0 {
		n += 1 + sovFsServer(uint64(m.HeroIndex))
	}
	return n
}

func (m *FsRandomDeliveryNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Rand {
		n += 2
	}
	return n
}

func (m *GsToFsUseItemNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ItemId != 0 {
		n += 1 + sovFsServer(uint64(m.ItemId))
	}
	return n
}

func (m *GSTOFSCheckFightReq) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *FSTOGSCheckFightAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *GSTOFSGetFightIdReq) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Ext != 0 {
		n += 1 + sovFsServer(uint64(m.Ext))
	}
	return n
}

func (m *FSTOGSGetFightIdAck) Size() (n int) {
	var l int
	_ = l
	if m.FightId != 0 {
		n += 1 + sovFsServer(uint64(m.FightId))
	}
	return n
}

func (m *GsToFsGetCheerNumReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsGetCheerNumAck) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.CheerNum != 0 {
		n += 1 + sovFsServer(uint64(m.CheerNum))
	}
	if m.GuildCheerNum != 0 {
		n += 1 + sovFsServer(uint64(m.GuildCheerNum))
	}
	return n
}

func (m *GsToFsCheerReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsCheerAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GsToFsGetPotionCdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsGetPotionCdAck) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	return n
}

func (m *GsToFsUsePotionReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsUsePotionAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.UseTime != 0 {
		n += 1 + sovFsServer(uint64(m.UseTime))
	}
	return n
}

func (m *GsToFsCollectionReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ObjId != 0 {
		n += 1 + sovFsServer(uint64(m.ObjId))
	}
	return n
}

func (m *FsToGsCollectionAck) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovFsServer(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFsServer(uint64(m.EndTime))
	}
	return n
}

func (m *GsToFsCollectionCancelReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ObjId != 0 {
		n += 1 + sovFsServer(uint64(m.ObjId))
	}
	return n
}

func (m *FsToGsCollectionCancelAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *FsToGsCollectionNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageType != 0 {
		n += 1 + sovFsServer(uint64(m.StageType))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GsToFsUseFitReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Fit != nil {
		l = m.Fit.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsUseFitAck) Size() (n int) {
	var l int
	_ = l
	if m.IsSuccess {
		n += 2
	}
	return n
}

func (m *GsToFsFitCacelReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsFitCacelAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GsToFsUpdatePetReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Pet != nil {
		l = m.Pet.Size()
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsUpdatePetAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GsToFsGmReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *FsToGsGmAck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *GsToFsUseCutTreasureReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.CutTreasureLv != 0 {
		n += 1 + sovFsServer(uint64(m.CutTreasureLv))
	}
	return n
}

func (m *FsToGsUseCutTreasureAck) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GsToFsCheckForHelpReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *FsToGsCheckForHelpResultAck) Size() (n int) {
	var l int
	_ = l
	if m.CanGetHelp {
		n += 2
	}
	return n
}

func (m *GsToFsChangeToHelperReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.ToHelpUserId != 0 {
		n += 1 + sovFsServer(uint64(m.ToHelpUserId))
	}
	return n
}

func (m *GsToFsFightNumChangeReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.FightNumChange != 0 {
		n += 1 + sovFsServer(uint64(m.FightNumChange))
	}
	return n
}

func (m *GsToFsFightNpcEventReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.NpcId != 0 {
		n += 1 + sovFsServer(uint64(m.NpcId))
	}
	return n
}

func (m *FsToGsFightNpcEventAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GsToFsGamedbReloadReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GsToFsGamedbReloadAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WorldBossStatusNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Status != 0 {
		n += 1 + sovFsServer(uint64(m.Status))
	}
	return n
}

func (m *ExpStageKillMonsterNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	return n
}

func (m *PersonFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *VipBossFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *TowerFightResult) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *FieldBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DarkPalaceBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if len(m.Helper) > 0 {
		for k, v := range m.Helper {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AncientBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HellBossResult) Size() (n int) {
	var l int
	_ = l
	if m.SendWinner {
		n += 2
	}
	if len(m.UserPickItems) > 0 {
		for k, v := range m.UserPickItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFsServer(uint64(l))
			}
			mapEntrySize := 1 + sovFsServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	if len(m.Helper) > 0 {
		for k, v := range m.Helper {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DaBaoKillMonsterNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.MonsterId != 0 {
		n += 1 + sovFsServer(uint64(m.MonsterId))
	}
	if m.Energy != 0 {
		n += 1 + sovFsServer(uint64(m.Energy))
	}
	return n
}

func (m *DaBaoResumeEnergyReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Energy != 0 {
		n += 1 + sovFsServer(uint64(m.Energy))
	}
	return n
}

func (m *MiningNewFightInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.MiningId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningUserId))
	}
	if m.IsRetake {
		n += 2
	}
	return n
}

func (m *MiningNewFightInfoAck) Size() (n int) {
	var l int
	_ = l
	if m.ReadyOk {
		n += 2
	}
	return n
}

func (m *MiningFightResultNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.MiningId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningId))
	}
	if m.MiningUserId != 0 {
		n += 1 + sovFsServer(uint64(m.MiningUserId))
	}
	if m.IsRetake {
		n += 2
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	return n
}

func (m *HangUpKillWaveNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	return n
}

func (m *HangUpBossFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.Result != 0 {
		n += 1 + sovFsServer(uint64(m.Result))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FightTotalData) Size() (n int) {
	var l int
	_ = l
	if m.Damage != 0 {
		n += 1 + sovFsServer(uint64(m.Damage))
	}
	if m.BeDamage != 0 {
		n += 1 + sovFsServer(uint64(m.BeDamage))
	}
	if m.Treat != 0 {
		n += 1 + sovFsServer(uint64(m.Treat))
	}
	return n
}

func (m *GuildbonfireExpAddNtf) Size() (n int) {
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovFsServer(uint64(m.GuildId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *PaodianGoodsAddNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if len(m.UserIds) > 0 {
		for k, v := range m.UserIds {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ShabakeFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, e := range m.UserRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	if len(m.GuildRank) > 0 {
		for _, e := range m.GuildRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *ShabakeRankScore) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFsServer(uint64(m.Id))
	}
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	return n
}

func (m *ShabakeCrossFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if len(m.ServerRank) > 0 {
		for _, e := range m.ServerRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	if len(m.GuildRank) > 0 {
		for _, e := range m.GuildRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *ShabakeCrossRankScore) Size() (n int) {
	var l int
	_ = l
	if m.ServerId != 0 {
		n += 1 + sovFsServer(uint64(m.ServerId))
	}
	if m.GuildId != 0 {
		n += 1 + sovFsServer(uint64(m.GuildId))
	}
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *WorldLeaderFightEndNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.LastAttacker != 0 {
		n += 1 + sovFsServer(uint64(m.LastAttacker))
	}
	if len(m.Ranks) > 0 {
		for _, e := range m.Ranks {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *WorldLeaderFightRankNtf) Size() (n int) {
	var l int
	_ = l
	if m.StageId != 0 {
		n += 1 + sovFsServer(uint64(m.StageId))
	}
	if m.BossHp != 0 {
		n += 1 + sovFsServer(uint64(m.BossHp))
	}
	if len(m.Ranks) > 0 {
		for _, e := range m.Ranks {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *WorldLeaderRankUnit) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovFsServer(uint64(m.Rank))
	}
	if m.GuildId != 0 {
		n += 1 + sovFsServer(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	if m.ServerId != 0 {
		n += 1 + sovFsServer(uint64(m.ServerId))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *GuardPillarFightEnd) Size() (n int) {
	var l int
	_ = l
	if m.Wave != 0 {
		n += 1 + sovFsServer(uint64(m.Wave))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovFsServer(uint64(e))
		}
		n += 1 + sovFsServer(uint64(l)) + l
	}
	return n
}

func (m *FsFieldBossDieUserInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.DieUserId != 0 {
		n += 1 + sovFsServer(uint64(m.DieUserId))
	}
	if m.DieTime != 0 {
		n += 1 + sovFsServer(uint64(m.DieTime))
	}
	return n
}

func (m *MagicTowerFightEnd) Size() (n int) {
	var l int
	_ = l
	if len(m.UserRank) > 0 {
		for _, e := range m.UserRank {
			l = e.Size()
			n += 1 + l + sovFsServer(uint64(l))
		}
	}
	return n
}

func (m *GsToFsFightScoreLessReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.LessNum != 0 {
		n += 1 + sovFsServer(uint64(m.LessNum))
	}
	return n
}

func (m *FsToGsFightScoreLessAck) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	return n
}

func (m *MagicTowerGetUserInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovFsServer(uint64(m.UserId))
	}
	if m.IsGetAward {
		n += 2
	}
	return n
}

func (m *MagicTowerGetUserInfoAck) Size() (n int) {
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovFsServer(uint64(m.Score))
	}
	if m.IsGetAward {
		n += 2
	}
	if m.CanGetAward {
		n += 2
	}
	return n
}

func (m *FsToGsShabakeKillBossNtf) Size() (n int) {
	var l int
	_ = l
	l = len(m.Infos)
	if l > 0 {
		n += 1 + l + sovFsServer(uint64(l))
	}
	return n
}

func (m *BossFamilyBossInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.BossFamilyType != 0 {
		n += 1 + sovFsServer(uint64(m.BossFamilyType))
	}
	return n
}

func (m *BossFamilyBossInfoAck) Size() (n int) {
	var l int
	_ = l
	if len(m.BossFamilyInfo) > 0 {
		for k, v := range m.BossFamilyInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsServer(uint64(k)) + 1 + sovFsServer(uint64(v))
			n += mapEntrySize + 1 + sovFsServer(uint64(mapEntrySize))
		}
	}
	return n
}

func sovFsServer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFsServer(x uint64) (n int) {
	return sovFsServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GsRouteMessageToFight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsRouteMessageToFight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsRouteMessageToFight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdId", wireType)
			}
			m.CmdId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgData = append(m.MsgData[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgData == nil {
				m.MsgData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSCreateFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSCreateFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSCreateFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpData = append(m.CpData[:0], dAtA[iNdEx:postIndex]...)
			if m.CpData == nil {
				m.CpData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSCreateFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSCreateFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSCreateFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsResidentFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsResidentFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsResidentFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsResidentFightNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsResidentFightNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsResidentFightNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentFights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResidentFights == nil {
				m.ResidentFights = make(map[int32]uint32)
			}
			var mapkey int32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResidentFights[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldBossFightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldBossFightInfo == nil {
				m.FieldBossFightInfo = make(map[int32]*FsFieldBossInfoNtf)
			}
			var mapkey int32
			var mapvalue *FsFieldBossInfoNtf
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FsFieldBossInfoNtf{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldBossFightInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsFieldBossInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsFieldBossInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsFieldBossInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Hp = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTime", wireType)
			}
			m.ReliveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCount", wireType)
			}
			m.UserCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSContinueFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSContinueFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSContinueFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners = append(m.Winners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winners = append(m.Winners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Losers = append(m.Losers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Losers = append(m.Losers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Losers", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpData = append(m.CpData[:0], dAtA[iNdEx:postIndex]...)
			if m.CpData == nil {
				m.CpData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSEnterFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSEnterFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSEnterFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FightUser == nil {
				m.FightUser = &User{}
			}
			if err := m.FightUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterType", wireType)
			}
			m.EnterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnterType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSEnterFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSEnterFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSEnterFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refuse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Refuse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSUpdateUserInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSUpdateUserInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSUpdateUserInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &Actor{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSUpdateUserInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSUpdateUserInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSUpdateUserInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refuse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Refuse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUpdateUserElfReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUpdateUserElfReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUpdateUserElfReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Elf == nil {
				m.Elf = &ElfInfo{}
			}
			if err := m.Elf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUpdateUserElfAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUpdateUserElfAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUpdateUserElfAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSLeaveFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSLeaveFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSLeaveFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorSessionId", wireType)
			}
			m.ActorSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActorSessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSLeaveFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSLeaveFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSLeaveFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSToFsUpdateUserFightModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSToFsUpdateUserFightModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSToFsUpdateUserFightModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FigthModel", wireType)
			}
			m.FigthModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FigthModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFSUserReliveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFSUserReliveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFSUserReliveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveType", wireType)
			}
			m.ReliveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSToGsUserReliveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSToGsUserReliveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSToGsUserReliveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTimes", wireType)
			}
			m.ReliveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveByIngotTimes", wireType)
			}
			m.ReliveByIngotTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveByIngotTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFSCheckUserReliveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFSCheckUserReliveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFSCheckUserReliveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGSCheckUserReliveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGSCheckUserReliveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGSCheckUserReliveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDie", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDie = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveTimes", wireType)
			}
			m.ReliveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveByIngotTimes", wireType)
			}
			m.ReliveByIngotTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveByIngotTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSGetFightIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSGetFightIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSGetFightIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (FSFightType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSGetFightIdAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSGetFightIdAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSGetFightIdAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocatedServerId", wireType)
			}
			m.LocatedServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocatedServerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &Actor{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightModel", wireType)
			}
			m.FightModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightModel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthArea", wireType)
			}
			m.BirthArea = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthArea |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserType", wireType)
			}
			m.UserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToHelpUserId", wireType)
			}
			m.ToHelpUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToHelpUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDropReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDropReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDropReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDropAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDropAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDropAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSAddItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSAddItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSAddItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSAddItemAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSAddItemAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSAddItemAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsTOFsPickUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsTOFsPickUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsTOFsPickUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseId", wireType)
			}
			m.UseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObjIds = append(m.ObjIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObjIds = append(m.ObjIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPick", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPick = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsTOGsPickUpAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsTOGsPickUpAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsTOGsPickUpAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]*ItemUnitForPickUp)
			}
			var mapkey int32
			var mapvalue *ItemUnitForPickUp
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnitForPickUp{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPick", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPick = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsPickRedPacketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsPickRedPacketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsPickRedPacketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPacket == nil {
				m.RedPacket = &ActorRedPacket{}
			}
			if err := m.RedPacket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsSkillUseNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsSkillUseNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsSkillUseNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseId", wireType)
			}
			m.UseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStartTime", wireType)
			}
			m.CdStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdStopTime", wireType)
			}
			m.CdStopTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdStopTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KillMonsterIds = append(m.KillMonsterIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KillMonsterIds = append(m.KillMonsterIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonsterIds", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillUserNum", wireType)
			}
			m.KillUserNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillUserNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsActorKillNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsActorKillNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsActorKillNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killer", wireType)
			}
			m.Killer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Killer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeKiller", wireType)
			}
			m.BeKiller = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeKiller |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPlayer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPlayer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsTOGsClearSkillCdNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsTOGsClearSkillCdNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsTOGsClearSkillCdNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsRandomDeliveryNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsRandomDeliveryNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsRandomDeliveryNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUseItemNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUseItemNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUseItemNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSTOFSCheckFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSTOFSCheckFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSTOFSCheckFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSTOGSCheckFightAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSTOGSCheckFightAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSTOGSCheckFightAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GSTOFSGetFightIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GSTOFSGetFightIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GSTOFSGetFightIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			m.Ext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ext |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSTOGSGetFightIdAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSTOGSGetFightIdAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSTOGSGetFightIdAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightId", wireType)
			}
			m.FightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGetCheerNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGetCheerNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGetCheerNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsGetCheerNumAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsGetCheerNumAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsGetCheerNumAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheerNum", wireType)
			}
			m.CheerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildCheerNum", wireType)
			}
			m.GuildCheerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildCheerNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCheerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCheerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCheerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCheerAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCheerAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCheerAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGetPotionCdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGetPotionCdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGetPotionCdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsGetPotionCdAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsGetPotionCdAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsGetPotionCdAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUsePotionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUsePotionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUsePotionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUsePotionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUsePotionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUsePotionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTime", wireType)
			}
			m.UseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCollectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCollectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCollectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCollectionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCollectionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCollectionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCollectionCancelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCollectionCancelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCollectionCancelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCollectionCancelAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCollectionCancelAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCollectionCancelAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCollectionNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCollectionNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCollectionNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageType", wireType)
			}
			m.StageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUseFitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUseFitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUseFitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fit == nil {
				m.Fit = &ActorFit{}
			}
			if err := m.Fit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUseFitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUseFitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUseFitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsFitCacelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsFitCacelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsFitCacelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsFitCacelAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsFitCacelAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsFitCacelAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUpdatePetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUpdatePetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUpdatePetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pet == nil {
				m.Pet = &ActorPet{}
			}
			if err := m.Pet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUpdatePetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUpdatePetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUpdatePetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGmReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGmReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGmReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsGmAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsGmAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsGmAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsUseCutTreasureReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsUseCutTreasureReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsUseCutTreasureReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutTreasureLv", wireType)
			}
			m.CutTreasureLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutTreasureLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsUseCutTreasureAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsUseCutTreasureAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsUseCutTreasureAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsCheckForHelpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsCheckForHelpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsCheckForHelpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsCheckForHelpResultAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsCheckForHelpResultAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsCheckForHelpResultAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGetHelp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanGetHelp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsChangeToHelperReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsChangeToHelperReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsChangeToHelperReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToHelpUserId", wireType)
			}
			m.ToHelpUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToHelpUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsFightNumChangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsFightNumChangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsFightNumChangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightNumChange", wireType)
			}
			m.FightNumChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightNumChange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsFightNpcEventReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsFightNpcEventReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsFightNpcEventReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcId", wireType)
			}
			m.NpcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsFightNpcEventAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsFightNpcEventAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsFightNpcEventAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGamedbReloadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGamedbReloadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGamedbReloadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsGamedbReloadAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsGamedbReloadAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsGamedbReloadAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldBossStatusNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldBossStatusNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldBossStatusNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpStageKillMonsterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpStageKillMonsterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpStageKillMonsterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipBossFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipBossFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipBossFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerFightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerFightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerFightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DarkPalaceBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DarkPalaceBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DarkPalaceBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Helper == nil {
				m.Helper = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Helper[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AncientBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AncientBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AncientBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HellBossResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HellBossResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HellBossResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWinner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendWinner = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPickItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPickItems == nil {
				m.UserPickItems = make(map[int32]*ItemUnits)
			}
			var mapkey int32
			var mapvalue *ItemUnits
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthFsServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemUnits{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPickItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Helper == nil {
				m.Helper = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Helper[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaBaoKillMonsterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaBaoKillMonsterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaBaoKillMonsterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			m.Energy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Energy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaBaoResumeEnergyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaBaoResumeEnergyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaBaoResumeEnergyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			m.Energy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Energy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningNewFightInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningNewFightInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningNewFightInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningId", wireType)
			}
			m.MiningId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningUserId", wireType)
			}
			m.MiningUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRetake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRetake = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningNewFightInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningNewFightInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningNewFightInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadyOk = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningFightResultNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningFightResultNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningFightResultNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningId", wireType)
			}
			m.MiningId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningUserId", wireType)
			}
			m.MiningUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiningUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRetake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRetake = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HangUpKillWaveNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HangUpKillWaveNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HangUpKillWaveNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HangUpBossFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HangUpBossFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HangUpBossFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightTotalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightTotalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightTotalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Damage", wireType)
			}
			m.Damage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Damage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamage", wireType)
			}
			m.BeDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeDamage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treat", wireType)
			}
			m.Treat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Treat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildbonfireExpAddNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildbonfireExpAddNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildbonfireExpAddNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaodianGoodsAddNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaodianGoodsAddNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaodianGoodsAddNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserIds == nil {
				m.UserIds = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRank = append(m.UserRank, &ShabakeRankScore{})
			if err := m.UserRank[len(m.UserRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildRank = append(m.GuildRank, &ShabakeRankScore{})
			if err := m.GuildRank[len(m.GuildRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeRankScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeRankScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeRankScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeCrossFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeCrossFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeCrossFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerRank = append(m.ServerRank, &ShabakeRankScore{})
			if err := m.ServerRank[len(m.ServerRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildRank = append(m.GuildRank, &ShabakeCrossRankScore{})
			if err := m.GuildRank[len(m.GuildRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShabakeCrossRankScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShabakeCrossRankScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShabakeCrossRankScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldLeaderFightEndNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldLeaderFightEndNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldLeaderFightEndNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAttacker", wireType)
			}
			m.LastAttacker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAttacker |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranks = append(m.Ranks, &WorldLeaderRankUnit{})
			if err := m.Ranks[len(m.Ranks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldLeaderFightRankNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldLeaderFightRankNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldLeaderFightRankNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageId", wireType)
			}
			m.StageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossHp", wireType)
			}
			m.BossHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossHp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranks = append(m.Ranks, &WorldLeaderRankUnit{})
			if err := m.Ranks[len(m.Ranks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorldLeaderRankUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorldLeaderRankUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorldLeaderRankUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuardPillarFightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuardPillarFightEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuardPillarFightEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wave", wireType)
			}
			m.Wave = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wave |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFsServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsFieldBossDieUserInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsFieldBossDieUserInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsFieldBossDieUserInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DieUserId", wireType)
			}
			m.DieUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DieUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DieTime", wireType)
			}
			m.DieTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DieTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MagicTowerFightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MagicTowerFightEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MagicTowerFightEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRank = append(m.UserRank, &ShabakeRankScore{})
			if err := m.UserRank[len(m.UserRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GsToFsFightScoreLessReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GsToFsFightScoreLessReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GsToFsFightScoreLessReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessNum", wireType)
			}
			m.LessNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LessNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsFightScoreLessAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsFightScoreLessAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsFightScoreLessAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MagicTowerGetUserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MagicTowerGetUserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MagicTowerGetUserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGetAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGetAward = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MagicTowerGetUserInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MagicTowerGetUserInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MagicTowerGetUserInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGetAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGetAward = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGetAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanGetAward = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsToGsShabakeKillBossNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsToGsShabakeKillBossNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsToGsShabakeKillBossNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossFamilyBossInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossFamilyBossInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossFamilyBossInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossFamilyType", wireType)
			}
			m.BossFamilyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossFamilyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossFamilyBossInfoAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossFamilyBossInfoAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossFamilyBossInfoAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossFamilyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BossFamilyInfo == nil {
				m.BossFamilyInfo = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFsServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BossFamilyInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFsServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFsServer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFsServer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFsServer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFsServer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsServer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fs_server.proto", fileDescriptorFsServer) }

var fileDescriptorFsServer = []byte{
	// 3019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0xcd, 0x6f, 0x24, 0x47,
	0x15, 0x4f, 0xcf, 0xac, 0x1d, 0xfb, 0x79, 0xd7, 0xeb, 0x6d, 0x7f, 0xec, 0xc4, 0x59, 0x96, 0xa5,
	0xd8, 0x04, 0x27, 0xbb, 0x38, 0xfb, 0x11, 0x25, 0xcb, 0x92, 0x10, 0xec, 0xb1, 0x67, 0xd6, 0xda,
	0x2f, 0xa7, 0xc7, 0x66, 0xf9, 0x50, 0x84, 0xca, 0xdd, 0x35, 0xe3, 0x66, 0x7a, 0xba, 0x27, 0x5d,
	0x3d, 0xde, 0xb5, 0xc4, 0x01, 0x71, 0xe0, 0xc2, 0x09, 0x89, 0x03, 0x67, 0x6e, 0x88, 0x03, 0xe2,
	0x84, 0x10, 0x70, 0x44, 0xe2, 0x88, 0xc4, 0x15, 0xa4, 0x28, 0x88, 0x03, 0xff, 0x03, 0x07, 0xf4,
	0xea, 0xa3, 0xbb, 0xba, 0xa7, 0xdd, 0xb3, 0x4e, 0x20, 0x88, 0x5b, 0xbf, 0x57, 0xaf, 0x7e, 0xf5,
	0xde, 0xab, 0x57, 0xf5, 0x5e, 0x55, 0x17, 0x9c, 0xef, 0xf2, 0xef, 0x72, 0x16, 0x1f, 0xb1, 0x78,
	0x7d, 0x18, 0x47, 0x49, 0x64, 0xcf, 0x0c, 0x0f, 0x24, 0xbd, 0x7a, 0xd6, 0x8d, 0x06, 0x83, 0x28,
	0x94, 0x7c, 0x42, 0x61, 0xb9, 0xcd, 0x9d, 0x68, 0x94, 0xb0, 0x87, 0x8c, 0x73, 0xda, 0x63, 0x7b,
	0x51, 0xcb, 0xef, 0x1d, 0x26, 0x76, 0x03, 0x5e, 0xec, 0xe2, 0xc7, 0x8e, 0xd7, 0xb0, 0xae, 0x58,
	0x6b, 0x53, 0x8e, 0x26, 0xed, 0x25, 0x98, 0x72, 0x07, 0xde, 0x8e, 0xd7, 0xa8, 0x09, 0xbe, 0x24,
	0x50, 0x7e, 0xc0, 0x7b, 0x5b, 0x34, 0xa1, 0x8d, 0xfa, 0x15, 0x6b, 0xed, 0xac, 0xa3, 0x49, 0xb2,
	0x05, 0x0b, 0xad, 0x4e, 0x33, 0x66, 0x34, 0x61, 0x02, 0xda, 0x61, 0x1f, 0xa2, 0x34, 0x4f, 0x68,
	0x8f, 0x65, 0xe8, 0x8a, 0xb4, 0x57, 0x60, 0xda, 0x1d, 0x0a, 0x98, 0x9a, 0x80, 0x51, 0x14, 0xb9,
	0x5e, 0x40, 0xd9, 0x70, 0xfb, 0x45, 0x1d, 0xcf, 0xa5, 0x3a, 0x92, 0x37, 0x61, 0xa5, 0xcd, 0xf7,
	0xa2, 0x16, 0x77, 0x18, 0xf7, 0x3d, 0x16, 0x26, 0xe9, 0xc8, 0xab, 0x30, 0x23, 0x1d, 0x91, 0x0e,
	0x9d, 0xd2, 0xe4, 0x5f, 0x35, 0xb0, 0x0b, 0x5d, 0x1e, 0x25, 0x5d, 0xfb, 0x9b, 0x30, 0x1f, 0x9b,
	0x3c, 0xde, 0xb0, 0xae, 0xd4, 0xd7, 0xe6, 0x6e, 0xdd, 0x58, 0xd7, 0x4e, 0x5d, 0x1f, 0xef, 0xb5,
	0x9e, 0x63, 0xf0, 0xed, 0x30, 0x89, 0x8f, 0x9d, 0x02, 0x8e, 0xed, 0x81, 0xdd, 0xf5, 0x59, 0xe0,
	0x6d, 0x46, 0x9c, 0x0b, 0xd6, 0x4e, 0xd8, 0x8d, 0x1a, 0x35, 0x81, 0xfe, 0x66, 0x25, 0x7a, 0x6b,
	0xac, 0x9b, 0x1c, 0xa1, 0x04, 0x6f, 0x75, 0x03, 0x16, 0x4b, 0x94, 0xb1, 0x17, 0xa0, 0xde, 0x67,
	0xc7, 0xca, 0x09, 0xf8, 0x89, 0x33, 0x7b, 0x44, 0x83, 0x11, 0x13, 0xae, 0x3f, 0xe7, 0x48, 0xe2,
	0x6e, 0xed, 0x8e, 0xb5, 0xea, 0xc2, 0xc5, 0x13, 0x46, 0x2c, 0x81, 0xb9, 0x65, 0xc2, 0xcc, 0xdd,
	0xba, 0x64, 0x1a, 0x92, 0xa2, 0x20, 0xc0, 0xa3, 0xa4, 0x6b, 0x0c, 0x42, 0xbe, 0x8f, 0xde, 0x2f,
	0x0a, 0x54, 0x84, 0xca, 0x3c, 0xd4, 0x0e, 0x87, 0x62, 0x90, 0x9a, 0x53, 0x3b, 0x1c, 0xda, 0x97,
	0x01, 0x62, 0x16, 0xf8, 0x47, 0x6c, 0xcf, 0x1f, 0x30, 0x11, 0x85, 0x75, 0xc7, 0xe0, 0xd8, 0x97,
	0x60, 0x76, 0xc4, 0x59, 0xdc, 0x8c, 0x46, 0x61, 0xd2, 0x38, 0x23, 0xb0, 0x32, 0x06, 0x59, 0x07,
	0xbb, 0xd5, 0x69, 0x46, 0x61, 0xe2, 0x87, 0xa3, 0xe7, 0x08, 0x54, 0xf2, 0x4b, 0x0b, 0xce, 0xb5,
	0x3a, 0x42, 0x70, 0x3b, 0xf4, 0x50, 0xd3, 0x4b, 0x30, 0x2b, 0xe2, 0x6f, 0xef, 0x78, 0xc8, 0x94,
	0x74, 0xc6, 0x30, 0x91, 0x6a, 0x79, 0x3b, 0x1a, 0xf0, 0xe2, 0x53, 0x3f, 0x0c, 0x59, 0xcc, 0x1b,
	0xf5, 0x2b, 0x75, 0x6c, 0x51, 0x24, 0x2e, 0x86, 0x20, 0xe2, 0xd8, 0x70, 0x46, 0x34, 0x28, 0x0a,
	0x7b, 0x8c, 0xb8, 0x34, 0x73, 0x4a, 0x62, 0x29, 0xd2, 0x58, 0x3e, 0xd3, 0xb9, 0xe5, 0xf3, 0x01,
	0x9c, 0x6f, 0x75, 0xb6, 0xc3, 0x84, 0xc5, 0xa9, 0x69, 0xd7, 0x95, 0xba, 0xfb, 0x9c, 0xc5, 0x42,
	0xdd, 0xb9, 0x5b, 0xf3, 0xd9, 0x54, 0x21, 0xd7, 0xc9, 0x04, 0xd0, 0x38, 0x86, 0xdd, 0x85, 0x71,
	0xd2, 0x80, 0x8c, 0x41, 0x5e, 0xcb, 0xc3, 0xe3, 0xe2, 0x5c, 0x81, 0xe9, 0x98, 0x75, 0x47, 0x5c,
	0xba, 0x62, 0xc6, 0x51, 0x14, 0xd9, 0x84, 0xc5, 0x56, 0x67, 0x7f, 0xe8, 0xd1, 0x84, 0x21, 0xb0,
	0x9e, 0xe6, 0x6b, 0x30, 0x33, 0x52, 0xa4, 0x52, 0xe6, 0x7c, 0xa6, 0xcc, 0x86, 0x9b, 0x44, 0xb1,
	0x93, 0x0a, 0x90, 0x2f, 0x8f, 0x63, 0x54, 0x0d, 0xb9, 0xaf, 0x77, 0x83, 0xac, 0xcb, 0x76, 0xd0,
	0x45, 0x1f, 0xac, 0xc0, 0xb4, 0x00, 0xd5, 0xb3, 0xab, 0x28, 0xfb, 0x8b, 0x50, 0x67, 0x41, 0x57,
	0x05, 0xf0, 0x85, 0x4c, 0x91, 0xed, 0xa0, 0x8b, 0x83, 0x39, 0xd8, 0x4a, 0x6e, 0xc0, 0x4a, 0x8b,
	0xef, 0x45, 0xed, 0x3c, 0x6c, 0xaa, 0x08, 0x1f, 0x05, 0x49, 0xa6, 0x08, 0x52, 0xe4, 0x7d, 0x74,
	0xd3, 0x03, 0x46, 0x8f, 0xb2, 0x00, 0x7b, 0x15, 0xe6, 0x29, 0x5a, 0xd7, 0x61, 0x9c, 0xfb, 0x51,
	0x98, 0x6e, 0x65, 0x05, 0xae, 0x84, 0xa4, 0x3c, 0x0a, 0xd5, 0xe2, 0x54, 0x14, 0xb9, 0x90, 0x87,
	0xdc, 0x70, 0xfb, 0x64, 0x0f, 0x56, 0xdb, 0x9d, 0xbc, 0xb9, 0xa2, 0xed, 0x61, 0xe4, 0xb1, 0xe0,
	0x44, 0x93, 0x2f, 0x03, 0x74, 0xfd, 0x5e, 0x72, 0x28, 0xa4, 0xd4, 0x0c, 0x1b, 0x1c, 0xf2, 0x10,
	0x16, 0x85, 0x13, 0x3b, 0x22, 0x32, 0xc4, 0xaa, 0xaa, 0xf2, 0x60, 0xb6, 0x18, 0xb3, 0x80, 0x31,
	0x38, 0xa4, 0x87, 0x53, 0x28, 0x9c, 0x97, 0xc2, 0xa1, 0xe7, 0xae, 0xc0, 0x5c, 0xb6, 0x62, 0xb9,
	0xc2, 0x34, 0x59, 0xf6, 0x3a, 0xd8, 0x92, 0xdc, 0x3c, 0xde, 0x09, 0x7b, 0x51, 0x22, 0x05, 0xe5,
	0x00, 0x25, 0x2d, 0xe4, 0x16, 0x34, 0xa4, 0xde, 0xcd, 0x43, 0xe6, 0xf6, 0x9f, 0x4b, 0x79, 0xf2,
	0x43, 0x0b, 0x1a, 0x62, 0x6a, 0x8b, 0x9d, 0x50, 0xc5, 0x25, 0x98, 0xf2, 0xf9, 0x96, 0xaf, 0x83,
	0x4c, 0x12, 0x45, 0xc5, 0x6b, 0xcf, 0xab, 0x78, 0xfd, 0x44, 0xc5, 0x5b, 0x38, 0xb3, 0x6d, 0x26,
	0xf7, 0xec, 0x1d, 0x0f, 0xf5, 0xbd, 0x5d, 0xdc, 0x61, 0xe6, 0x6f, 0x2d, 0x1b, 0xbb, 0xab, 0xdc,
	0x8d, 0xb0, 0xd1, 0xd8, 0x78, 0xc8, 0xb5, 0x3c, 0x4e, 0x75, 0xe2, 0xfc, 0x49, 0x0d, 0xce, 0xe8,
	0xf5, 0xce, 0x0b, 0x21, 0x99, 0x31, 0xec, 0x35, 0x38, 0x1f, 0x44, 0x2e, 0x4d, 0x98, 0xd7, 0xd1,
	0xc9, 0x54, 0x86, 0x65, 0x91, 0x9d, 0x5b, 0xd7, 0xf5, 0x09, 0xeb, 0x1a, 0xe7, 0x23, 0x61, 0x74,
	0xb0, 0xe3, 0xa9, 0xed, 0x59, 0x51, 0x2a, 0x36, 0x55, 0x04, 0xab, 0x2d, 0xcf, 0xe0, 0xa0, 0xb2,
	0x07, 0x7e, 0x9c, 0x1c, 0x6e, 0xc4, 0x4c, 0x6e, 0x7c, 0x53, 0x4e, 0xc6, 0xc0, 0x94, 0x8f, 0x23,
	0x08, 0xa7, 0xbd, 0x28, 0x53, 0xbe, 0xa6, 0x6d, 0x02, 0x67, 0x93, 0xe8, 0x1e, 0x0b, 0x86, 0xfb,
	0x32, 0x0e, 0x66, 0x44, 0x7b, 0x8e, 0x47, 0x3e, 0x80, 0x39, 0xfc, 0xda, 0x8a, 0xa3, 0x21, 0x4e,
	0xc2, 0x27, 0xdd, 0xe6, 0xb3, 0x60, 0xab, 0xe7, 0x82, 0xed, 0xed, 0x0c, 0x1e, 0xe7, 0x66, 0x0d,
	0xa6, 0xfc, 0x84, 0x0d, 0x74, 0x91, 0x61, 0x67, 0xde, 0xda, 0x49, 0xd8, 0x60, 0x3f, 0xf4, 0x13,
	0x47, 0x0a, 0x90, 0x5f, 0x5b, 0x70, 0xb6, 0xd5, 0xd9, 0xf0, 0x3c, 0x6c, 0xa8, 0x5a, 0x8b, 0x6f,
	0x6b, 0x48, 0x59, 0x59, 0x7c, 0xc1, 0x0c, 0x99, 0xac, 0xbb, 0xc0, 0x57, 0x85, 0x8a, 0x94, 0x47,
	0xc0, 0xc7, 0x43, 0x61, 0xa7, 0x52, 0x59, 0x52, 0xab, 0x77, 0x00, 0x32, 0xe1, 0x49, 0x85, 0xc4,
	0x94, 0x99, 0xe3, 0xaf, 0x1b, 0x2a, 0xa3, 0xb5, 0x97, 0x60, 0xd6, 0xe7, 0x9d, 0x91, 0xeb, 0x32,
	0xce, 0xd5, 0x82, 0xca, 0x18, 0xe4, 0x09, 0x9c, 0x6f, 0xf3, 0xbd, 0xc7, 0x2d, 0xbe, 0xeb, 0xbb,
	0xfd, 0x7d, 0xe1, 0xfd, 0x25, 0x98, 0x1a, 0xf1, 0x2c, 0x1d, 0x4b, 0x02, 0x15, 0x8d, 0x0e, 0xbe,
	0xb7, 0xe3, 0x49, 0x13, 0xa7, 0x1c, 0x45, 0x21, 0xdf, 0x17, 0x9d, 0x85, 0x01, 0x33, 0x8e, 0xa2,
	0xc8, 0xef, 0x2d, 0x38, 0xdf, 0xe2, 0x7b, 0x8f, 0xdb, 0x0a, 0x19, 0x55, 0xb9, 0x9b, 0x77, 0xfc,
	0x55, 0xb3, 0x6c, 0xc9, 0x49, 0x96, 0x3b, 0x4a, 0x8d, 0x53, 0x33, 0xc7, 0x59, 0xdd, 0x9f, 0xe0,
	0xa8, 0x9b, 0xf9, 0x52, 0xe9, 0xe5, 0xf1, 0xc9, 0x6e, 0x45, 0xb1, 0x32, 0xde, 0xf0, 0xa2, 0x0f,
	0x17, 0x65, 0x42, 0xc3, 0x26, 0x87, 0x79, 0xbb, 0xd4, 0xed, 0xb3, 0x44, 0x2f, 0xa1, 0xd2, 0x18,
	0x78, 0x0b, 0x66, 0x63, 0x2d, 0xa8, 0x46, 0x6b, 0x14, 0x17, 0xa2, 0x6e, 0x77, 0x32, 0x51, 0xf2,
	0x4f, 0x2c, 0x73, 0x78, 0xa7, 0xef, 0x07, 0xc1, 0x3e, 0x67, 0x98, 0xa9, 0xcb, 0x67, 0xe0, 0x12,
	0xcc, 0x1e, 0xb2, 0x38, 0xda, 0x09, 0x3d, 0xf6, 0x4c, 0xd7, 0x07, 0x29, 0x43, 0xac, 0x0a, 0x84,
	0x48, 0x83, 0x5f, 0x93, 0xb8, 0x6f, 0xba, 0x5e, 0x27, 0xa1, 0xb1, 0xd8, 0xf5, 0xc4, 0xba, 0xaf,
	0x3b, 0x26, 0x0b, 0x17, 0x3f, 0x92, 0xd1, 0x30, 0xad, 0x77, 0xea, 0x8e, 0xc1, 0xc1, 0x0c, 0x8a,
	0x58, 0x0f, 0xa3, 0x90, 0x27, 0x68, 0x2a, 0x6f, 0x4c, 0x8b, 0x18, 0x28, 0x70, 0x71, 0x24, 0x65,
	0x45, 0xfc, 0x68, 0x34, 0x50, 0x3b, 0x81, 0xc9, 0x22, 0x1e, 0x16, 0xa0, 0x98, 0x93, 0x84, 0x3b,
	0xee, 0xfb, 0x41, 0x80, 0xf6, 0xae, 0xc0, 0x34, 0x0a, 0xa9, 0x22, 0x69, 0xca, 0x51, 0x14, 0x6e,
	0x2b, 0x07, 0xec, 0xbe, 0x6c, 0x91, 0x06, 0xa7, 0x34, 0xb6, 0xf9, 0x7c, 0x37, 0xa0, 0xc7, 0x2c,
	0x56, 0x91, 0x97, 0xd2, 0xe4, 0x21, 0x2c, 0xcb, 0x80, 0x6a, 0x06, 0x8c, 0xc6, 0xc2, 0xb3, 0x4d,
	0x4f, 0x0d, 0x54, 0x3a, 0x75, 0x95, 0xae, 0x25, 0x1b, 0xb0, 0xd8, 0xe2, 0x0e, 0x0d, 0xbd, 0x68,
	0xb0, 0x25, 0x92, 0x48, 0x7c, 0x5c, 0x05, 0x66, 0xc3, 0x99, 0x98, 0x86, 0x9e, 0x8a, 0x53, 0xf1,
	0x4d, 0x36, 0x61, 0x41, 0xd5, 0x47, 0x9c, 0x61, 0xdc, 0x55, 0xf5, 0xc7, 0x48, 0x4f, 0xd8, 0x20,
	0xdd, 0xde, 0x14, 0x45, 0xde, 0x80, 0xc5, 0x76, 0x67, 0xef, 0xb1, 0x4a, 0xb3, 0x66, 0xfd, 0x5c,
	0x7e, 0x8c, 0xc4, 0x0e, 0xad, 0xce, 0xde, 0xe3, 0xb6, 0xd1, 0xa1, 0x24, 0x35, 0x19, 0x1d, 0x36,
	0xf4, 0x08, 0xf9, 0x9c, 0x78, 0xf2, 0xf9, 0x60, 0x01, 0xea, 0xec, 0x59, 0xa2, 0xf4, 0xc4, 0xcf,
	0x6c, 0xcc, 0xca, 0x74, 0x68, 0x8c, 0xb9, 0x0e, 0x4b, 0xd2, 0x33, 0x6d, 0x96, 0x34, 0x0f, 0x99,
	0x08, 0x93, 0xaa, 0xc2, 0x61, 0x08, 0x4b, 0x32, 0x82, 0x0c, 0x79, 0x55, 0x10, 0x96, 0x7a, 0x73,
	0x15, 0x66, 0x5c, 0x25, 0xa6, 0x63, 0x48, 0xd3, 0xf6, 0x55, 0x38, 0xd7, 0x1b, 0xf9, 0x81, 0xa7,
	0x71, 0xd4, 0xca, 0xc9, 0x33, 0xc9, 0x1a, 0xcc, 0x4b, 0x0d, 0x05, 0xa7, 0x4a, 0xb7, 0x35, 0x98,
	0x97, 0xba, 0x09, 0xc9, 0xaa, 0x32, 0xd5, 0xb4, 0x7a, 0x37, 0x4a, 0xfc, 0x28, 0x6c, 0x7a, 0x55,
	0xc8, 0xf7, 0x0c, 0xab, 0xb5, 0x7c, 0x95, 0xd5, 0xc6, 0xf1, 0xa5, 0x26, 0x96, 0xb3, 0x26, 0xc9,
	0x75, 0xb0, 0xd3, 0x48, 0x94, 0x48, 0x55, 0xe3, 0xb6, 0xf4, 0x7a, 0x4d, 0xa5, 0x2b, 0xac, 0xaa,
	0x18, 0xb5, 0xa9, 0x4a, 0x5b, 0xde, 0x8c, 0x82, 0x80, 0xb9, 0x13, 0x86, 0xc5, 0x0d, 0x50, 0xa4,
	0x17, 0x9d, 0xdd, 0x04, 0x81, 0xf5, 0xb1, 0x72, 0x6f, 0x0a, 0xa2, 0x12, 0x1c, 0x4f, 0x77, 0x37,
	0x4b, 0x8c, 0x9b, 0x31, 0x50, 0x27, 0x16, 0x7a, 0xa6, 0x4e, 0x8a, 0x24, 0x3b, 0xf0, 0x52, 0x51,
	0xa7, 0x26, 0x0d, 0x5d, 0x16, 0x9c, 0x5e, 0xb3, 0xdb, 0xf0, 0x52, 0x51, 0x33, 0x09, 0x55, 0x15,
	0x03, 0x7f, 0xb4, 0xc6, 0xed, 0x99, 0xb0, 0x49, 0x89, 0x75, 0x67, 0x9e, 0x0f, 0x53, 0x86, 0xfd,
	0x35, 0x9d, 0x5b, 0xeb, 0x22, 0xb7, 0xae, 0xe5, 0x72, 0x6b, 0x71, 0x8c, 0xf1, 0xfc, 0xfa, 0x29,
	0x0a, 0x8e, 0xc7, 0xa2, 0x84, 0x90, 0x11, 0xd5, 0xf2, 0x93, 0x2a, 0xef, 0x5d, 0x85, 0x7a, 0xd7,
	0xd7, 0xc9, 0xd1, 0x2e, 0x24, 0x47, 0xec, 0x8b, 0xcd, 0xe4, 0x0d, 0x51, 0x39, 0xc8, 0xa0, 0x6b,
	0xf9, 0xc9, 0xe4, 0x22, 0xe6, 0x1a, 0x5c, 0x90, 0x1a, 0xb4, 0xfc, 0xa4, 0x49, 0xab, 0x67, 0x90,
	0x2c, 0xc2, 0x05, 0x89, 0xae, 0x85, 0xf1, 0x40, 0xe7, 0xa4, 0xab, 0x42, 0x1c, 0xe8, 0x76, 0xd9,
	0x24, 0x33, 0x86, 0xec, 0x24, 0x33, 0xb0, 0x2f, 0x36, 0x93, 0xa5, 0x74, 0xed, 0x68, 0x4c, 0x1c,
	0xe9, 0x6d, 0x98, 0x53, 0x2b, 0xbf, 0xb2, 0xa0, 0x5c, 0x80, 0xba, 0x3b, 0x90, 0x51, 0x36, 0xeb,
	0xe0, 0x27, 0x79, 0x05, 0xe6, 0xd4, 0x16, 0x30, 0x18, 0x8f, 0xaa, 0xd9, 0x34, 0xaa, 0x9e, 0xe8,
	0xc2, 0x65, 0x9f, 0xb3, 0xe6, 0x28, 0xd9, 0xc3, 0x43, 0xec, 0x28, 0x66, 0xd5, 0xe6, 0x9c, 0x73,
	0x33, 0xc9, 0x07, 0x47, 0x6a, 0x8a, 0xf3, 0x4c, 0x72, 0x13, 0x2e, 0xa6, 0xb3, 0x62, 0x00, 0x57,
	0x45, 0xf8, 0x1b, 0xb0, 0x9c, 0xee, 0x9c, 0x6e, 0xbf, 0x15, 0xc5, 0x58, 0xf2, 0x57, 0xcd, 0xcd,
	0xbb, 0xf0, 0x72, 0xba, 0x81, 0x1a, 0x1d, 0x10, 0x0c, 0xc7, 0xc1, 0x3a, 0x85, 0x86, 0x6d, 0x96,
	0x20, 0x5b, 0x8d, 0x65, 0x70, 0xc8, 0xbe, 0xb6, 0xbd, 0x79, 0x48, 0xc3, 0x1e, 0xdb, 0x13, 0x47,
	0x8c, 0xca, 0x2d, 0x7b, 0xec, 0x74, 0x52, 0x2b, 0x39, 0x9d, 0x7c, 0x4b, 0xc3, 0xca, 0xbb, 0xc1,
	0xd1, 0x40, 0xc2, 0x57, 0xc1, 0xbe, 0x0a, 0xf3, 0xdd, 0x9c, 0xb0, 0x02, 0x2e, 0x70, 0x49, 0x4b,
	0xdf, 0x9b, 0x48, 0xe8, 0xa1, 0xbb, 0x7d, 0xc4, 0xc2, 0x64, 0xc2, 0x06, 0x14, 0x0e, 0xdd, 0x6c,
	0x03, 0x12, 0x04, 0x69, 0xe8, 0x8b, 0x92, 0x1c, 0x0e, 0xc6, 0xdb, 0x45, 0x3d, 0x07, 0x6d, 0x3a,
	0x60, 0xde, 0x81, 0xc3, 0x82, 0x88, 0x62, 0xaa, 0x29, 0x6f, 0xc0, 0x1e, 0x2d, 0xb0, 0x9f, 0x44,
	0xb1, 0xbc, 0x22, 0xec, 0x24, 0x34, 0x19, 0xf1, 0xea, 0x4b, 0xc2, 0x15, 0x98, 0xe6, 0x42, 0x4c,
	0xd7, 0x2b, 0x92, 0x22, 0x37, 0x60, 0x65, 0xfb, 0xd9, 0xb0, 0x83, 0x52, 0xf7, 0xb3, 0x3a, 0xb1,
	0x62, 0x87, 0x23, 0xbf, 0xb3, 0xe0, 0xc2, 0x2e, 0x8b, 0x79, 0x14, 0xaa, 0xea, 0x46, 0x64, 0x95,
	0x93, 0x3c, 0xf1, 0x4e, 0xfe, 0xcc, 0xf5, 0x6a, 0xb6, 0x0e, 0xc7, 0x30, 0xca, 0xcf, 0x13, 0x2a,
	0x66, 0xd5, 0xc1, 0x4b, 0x52, 0x9f, 0x62, 0x1f, 0xfc, 0x83, 0x05, 0xf6, 0x37, 0xfc, 0x61, 0x7a,
	0x81, 0x3b, 0x41, 0xfd, 0x77, 0xf3, 0xea, 0x7f, 0x29, 0x53, 0x7f, 0x1c, 0xe4, 0x33, 0xd1, 0xff,
	0xb7, 0x16, 0x2c, 0xec, 0x45, 0x4f, 0xd3, 0xfb, 0xcb, 0x4a, 0xed, 0xbf, 0x9a, 0xd7, 0xfe, 0x95,
	0x4c, 0xfb, 0x22, 0xc4, 0x67, 0xa2, 0xfb, 0x5f, 0xf1, 0xb4, 0xa9, 0xef, 0xb5, 0x95, 0xea, 0x97,
	0x01, 0x38, 0x0b, 0xbd, 0x27, 0xe2, 0xa6, 0x57, 0xef, 0x16, 0x19, 0xc7, 0x76, 0xe0, 0x1c, 0x1a,
	0x83, 0x07, 0xbc, 0x1d, 0xc3, 0x94, 0xeb, 0x46, 0xe6, 0xcc, 0x23, 0x8a, 0x1b, 0xdb, 0x54, 0x5c,
	0x5a, 0x94, 0x87, 0x58, 0xdd, 0x07, 0x7b, 0x5c, 0xa8, 0xc4, 0x92, 0xd7, 0xf2, 0xa7, 0xd2, 0xc5,
	0xf1, 0x53, 0x29, 0x37, 0xcd, 0xfb, 0x47, 0x0d, 0x96, 0xb6, 0x68, 0xdc, 0xdf, 0xa5, 0x01, 0x75,
	0xd9, 0x29, 0x6c, 0x7c, 0x52, 0x6e, 0xe3, 0xcd, 0x6c, 0xbc, 0x32, 0xd8, 0xc9, 0x86, 0xda, 0x9b,
	0x30, 0x7d, 0x28, 0x36, 0x57, 0x55, 0x6f, 0xbc, 0x3e, 0x01, 0x51, 0xee, 0xc4, 0x12, 0x4a, 0xf5,
	0xfc, 0x2f, 0x39, 0x6b, 0xf5, 0x2b, 0x30, 0x67, 0x8c, 0x76, 0xaa, 0x30, 0xfa, 0xc8, 0x82, 0x0b,
	0x1b, 0xa1, 0xeb, 0xb3, 0x30, 0x39, 0x85, 0x93, 0xf7, 0xca, 0x9d, 0xbc, 0x6e, 0x14, 0x06, 0x45,
	0xcc, 0xff, 0x5d, 0x28, 0xfd, 0xa5, 0x06, 0xf3, 0xf7, 0x58, 0x10, 0x9c, 0xc2, 0xbe, 0xf7, 0xcb,
	0xed, 0xbb, 0x96, 0x8d, 0x94, 0x07, 0x7c, 0x8e, 0xf0, 0x79, 0xa7, 0x10, 0x3e, 0x57, 0x4f, 0xc4,
	0xfa, 0xff, 0x08, 0x1c, 0x17, 0x16, 0xb7, 0xe8, 0x26, 0x8d, 0x9e, 0x2f, 0xd1, 0x61, 0x39, 0x3b,
	0xd0, 0xd7, 0x26, 0xba, 0x94, 0x4f, 0x19, 0xd8, 0x8b, 0x85, 0x2c, 0xee, 0x1d, 0xeb, 0xed, 0x51,
	0x52, 0xa4, 0x85, 0x9b, 0xc0, 0x26, 0x8d, 0xd0, 0x33, 0x03, 0xb6, 0x2d, 0x98, 0x55, 0xa5, 0x42,
	0x86, 0x53, 0xcb, 0xe1, 0x70, 0x58, 0x7e, 0xe8, 0x87, 0x7e, 0xd8, 0x7b, 0xc4, 0x9e, 0xa6, 0xbf,
	0x1a, 0xd5, 0x9f, 0xdb, 0x81, 0x68, 0xc8, 0xfe, 0xdc, 0x6a, 0x1a, 0x0b, 0x25, 0xf9, 0x9d, 0x2f,
	0x94, 0x4c, 0x9e, 0xbc, 0x93, 0x71, 0x58, 0x42, 0xfb, 0x2c, 0xbb, 0x93, 0x91, 0x34, 0xb9, 0x59,
	0x36, 0xa8, 0xba, 0x1a, 0x88, 0x19, 0xf5, 0x8e, 0x1f, 0xf7, 0x55, 0xe8, 0x69, 0x92, 0xfc, 0xdc,
	0x82, 0x25, 0xd9, 0xc7, 0x48, 0x27, 0x55, 0x6e, 0x35, 0xf5, 0xaf, 0x4d, 0xd0, 0xbf, 0x3e, 0x41,
	0xff, 0x33, 0x79, 0xfd, 0x8d, 0x9c, 0x35, 0x65, 0xe6, 0x2c, 0xb2, 0x0d, 0x17, 0xee, 0xd1, 0xb0,
	0xb7, 0x3f, 0xc4, 0xa9, 0x7f, 0x42, 0x8f, 0x58, 0x95, 0x82, 0x27, 0x5e, 0x5d, 0x93, 0xbf, 0x59,
	0xb0, 0x2c, 0x71, 0xd2, 0xd4, 0xaf, 0xfe, 0x79, 0x9e, 0x1a, 0xeb, 0xa4, 0xf4, 0x6a, 0x7f, 0x5d,
	0xe7, 0xec, 0x33, 0xc5, 0x2d, 0xbb, 0x74, 0xe4, 0xff, 0xe8, 0x21, 0xf1, 0xdb, 0x30, 0x2f, 0x7f,
	0x9d, 0x44, 0x09, 0x0d, 0xb6, 0x68, 0x42, 0x51, 0x4b, 0x8f, 0x0e, 0x68, 0x4f, 0x9f, 0xd9, 0x15,
	0x25, 0x2f, 0xfd, 0xb6, 0x64, 0x8b, 0x3c, 0xb1, 0xa7, 0x34, 0xe2, 0x27, 0x31, 0xa3, 0x89, 0xfa,
	0xf5, 0x2c, 0x09, 0x72, 0x1f, 0x96, 0xdb, 0x23, 0x3f, 0xf0, 0x0e, 0xa2, 0xb0, 0xeb, 0xc7, 0x6c,
	0xfb, 0xd9, 0x70, 0xc3, 0xf3, 0x54, 0xcd, 0x2a, 0xae, 0x72, 0xb2, 0x9a, 0x55, 0x91, 0xea, 0xa6,
	0x22, 0xce, 0xae, 0xb3, 0x35, 0x49, 0x7e, 0x65, 0x81, 0xbd, 0x4b, 0x23, 0xcf, 0xa7, 0x61, 0x3b,
	0x8a, 0x3c, 0x9e, 0x41, 0x9d, 0x50, 0xfe, 0x36, 0xf3, 0x50, 0x73, 0xb7, 0x5e, 0x33, 0x0a, 0xd1,
	0x31, 0xa0, 0x75, 0x19, 0x6a, 0xca, 0xad, 0xba, 0xe7, 0xea, 0x5d, 0x38, 0x6b, 0x36, 0x9c, 0xca,
	0xb5, 0x3f, 0xb2, 0xc0, 0xee, 0x1c, 0xd2, 0x03, 0xda, 0x67, 0x66, 0xdc, 0xbc, 0x25, 0xff, 0xc9,
	0x38, 0x34, 0xec, 0xab, 0xfb, 0xf6, 0xd5, 0x4c, 0x31, 0x25, 0x8f, 0x8d, 0x1d, 0x37, 0x8a, 0x99,
	0x93, 0xca, 0xda, 0x77, 0x60, 0x56, 0x78, 0x49, 0x74, 0xac, 0x4d, 0xec, 0x98, 0x09, 0x93, 0x3b,
	0xb0, 0x50, 0x6c, 0xb6, 0xe7, 0xa1, 0xe6, 0x6b, 0x97, 0xd5, 0x7c, 0x71, 0x7c, 0xe1, 0xd8, 0xa0,
	0xcd, 0x10, 0x04, 0xf9, 0xa9, 0x05, 0x17, 0x55, 0xd7, 0x66, 0x5c, 0x88, 0xff, 0xbb, 0x98, 0x9d,
	0x70, 0xec, 0xe7, 0xb4, 0xc4, 0x90, 0xb6, 0xdf, 0x1d, 0xb7, 0xe5, 0xf3, 0x63, 0x5d, 0xc5, 0x88,
	0xa5, 0x06, 0x1d, 0xc3, 0x72, 0xa9, 0x4c, 0xd5, 0x13, 0x17, 0x33, 0xe8, 0x6a, 0xf9, 0xa0, 0x4b,
	0x6d, 0xaf, 0x1b, 0xb6, 0xab, 0xcb, 0xfe, 0xf4, 0x01, 0x82, 0x24, 0xc8, 0x8f, 0x2d, 0x58, 0x11,
	0xa7, 0xb0, 0x07, 0x8c, 0x7a, 0xaa, 0x9e, 0x56, 0x0e, 0x39, 0x39, 0x14, 0x09, 0x9c, 0x0d, 0x28,
	0x4f, 0x36, 0x92, 0x84, 0xba, 0xfd, 0xf4, 0xce, 0x3c, 0xc7, 0xb3, 0x6f, 0xc3, 0x54, 0x4c, 0xc3,
	0xbe, 0xbe, 0x27, 0xfa, 0x5c, 0xe6, 0x0e, 0x63, 0x38, 0xb4, 0x54, 0xfe, 0x07, 0x13, 0xb2, 0xe4,
	0x07, 0x16, 0x5c, 0x2c, 0x6a, 0x83, 0x32, 0x13, 0x0f, 0x86, 0x07, 0x11, 0xe7, 0xf7, 0x86, 0x3a,
	0xff, 0x48, 0xea, 0x93, 0xa9, 0xf0, 0x0b, 0x0b, 0x16, 0x4b, 0x9a, 0xd5, 0x6d, 0x7b, 0x5f, 0x8d,
	0x2d, 0xbe, 0x2b, 0xa6, 0xe0, 0x92, 0x0a, 0x88, 0x47, 0x54, 0xbd, 0x5f, 0x99, 0x75, 0x32, 0x46,
	0x36, 0x41, 0xf2, 0x1f, 0x89, 0x9a, 0x20, 0x73, 0xb2, 0xa7, 0x0a, 0x93, 0x9d, 0x4e, 0xde, 0xb4,
	0x39, 0x79, 0xef, 0xc1, 0x62, 0x7b, 0x44, 0x63, 0x6f, 0xd7, 0x0f, 0x02, 0x9a, 0xce, 0x1d, 0xaa,
	0xfa, 0x94, 0x1e, 0xe9, 0x3f, 0x9a, 0xe2, 0x3b, 0x03, 0xa8, 0x99, 0x00, 0x1d, 0x78, 0xc9, 0x78,
	0xa7, 0xb3, 0xe5, 0xe7, 0xde, 0x71, 0x5c, 0x82, 0x59, 0x4f, 0x71, 0xb4, 0xcb, 0x33, 0x06, 0xda,
	0xee, 0xf9, 0xb9, 0x3b, 0x58, 0x45, 0x92, 0x07, 0x60, 0x3f, 0xa4, 0x3d, 0xdf, 0xcd, 0x0e, 0x68,
	0xa8, 0xd4, 0x27, 0xdc, 0x26, 0xc8, 0xfd, 0xdc, 0xa5, 0x88, 0x68, 0x7d, 0xc0, 0xb0, 0x6a, 0xfb,
	0xb0, 0x2a, 0x63, 0x05, 0x8c, 0xf3, 0xec, 0x26, 0x5e, 0x93, 0xa4, 0xad, 0xef, 0x96, 0xf2, 0x60,
	0x55, 0x37, 0xdc, 0xe5, 0x1b, 0x89, 0x03, 0x8d, 0xcc, 0xc6, 0x36, 0x4b, 0xb4, 0xdf, 0x26, 0xbc,
	0xa3, 0xf0, 0x79, 0x9b, 0x25, 0x1b, 0x4f, 0x69, 0xac, 0xff, 0xda, 0x18, 0x1c, 0x12, 0x9f, 0x80,
	0xa9, 0x5e, 0x2a, 0x48, 0x2d, 0x2c, 0x73, 0x49, 0x4f, 0x40, 0x14, 0x7f, 0xe4, 0xc4, 0xad, 0x95,
	0x14, 0x90, 0xa5, 0x92, 0xc9, 0x22, 0x37, 0xd4, 0xeb, 0x08, 0xae, 0x66, 0x00, 0x8b, 0x0b, 0x0c,
	0x05, 0xf5, 0x77, 0xd0, 0x0f, 0xbb, 0x11, 0x57, 0x17, 0x7f, 0x92, 0x20, 0xef, 0xc1, 0xb2, 0xc8,
	0xdf, 0x74, 0xe0, 0x07, 0xc7, 0xfa, 0x75, 0x97, 0x7a, 0xfe, 0x72, 0x90, 0x36, 0x18, 0x7f, 0xd4,
	0x0b, 0x5c, 0xf2, 0x1b, 0xab, 0x0c, 0x01, 0x8d, 0xfc, 0x8e, 0x89, 0xa0, 0x9e, 0x0f, 0x61, 0xa0,
	0xdc, 0xce, 0x02, 0xa5, 0xb4, 0xa3, 0xc1, 0xcd, 0x9e, 0xcf, 0x15, 0xa0, 0x56, 0x37, 0x60, 0xb1,
	0x44, 0xec, 0x34, 0x09, 0xf0, 0xf5, 0x8b, 0x30, 0x67, 0x3c, 0xcc, 0xb0, 0x67, 0xe0, 0x0c, 0x22,
	0x2e, 0xbc, 0xb0, 0xb9, 0xf0, 0xa7, 0x8f, 0x2f, 0x5b, 0x7f, 0xfe, 0xf8, 0xb2, 0xf5, 0xd1, 0xc7,
	0x97, 0xad, 0x9f, 0xfd, 0xfd, 0xf2, 0x0b, 0x07, 0xd3, 0xe2, 0x4d, 0xe6, 0xed, 0x7f, 0x07, 0x00,
	0x00, 0xff, 0xff, 0x47, 0x4f, 0x62, 0x4d, 0xbe, 0x29, 0x00, 0x00,
}
