// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: css_server.proto

package pbserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SyncUserInfoNtf struct {
	UserId           int32           `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	OpenId           string          `protobuf:"bytes,2,opt,name=openId,proto3" json:"openId,omitempty"`
	ServerId         int32           `protobuf:"varint,3,opt,name=serverId,proto3" json:"serverId,omitempty"`
	ServerIndex      int32           `protobuf:"varint,4,opt,name=serverIndex,proto3" json:"serverIndex,omitempty"`
	ChannelId        int32           `protobuf:"varint,5,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Nickname         string          `protobuf:"bytes,6,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Vip              int32           `protobuf:"varint,8,opt,name=vip,proto3" json:"vip,omitempty"`
	Combat           int64           `protobuf:"varint,9,opt,name=combat,proto3" json:"combat,omitempty"`
	CreateTime       int32           `protobuf:"varint,10,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Avatar           string          `protobuf:"bytes,11,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Recharge         int32           `protobuf:"varint,13,opt,name=recharge,proto3" json:"recharge,omitempty"`
	Gold             int64           `protobuf:"varint,14,opt,name=gold,proto3" json:"gold,omitempty"`
	Ingot            int32           `protobuf:"varint,15,opt,name=ingot,proto3" json:"ingot,omitempty"`
	TaskId           int32           `protobuf:"varint,16,opt,name=taskId,proto3" json:"taskId,omitempty"`
	LastRechargeTime int32           `protobuf:"varint,17,opt,name=lastRechargeTime,proto3" json:"lastRechargeTime,omitempty"`
	OfflineTime      int32           `protobuf:"varint,18,opt,name=offlineTime,proto3" json:"offlineTime,omitempty"`
	SyscStatus       int32           `protobuf:"varint,19,opt,name=syscStatus,proto3" json:"syscStatus,omitempty"`
	Exp              int64           `protobuf:"varint,20,opt,name=exp,proto3" json:"exp,omitempty"`
	LoginTime        int32           `protobuf:"varint,21,opt,name=loginTime,proto3" json:"loginTime,omitempty"`
	TokenRecharge    int32           `protobuf:"varint,22,opt,name=tokenRecharge,proto3" json:"tokenRecharge,omitempty"`
	Heros            []*SyscHeroInfo `protobuf:"bytes,50,rep,name=heros" json:"heros,omitempty"`
}

func (m *SyncUserInfoNtf) Reset()                    { *m = SyncUserInfoNtf{} }
func (m *SyncUserInfoNtf) String() string            { return proto.CompactTextString(m) }
func (*SyncUserInfoNtf) ProtoMessage()               {}
func (*SyncUserInfoNtf) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{0} }

func (m *SyncUserInfoNtf) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SyncUserInfoNtf) GetOpenId() string {
	if m != nil {
		return m.OpenId
	}
	return ""
}

func (m *SyncUserInfoNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *SyncUserInfoNtf) GetServerIndex() int32 {
	if m != nil {
		return m.ServerIndex
	}
	return 0
}

func (m *SyncUserInfoNtf) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *SyncUserInfoNtf) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *SyncUserInfoNtf) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *SyncUserInfoNtf) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

func (m *SyncUserInfoNtf) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *SyncUserInfoNtf) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *SyncUserInfoNtf) GetRecharge() int32 {
	if m != nil {
		return m.Recharge
	}
	return 0
}

func (m *SyncUserInfoNtf) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *SyncUserInfoNtf) GetIngot() int32 {
	if m != nil {
		return m.Ingot
	}
	return 0
}

func (m *SyncUserInfoNtf) GetTaskId() int32 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *SyncUserInfoNtf) GetLastRechargeTime() int32 {
	if m != nil {
		return m.LastRechargeTime
	}
	return 0
}

func (m *SyncUserInfoNtf) GetOfflineTime() int32 {
	if m != nil {
		return m.OfflineTime
	}
	return 0
}

func (m *SyncUserInfoNtf) GetSyscStatus() int32 {
	if m != nil {
		return m.SyscStatus
	}
	return 0
}

func (m *SyncUserInfoNtf) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *SyncUserInfoNtf) GetLoginTime() int32 {
	if m != nil {
		return m.LoginTime
	}
	return 0
}

func (m *SyncUserInfoNtf) GetTokenRecharge() int32 {
	if m != nil {
		return m.TokenRecharge
	}
	return 0
}

func (m *SyncUserInfoNtf) GetHeros() []*SyscHeroInfo {
	if m != nil {
		return m.Heros
	}
	return nil
}

type SyscHeroInfo struct {
	HeroIndex int32 `protobuf:"varint,1,opt,name=heroIndex,proto3" json:"heroIndex,omitempty"`
	Sex       int32 `protobuf:"varint,2,opt,name=sex,proto3" json:"sex,omitempty"`
	Level     int32 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	Job       int32 `protobuf:"varint,4,opt,name=job,proto3" json:"job,omitempty"`
	Combat    int64 `protobuf:"varint,5,opt,name=combat,proto3" json:"combat,omitempty"`
}

func (m *SyscHeroInfo) Reset()                    { *m = SyscHeroInfo{} }
func (m *SyscHeroInfo) String() string            { return proto.CompactTextString(m) }
func (*SyscHeroInfo) ProtoMessage()               {}
func (*SyscHeroInfo) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{1} }

func (m *SyscHeroInfo) GetHeroIndex() int32 {
	if m != nil {
		return m.HeroIndex
	}
	return 0
}

func (m *SyscHeroInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *SyscHeroInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SyscHeroInfo) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *SyscHeroInfo) GetCombat() int64 {
	if m != nil {
		return m.Combat
	}
	return 0
}

type CCSToGsCrossFsIdChangeNtf struct {
	CrossFsId int32 `protobuf:"varint,1,opt,name=crossFsId,proto3" json:"crossFsId,omitempty"`
}

func (m *CCSToGsCrossFsIdChangeNtf) Reset()         { *m = CCSToGsCrossFsIdChangeNtf{} }
func (m *CCSToGsCrossFsIdChangeNtf) String() string { return proto.CompactTextString(m) }
func (*CCSToGsCrossFsIdChangeNtf) ProtoMessage()    {}
func (*CCSToGsCrossFsIdChangeNtf) Descriptor() ([]byte, []int) {
	return fileDescriptorCssServer, []int{2}
}

func (m *CCSToGsCrossFsIdChangeNtf) GetCrossFsId() int32 {
	if m != nil {
		return m.CrossFsId
	}
	return 0
}

type RechageCcsToGsReq struct {
	Oid       string `protobuf:"bytes,1,opt,name=oid,proto3" json:"oid,omitempty"`
	GameOrder string `protobuf:"bytes,2,opt,name=gameOrder,proto3" json:"gameOrder,omitempty"`
	Money     int32  `protobuf:"varint,3,opt,name=money,proto3" json:"money,omitempty"`
	Coin      int32  `protobuf:"varint,4,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *RechageCcsToGsReq) Reset()                    { *m = RechageCcsToGsReq{} }
func (m *RechageCcsToGsReq) String() string            { return proto.CompactTextString(m) }
func (*RechageCcsToGsReq) ProtoMessage()               {}
func (*RechageCcsToGsReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{3} }

func (m *RechageCcsToGsReq) GetOid() string {
	if m != nil {
		return m.Oid
	}
	return ""
}

func (m *RechageCcsToGsReq) GetGameOrder() string {
	if m != nil {
		return m.GameOrder
	}
	return ""
}

func (m *RechageCcsToGsReq) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *RechageCcsToGsReq) GetCoin() int32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type RechageGsToCcsAck struct {
	Result int32  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *RechageGsToCcsAck) Reset()                    { *m = RechageGsToCcsAck{} }
func (m *RechageGsToCcsAck) String() string            { return proto.CompactTextString(m) }
func (*RechageGsToCcsAck) ProtoMessage()               {}
func (*RechageGsToCcsAck) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{4} }

func (m *RechageGsToCcsAck) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *RechageGsToCcsAck) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type RechargeApplyReq struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	PayType   int32 `protobuf:"varint,2,opt,name=payType,proto3" json:"payType,omitempty"`
	PayTypeId int32 `protobuf:"varint,3,opt,name=payTypeId,proto3" json:"payTypeId,omitempty"`
	PayNum    int32 `protobuf:"varint,4,opt,name=payNum,proto3" json:"payNum,omitempty"`
}

func (m *RechargeApplyReq) Reset()                    { *m = RechargeApplyReq{} }
func (m *RechargeApplyReq) String() string            { return proto.CompactTextString(m) }
func (*RechargeApplyReq) ProtoMessage()               {}
func (*RechargeApplyReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{5} }

func (m *RechargeApplyReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RechargeApplyReq) GetPayType() int32 {
	if m != nil {
		return m.PayType
	}
	return 0
}

func (m *RechargeApplyReq) GetPayTypeId() int32 {
	if m != nil {
		return m.PayTypeId
	}
	return 0
}

func (m *RechargeApplyReq) GetPayNum() int32 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

type RechargeApplyAck struct {
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
}

func (m *RechargeApplyAck) Reset()                    { *m = RechargeApplyAck{} }
func (m *RechargeApplyAck) String() string            { return proto.CompactTextString(m) }
func (*RechargeApplyAck) ProtoMessage()               {}
func (*RechargeApplyAck) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{6} }

func (m *RechargeApplyAck) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

// 封禁 解封
type BanInfoCcsToGsReq struct {
	OpenId   string `protobuf:"bytes,1,opt,name=openId,proto3" json:"openId,omitempty"`
	UserId   int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	IsRemove bool   `protobuf:"varint,3,opt,name=isRemove,proto3" json:"isRemove,omitempty"`
}

func (m *BanInfoCcsToGsReq) Reset()                    { *m = BanInfoCcsToGsReq{} }
func (m *BanInfoCcsToGsReq) String() string            { return proto.CompactTextString(m) }
func (*BanInfoCcsToGsReq) ProtoMessage()               {}
func (*BanInfoCcsToGsReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{7} }

func (m *BanInfoCcsToGsReq) GetOpenId() string {
	if m != nil {
		return m.OpenId
	}
	return ""
}

func (m *BanInfoCcsToGsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BanInfoCcsToGsReq) GetIsRemove() bool {
	if m != nil {
		return m.IsRemove
	}
	return false
}

// 发送邮件
type MailSendCCsToGsReq struct {
	MailId       string      `protobuf:"bytes,1,opt,name=mailId,proto3" json:"mailId,omitempty"`
	Title        string      `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Content      string      `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	ValidityDay  int32       `protobuf:"varint,4,opt,name=validityDay,proto3" json:"validityDay,omitempty"`
	Items        []*ItemUnit `protobuf:"bytes,5,rep,name=items" json:"items,omitempty"`
	UserIds      []int32     `protobuf:"varint,6,rep,packed,name=userIds" json:"userIds,omitempty"`
	HighVip      int32       `protobuf:"varint,7,opt,name=highVip,proto3" json:"highVip,omitempty"`
	LowVip       int32       `protobuf:"varint,8,opt,name=lowVip,proto3" json:"lowVip,omitempty"`
	HighLevel    int32       `protobuf:"varint,9,opt,name=highLevel,proto3" json:"highLevel,omitempty"`
	LowLevel     int32       `protobuf:"varint,10,opt,name=lowLevel,proto3" json:"lowLevel,omitempty"`
	IsOnline     bool        `protobuf:"varint,11,opt,name=isOnline,proto3" json:"isOnline,omitempty"`
	HighRecharge int32       `protobuf:"varint,12,opt,name=highRecharge,proto3" json:"highRecharge,omitempty"`
	LowRecharge  int32       `protobuf:"varint,13,opt,name=lowRecharge,proto3" json:"lowRecharge,omitempty"`
}

func (m *MailSendCCsToGsReq) Reset()                    { *m = MailSendCCsToGsReq{} }
func (m *MailSendCCsToGsReq) String() string            { return proto.CompactTextString(m) }
func (*MailSendCCsToGsReq) ProtoMessage()               {}
func (*MailSendCCsToGsReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{8} }

func (m *MailSendCCsToGsReq) GetMailId() string {
	if m != nil {
		return m.MailId
	}
	return ""
}

func (m *MailSendCCsToGsReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MailSendCCsToGsReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *MailSendCCsToGsReq) GetValidityDay() int32 {
	if m != nil {
		return m.ValidityDay
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetItems() []*ItemUnit {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *MailSendCCsToGsReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *MailSendCCsToGsReq) GetHighVip() int32 {
	if m != nil {
		return m.HighVip
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetLowVip() int32 {
	if m != nil {
		return m.LowVip
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetHighLevel() int32 {
	if m != nil {
		return m.HighLevel
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetLowLevel() int32 {
	if m != nil {
		return m.LowLevel
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetIsOnline() bool {
	if m != nil {
		return m.IsOnline
	}
	return false
}

func (m *MailSendCCsToGsReq) GetHighRecharge() int32 {
	if m != nil {
		return m.HighRecharge
	}
	return 0
}

func (m *MailSendCCsToGsReq) GetLowRecharge() int32 {
	if m != nil {
		return m.LowRecharge
	}
	return 0
}

type MailSendGsToCcsAck struct {
}

func (m *MailSendGsToCcsAck) Reset()                    { *m = MailSendGsToCcsAck{} }
func (m *MailSendGsToCcsAck) String() string            { return proto.CompactTextString(m) }
func (*MailSendGsToCcsAck) ProtoMessage()               {}
func (*MailSendGsToCcsAck) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{9} }

type FuncStateUpdateReq struct {
}

func (m *FuncStateUpdateReq) Reset()                    { *m = FuncStateUpdateReq{} }
func (m *FuncStateUpdateReq) String() string            { return proto.CompactTextString(m) }
func (*FuncStateUpdateReq) ProtoMessage()               {}
func (*FuncStateUpdateReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{10} }

// 更新公告
type UpAnnouncementNowReq struct {
}

func (m *UpAnnouncementNowReq) Reset()                    { *m = UpAnnouncementNowReq{} }
func (m *UpAnnouncementNowReq) String() string            { return proto.CompactTextString(m) }
func (*UpAnnouncementNowReq) ProtoMessage()               {}
func (*UpAnnouncementNowReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{11} }

// 更新跑马灯
type UpPaoMaDengNowReq struct {
}

func (m *UpPaoMaDengNowReq) Reset()                    { *m = UpPaoMaDengNowReq{} }
func (m *UpPaoMaDengNowReq) String() string            { return proto.CompactTextString(m) }
func (*UpPaoMaDengNowReq) ProtoMessage()               {}
func (*UpPaoMaDengNowReq) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{12} }

type SetDayRechargeNumNtf struct {
	ServerId    int32 `protobuf:"varint,1,opt,name=serverId,proto3" json:"serverId,omitempty"`
	RechargeNum int32 `protobuf:"varint,2,opt,name=rechargeNum,proto3" json:"rechargeNum,omitempty"`
}

func (m *SetDayRechargeNumNtf) Reset()                    { *m = SetDayRechargeNumNtf{} }
func (m *SetDayRechargeNumNtf) String() string            { return proto.CompactTextString(m) }
func (*SetDayRechargeNumNtf) ProtoMessage()               {}
func (*SetDayRechargeNumNtf) Descriptor() ([]byte, []int) { return fileDescriptorCssServer, []int{13} }

func (m *SetDayRechargeNumNtf) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *SetDayRechargeNumNtf) GetRechargeNum() int32 {
	if m != nil {
		return m.RechargeNum
	}
	return 0
}

func init() {
	proto.RegisterType((*SyncUserInfoNtf)(nil), "pbserver.SyncUserInfoNtf")
	proto.RegisterType((*SyscHeroInfo)(nil), "pbserver.SyscHeroInfo")
	proto.RegisterType((*CCSToGsCrossFsIdChangeNtf)(nil), "pbserver.CCSToGsCrossFsIdChangeNtf")
	proto.RegisterType((*RechageCcsToGsReq)(nil), "pbserver.RechageCcsToGsReq")
	proto.RegisterType((*RechageGsToCcsAck)(nil), "pbserver.RechageGsToCcsAck")
	proto.RegisterType((*RechargeApplyReq)(nil), "pbserver.RechargeApplyReq")
	proto.RegisterType((*RechargeApplyAck)(nil), "pbserver.RechargeApplyAck")
	proto.RegisterType((*BanInfoCcsToGsReq)(nil), "pbserver.BanInfoCcsToGsReq")
	proto.RegisterType((*MailSendCCsToGsReq)(nil), "pbserver.MailSendCCsToGsReq")
	proto.RegisterType((*MailSendGsToCcsAck)(nil), "pbserver.MailSendGsToCcsAck")
	proto.RegisterType((*FuncStateUpdateReq)(nil), "pbserver.FuncStateUpdateReq")
	proto.RegisterType((*UpAnnouncementNowReq)(nil), "pbserver.UpAnnouncementNowReq")
	proto.RegisterType((*UpPaoMaDengNowReq)(nil), "pbserver.UpPaoMaDengNowReq")
	proto.RegisterType((*SetDayRechargeNumNtf)(nil), "pbserver.SetDayRechargeNumNtf")
}
func (m *SyncUserInfoNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncUserInfoNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.UserId))
	}
	if len(m.OpenId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.OpenId)))
		i += copy(dAtA[i:], m.OpenId)
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.ServerId))
	}
	if m.ServerIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.ServerIndex))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if m.Vip != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Vip))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Combat))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.CreateTime))
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Recharge != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Recharge))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Gold))
	}
	if m.Ingot != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Ingot))
	}
	if m.TaskId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.TaskId))
	}
	if m.LastRechargeTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.LastRechargeTime))
	}
	if m.OfflineTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.OfflineTime))
	}
	if m.SyscStatus != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.SyscStatus))
	}
	if m.Exp != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Exp))
	}
	if m.LoginTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.LoginTime))
	}
	if m.TokenRecharge != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.TokenRecharge))
	}
	if len(m.Heros) > 0 {
		for _, msg := range m.Heros {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintCssServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SyscHeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyscHeroInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.HeroIndex))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Sex))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Level))
	}
	if m.Job != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Job))
	}
	if m.Combat != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Combat))
	}
	return i, nil
}

func (m *CCSToGsCrossFsIdChangeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCSToGsCrossFsIdChangeNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CrossFsId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.CrossFsId))
	}
	return i, nil
}

func (m *RechageCcsToGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechageCcsToGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Oid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Oid)))
		i += copy(dAtA[i:], m.Oid)
	}
	if len(m.GameOrder) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.GameOrder)))
		i += copy(dAtA[i:], m.GameOrder)
	}
	if m.Money != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Money))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *RechageGsToCcsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechageGsToCcsAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.Result))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *RechargeApplyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeApplyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.UserId))
	}
	if m.PayType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.PayType))
	}
	if m.PayTypeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.PayTypeId))
	}
	if m.PayNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.PayNum))
	}
	return i, nil
}

func (m *RechargeApplyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeApplyAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	return i, nil
}

func (m *BanInfoCcsToGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BanInfoCcsToGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpenId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.OpenId)))
		i += copy(dAtA[i:], m.OpenId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.UserId))
	}
	if m.IsRemove {
		dAtA[i] = 0x18
		i++
		if m.IsRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MailSendCCsToGsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailSendCCsToGsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MailId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.ValidityDay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.ValidityDay))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCssServer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UserIds) > 0 {
		dAtA2 := make([]byte, len(m.UserIds)*10)
		var j1 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.HighVip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.HighVip))
	}
	if m.LowVip != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.LowVip))
	}
	if m.HighLevel != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.HighLevel))
	}
	if m.LowLevel != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.LowLevel))
	}
	if m.IsOnline {
		dAtA[i] = 0x58
		i++
		if m.IsOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HighRecharge != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.HighRecharge))
	}
	if m.LowRecharge != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.LowRecharge))
	}
	return i, nil
}

func (m *MailSendGsToCcsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailSendGsToCcsAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FuncStateUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncStateUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpAnnouncementNowReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpAnnouncementNowReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpPaoMaDengNowReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpPaoMaDengNowReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SetDayRechargeNumNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDayRechargeNumNtf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.ServerId))
	}
	if m.RechargeNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCssServer(dAtA, i, uint64(m.RechargeNum))
	}
	return i, nil
}

func encodeVarintCssServer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SyncUserInfoNtf) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCssServer(uint64(m.UserId))
	}
	l = len(m.OpenId)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.ServerId != 0 {
		n += 1 + sovCssServer(uint64(m.ServerId))
	}
	if m.ServerIndex != 0 {
		n += 1 + sovCssServer(uint64(m.ServerIndex))
	}
	if m.ChannelId != 0 {
		n += 1 + sovCssServer(uint64(m.ChannelId))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.Vip != 0 {
		n += 1 + sovCssServer(uint64(m.Vip))
	}
	if m.Combat != 0 {
		n += 1 + sovCssServer(uint64(m.Combat))
	}
	if m.CreateTime != 0 {
		n += 1 + sovCssServer(uint64(m.CreateTime))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.Recharge != 0 {
		n += 1 + sovCssServer(uint64(m.Recharge))
	}
	if m.Gold != 0 {
		n += 1 + sovCssServer(uint64(m.Gold))
	}
	if m.Ingot != 0 {
		n += 1 + sovCssServer(uint64(m.Ingot))
	}
	if m.TaskId != 0 {
		n += 2 + sovCssServer(uint64(m.TaskId))
	}
	if m.LastRechargeTime != 0 {
		n += 2 + sovCssServer(uint64(m.LastRechargeTime))
	}
	if m.OfflineTime != 0 {
		n += 2 + sovCssServer(uint64(m.OfflineTime))
	}
	if m.SyscStatus != 0 {
		n += 2 + sovCssServer(uint64(m.SyscStatus))
	}
	if m.Exp != 0 {
		n += 2 + sovCssServer(uint64(m.Exp))
	}
	if m.LoginTime != 0 {
		n += 2 + sovCssServer(uint64(m.LoginTime))
	}
	if m.TokenRecharge != 0 {
		n += 2 + sovCssServer(uint64(m.TokenRecharge))
	}
	if len(m.Heros) > 0 {
		for _, e := range m.Heros {
			l = e.Size()
			n += 2 + l + sovCssServer(uint64(l))
		}
	}
	return n
}

func (m *SyscHeroInfo) Size() (n int) {
	var l int
	_ = l
	if m.HeroIndex != 0 {
		n += 1 + sovCssServer(uint64(m.HeroIndex))
	}
	if m.Sex != 0 {
		n += 1 + sovCssServer(uint64(m.Sex))
	}
	if m.Level != 0 {
		n += 1 + sovCssServer(uint64(m.Level))
	}
	if m.Job != 0 {
		n += 1 + sovCssServer(uint64(m.Job))
	}
	if m.Combat != 0 {
		n += 1 + sovCssServer(uint64(m.Combat))
	}
	return n
}

func (m *CCSToGsCrossFsIdChangeNtf) Size() (n int) {
	var l int
	_ = l
	if m.CrossFsId != 0 {
		n += 1 + sovCssServer(uint64(m.CrossFsId))
	}
	return n
}

func (m *RechageCcsToGsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Oid)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	l = len(m.GameOrder)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.Money != 0 {
		n += 1 + sovCssServer(uint64(m.Money))
	}
	if m.Coin != 0 {
		n += 1 + sovCssServer(uint64(m.Coin))
	}
	return n
}

func (m *RechageGsToCcsAck) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovCssServer(uint64(m.Result))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	return n
}

func (m *RechargeApplyReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCssServer(uint64(m.UserId))
	}
	if m.PayType != 0 {
		n += 1 + sovCssServer(uint64(m.PayType))
	}
	if m.PayTypeId != 0 {
		n += 1 + sovCssServer(uint64(m.PayTypeId))
	}
	if m.PayNum != 0 {
		n += 1 + sovCssServer(uint64(m.PayNum))
	}
	return n
}

func (m *RechargeApplyAck) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	return n
}

func (m *BanInfoCcsToGsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.OpenId)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovCssServer(uint64(m.UserId))
	}
	if m.IsRemove {
		n += 2
	}
	return n
}

func (m *MailSendCCsToGsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovCssServer(uint64(l))
	}
	if m.ValidityDay != 0 {
		n += 1 + sovCssServer(uint64(m.ValidityDay))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCssServer(uint64(l))
		}
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovCssServer(uint64(e))
		}
		n += 1 + sovCssServer(uint64(l)) + l
	}
	if m.HighVip != 0 {
		n += 1 + sovCssServer(uint64(m.HighVip))
	}
	if m.LowVip != 0 {
		n += 1 + sovCssServer(uint64(m.LowVip))
	}
	if m.HighLevel != 0 {
		n += 1 + sovCssServer(uint64(m.HighLevel))
	}
	if m.LowLevel != 0 {
		n += 1 + sovCssServer(uint64(m.LowLevel))
	}
	if m.IsOnline {
		n += 2
	}
	if m.HighRecharge != 0 {
		n += 1 + sovCssServer(uint64(m.HighRecharge))
	}
	if m.LowRecharge != 0 {
		n += 1 + sovCssServer(uint64(m.LowRecharge))
	}
	return n
}

func (m *MailSendGsToCcsAck) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FuncStateUpdateReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpAnnouncementNowReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpPaoMaDengNowReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SetDayRechargeNumNtf) Size() (n int) {
	var l int
	_ = l
	if m.ServerId != 0 {
		n += 1 + sovCssServer(uint64(m.ServerId))
	}
	if m.RechargeNum != 0 {
		n += 1 + sovCssServer(uint64(m.RechargeNum))
	}
	return n
}

func sovCssServer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCssServer(x uint64) (n int) {
	return sovCssServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SyncUserInfoNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUserInfoNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUserInfoNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIndex", wireType)
			}
			m.ServerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recharge", wireType)
			}
			m.Recharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingot", wireType)
			}
			m.Ingot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ingot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRechargeTime", wireType)
			}
			m.LastRechargeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRechargeTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineTime", wireType)
			}
			m.OfflineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfflineTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscStatus", wireType)
			}
			m.SyscStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			m.LoginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenRecharge", wireType)
			}
			m.TokenRecharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenRecharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heros = append(m.Heros, &SyscHeroInfo{})
			if err := m.Heros[len(m.Heros)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyscHeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyscHeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyscHeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroIndex", wireType)
			}
			m.HeroIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			m.Combat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCSToGsCrossFsIdChangeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCSToGsCrossFsIdChangeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCSToGsCrossFsIdChangeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossFsId", wireType)
			}
			m.CrossFsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossFsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechageCcsToGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechageCcsToGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechageCcsToGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameOrder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechageGsToCcsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechageGsToCcsAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechageGsToCcsAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeApplyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeApplyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeApplyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			m.PayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayTypeId", wireType)
			}
			m.PayTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayTypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeApplyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeApplyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeApplyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BanInfoCcsToGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BanInfoCcsToGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BanInfoCcsToGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRemove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailSendCCsToGsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailSendCCsToGsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailSendCCsToGsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidityDay", wireType)
			}
			m.ValidityDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidityDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCssServer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemUnit{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCssServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCssServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCssServer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCssServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighVip", wireType)
			}
			m.HighVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighVip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowVip", wireType)
			}
			m.LowVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowVip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighLevel", wireType)
			}
			m.HighLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowLevel", wireType)
			}
			m.LowLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnline = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighRecharge", wireType)
			}
			m.HighRecharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighRecharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowRecharge", wireType)
			}
			m.LowRecharge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowRecharge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailSendGsToCcsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailSendGsToCcsAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailSendGsToCcsAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncStateUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuncStateUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuncStateUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpAnnouncementNowReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpAnnouncementNowReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpAnnouncementNowReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpPaoMaDengNowReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpPaoMaDengNowReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpPaoMaDengNowReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDayRechargeNumNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDayRechargeNumNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDayRechargeNumNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeNum", wireType)
			}
			m.RechargeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCssServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCssServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCssServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCssServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCssServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCssServer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCssServer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCssServer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCssServer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCssServer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("css_server.proto", fileDescriptorCssServer) }

var fileDescriptorCssServer = []byte{
	// 916 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0xcd, 0x6e, 0x1b, 0x37,
	0x10, 0xee, 0x46, 0x91, 0x2d, 0xd1, 0x4e, 0x23, 0x33, 0xaa, 0xc1, 0x1a, 0x85, 0x20, 0x2c, 0x7a,
	0x10, 0x8a, 0xc0, 0x87, 0xf4, 0xd4, 0x43, 0x0f, 0x8e, 0x8c, 0xa4, 0x02, 0x1a, 0xa7, 0x58, 0x49,
	0xb9, 0x06, 0xf4, 0xee, 0x78, 0xc5, 0x7a, 0x97, 0x5c, 0x2f, 0x29, 0xd9, 0xdb, 0x43, 0x9f, 0xa1,
	0xc7, 0x3e, 0x52, 0x8f, 0x7d, 0x84, 0xc2, 0x3d, 0xf6, 0x25, 0x8a, 0x21, 0xb9, 0x3f, 0x6a, 0xd0,
	0xdb, 0x7c, 0xdf, 0x92, 0xf3, 0xf3, 0x71, 0x66, 0x96, 0x8c, 0x62, 0xad, 0x3f, 0x6a, 0x28, 0x77,
	0x50, 0x9e, 0x17, 0xa5, 0x32, 0x8a, 0x0e, 0x8a, 0x6b, 0x87, 0xcf, 0x8e, 0x63, 0x95, 0xe7, 0x4a,
	0x3a, 0x3e, 0xfc, 0xe7, 0x29, 0x79, 0xbe, 0xac, 0x64, 0xbc, 0xd6, 0x50, 0x2e, 0xe4, 0x8d, 0xba,
	0x32, 0x37, 0xf4, 0x94, 0x1c, 0x6c, 0x11, 0x26, 0x2c, 0x98, 0x06, 0xb3, 0x7e, 0xe4, 0x11, 0xf2,
	0xaa, 0x00, 0xb9, 0x48, 0xd8, 0x93, 0x69, 0x30, 0x1b, 0x46, 0x1e, 0xd1, 0x33, 0x32, 0x70, 0xbe,
	0x17, 0x09, 0xeb, 0xd9, 0x1b, 0x0d, 0xa6, 0x53, 0x72, 0xe4, 0x6d, 0x99, 0xc0, 0x03, 0x7b, 0x6a,
	0x3f, 0x77, 0x29, 0xfa, 0x15, 0x19, 0xc6, 0x1b, 0x2e, 0x25, 0x64, 0x8b, 0x84, 0xf5, 0xed, 0xf7,
	0x96, 0x40, 0xdf, 0x52, 0xc4, 0xb7, 0x92, 0xe7, 0xc0, 0x0e, 0x6c, 0xd4, 0x06, 0xd3, 0x11, 0xe9,
	0xed, 0x44, 0xc1, 0x06, 0xf6, 0x0e, 0x9a, 0x98, 0x61, 0xac, 0xf2, 0x6b, 0x6e, 0xd8, 0x70, 0x1a,
	0xcc, 0x7a, 0x91, 0x47, 0x74, 0x42, 0x48, 0x5c, 0x02, 0x37, 0xb0, 0x12, 0x39, 0x30, 0x62, 0x2f,
	0x74, 0x18, 0xbc, 0xc7, 0x77, 0xdc, 0xf0, 0x92, 0x1d, 0xb9, 0xca, 0x1c, 0xc2, 0xe8, 0x25, 0xc4,
	0x1b, 0x5e, 0xa6, 0xc0, 0x9e, 0xb9, 0xca, 0x6a, 0x4c, 0x29, 0x79, 0x9a, 0xaa, 0x2c, 0x61, 0x9f,
	0xdb, 0x48, 0xd6, 0xa6, 0x63, 0xd2, 0x17, 0x32, 0x55, 0x86, 0x3d, 0xb7, 0x87, 0x1d, 0x40, 0xef,
	0x86, 0xeb, 0xdb, 0x45, 0xc2, 0x46, 0x4e, 0x4f, 0x87, 0xe8, 0x37, 0x64, 0x94, 0x71, 0x6d, 0x22,
	0xef, 0xd1, 0xe6, 0x76, 0x62, 0x4f, 0x7c, 0xc2, 0xa3, 0x8e, 0xea, 0xe6, 0x26, 0x13, 0xd2, 0x1d,
	0xa3, 0x4e, 0xc7, 0x0e, 0x85, 0x35, 0xea, 0x4a, 0xc7, 0x4b, 0xc3, 0xcd, 0x56, 0xb3, 0x17, 0xae,
	0xc6, 0x96, 0x41, 0xb5, 0xe0, 0xa1, 0x60, 0x63, 0x9b, 0x2e, 0x9a, 0xa8, 0x7c, 0xa6, 0x52, 0x21,
	0xad, 0xc7, 0x2f, 0x9c, 0xf2, 0x0d, 0x41, 0xbf, 0x26, 0xcf, 0x8c, 0xba, 0x05, 0x59, 0xa7, 0xc1,
	0x4e, 0xed, 0x89, 0x7d, 0x92, 0xbe, 0x24, 0xfd, 0x0d, 0x94, 0x4a, 0xb3, 0x57, 0xd3, 0xde, 0xec,
	0xe8, 0xd5, 0xe9, 0x79, 0xdd, 0x67, 0xe7, 0xcb, 0x4a, 0xc7, 0x3f, 0x40, 0xa9, 0xb0, 0xab, 0x22,
	0x77, 0x28, 0xfc, 0x95, 0x1c, 0x77, 0x69, 0xcc, 0x60, 0x63, 0x6d, 0xec, 0x0d, 0xd7, 0x6c, 0x2d,
	0x81, 0x19, 0x6b, 0x78, 0xb0, 0xcd, 0xd6, 0x8f, 0xd0, 0x44, 0x7d, 0x33, 0xd8, 0x41, 0xe6, 0xdb,
	0xcc, 0x01, 0x3c, 0xf7, 0xb3, 0xba, 0xf6, 0xbd, 0x85, 0x66, 0xa7, 0x0f, 0xfa, 0xdd, 0x3e, 0x08,
	0xbf, 0x23, 0x5f, 0xce, 0xe7, 0xcb, 0x95, 0x7a, 0xab, 0xe7, 0xa5, 0xd2, 0xfa, 0x8d, 0x5e, 0x24,
	0xf3, 0x0d, 0x97, 0x29, 0x60, 0xdb, 0x63, 0x23, 0xd6, 0x6c, 0x9d, 0x4c, 0x43, 0x84, 0x39, 0x39,
	0xb1, 0x45, 0xa7, 0x30, 0x8f, 0x35, 0x7a, 0x88, 0xe0, 0x0e, 0x23, 0x2b, 0xe1, 0x0e, 0x0f, 0x23,
	0x34, 0xd1, 0x49, 0xca, 0x73, 0x78, 0x5f, 0x26, 0x50, 0xfa, 0x31, 0x69, 0x09, 0xcc, 0x3f, 0x57,
	0x12, 0xaa, 0x3a, 0x7f, 0x0b, 0xb0, 0x93, 0x62, 0x25, 0xa4, 0x2f, 0xc0, 0xda, 0xe1, 0xf7, 0x4d,
	0xb8, 0xb7, 0x7a, 0xa5, 0xe6, 0xb1, 0xbe, 0x88, 0x6f, 0xb1, 0xac, 0x12, 0xf4, 0x36, 0x33, 0xf5,
	0x60, 0x3a, 0x84, 0x69, 0xe4, 0x3a, 0xf5, 0xe1, 0xd0, 0x0c, 0x7f, 0x21, 0xa3, 0xfa, 0x89, 0x2e,
	0x8a, 0x22, 0xab, 0x30, 0xd9, 0xff, 0x1b, 0x6b, 0x46, 0x0e, 0x0b, 0x5e, 0xad, 0xaa, 0x02, 0xbc,
	0xd4, 0x35, 0xc4, 0x62, 0xbc, 0xd9, 0x4c, 0x76, 0x4b, 0xa0, 0xbf, 0x82, 0x57, 0x57, 0xdb, 0xdc,
	0x27, 0xee, 0x51, 0xf8, 0xf2, 0x3f, 0xb1, 0x31, 0x73, 0x46, 0x0e, 0x15, 0x2a, 0xb0, 0xa8, 0xc5,
	0xaa, 0x61, 0xf8, 0x91, 0x9c, 0xbc, 0xe6, 0x12, 0xbb, 0xa1, 0xa3, 0x6b, 0xbb, 0x69, 0x82, 0xbd,
	0x4d, 0xd3, 0x96, 0xf0, 0x64, 0xaf, 0x84, 0x33, 0x32, 0x10, 0x3a, 0x82, 0x5c, 0xed, 0xc0, 0xe6,
	0x39, 0x88, 0x1a, 0x1c, 0xfe, 0xd6, 0x23, 0xf4, 0x1d, 0x17, 0xd9, 0x12, 0x64, 0x32, 0x9f, 0x77,
	0x43, 0xe4, 0x5c, 0x64, 0x6d, 0x08, 0x87, 0xf0, 0x89, 0x8c, 0x30, 0x19, 0x78, 0x35, 0x1d, 0xc0,
	0xfc, 0x63, 0x25, 0x0d, 0x48, 0x63, 0xfd, 0x0f, 0xa3, 0x1a, 0xe2, 0x60, 0xee, 0x78, 0x26, 0x12,
	0x61, 0xaa, 0x4b, 0x5e, 0xd5, 0x0b, 0xae, 0x43, 0xd1, 0x19, 0xe9, 0x0b, 0x03, 0xb9, 0x66, 0x7d,
	0x3b, 0x22, 0xb4, 0x1d, 0x91, 0x85, 0x81, 0x7c, 0x2d, 0x85, 0x89, 0xdc, 0x01, 0x8c, 0xe2, 0x0a,
	0xd2, 0xec, 0x60, 0xda, 0xc3, 0x97, 0xf0, 0x10, 0xbf, 0x6c, 0x44, 0xba, 0xf9, 0x20, 0x0a, 0x76,
	0xe8, 0xde, 0xc8, 0x43, 0xac, 0x23, 0x53, 0xf7, 0x1f, 0x9a, 0x3d, 0xe8, 0x91, 0x1d, 0x2d, 0x91,
	0x6e, 0x7e, 0xb4, 0xe3, 0x32, 0xf4, 0xa3, 0x55, 0x13, 0x28, 0x58, 0xa6, 0xee, 0xdd, 0x47, 0xb7,
	0x0e, 0x1b, 0xec, 0xc4, 0x7c, 0x2f, 0x71, 0xb1, 0xd8, 0x75, 0x68, 0xc5, 0x74, 0x98, 0x86, 0xe4,
	0x18, 0x9d, 0x34, 0x3b, 0xe1, 0xd8, 0xde, 0xdd, 0xe3, 0x50, 0x91, 0x4c, 0xdd, 0x47, 0xfb, 0x7b,
	0xb3, 0x4b, 0x85, 0xe3, 0xf6, 0x45, 0xda, 0xee, 0x46, 0xf6, 0xcd, 0x56, 0xda, 0x75, 0x05, 0xeb,
	0x22, 0xe1, 0x06, 0x22, 0xb8, 0x0b, 0x4f, 0xc9, 0x78, 0x5d, 0x5c, 0x48, 0xa9, 0xb6, 0x32, 0x86,
	0x1c, 0xa4, 0xb9, 0x42, 0x47, 0x77, 0xe1, 0x0b, 0x72, 0xb2, 0x2e, 0x7e, 0xe2, 0xea, 0x1d, 0xbf,
	0x04, 0x99, 0x7a, 0x72, 0x45, 0xc6, 0x4b, 0x30, 0x97, 0xbc, 0xaa, 0x43, 0x5d, 0x6d, 0x73, 0x1c,
	0xed, 0xee, 0x1f, 0x2a, 0xf8, 0xf4, 0x0f, 0x55, 0xb6, 0xa7, 0x7d, 0x63, 0x75, 0xa9, 0xd7, 0xa3,
	0x3f, 0x1e, 0x27, 0xc1, 0x9f, 0x8f, 0x93, 0xe0, 0xaf, 0xc7, 0x49, 0xf0, 0xfb, 0xdf, 0x93, 0xcf,
	0xae, 0x0f, 0xec, 0xcf, 0xf3, 0xdb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x36, 0xa2, 0xac, 0xd5,
	0x68, 0x07, 0x00, 0x00,
}
